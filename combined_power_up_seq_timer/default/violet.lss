
violet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000206  00800100  00002ac6  00002b5a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002ac6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000ff1  00800306  00800306  00002d60  2**0
                  ALLOC
  3 .stab         00003ff0  00000000  00000000  00002d60  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000010d7  00000000  00000000  00006d50  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00007e27  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000288  00000000  00000000  00007e56  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000538c  00000000  00000000  000080de  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000110f  00000000  00000000  0000d46a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000014b7  00000000  00000000  0000e579  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000ac4  00000000  00000000  0000fa30  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000ba8  00000000  00000000  000104f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00003057  00000000  00000000  0001109c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000210  00000000  00000000  000140f3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
{
       0:	0c 94 f4 00 	jmp	0x1e8	; 0x1e8 <__ctors_end>
       4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
       8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
       c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      10:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 * insert_str
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
      14:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      18:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
{
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
      1c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      20:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      24:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      28:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
		output[i] = input[i - start_index];

	return i;
}
      2c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      30:	0c 94 b9 0c 	jmp	0x1972	; 0x1972 <__vector_12>
      34:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      38:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      3c:	0c 94 9b 0c 	jmp	0x1936	; 0x1936 <__vector_15>
      40:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      44:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      48:	0c 94 f2 0d 	jmp	0x1be4	; 0x1be4 <__vector_18>
      4c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      50:	0c 94 c9 0d 	jmp	0x1b92	; 0x1b92 <__vector_20>
      54:	0c 94 9b 0d 	jmp	0x1b36	; 0x1b36 <__vector_21>
      58:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      5c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      60:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      64:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      68:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      6c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      70:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      74:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      78:	0c 94 66 0d 	jmp	0x1acc	; 0x1acc <__vector_30>
      7c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      80:	0c 94 3d 0d 	jmp	0x1a7a	; 0x1a7a <__vector_32>
      84:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      88:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>

0000008c <charge20Pc>:
      8c:	08 00 09 00 09 00 0a 00 0b 00 0c 00 0d 00 0d 00     ................
      9c:	0e 00 0f 00 10 00 11 00 12 00 13 00 14 00 15 00     ................
      ac:	16 00 17 00 19 00 1a 00 1b 00 1d 00 1e 00 1f 00     ................
      bc:	21 00 22 00 24 00 25 00 27 00 28 00 2b 00 2c 00     !.".$.%.'.(.+.,.
      cc:	2e 00 30 00 32 00 34 00 36 00 38 00 3b 00 3e 00     ..0.2.4.6.8.;.>.
      dc:	3f 00 42 00 45 00 48 00 4c 00 50 00 59 00 6b 00     ?.B.E.H.L.P.Y.k.
      ec:	7f 00 8a 00 9c 00 a8 00 b3 00 c1 00 ce 00 dd 00     ................
      fc:	ea 00 f9 00 0d 01 1f 01 2b 01 3f 01 7e 01 a9 01     ........+.?.~...
     10c:	b7 01 e1 01 ff 01 18 02 28 02 3d 02 4d 02 62 02     ........(.=.M.b.
     11c:	7d 02 90 02 b8 02 c5 02 d6 02 e9 02 fa 02 08 03     }...............
     12c:	16 03 25 03 32 03 40 03 4d 03 60 03 6f 03 77 03     ..%.2.@.M.`.o.w.
     13c:	83 03 95 03 9f 03 aa 03 b4 03 c0 03 c9 03 d5 03     ................
     14c:	df 03 eb 03 f5 03 00 04 05 04 12 04 19 04 22 04     ..............".
     15c:	2c 04 34 04 37 04 40 04 74 04 7e 04                 ,.4.7.@.t.~.

00000168 <discharge20Pc>:
     168:	00 00 03 00 03 00 03 00 03 00 03 00 03 00 03 00     ................
     178:	03 00 03 00 03 00 03 00 03 00 03 00 03 00 03 00     ................
     188:	03 00 04 00 04 00 04 00 04 00 18 00 18 00 18 00     ................
     198:	18 00 40 00 40 00 40 00 40 00 68 00 68 00 68 00     ..@.@.@.@.h.h.h.
     1a8:	68 00 99 00 99 00 99 00 99 00 cd 00 cd 00 cd 00     h...............
     1b8:	cd 00 ff 00 ff 00 ff 00 ff 00 39 01 39 01 39 01     ..........9.9.9.
     1c8:	39 01 97 01 97 01 97 01 97 01 26 02 a9 02 40 03     9.........&...@.
     1d8:	91 03 ef 03 18 04 2a 04 34 04 3e 04 45 04 4d 04     ......*.4.>.E.M.

000001e8 <__ctors_end>:
     1e8:	11 24       	eor	r1, r1
     1ea:	1f be       	out	0x3f, r1	; 63
     1ec:	cf ef       	ldi	r28, 0xFF	; 255
     1ee:	d0 e1       	ldi	r29, 0x10	; 16
     1f0:	de bf       	out	0x3e, r29	; 62
     1f2:	cd bf       	out	0x3d, r28	; 61

000001f4 <__do_copy_data>:
     1f4:	13 e0       	ldi	r17, 0x03	; 3
     1f6:	a0 e0       	ldi	r26, 0x00	; 0
     1f8:	b1 e0       	ldi	r27, 0x01	; 1
     1fa:	e6 ec       	ldi	r30, 0xC6	; 198
     1fc:	fa e2       	ldi	r31, 0x2A	; 42
     1fe:	00 e0       	ldi	r16, 0x00	; 0
     200:	0b bf       	out	0x3b, r16	; 59
     202:	02 c0       	rjmp	.+4      	; 0x208 <__do_copy_data+0x14>
     204:	07 90       	elpm	r0, Z+
     206:	0d 92       	st	X+, r0
     208:	a6 30       	cpi	r26, 0x06	; 6
     20a:	b1 07       	cpc	r27, r17
     20c:	d9 f7       	brne	.-10     	; 0x204 <__do_copy_data+0x10>

0000020e <__do_clear_bss>:
     20e:	22 e1       	ldi	r18, 0x12	; 18
     210:	a6 e0       	ldi	r26, 0x06	; 6
     212:	b3 e0       	ldi	r27, 0x03	; 3
     214:	01 c0       	rjmp	.+2      	; 0x218 <.do_clear_bss_start>

00000216 <.do_clear_bss_loop>:
     216:	1d 92       	st	X+, r1

00000218 <.do_clear_bss_start>:
     218:	a7 3f       	cpi	r26, 0xF7	; 247
     21a:	b2 07       	cpc	r27, r18
     21c:	e1 f7       	brne	.-8      	; 0x216 <.do_clear_bss_loop>
     21e:	0e 94 f9 07 	call	0xff2	; 0xff2 <main>
     222:	0c 94 61 15 	jmp	0x2ac2	; 0x2ac2 <_exit>

00000226 <__bad_interrupt>:
     226:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000022a <set_component>:
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     22a:	8f 92       	push	r8
     22c:	af 92       	push	r10
     22e:	cf 92       	push	r12
     230:	ef 92       	push	r14
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     232:	0f 93       	push	r16
     234:	cf 93       	push	r28
     236:	df 93       	push	r29
     238:	cd b7       	in	r28, 0x3d	; 61
     23a:	de b7       	in	r29, 0x3e	; 62
     23c:	93 e3       	ldi	r25, 0x33	; 51
     23e:	89 9f       	mul	r24, r25
     240:	f0 01       	movw	r30, r0
     242:	11 24       	eor	r1, r1
     244:	e4 5c       	subi	r30, 0xC4	; 196
     246:	fc 4f       	sbci	r31, 0xFC	; 252
     248:	60 83       	st	Z, r22
     24a:	41 83       	std	Z+1, r20	; 0x01
     24c:	22 83       	std	Z+2, r18	; 0x02
     24e:	13 82       	std	Z+3, r1	; 0x03
     250:	04 83       	std	Z+4, r16	; 0x04
     252:	e5 82       	std	Z+5, r14	; 0x05
     254:	c6 82       	std	Z+6, r12	; 0x06
     256:	a7 82       	std	Z+7, r10	; 0x07
     258:	13 86       	std	Z+11, r1	; 0x0b
     25a:	14 86       	std	Z+12, r1	; 0x0c
     25c:	85 86       	std	Z+13, r8	; 0x0d
     25e:	8a 85       	ldd	r24, Y+10	; 0x0a
     260:	86 87       	std	Z+14, r24	; 0x0e
     262:	8b 85       	ldd	r24, Y+11	; 0x0b
     264:	87 87       	std	Z+15, r24	; 0x0f
     266:	8c 85       	ldd	r24, Y+12	; 0x0c
     268:	80 8b       	std	Z+16, r24	; 0x10
     26a:	14 8a       	std	Z+20, r1	; 0x14
     26c:	15 8a       	std	Z+21, r1	; 0x15
     26e:	8d 85       	ldd	r24, Y+13	; 0x0d
     270:	86 8b       	std	Z+22, r24	; 0x16
     272:	8e 85       	ldd	r24, Y+14	; 0x0e
     274:	87 8b       	std	Z+23, r24	; 0x17
     276:	13 8e       	std	Z+27, r1	; 0x1b
     278:	df 91       	pop	r29
     27a:	cf 91       	pop	r28
     27c:	0f 91       	pop	r16
     27e:	ef 90       	pop	r14
     280:	cf 90       	pop	r12
     282:	af 90       	pop	r10
     284:	8f 90       	pop	r8
     286:	08 95       	ret

00000288 <initialize_svit>:
     288:	5f 92       	push	r5
     28a:	6f 92       	push	r6
     28c:	7f 92       	push	r7
     28e:	8f 92       	push	r8
     290:	9f 92       	push	r9
     292:	af 92       	push	r10
     294:	bf 92       	push	r11
     296:	cf 92       	push	r12
     298:	df 92       	push	r13
     29a:	ef 92       	push	r14
     29c:	ff 92       	push	r15
     29e:	0f 93       	push	r16
     2a0:	1f 93       	push	r17
     2a2:	cf 93       	push	r28
     2a4:	df 93       	push	r29
     2a6:	80 e6       	ldi	r24, 0x60	; 96
     2a8:	87 b9       	out	0x07, r24	; 7
     2aa:	8f e8       	ldi	r24, 0x8F	; 143
     2ac:	86 b9       	out	0x06, r24	; 6
     2ae:	1f 92       	push	r1
     2b0:	13 e0       	ldi	r17, 0x03	; 3
     2b2:	1f 93       	push	r17
     2b4:	c0 e1       	ldi	r28, 0x10	; 16
     2b6:	cf 93       	push	r28
     2b8:	d0 ea       	ldi	r29, 0xA0	; 160
     2ba:	df 93       	push	r29
     2bc:	86 e0       	ldi	r24, 0x06	; 6
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2be:	d8 2e       	mov	r13, r24
     2c0:	df 92       	push	r13
     2c2:	81 2c       	mov	r8, r1
     2c4:	90 e1       	ldi	r25, 0x10	; 16
     2c6:	a9 2e       	mov	r10, r25
     2c8:	20 ea       	ldi	r18, 0xA0	; 160
     2ca:	c2 2e       	mov	r12, r18
     2cc:	3b e0       	ldi	r19, 0x0B	; 11
     2ce:	e3 2e       	mov	r14, r19
     2d0:	00 e0       	ldi	r16, 0x00	; 0
     2d2:	21 e0       	ldi	r18, 0x01	; 1
     2d4:	47 e0       	ldi	r20, 0x07	; 7
     2d6:	60 e0       	ldi	r22, 0x00	; 0
     2d8:	80 e0       	ldi	r24, 0x00	; 0
     2da:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     2de:	87 e0       	ldi	r24, 0x07	; 7
     2e0:	8f 93       	push	r24
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     2e2:	bb 24       	eor	r11, r11
     2e4:	b3 94       	inc	r11
     2e6:	bf 92       	push	r11
     2e8:	cf 93       	push	r28
     2ea:	df 93       	push	r29
     2ec:	8f 93       	push	r24
     2ee:	47 e1       	ldi	r20, 0x17	; 23
     2f0:	e4 2e       	mov	r14, r20
     2f2:	21 e0       	ldi	r18, 0x01	; 1
     2f4:	48 e0       	ldi	r20, 0x08	; 8
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2f6:	61 e0       	ldi	r22, 0x01	; 1
     2f8:	81 e0       	ldi	r24, 0x01	; 1
     2fa:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     2fe:	1f 92       	push	r1
     300:	1f 93       	push	r17
     302:	cf 93       	push	r28
     304:	df 93       	push	r29
     306:	1f 92       	push	r1
     308:	88 24       	eor	r8, r8
     30a:	83 94       	inc	r8
     30c:	53 e1       	ldi	r21, 0x13	; 19
     30e:	e5 2e       	mov	r14, r21
     310:	01 e0       	ldi	r16, 0x01	; 1
     312:	21 e0       	ldi	r18, 0x01	; 1
     314:	41 e0       	ldi	r20, 0x01	; 1
     316:	62 e0       	ldi	r22, 0x02	; 2
     318:	82 e0       	ldi	r24, 0x02	; 2
     31a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     31e:	1f 92       	push	r1
     320:	1f 93       	push	r17
     322:	cf 93       	push	r28
     324:	df 93       	push	r29
     326:	8e e0       	ldi	r24, 0x0E	; 14
     328:	8f 93       	push	r24
     32a:	62 e0       	ldi	r22, 0x02	; 2
     32c:	86 2e       	mov	r8, r22
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     32e:	7d e0       	ldi	r23, 0x0D	; 13
     330:	e7 2e       	mov	r14, r23
     332:	02 e0       	ldi	r16, 0x02	; 2
     334:	21 e0       	ldi	r18, 0x01	; 1
     336:	41 e0       	ldi	r20, 0x01	; 1
     338:	63 e0       	ldi	r22, 0x03	; 3
     33a:	83 e0       	ldi	r24, 0x03	; 3
     33c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     340:	1f 92       	push	r1
     342:	1f 93       	push	r17
     344:	cf 93       	push	r28
     346:	df 93       	push	r29
     348:	bf 92       	push	r11
     34a:	88 24       	eor	r8, r8
     34c:	83 94       	inc	r8
     34e:	e5 e1       	ldi	r30, 0x15	; 21
     350:	ee 2e       	mov	r14, r30
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     352:	01 e0       	ldi	r16, 0x01	; 1
     354:	21 e0       	ldi	r18, 0x01	; 1
     356:	42 e0       	ldi	r20, 0x02	; 2
     358:	64 e0       	ldi	r22, 0x04	; 4
     35a:	84 e0       	ldi	r24, 0x04	; 4
     35c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     360:	1f 92       	push	r1
     362:	1f 93       	push	r17
     364:	cf 93       	push	r28
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     366:	df 93       	push	r29
     368:	f2 e0       	ldi	r31, 0x02	; 2
     36a:	ff 2e       	mov	r15, r31
     36c:	ff 92       	push	r15
     36e:	aa e1       	ldi	r26, 0x1A	; 26
     370:	ea 2e       	mov	r14, r26
     372:	21 e0       	ldi	r18, 0x01	; 1
     374:	43 e0       	ldi	r20, 0x03	; 3
     376:	65 e0       	ldi	r22, 0x05	; 5
     378:	85 e0       	ldi	r24, 0x05	; 5
     37a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     37e:	1f 92       	push	r1
     380:	1f 93       	push	r17
     382:	cf 93       	push	r28
     384:	df 93       	push	r29
     386:	1f 93       	push	r17
     388:	bd e1       	ldi	r27, 0x1D	; 29
     38a:	eb 2e       	mov	r14, r27
     38c:	21 e0       	ldi	r18, 0x01	; 1
     38e:	44 e0       	ldi	r20, 0x04	; 4
     390:	66 e0       	ldi	r22, 0x06	; 6
     392:	86 e0       	ldi	r24, 0x06	; 6
     394:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     398:	8d b7       	in	r24, 0x3d	; 61
     39a:	9e b7       	in	r25, 0x3e	; 62
     39c:	83 96       	adiw	r24, 0x23	; 35
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     39e:	0f b6       	in	r0, 0x3f	; 63
     3a0:	f8 94       	cli
     3a2:	9e bf       	out	0x3e, r25	; 62
     3a4:	0f be       	out	0x3f, r0	; 63
     3a6:	8d bf       	out	0x3d, r24	; 61
     3a8:	1f 92       	push	r1
     3aa:	1f 93       	push	r17
     3ac:	cf 93       	push	r28
     3ae:	df 93       	push	r29
     3b0:	8f e1       	ldi	r24, 0x1F	; 31
     3b2:	98 2e       	mov	r9, r24
     3b4:	9f 92       	push	r9
     3b6:	9e e0       	ldi	r25, 0x0E	; 14
     3b8:	e9 2e       	mov	r14, r25
     3ba:	21 e0       	ldi	r18, 0x01	; 1
     3bc:	45 e0       	ldi	r20, 0x05	; 5
     3be:	67 e0       	ldi	r22, 0x07	; 7
     3c0:	87 e0       	ldi	r24, 0x07	; 7
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     3c2:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     3c6:	1f 92       	push	r1
     3c8:	1f 93       	push	r17
     3ca:	cf 93       	push	r28
     3cc:	df 93       	push	r29
     3ce:	24 e0       	ldi	r18, 0x04	; 4
     3d0:	52 2e       	mov	r5, r18
     3d2:	5f 92       	push	r5
     3d4:	3b e1       	ldi	r19, 0x1B	; 27
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     3d6:	e3 2e       	mov	r14, r19
     3d8:	21 e0       	ldi	r18, 0x01	; 1
     3da:	46 e0       	ldi	r20, 0x06	; 6
     3dc:	68 e0       	ldi	r22, 0x08	; 8
     3de:	88 e0       	ldi	r24, 0x08	; 8
     3e0:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     3e4:	1f 92       	push	r1
     3e6:	1f 93       	push	r17
     3e8:	cf 93       	push	r28
     3ea:	df 93       	push	r29
     3ec:	48 e0       	ldi	r20, 0x08	; 8
     3ee:	64 2e       	mov	r6, r20
     3f0:	6f 92       	push	r6
     3f2:	5f e0       	ldi	r21, 0x0F	; 15
     3f4:	e5 2e       	mov	r14, r21
     3f6:	21 e0       	ldi	r18, 0x01	; 1
     3f8:	49 e0       	ldi	r20, 0x09	; 9
     3fa:	69 e0       	ldi	r22, 0x09	; 9
     3fc:	89 e0       	ldi	r24, 0x09	; 9
     3fe:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     402:	1f 92       	push	r1
     404:	1f 93       	push	r17
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     406:	cf 93       	push	r28
     408:	df 93       	push	r29
     40a:	69 e0       	ldi	r22, 0x09	; 9
     40c:	76 2e       	mov	r7, r22
     40e:	7f 92       	push	r7
     410:	79 e1       	ldi	r23, 0x19	; 25
     412:	e7 2e       	mov	r14, r23
     414:	21 e0       	ldi	r18, 0x01	; 1
     416:	4a e0       	ldi	r20, 0x0A	; 10
     418:	6a e0       	ldi	r22, 0x0A	; 10
     41a:	8a e0       	ldi	r24, 0x0A	; 10
     41c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     420:	1f 92       	push	r1
     422:	1f 93       	push	r17
     424:	cf 93       	push	r28
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     426:	df 93       	push	r29
     428:	8a e0       	ldi	r24, 0x0A	; 10
     42a:	8f 93       	push	r24
     42c:	e8 e1       	ldi	r30, 0x18	; 24
     42e:	ee 2e       	mov	r14, r30
     430:	20 e0       	ldi	r18, 0x00	; 0
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     432:	4b e0       	ldi	r20, 0x0B	; 11
     434:	6b e0       	ldi	r22, 0x0B	; 11
     436:	8b e0       	ldi	r24, 0x0B	; 11
     438:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     43c:	1f 92       	push	r1
     43e:	1f 93       	push	r17
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
	}
    else 
	{
	  debug = 0x0B;
     444:	cf 93       	push	r28
     446:	f1 e1       	ldi	r31, 0x11	; 17
     448:	ef 2e       	mov	r14, r31
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     44a:	20 e0       	ldi	r18, 0x00	; 0
     44c:	4c e0       	ldi	r20, 0x0C	; 12
     44e:	6c e0       	ldi	r22, 0x0C	; 12
     450:	8c e0       	ldi	r24, 0x0C	; 12
     452:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     456:	6f 92       	push	r6
     458:	ff 92       	push	r15
     45a:	cf 93       	push	r28
     45c:	df 93       	push	r29
     45e:	8c e0       	ldi	r24, 0x0C	; 12
     460:	8f 93       	push	r24
     462:	a6 e1       	ldi	r26, 0x16	; 22
     464:	ea 2e       	mov	r14, r26
     466:	21 e0       	ldi	r18, 0x01	; 1
     468:	4d e0       	ldi	r20, 0x0D	; 13
     46a:	6d e0       	ldi	r22, 0x0D	; 13
     46c:	8d e0       	ldi	r24, 0x0D	; 13
     46e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     472:	8d b7       	in	r24, 0x3d	; 61
     474:	9e b7       	in	r25, 0x3e	; 62
     476:	83 96       	adiw	r24, 0x23	; 35
     478:	0f b6       	in	r0, 0x3f	; 63
     47a:	f8 94       	cli
     47c:	9e bf       	out	0x3e, r25	; 62
     47e:	0f be       	out	0x3f, r0	; 63
     480:	8d bf       	out	0x3d, r24	; 61
     482:	1f 92       	push	r1
     484:	1f 93       	push	r17
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	df 92       	push	r13
     48c:	81 2c       	mov	r8, r1
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     48e:	b4 e0       	ldi	r27, 0x04	; 4
     490:	eb 2e       	mov	r14, r27
     492:	00 e0       	ldi	r16, 0x00	; 0
     494:	21 e0       	ldi	r18, 0x01	; 1
     496:	4e e0       	ldi	r20, 0x0E	; 14
     498:	6e e0       	ldi	r22, 0x0E	; 14
     49a:	8e e0       	ldi	r24, 0x0E	; 14
     49c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4a0:	1f 92       	push	r1
     4a2:	1f 93       	push	r17
     4a4:	cf 93       	push	r28
     4a6:	df 93       	push	r29
     4a8:	1f 92       	push	r1
     4aa:	03 e0       	ldi	r16, 0x03	; 3
     4ac:	80 2e       	mov	r8, r16
     4ae:	85 e1       	ldi	r24, 0x15	; 21
     4b0:	e8 2e       	mov	r14, r24
     4b2:	02 e0       	ldi	r16, 0x02	; 2
     4b4:	21 e0       	ldi	r18, 0x01	; 1
     4b6:	40 e1       	ldi	r20, 0x10	; 16
     4b8:	6f e0       	ldi	r22, 0x0F	; 15
     4ba:	8f e0       	ldi	r24, 0x0F	; 15
     4bc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4c0:	1f 92       	push	r1
     4c2:	1f 93       	push	r17
     4c4:	cf 93       	push	r28
     4c6:	df 93       	push	r29
     4c8:	8d e0       	ldi	r24, 0x0D	; 13
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     4ca:	8f 93       	push	r24
     4cc:	88 24       	eor	r8, r8
     4ce:	83 94       	inc	r8
     4d0:	92 e1       	ldi	r25, 0x12	; 18
     4d2:	e9 2e       	mov	r14, r25
     4d4:	01 e0       	ldi	r16, 0x01	; 1
     4d6:	21 e0       	ldi	r18, 0x01	; 1
     4d8:	4f e0       	ldi	r20, 0x0F	; 15
     4da:	60 e1       	ldi	r22, 0x10	; 16
     4dc:	80 e1       	ldi	r24, 0x10	; 16
     4de:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4e2:	1f 92       	push	r1
     4e4:	1f 93       	push	r17
     4e6:	cf 93       	push	r28
     4e8:	df 93       	push	r29
     4ea:	25 e0       	ldi	r18, 0x05	; 5
     4ec:	62 2e       	mov	r6, r18
     4ee:	6f 92       	push	r6
     4f0:	3c e1       	ldi	r19, 0x1C	; 28
     4f2:	e3 2e       	mov	r14, r19
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	4f ef       	ldi	r20, 0xFF	; 255
     4f8:	61 e1       	ldi	r22, 0x11	; 17
     4fa:	81 e1       	ldi	r24, 0x11	; 17
     4fc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     500:	1f 92       	push	r1
     502:	1f 93       	push	r17
     504:	cf 93       	push	r28
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     506:	df 93       	push	r29
     508:	cf 93       	push	r28
     50a:	42 e0       	ldi	r20, 0x02	; 2
     50c:	84 2e       	mov	r8, r20
     50e:	5f e0       	ldi	r21, 0x0F	; 15
     510:	e5 2e       	mov	r14, r21
     512:	02 e0       	ldi	r16, 0x02	; 2
     514:	20 e0       	ldi	r18, 0x00	; 0
     516:	4f ef       	ldi	r20, 0xFF	; 255
     518:	62 e1       	ldi	r22, 0x12	; 18
     51a:	82 e1       	ldi	r24, 0x12	; 18
     51c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     520:	1f 92       	push	r1
     522:	1f 93       	push	r17
     524:	cf 93       	push	r28
     526:	df 93       	push	r29
     528:	82 e1       	ldi	r24, 0x12	; 18
     52a:	8f 93       	push	r24
     52c:	61 e1       	ldi	r22, 0x11	; 17
     52e:	e6 2e       	mov	r14, r22
     530:	20 e0       	ldi	r18, 0x00	; 0
     532:	4f ef       	ldi	r20, 0xFF	; 255
     534:	63 e1       	ldi	r22, 0x13	; 19
     536:	83 e1       	ldi	r24, 0x13	; 19
     538:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     53c:	7f 92       	push	r7
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     53e:	ff 92       	push	r15
     540:	cf 93       	push	r28
     542:	df 93       	push	r29
     544:	ff 92       	push	r15
     546:	81 2c       	mov	r8, r1
     548:	ee 24       	eor	r14, r14
     54a:	e3 94       	inc	r14
     54c:	00 e0       	ldi	r16, 0x00	; 0
     54e:	21 e0       	ldi	r18, 0x01	; 1
     550:	4f ef       	ldi	r20, 0xFF	; 255
     552:	64 e1       	ldi	r22, 0x14	; 20
     554:	84 e1       	ldi	r24, 0x14	; 20
     556:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     55a:	8d b7       	in	r24, 0x3d	; 61
     55c:	9e b7       	in	r25, 0x3e	; 62
     55e:	83 96       	adiw	r24, 0x23	; 35
     560:	0f b6       	in	r0, 0x3f	; 63
     562:	f8 94       	cli
     564:	9e bf       	out	0x3e, r25	; 62
     566:	0f be       	out	0x3f, r0	; 63
     568:	8d bf       	out	0x3d, r24	; 61
     56a:	8b e0       	ldi	r24, 0x0B	; 11
     56c:	8f 93       	push	r24
     56e:	ff 92       	push	r15
     570:	cf 93       	push	r28
     572:	df 93       	push	r29
     574:	7e e1       	ldi	r23, 0x1E	; 30
     576:	77 2e       	mov	r7, r23
     578:	7f 92       	push	r7
     57a:	e2 e0       	ldi	r30, 0x02	; 2
     57c:	8e 2e       	mov	r8, r30
     57e:	f4 e1       	ldi	r31, 0x14	; 20
     580:	ef 2e       	mov	r14, r31
     582:	02 e0       	ldi	r16, 0x02	; 2
     584:	21 e0       	ldi	r18, 0x01	; 1
     586:	4f ef       	ldi	r20, 0xFF	; 255
     588:	65 e1       	ldi	r22, 0x15	; 21
     58a:	85 e1       	ldi	r24, 0x15	; 21
     58c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     590:	1f 92       	push	r1
     592:	1f 93       	push	r17
     594:	cf 93       	push	r28
     596:	df 93       	push	r29
     598:	1f 93       	push	r17
     59a:	81 2c       	mov	r8, r1
     59c:	a7 e0       	ldi	r26, 0x07	; 7
     59e:	ea 2e       	mov	r14, r26
     5a0:	00 e0       	ldi	r16, 0x00	; 0
     5a2:	21 e0       	ldi	r18, 0x01	; 1
     5a4:	4f ef       	ldi	r20, 0xFF	; 255
     5a6:	66 e1       	ldi	r22, 0x16	; 22
     5a8:	86 e1       	ldi	r24, 0x16	; 22
     5aa:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     5ae:	1f 92       	push	r1
     5b0:	ff 92       	push	r15
     5b2:	cf 93       	push	r28
     5b4:	df 93       	push	r29
     5b6:	84 e1       	ldi	r24, 0x14	; 20
     5b8:	8f 93       	push	r24
     5ba:	b2 e1       	ldi	r27, 0x12	; 18
     5bc:	eb 2e       	mov	r14, r27
     5be:	21 e0       	ldi	r18, 0x01	; 1
     5c0:	4f ef       	ldi	r20, 0xFF	; 255
     5c2:	67 e1       	ldi	r22, 0x17	; 23
     5c4:	87 e1       	ldi	r24, 0x17	; 23
     5c6:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     5ca:	bf 92       	push	r11
     5cc:	ff 92       	push	r15
     5ce:	cf 93       	push	r28
     5d0:	df 93       	push	r29
     5d2:	85 e1       	ldi	r24, 0x15	; 21
     5d4:	8f 93       	push	r24
     5d6:	83 e1       	ldi	r24, 0x13	; 19
     5d8:	e8 2e       	mov	r14, r24
     5da:	21 e0       	ldi	r18, 0x01	; 1
     5dc:	4f ef       	ldi	r20, 0xFF	; 255
     5de:	68 e1       	ldi	r22, 0x18	; 24
     5e0:	88 e1       	ldi	r24, 0x18	; 24
     5e2:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     5e6:	ff 92       	push	r15
     5e8:	ff 92       	push	r15
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     5ee:	86 e1       	ldi	r24, 0x16	; 22
     5f0:	8f 93       	push	r24
     5f2:	9a e0       	ldi	r25, 0x0A	; 10
     5f4:	e9 2e       	mov	r14, r25
     5f6:	21 e0       	ldi	r18, 0x01	; 1
     5f8:	4f ef       	ldi	r20, 0xFF	; 255
     5fa:	69 e1       	ldi	r22, 0x19	; 25
     5fc:	89 e1       	ldi	r24, 0x19	; 25
     5fe:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     602:	1f 93       	push	r17
     604:	ff 92       	push	r15
     606:	cf 93       	push	r28
     608:	df 93       	push	r29
     60a:	87 e1       	ldi	r24, 0x17	; 23
     60c:	8f 93       	push	r24
     60e:	2f e0       	ldi	r18, 0x0F	; 15
     610:	e2 2e       	mov	r14, r18
     612:	21 e0       	ldi	r18, 0x01	; 1
     614:	4f ef       	ldi	r20, 0xFF	; 255
     616:	6a e1       	ldi	r22, 0x1A	; 26
     618:	8a e1       	ldi	r24, 0x1A	; 26
     61a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     61e:	5f 92       	push	r5
     620:	ff 92       	push	r15
     622:	cf 93       	push	r28
     624:	df 93       	push	r29
     626:	88 e1       	ldi	r24, 0x18	; 24
     628:	8f 93       	push	r24
     62a:	39 e0       	ldi	r19, 0x09	; 9
     62c:	e3 2e       	mov	r14, r19
     62e:	21 e0       	ldi	r18, 0x01	; 1
     630:	4f ef       	ldi	r20, 0xFF	; 255
     632:	6b e1       	ldi	r22, 0x1B	; 27
     634:	8b e1       	ldi	r24, 0x1B	; 27
     636:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     63a:	8d b7       	in	r24, 0x3d	; 61
     63c:	9e b7       	in	r25, 0x3e	; 62
     63e:	83 96       	adiw	r24, 0x23	; 35
     640:	0f b6       	in	r0, 0x3f	; 63
     642:	f8 94       	cli
     644:	9e bf       	out	0x3e, r25	; 62
     646:	0f be       	out	0x3f, r0	; 63
     648:	8d bf       	out	0x3d, r24	; 61
     64a:	1f 92       	push	r1
     64c:	1f 93       	push	r17
     64e:	cf 93       	push	r28
     650:	df 93       	push	r29
     652:	89 e1       	ldi	r24, 0x19	; 25
     654:	8f 93       	push	r24
     656:	4e e0       	ldi	r20, 0x0E	; 14
     658:	e4 2e       	mov	r14, r20
     65a:	21 e0       	ldi	r18, 0x01	; 1
     65c:	4f ef       	ldi	r20, 0xFF	; 255
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     65e:	6c e1       	ldi	r22, 0x1C	; 28
     660:	8c e1       	ldi	r24, 0x1C	; 28
     662:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     666:	1f 92       	push	r1
     668:	1f 93       	push	r17
     66a:	cf 93       	push	r28
     66c:	df 93       	push	r29
     66e:	8a e1       	ldi	r24, 0x1A	; 26
     670:	8f 93       	push	r24
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     672:	50 e1       	ldi	r21, 0x10	; 16
     674:	e5 2e       	mov	r14, r21
     676:	21 e0       	ldi	r18, 0x01	; 1
     678:	4f ef       	ldi	r20, 0xFF	; 255
     67a:	6d e1       	ldi	r22, 0x1D	; 29
     67c:	8d e1       	ldi	r24, 0x1D	; 29
     67e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     682:	1f 92       	push	r1
     684:	1f 93       	push	r17
     686:	cf 93       	push	r28
     688:	df 93       	push	r29
     68a:	8b e1       	ldi	r24, 0x1B	; 27
     68c:	8f 93       	push	r24
     68e:	68 e0       	ldi	r22, 0x08	; 8
     690:	e6 2e       	mov	r14, r22
     692:	21 e0       	ldi	r18, 0x01	; 1
     694:	4f ef       	ldi	r20, 0xFF	; 255
     696:	6e e1       	ldi	r22, 0x1E	; 30
     698:	8e e1       	ldi	r24, 0x1E	; 30
     69a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     69e:	6f 92       	push	r6
     6a0:	ff 92       	push	r15
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6a2:	cf 93       	push	r28
     6a4:	df 93       	push	r29
     6a6:	8c e1       	ldi	r24, 0x1C	; 28
     6a8:	8f 93       	push	r24
     6aa:	7d e0       	ldi	r23, 0x0D	; 13
     6ac:	e7 2e       	mov	r14, r23
     6ae:	21 e0       	ldi	r18, 0x01	; 1
     6b0:	4f ef       	ldi	r20, 0xFF	; 255
     6b2:	6f e1       	ldi	r22, 0x1F	; 31
     6b4:	8f e1       	ldi	r24, 0x1F	; 31
     6b6:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6ba:	1f 92       	push	r1
     6bc:	1f 93       	push	r17
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     6c2:	8d e1       	ldi	r24, 0x1D	; 29
     6c4:	8f 93       	push	r24
     6c6:	ec e0       	ldi	r30, 0x0C	; 12
     6c8:	ee 2e       	mov	r14, r30
     6ca:	21 e0       	ldi	r18, 0x01	; 1
     6cc:	4f ef       	ldi	r20, 0xFF	; 255
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6ce:	60 e2       	ldi	r22, 0x20	; 32
     6d0:	80 e2       	ldi	r24, 0x20	; 32
     6d2:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6d6:	1f 92       	push	r1
     6d8:	1f 93       	push	r17
     6da:	cf 93       	push	r28
     6dc:	df 93       	push	r29
     6de:	7f 92       	push	r7
     6e0:	fb e0       	ldi	r31, 0x0B	; 11
     6e2:	ef 2e       	mov	r14, r31
     6e4:	21 e0       	ldi	r18, 0x01	; 1
     6e6:	4f ef       	ldi	r20, 0xFF	; 255
     6e8:	61 e2       	ldi	r22, 0x21	; 33
     6ea:	81 e2       	ldi	r24, 0x21	; 33
     6ec:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6f0:	1f 92       	push	r1
     6f2:	1f 93       	push	r17
     6f4:	cf 93       	push	r28
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     6f6:	df 93       	push	r29
     6f8:	9f 92       	push	r9
     6fa:	a1 e1       	ldi	r26, 0x11	; 17
     6fc:	ea 2e       	mov	r14, r26
     6fe:	21 e0       	ldi	r18, 0x01	; 1
     700:	4f ef       	ldi	r20, 0xFF	; 255
     702:	62 e2       	ldi	r22, 0x22	; 34
     704:	82 e2       	ldi	r24, 0x22	; 34
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
	}
  	percent = 100*(1 - batt_time/discharge_max_time);
     706:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     70a:	8d b7       	in	r24, 0x3d	; 61
     70c:	9e b7       	in	r25, 0x3e	; 62
     70e:	83 96       	adiw	r24, 0x23	; 35
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	f8 94       	cli
     714:	9e bf       	out	0x3e, r25	; 62
     716:	0f be       	out	0x3f, r0	; 63
     718:	8d bf       	out	0x3d, r24	; 61
     71a:	df 92       	push	r13
     71c:	ff 92       	push	r15
     71e:	cf 93       	push	r28
     720:	df 93       	push	r29
     722:	1f 92       	push	r1
     724:	b5 e0       	ldi	r27, 0x05	; 5
     726:	eb 2e       	mov	r14, r27
     728:	21 e0       	ldi	r18, 0x01	; 1
     72a:	4f ef       	ldi	r20, 0xFF	; 255
     72c:	63 e2       	ldi	r22, 0x23	; 35
     72e:	83 e2       	ldi	r24, 0x23	; 35
     730:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     734:	0f 90       	pop	r0
     736:	0f 90       	pop	r0
     738:	0f 90       	pop	r0
     73a:	0f 90       	pop	r0
  }
  else 
  {
    float temp_real = 0;
    if (real < 13.35)
     73c:	0f 90       	pop	r0
     73e:	df 91       	pop	r29
     740:	cf 91       	pop	r28
     742:	1f 91       	pop	r17
     744:	0f 91       	pop	r16
     746:	ff 90       	pop	r15
     748:	ef 90       	pop	r14
     74a:	df 90       	pop	r13
     74c:	cf 90       	pop	r12
     74e:	bf 90       	pop	r11
	{
	  debug = 0x0C;
     750:	af 90       	pop	r10
     752:	9f 90       	pop	r9
     754:	8f 90       	pop	r8
	  // voltage is normalized by mean 13.13 and std 0.1754 (real - 13.13)/0.1754
	  temp_real = (real - 13.13)*5.701254;
     756:	7f 90       	pop	r7
     758:	6f 90       	pop	r6
     75a:	5f 90       	pop	r5
     75c:	08 95       	ret

0000075e <receive_message>:
     75e:	ff 92       	push	r15
     760:	0f 93       	push	r16
     762:	1f 93       	push	r17
     764:	cf 93       	push	r28
     766:	df 93       	push	r29
     768:	f8 2e       	mov	r15, r24
     76a:	fb 01       	movw	r30, r22
     76c:	c1 81       	ldd	r28, Z+1	; 0x01
     76e:	90 81       	ld	r25, Z
     770:	93 30       	cpi	r25, 0x03	; 3
     772:	09 f4       	brne	.+2      	; 0x776 <receive_message+0x18>
     774:	5a c0       	rjmp	.+180    	; 0x82a <receive_message+0xcc>
	  batt_time = p1*pow(temp_real,3) + p2*pow(temp_real,2) + p3*temp_real + p4;
     776:	30 f4       	brcc	.+12     	; 0x784 <receive_message+0x26>
     778:	0c 2f       	mov	r16, r28
     77a:	10 e0       	ldi	r17, 0x00	; 0
     77c:	91 30       	cpi	r25, 0x01	; 1
     77e:	11 f1       	breq	.+68     	; 0x7c4 <receive_message+0x66>
     780:	90 f5       	brcc	.+100    	; 0x7e6 <receive_message+0x88>
     782:	0c c0       	rjmp	.+24     	; 0x79c <receive_message+0x3e>
     784:	95 30       	cpi	r25, 0x05	; 5
     786:	09 f4       	brne	.+2      	; 0x78a <receive_message+0x2c>
     788:	55 c0       	rjmp	.+170    	; 0x834 <receive_message+0xd6>
     78a:	08 f4       	brcc	.+2      	; 0x78e <receive_message+0x30>
     78c:	50 c0       	rjmp	.+160    	; 0x82e <receive_message+0xd0>
     78e:	96 30       	cpi	r25, 0x06	; 6
     790:	09 f4       	brne	.+2      	; 0x794 <receive_message+0x36>
     792:	60 c0       	rjmp	.+192    	; 0x854 <receive_message+0xf6>
     794:	97 30       	cpi	r25, 0x07	; 7
     796:	09 f0       	breq	.+2      	; 0x79a <receive_message+0x3c>
     798:	7b c0       	rjmp	.+246    	; 0x890 <receive_message+0x132>
     79a:	6b c0       	rjmp	.+214    	; 0x872 <receive_message+0x114>
     79c:	8c e2       	ldi	r24, 0x2C	; 44
     79e:	80 93 e2 10 	sts	0x10E2, r24
     7a2:	83 e3       	ldi	r24, 0x33	; 51
     7a4:	80 9f       	mul	r24, r16
     7a6:	e0 01       	movw	r28, r0
     7a8:	81 9f       	mul	r24, r17
     7aa:	d0 0d       	add	r29, r0
     7ac:	11 24       	eor	r1, r1
     7ae:	c4 5c       	subi	r28, 0xC4	; 196
     7b0:	dc 4f       	sbci	r29, 0xFC	; 252
     7b2:	89 81       	ldd	r24, Y+1	; 0x01
     7b4:	8f 3f       	cpi	r24, 0xFF	; 255
     7b6:	21 f0       	breq	.+8      	; 0x7c0 <receive_message+0x62>
     7b8:	0e 94 08 09 	call	0x1210	; 0x1210 <switch_on>
     7bc:	81 e0       	ldi	r24, 0x01	; 1
     7be:	8a 83       	std	Y+2, r24	; 0x02
     7c0:	40 e0       	ldi	r20, 0x00	; 0
     7c2:	0f c0       	rjmp	.+30     	; 0x7e2 <receive_message+0x84>
     7c4:	83 e3       	ldi	r24, 0x33	; 51
     7c6:	80 9f       	mul	r24, r16
     7c8:	e0 01       	movw	r28, r0
     7ca:	81 9f       	mul	r24, r17
     7cc:	d0 0d       	add	r29, r0
     7ce:	11 24       	eor	r1, r1
     7d0:	c4 5c       	subi	r28, 0xC4	; 196
     7d2:	dc 4f       	sbci	r29, 0xFC	; 252
     7d4:	89 81       	ldd	r24, Y+1	; 0x01
     7d6:	8f 3f       	cpi	r24, 0xFF	; 255
     7d8:	19 f0       	breq	.+6      	; 0x7e0 <receive_message+0x82>
     7da:	0e 94 4b 09 	call	0x1296	; 0x1296 <switch_off>
     7de:	1a 82       	std	Y+2, r1	; 0x02
     7e0:	41 e0       	ldi	r20, 0x01	; 1
     7e2:	62 e0       	ldi	r22, 0x02	; 2
     7e4:	57 c0       	rjmp	.+174    	; 0x894 <receive_message+0x136>
     7e6:	83 e3       	ldi	r24, 0x33	; 51
     7e8:	80 9f       	mul	r24, r16
     7ea:	e0 01       	movw	r28, r0
     7ec:	81 9f       	mul	r24, r17
     7ee:	d0 0d       	add	r29, r0
     7f0:	11 24       	eor	r1, r1
     7f2:	c4 5c       	subi	r28, 0xC4	; 196
     7f4:	dc 4f       	sbci	r29, 0xFC	; 252
     7f6:	89 81       	ldd	r24, Y+1	; 0x01
     7f8:	8f 3f       	cpi	r24, 0xFF	; 255
     7fa:	19 f0       	breq	.+6      	; 0x802 <receive_message+0xa4>
     7fc:	0e 94 4b 09 	call	0x1296	; 0x1296 <switch_off>
     800:	1a 82       	std	Y+2, r1	; 0x02
     802:	85 e0       	ldi	r24, 0x05	; 5
     804:	8a 95       	dec	r24
     806:	f1 f7       	brne	.-4      	; 0x804 <receive_message+0xa6>
     808:	83 e3       	ldi	r24, 0x33	; 51
     80a:	80 9f       	mul	r24, r16
     80c:	e0 01       	movw	r28, r0
     80e:	81 9f       	mul	r24, r17
	}
	else 
	{
	  debug = 0x0D;
     810:	d0 0d       	add	r29, r0
     812:	11 24       	eor	r1, r1
     814:	c4 5c       	subi	r28, 0xC4	; 196
	  // voltage is normalized by mean 13.7 and std 0.1558 (real - 13.7)/0.1558;
	  temp_real = (real - 13.7)*6.418485;
     816:	dc 4f       	sbci	r29, 0xFC	; 252
     818:	89 81       	ldd	r24, Y+1	; 0x01
     81a:	8f 3f       	cpi	r24, 0xFF	; 255
     81c:	21 f0       	breq	.+8      	; 0x826 <receive_message+0xc8>
     81e:	0e 94 08 09 	call	0x1210	; 0x1210 <switch_on>
     822:	81 e0       	ldi	r24, 0x01	; 1
     824:	8a 83       	std	Y+2, r24	; 0x02
     826:	42 e0       	ldi	r20, 0x02	; 2
     828:	dc cf       	rjmp	.-72     	; 0x7e2 <receive_message+0x84>
     82a:	43 e0       	ldi	r20, 0x03	; 3
     82c:	da cf       	rjmp	.-76     	; 0x7e2 <receive_message+0x84>
     82e:	40 e0       	ldi	r20, 0x00	; 0
     830:	60 e0       	ldi	r22, 0x00	; 0
     832:	30 c0       	rjmp	.+96     	; 0x894 <receive_message+0x136>
     834:	83 e3       	ldi	r24, 0x33	; 51
      batt_time = q1*pow(temp_real,3) + q2*pow(temp_real,2) + q3*temp_real + q4;
     836:	c8 9f       	mul	r28, r24
     838:	e0 01       	movw	r28, r0
     83a:	11 24       	eor	r1, r1
     83c:	c4 5c       	subi	r28, 0xC4	; 196
     83e:	dc 4f       	sbci	r29, 0xFC	; 252
     840:	89 81       	ldd	r24, Y+1	; 0x01
     842:	8f 3f       	cpi	r24, 0xFF	; 255
     844:	29 f0       	breq	.+10     	; 0x850 <receive_message+0xf2>
     846:	0e 94 08 09 	call	0x1210	; 0x1210 <switch_on>
     84a:	81 e0       	ldi	r24, 0x01	; 1
     84c:	8a 83       	std	Y+2, r24	; 0x02
     84e:	8b 83       	std	Y+3, r24	; 0x03
     850:	45 e0       	ldi	r20, 0x05	; 5
     852:	c7 cf       	rjmp	.-114    	; 0x7e2 <receive_message+0x84>
     854:	83 e3       	ldi	r24, 0x33	; 51
     856:	c8 9f       	mul	r28, r24
     858:	e0 01       	movw	r28, r0
     85a:	11 24       	eor	r1, r1
     85c:	c4 5c       	subi	r28, 0xC4	; 196
     85e:	dc 4f       	sbci	r29, 0xFC	; 252
     860:	89 81       	ldd	r24, Y+1	; 0x01
     862:	8f 3f       	cpi	r24, 0xFF	; 255
     864:	f9 f0       	breq	.+62     	; 0x8a4 <receive_message+0x146>
     866:	82 81       	ldd	r24, Z+2	; 0x02
     868:	8e 83       	std	Y+6, r24	; 0x06
     86a:	82 81       	ldd	r24, Z+2	; 0x02
     86c:	80 93 c0 0e 	sts	0x0EC0, r24
     870:	19 c0       	rjmp	.+50     	; 0x8a4 <receive_message+0x146>
     872:	83 e3       	ldi	r24, 0x33	; 51
     874:	c8 9f       	mul	r28, r24
     876:	e0 01       	movw	r28, r0
     878:	11 24       	eor	r1, r1
     87a:	c4 5c       	subi	r28, 0xC4	; 196
     87c:	dc 4f       	sbci	r29, 0xFC	; 252
     87e:	89 81       	ldd	r24, Y+1	; 0x01
     880:	8f 3f       	cpi	r24, 0xFF	; 255
     882:	81 f0       	breq	.+32     	; 0x8a4 <receive_message+0x146>
     884:	82 81       	ldd	r24, Z+2	; 0x02
     886:	8f 87       	std	Y+15, r24	; 0x0f
     888:	82 81       	ldd	r24, Z+2	; 0x02
     88a:	80 93 bb 0e 	sts	0x0EBB, r24
     88e:	0a c0       	rjmp	.+20     	; 0x8a4 <receive_message+0x146>
     890:	40 e0       	ldi	r20, 0x00	; 0
     892:	61 e0       	ldi	r22, 0x01	; 1
     894:	8f 2d       	mov	r24, r15
     896:	df 91       	pop	r29
     898:	cf 91       	pop	r28
     89a:	1f 91       	pop	r17
     89c:	0f 91       	pop	r16
     89e:	ff 90       	pop	r15
     8a0:	0c 94 c2 11 	jmp	0x2384	; 0x2384 <transmit_packet>
     8a4:	df 91       	pop	r29
     8a6:	cf 91       	pop	r28
     8a8:	1f 91       	pop	r17
     8aa:	0f 91       	pop	r16
     8ac:	ff 90       	pop	r15
     8ae:	08 95       	ret

000008b0 <StateofCharge>:
     8b0:	cf 93       	push	r28
     8b2:	90 91 b0 0c 	lds	r25, 0x0CB0
     8b6:	9f 3f       	cpi	r25, 0xFF	; 255
     8b8:	09 f4       	brne	.+2      	; 0x8bc <StateofCharge+0xc>
     8ba:	c2 c0       	rjmp	.+388    	; 0xa40 <StateofCharge+0x190>
     8bc:	80 91 9a 0c 	lds	r24, 0x0C9A
     8c0:	88 23       	and	r24, r24
     8c2:	09 f4       	brne	.+2      	; 0x8c6 <StateofCharge+0x16>
     8c4:	bd c0       	rjmp	.+378    	; 0xa40 <StateofCharge+0x190>
     8c6:	80 91 b1 0c 	lds	r24, 0x0CB1
     8ca:	88 23       	and	r24, r24
     8cc:	21 f0       	breq	.+8      	; 0x8d6 <StateofCharge+0x26>
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	80 93 ed 10 	sts	0x10ED, r24
     8d4:	02 c0       	rjmp	.+4      	; 0x8da <StateofCharge+0x2a>
     8d6:	10 92 ed 10 	sts	0x10ED, r1
     8da:	80 91 ed 10 	lds	r24, 0x10ED
     8de:	88 23       	and	r24, r24
     8e0:	19 f0       	breq	.+6      	; 0x8e8 <StateofCharge+0x38>
	}
  	percent = 100*(batt_time/charge_max_time);
     8e2:	9f 37       	cpi	r25, 0x7F	; 127
     8e4:	20 f0       	brcs	.+8      	; 0x8ee <StateofCharge+0x3e>
     8e6:	a0 c0       	rjmp	.+320    	; 0xa28 <StateofCharge+0x178>
     8e8:	98 37       	cpi	r25, 0x78	; 120
     8ea:	08 f0       	brcs	.+2      	; 0x8ee <StateofCharge+0x3e>
     8ec:	9d c0       	rjmp	.+314    	; 0xa28 <StateofCharge+0x178>
     8ee:	95 36       	cpi	r25, 0x65	; 101
     8f0:	08 f4       	brcc	.+2      	; 0x8f4 <StateofCharge+0x44>
     8f2:	95 c0       	rjmp	.+298    	; 0xa1e <StateofCharge+0x16e>
     8f4:	c0 91 06 03 	lds	r28, 0x0306
     8f8:	2c 2f       	mov	r18, r28
     8fa:	2f 5f       	subi	r18, 0xFF	; 255
     8fc:	20 93 06 03 	sts	0x0306, r18
     900:	88 23       	and	r24, r24
     902:	f1 f1       	breq	.+124    	; 0x980 <StateofCharge+0xd0>
     904:	80 91 c4 10 	lds	r24, 0x10C4
     908:	9a 36       	cpi	r25, 0x6A	; 106
     90a:	20 f4       	brcc	.+8      	; 0x914 <StateofCharge+0x64>
     90c:	82 95       	swap	r24
     90e:	86 95       	lsr	r24
     910:	86 95       	lsr	r24
     912:	0b c0       	rjmp	.+22     	; 0x92a <StateofCharge+0x7a>
     914:	29 2f       	mov	r18, r25
     916:	2a 56       	subi	r18, 0x6A	; 106
     918:	82 95       	swap	r24
     91a:	86 95       	lsr	r24
     91c:	86 95       	lsr	r24
     91e:	83 70       	andi	r24, 0x03	; 3
     920:	2a 30       	cpi	r18, 0x0A	; 10
  }
  
  // Percent limiting for periodic function
  if (percent < 1) 
     922:	10 f4       	brcc	.+4      	; 0x928 <StateofCharge+0x78>
     924:	8f 5f       	subi	r24, 0xFF	; 255
     926:	01 c0       	rjmp	.+2      	; 0x92a <StateofCharge+0x7a>
     928:	8e 5f       	subi	r24, 0xFE	; 254
     92a:	83 70       	andi	r24, 0x03	; 3
     92c:	80 93 e0 10 	sts	0x10E0, r24
     930:	e9 2f       	mov	r30, r25
     932:	f0 e0       	ldi	r31, 0x00	; 0
     934:	e5 56       	subi	r30, 0x65	; 101
     936:	f1 09       	sbc	r31, r1
     938:	ee 0f       	add	r30, r30
     93a:	ff 1f       	adc	r31, r31
     93c:	ee 0f       	add	r30, r30
     93e:	ff 1f       	adc	r31, r31
     940:	e8 0f       	add	r30, r24
     942:	f1 1d       	adc	r31, r1
     944:	ee 0f       	add	r30, r30
  { 
  	debug2 = 0xA0;
     946:	ff 1f       	adc	r31, r31
     948:	e4 57       	subi	r30, 0x74	; 116
     94a:	ff 4f       	sbci	r31, 0xFF	; 255
  	soc = 0; 
     94c:	65 91       	lpm	r22, Z+
     94e:	74 91       	lpm	r23, Z
     950:	6b 50       	subi	r22, 0x0B	; 11
  }
  else if (percent > 99) 
     952:	71 09       	sbc	r23, r1
     954:	80 e0       	ldi	r24, 0x00	; 0
     956:	90 e0       	ldi	r25, 0x00	; 0
     958:	0e 94 40 13 	call	0x2680	; 0x2680 <__floatunsisf>
     95c:	28 eb       	ldi	r18, 0xB8	; 184
     95e:	3e e1       	ldi	r19, 0x1E	; 30
     960:	49 e2       	ldi	r20, 0x29	; 41
     962:	51 e4       	ldi	r21, 0x41	; 65
     964:	0e 94 d8 12 	call	0x25b0	; 0x25b0 <__divsf3>
  { 
  	debug2 = 0xB0;
     968:	60 93 6f 0a 	sts	0x0A6F, r22
  	soc = 255;
     96c:	70 93 70 0a 	sts	0x0A70, r23
     970:	80 93 71 0a 	sts	0x0A71, r24
  }
  else { 
  	debug2 = 0xC0;
     974:	90 93 72 0a 	sts	0x0A72, r25
     978:	c9 5f       	subi	r28, 0xF9	; 249
  	soc = (char)floor((int)(percent)); 
     97a:	c0 93 06 03 	sts	0x0306, r28
     97e:	60 c0       	rjmp	.+192    	; 0xa40 <StateofCharge+0x190>
     980:	9a 36       	cpi	r25, 0x6A	; 106
     982:	30 f4       	brcc	.+12     	; 0x990 <StateofCharge+0xe0>
     984:	80 91 c4 10 	lds	r24, 0x10C4
     988:	82 95       	swap	r24
     98a:	86 95       	lsr	r24
     98c:	86 95       	lsr	r24
     98e:	17 c0       	rjmp	.+46     	; 0x9be <StateofCharge+0x10e>
     990:	89 2f       	mov	r24, r25
     992:	8a 56       	subi	r24, 0x6A	; 106
     994:	8a 30       	cpi	r24, 0x0A	; 10
     996:	40 f4       	brcc	.+16     	; 0x9a8 <StateofCharge+0xf8>
     998:	80 91 c4 10 	lds	r24, 0x10C4
  }
}
     99c:	82 95       	swap	r24
     99e:	86 95       	lsr	r24
     9a0:	86 95       	lsr	r24
     9a2:	83 70       	andi	r24, 0x03	; 3
     9a4:	8f 5f       	subi	r24, 0xFF	; 255
     9a6:	0b c0       	rjmp	.+22     	; 0x9be <StateofCharge+0x10e>
     9a8:	89 2f       	mov	r24, r25
     9aa:	84 57       	subi	r24, 0x74	; 116
     9ac:	83 30       	cpi	r24, 0x03	; 3
     9ae:	48 f4       	brcc	.+18     	; 0x9c2 <StateofCharge+0x112>
     9b0:	80 91 c4 10 	lds	r24, 0x10C4
     9b4:	82 95       	swap	r24
     9b6:	86 95       	lsr	r24
     9b8:	86 95       	lsr	r24
     9ba:	83 70       	andi	r24, 0x03	; 3
     9bc:	8e 5f       	subi	r24, 0xFE	; 254
     9be:	83 70       	andi	r24, 0x03	; 3
     9c0:	01 c0       	rjmp	.+2      	; 0x9c4 <StateofCharge+0x114>
     9c2:	80 e0       	ldi	r24, 0x00	; 0
				percent = (charge20Pc[(batt1_voltage - 0x65)*4 + ltOffset] - 11) / (10.57);
				antioptimizer+=6;
				
			}else{
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     9c4:	80 93 e0 10 	sts	0x10E0, r24
							((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
							((batt1_voltage >= 0x74) && (batt1_voltage <= 0x76)) ? (((batt1_voltageLow >> 6) + 2) % 0x04) :
							0x00;
				
				percent = 100 - ((discharge20Pc[(0x77 - batt1_voltage)*4 - ltOffset]) ) / (10.07);
     9c8:	e7 e7       	ldi	r30, 0x77	; 119
     9ca:	f0 e0       	ldi	r31, 0x00	; 0
     9cc:	e9 1b       	sub	r30, r25
     9ce:	f1 09       	sbc	r31, r1
     9d0:	ee 0f       	add	r30, r30
     9d2:	ff 1f       	adc	r31, r31
     9d4:	ee 0f       	add	r30, r30
     9d6:	ff 1f       	adc	r31, r31
     9d8:	e8 1b       	sub	r30, r24
     9da:	f1 09       	sbc	r31, r1
     9dc:	ee 0f       	add	r30, r30
     9de:	ff 1f       	adc	r31, r31
     9e0:	e8 59       	subi	r30, 0x98	; 152
     9e2:	fe 4f       	sbci	r31, 0xFE	; 254
     9e4:	65 91       	lpm	r22, Z+
     9e6:	74 91       	lpm	r23, Z
     9e8:	80 e0       	ldi	r24, 0x00	; 0
     9ea:	90 e0       	ldi	r25, 0x00	; 0
     9ec:	0e 94 40 13 	call	0x2680	; 0x2680 <__floatunsisf>
     9f0:	28 eb       	ldi	r18, 0xB8	; 184
     9f2:	3e e1       	ldi	r19, 0x1E	; 30
     9f4:	41 e2       	ldi	r20, 0x21	; 33
     9f6:	51 e4       	ldi	r21, 0x41	; 65
     9f8:	0e 94 d8 12 	call	0x25b0	; 0x25b0 <__divsf3>
     9fc:	9b 01       	movw	r18, r22
     9fe:	ac 01       	movw	r20, r24
     a00:	60 e0       	ldi	r22, 0x00	; 0
     a02:	70 e0       	ldi	r23, 0x00	; 0
     a04:	88 ec       	ldi	r24, 0xC8	; 200
     a06:	92 e4       	ldi	r25, 0x42	; 66
     a08:	0e 94 6f 12 	call	0x24de	; 0x24de <__subsf3>
     a0c:	60 93 6f 0a 	sts	0x0A6F, r22
     a10:	70 93 70 0a 	sts	0x0A70, r23
     a14:	80 93 71 0a 	sts	0x0A71, r24
     a18:	90 93 72 0a 	sts	0x0A72, r25
     a1c:	11 c0       	rjmp	.+34     	; 0xa40 <StateofCharge+0x190>
			}
		}else if(batt1_voltage <= 0x64){
			percent = -1;
     a1e:	80 e0       	ldi	r24, 0x00	; 0
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	a0 e8       	ldi	r26, 0x80	; 128
     a24:	bf eb       	ldi	r27, 0xBF	; 191
     a26:	04 c0       	rjmp	.+8      	; 0xa30 <StateofCharge+0x180>
		}else if(  ((batt1_voltage > 0x7E)&&isCharging) || ((!isCharging)&&(batt1_voltage > 0x77)) ){
			percent = 108;
     a28:	80 e0       	ldi	r24, 0x00	; 0
     a2a:	90 e0       	ldi	r25, 0x00	; 0
     a2c:	a8 ed       	ldi	r26, 0xD8	; 216
     a2e:	b2 e4       	ldi	r27, 0x42	; 66
     a30:	80 93 6f 0a 	sts	0x0A6F, r24
     a34:	90 93 70 0a 	sts	0x0A70, r25
     a38:	a0 93 71 0a 	sts	0x0A71, r26
     a3c:	b0 93 72 0a 	sts	0x0A72, r27
		}
	}
	
	if(solar1_current < 0xFF && solar1_current > 0x00){
     a40:	80 91 b1 0c 	lds	r24, 0x0CB1
     a44:	81 50       	subi	r24, 0x01	; 1
     a46:	8e 3f       	cpi	r24, 0xFE	; 254
     a48:	28 f4       	brcc	.+10     	; 0xa54 <StateofCharge+0x1a4>
		antioptimizer++;
     a4a:	80 91 06 03 	lds	r24, 0x0306
     a4e:	8f 5f       	subi	r24, 0xFF	; 255
     a50:	80 93 06 03 	sts	0x0306, r24
	}
	
	
}
     a54:	cf 91       	pop	r28
     a56:	08 95       	ret

00000a58 <assign_charge_fit>:



/* Assigns values to the Fourier coefficients of the charge approximation */
void assign_charge_fit( void ) {
  charge_max_time = 10188;
     a58:	80 e0       	ldi	r24, 0x00	; 0
     a5a:	90 e3       	ldi	r25, 0x30	; 48
     a5c:	af e1       	ldi	r26, 0x1F	; 31
     a5e:	b6 e4       	ldi	r27, 0x46	; 70
     a60:	80 93 b7 0c 	sts	0x0CB7, r24
     a64:	90 93 b8 0c 	sts	0x0CB8, r25
     a68:	a0 93 b9 0c 	sts	0x0CB9, r26
     a6c:	b0 93 ba 0c 	sts	0x0CBA, r27
  // x is normalized by mean 13.13 and std 0.1754
  p1 = 18.57;
     a70:	8c e5       	ldi	r24, 0x5C	; 92
     a72:	9f e8       	ldi	r25, 0x8F	; 143
     a74:	a4 e9       	ldi	r26, 0x94	; 148
     a76:	b1 e4       	ldi	r27, 0x41	; 65
     a78:	80 93 89 0c 	sts	0x0C89, r24
     a7c:	90 93 8a 0c 	sts	0x0C8A, r25
     a80:	a0 93 8b 0c 	sts	0x0C8B, r26
     a84:	b0 93 8c 0c 	sts	0x0C8C, r27
  p2 = 184.8;
     a88:	8d ec       	ldi	r24, 0xCD	; 205
     a8a:	9c ec       	ldi	r25, 0xCC	; 204
     a8c:	a8 e3       	ldi	r26, 0x38	; 56
     a8e:	b3 e4       	ldi	r27, 0x43	; 67
     a90:	80 93 25 03 	sts	0x0325, r24
     a94:	90 93 26 03 	sts	0x0326, r25
     a98:	a0 93 27 03 	sts	0x0327, r26
     a9c:	b0 93 28 03 	sts	0x0328, r27
  p3 = 663.6;
     aa0:	86 e6       	ldi	r24, 0x66	; 102
     aa2:	96 ee       	ldi	r25, 0xE6	; 230
     aa4:	a5 e2       	ldi	r26, 0x25	; 37
     aa6:	b4 e4       	ldi	r27, 0x44	; 68
     aa8:	80 93 d4 10 	sts	0x10D4, r24
     aac:	90 93 d5 10 	sts	0x10D5, r25
     ab0:	a0 93 d6 10 	sts	0x10D6, r26
     ab4:	b0 93 d7 10 	sts	0x10D7, r27
  p4 = 838.6;
     ab8:	86 e6       	ldi	r24, 0x66	; 102
     aba:	96 ea       	ldi	r25, 0xA6	; 166
     abc:	a1 e5       	ldi	r26, 0x51	; 81
     abe:	b4 e4       	ldi	r27, 0x44	; 68
     ac0:	80 93 f0 10 	sts	0x10F0, r24
     ac4:	90 93 f1 10 	sts	0x10F1, r25
     ac8:	a0 93 f2 10 	sts	0x10F2, r26
     acc:	b0 93 f3 10 	sts	0x10F3, r27
  //where x is normalized by mean 13.7 and std 0.1558
  q1 = 78.49;
     ad0:	81 ee       	ldi	r24, 0xE1	; 225
     ad2:	9a ef       	ldi	r25, 0xFA	; 250
     ad4:	ac e9       	ldi	r26, 0x9C	; 156
     ad6:	b2 e4       	ldi	r27, 0x42	; 66
     ad8:	80 93 ab 0c 	sts	0x0CAB, r24
     adc:	90 93 ac 0c 	sts	0x0CAC, r25
     ae0:	a0 93 ad 0c 	sts	0x0CAD, r26
     ae4:	b0 93 ae 0c 	sts	0x0CAE, r27
  q2 = 543.1;
     ae8:	86 e6       	ldi	r24, 0x66	; 102
     aea:	96 ec       	ldi	r25, 0xC6	; 198
     aec:	a7 e0       	ldi	r26, 0x07	; 7
     aee:	b4 e4       	ldi	r27, 0x44	; 68
     af0:	80 93 68 0a 	sts	0x0A68, r24
     af4:	90 93 69 0a 	sts	0x0A69, r25
     af8:	a0 93 6a 0a 	sts	0x0A6A, r26
     afc:	b0 93 6b 0a 	sts	0x0A6B, r27
  q3 = 2427;
     b00:	80 e0       	ldi	r24, 0x00	; 0
     b02:	90 eb       	ldi	r25, 0xB0	; 176
     b04:	a7 e1       	ldi	r26, 0x17	; 23
     b06:	b5 e4       	ldi	r27, 0x45	; 69
     b08:	80 93 a7 0c 	sts	0x0CA7, r24
     b0c:	90 93 a8 0c 	sts	0x0CA8, r25
     b10:	a0 93 a9 0c 	sts	0x0CA9, r26
     b14:	b0 93 aa 0c 	sts	0x0CAA, r27
  q4 = 5587;
     b18:	80 e0       	ldi	r24, 0x00	; 0
     b1a:	98 e9       	ldi	r25, 0x98	; 152
     b1c:	ae ea       	ldi	r26, 0xAE	; 174
     b1e:	b5 e4       	ldi	r27, 0x45	; 69
     b20:	80 93 e5 10 	sts	0x10E5, r24
     b24:	90 93 e6 10 	sts	0x10E6, r25
     b28:	a0 93 e7 10 	sts	0x10E7, r26
     b2c:	b0 93 e8 10 	sts	0x10E8, r27
     b30:	08 95       	ret

00000b32 <assign_discharge_fit>:
}

/* Assigns values to the Fourier coefficients of the discharge approximation */

void assign_discharge_fit( void ) {
  discharge_max_time = 17547;
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	96 e1       	ldi	r25, 0x16	; 22
     b36:	a9 e8       	ldi	r26, 0x89	; 137
     b38:	b6 e4       	ldi	r27, 0x46	; 70
     b3a:	80 93 7d 0a 	sts	0x0A7D, r24
     b3e:	90 93 7e 0a 	sts	0x0A7E, r25
     b42:	a0 93 7f 0a 	sts	0x0A7F, r26
     b46:	b0 93 80 0a 	sts	0x0A80, r27
  f0 = -1.543291233254410E4;
     b4a:	88 eb       	ldi	r24, 0xB8	; 184
     b4c:	93 ec       	ldi	r25, 0xC3	; 195
     b4e:	90 93 cd 10 	sts	0x10CD, r25
     b52:	80 93 cc 10 	sts	0x10CC, r24
  f1 = -1.819810644993805E4;
     b56:	8a ee       	ldi	r24, 0xEA	; 234
     b58:	98 eb       	ldi	r25, 0xB8	; 184
     b5a:	90 93 db 10 	sts	0x10DB, r25
     b5e:	80 93 da 10 	sts	0x10DA, r24
  b1 = -2.548949173344369E4;
     b62:	8f e6       	ldi	r24, 0x6F	; 111
     b64:	9c e9       	ldi	r25, 0x9C	; 156
     b66:	90 93 6d 0a 	sts	0x0A6D, r25
     b6a:	80 93 6c 0a 	sts	0x0A6C, r24
  f2 = 1.141365113433748E4;
     b6e:	85 e9       	ldi	r24, 0x95	; 149
     b70:	9c e2       	ldi	r25, 0x2C	; 44
     b72:	90 93 a0 0c 	sts	0x0CA0, r25
     b76:	80 93 9f 0c 	sts	0x0C9F, r24
  b2 = -2.190399298389397E4;
     b7a:	81 e7       	ldi	r24, 0x71	; 113
     b7c:	9a ea       	ldi	r25, 0xAA	; 170
     b7e:	90 93 23 03 	sts	0x0323, r25
     b82:	80 93 22 03 	sts	0x0322, r24
  f3 = 1.453849538420288E4;
     b86:	8a ec       	ldi	r24, 0xCA	; 202
     b88:	98 e3       	ldi	r25, 0x38	; 56
     b8a:	90 93 94 0c 	sts	0x0C94, r25
     b8e:	80 93 93 0c 	sts	0x0C93, r24
  b3 = 7.700208204268025E2;
     b92:	82 e0       	ldi	r24, 0x02	; 2
     b94:	93 e0       	ldi	r25, 0x03	; 3
     b96:	90 93 cf 10 	sts	0x10CF, r25
     b9a:	80 93 ce 10 	sts	0x10CE, r24
  f4 = 1.965482651710955E3;
     b9e:	8d ea       	ldi	r24, 0xAD	; 173
     ba0:	97 e0       	ldi	r25, 0x07	; 7
     ba2:	90 93 d9 10 	sts	0x10D9, r25
     ba6:	80 93 d8 10 	sts	0x10D8, r24
  b4 = 5.504490550919407E3;
     baa:	80 e8       	ldi	r24, 0x80	; 128
     bac:	95 e1       	ldi	r25, 0x15	; 21
     bae:	90 93 88 0a 	sts	0x0A88, r25
     bb2:	80 93 87 0a 	sts	0x0A87, r24
  f5 = -9.466488439471518E2;
     bb6:	8e e4       	ldi	r24, 0x4E	; 78
     bb8:	9c ef       	ldi	r25, 0xFC	; 252
     bba:	90 93 85 0a 	sts	0x0A85, r25
     bbe:	80 93 84 0a 	sts	0x0A84, r24
  b5 = 8.270458368650347E2;
     bc2:	8b e3       	ldi	r24, 0x3B	; 59
     bc4:	93 e0       	ldi	r25, 0x03	; 3
     bc6:	90 93 cb 10 	sts	0x10CB, r25
     bca:	80 93 ca 10 	sts	0x10CA, r24
  w = 2.725333178515558;
     bce:	8c ed       	ldi	r24, 0xDC	; 220
     bd0:	9b e6       	ldi	r25, 0x6B	; 107
     bd2:	ae e2       	ldi	r26, 0x2E	; 46
     bd4:	b0 e4       	ldi	r27, 0x40	; 64
     bd6:	80 93 73 0a 	sts	0x0A73, r24
     bda:	90 93 74 0a 	sts	0x0A74, r25
     bde:	a0 93 75 0a 	sts	0x0A75, r26
     be2:	b0 93 76 0a 	sts	0x0A76, r27
  
  h0 = 2.979485572689352E8;
     be6:	80 e8       	ldi	r24, 0x80	; 128
     be8:	95 e5       	ldi	r25, 0x55	; 85
     bea:	a2 ec       	ldi	r26, 0xC2	; 194
     bec:	b1 e1       	ldi	r27, 0x11	; 17
     bee:	80 93 9b 0c 	sts	0x0C9B, r24
     bf2:	90 93 9c 0c 	sts	0x0C9C, r25
     bf6:	a0 93 9d 0c 	sts	0x0C9D, r26
     bfa:	b0 93 9e 0c 	sts	0x0C9E, r27
  h1 = 2.088787459098652E8;
     bfe:	80 ea       	ldi	r24, 0xA0	; 160
     c00:	9c e3       	ldi	r25, 0x3C	; 60
     c02:	a3 e7       	ldi	r26, 0x73	; 115
     c04:	bc e0       	ldi	r27, 0x0C	; 12
     c06:	80 93 2d 03 	sts	0x032D, r24
     c0a:	90 93 2e 03 	sts	0x032E, r25
     c0e:	a0 93 2f 03 	sts	0x032F, r26
     c12:	b0 93 30 03 	sts	0x0330, r27
  g1 = 4.359717315569648E8;
     c16:	80 ea       	ldi	r24, 0xA0	; 160
     c18:	96 e6       	ldi	r25, 0x66	; 102
     c1a:	ac ef       	ldi	r26, 0xFC	; 252
     c1c:	b9 e1       	ldi	r27, 0x19	; 25
     c1e:	80 93 32 03 	sts	0x0332, r24
     c22:	90 93 33 03 	sts	0x0333, r25
     c26:	a0 93 34 03 	sts	0x0334, r26
     c2a:	b0 93 35 03 	sts	0x0335, r27
  h2 =  -1.569778955752849E8;
     c2e:	80 e2       	ldi	r24, 0x20	; 32
     c30:	95 eb       	ldi	r25, 0xB5	; 181
     c32:	a4 ea       	ldi	r26, 0xA4	; 164
     c34:	b6 ef       	ldi	r27, 0xF6	; 246
     c36:	80 93 96 0c 	sts	0x0C96, r24
     c3a:	90 93 97 0c 	sts	0x0C97, r25
     c3e:	a0 93 98 0c 	sts	0x0C98, r26
     c42:	b0 93 99 0c 	sts	0x0C99, r27
  g2 =  1.969854815603661E8;
     c46:	80 e9       	ldi	r24, 0x90	; 144
     c48:	92 ec       	ldi	r25, 0xC2	; 194
     c4a:	ad eb       	ldi	r26, 0xBD	; 189
     c4c:	bb e0       	ldi	r27, 0x0B	; 11
     c4e:	80 93 8e 0c 	sts	0x0C8E, r24
     c52:	90 93 8f 0c 	sts	0x0C8F, r25
     c56:	a0 93 90 0c 	sts	0x0C90, r26
     c5a:	b0 93 91 0c 	sts	0x0C91, r27
  h3 =  -7.513816845838763E7;
     c5e:	88 e8       	ldi	r24, 0x88	; 136
     c60:	9b e7       	ldi	r25, 0x7B	; 123
     c62:	a5 e8       	ldi	r26, 0x85	; 133
     c64:	bb ef       	ldi	r27, 0xFB	; 251
     c66:	80 93 dc 10 	sts	0x10DC, r24
     c6a:	90 93 dd 10 	sts	0x10DD, r25
     c6e:	a0 93 de 10 	sts	0x10DE, r26
     c72:	b0 93 df 10 	sts	0x10DF, r27
  g3 =  -1.633385950799686E7;
     c76:	8c ed       	ldi	r24, 0xDC	; 220
     c78:	93 ec       	ldi	r25, 0xC3	; 195
     c7a:	a6 e0       	ldi	r26, 0x06	; 6
     c7c:	bf ef       	ldi	r27, 0xFF	; 255
     c7e:	80 93 1e 03 	sts	0x031E, r24
     c82:	90 93 1f 03 	sts	0x031F, r25
     c86:	a0 93 20 03 	sts	0x0320, r26
     c8a:	b0 93 21 03 	sts	0x0321, r27
  h4 =   -2.642581886559125E6;
     c8e:	8a e6       	ldi	r24, 0x6A	; 106
     c90:	9d ea       	ldi	r25, 0xAD	; 173
     c92:	a7 ed       	ldi	r26, 0xD7	; 215
     c94:	bf ef       	ldi	r27, 0xFF	; 255
     c96:	80 93 c0 10 	sts	0x10C0, r24
     c9a:	90 93 c1 10 	sts	0x10C1, r25
     c9e:	a0 93 c2 10 	sts	0x10C2, r26
     ca2:	b0 93 c3 10 	sts	0x10C3, r27
  g4 =   -1.016608352073227E7;
     ca6:	8c eb       	ldi	r24, 0xBC	; 188
     ca8:	90 ee       	ldi	r25, 0xE0	; 224
     caa:	a4 e6       	ldi	r26, 0x64	; 100
     cac:	bf ef       	ldi	r27, 0xFF	; 255
     cae:	80 93 09 03 	sts	0x0309, r24
     cb2:	90 93 0a 03 	sts	0x030A, r25
     cb6:	a0 93 0b 03 	sts	0x030B, r26
     cba:	b0 93 0c 03 	sts	0x030C, r27
  w2 =  0.364797662747743;
     cbe:	82 ec       	ldi	r24, 0xC2	; 194
     cc0:	96 ec       	ldi	r25, 0xC6	; 198
     cc2:	aa eb       	ldi	r26, 0xBA	; 186
     cc4:	be e3       	ldi	r27, 0x3E	; 62
     cc6:	80 93 bc 0e 	sts	0x0EBC, r24
     cca:	90 93 bd 0e 	sts	0x0EBD, r25
     cce:	a0 93 be 0e 	sts	0x0EBE, r26
     cd2:	b0 93 bf 0e 	sts	0x0EBF, r27
     cd6:	08 95       	ret

00000cd8 <initialize>:
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       6     );  // Fake Data
}

void initialize( void )
{
     cd8:	ef 92       	push	r14
     cda:	ff 92       	push	r15
     cdc:	0f 93       	push	r16
     cde:	1f 93       	push	r17
     ce0:	cf 93       	push	r28
     ce2:	df 93       	push	r29
   // pin initialization
  DDRA  = 0b11111111;
     ce4:	1f ef       	ldi	r17, 0xFF	; 255
     ce6:	1a bb       	out	0x1a, r17	; 26
  PORTA = 0b00000111;
     ce8:	87 e0       	ldi	r24, 0x07	; 7
     cea:	8b bb       	out	0x1b, r24	; 27

  DDRB  = 0b11111111;
     cec:	17 bb       	out	0x17, r17	; 23
  PORTB = 0b11100000;
     cee:	80 ee       	ldi	r24, 0xE0	; 224
     cf0:	88 bb       	out	0x18, r24	; 24

  DDRC  = 0b11111111;
     cf2:	14 bb       	out	0x14, r17	; 20
  PORTC = 0b11111111;
     cf4:	15 bb       	out	0x15, r17	; 21

  DDRD  = 0b11111011;
     cf6:	8b ef       	ldi	r24, 0xFB	; 251
     cf8:	81 bb       	out	0x11, r24	; 17
  PORTD = 0b11110000;
     cfa:	80 ef       	ldi	r24, 0xF0	; 240
     cfc:	82 bb       	out	0x12, r24	; 18

  DDRE  = 0b11111110;
     cfe:	8e ef       	ldi	r24, 0xFE	; 254
     d00:	82 b9       	out	0x02, r24	; 2
  PORTE = 0b00000000;
     d02:	13 b8       	out	0x03, r1	; 3

  DDRF  = //0b11110000;
     d04:	10 93 61 00 	sts	0x0061, r17
  0b11111111;	//testing
  PORTF = 0b00000000;
     d08:	10 92 62 00 	sts	0x0062, r1

  DDRG  = 0b00011111;
     d0c:	8f e1       	ldi	r24, 0x1F	; 31
     d0e:	80 93 64 00 	sts	0x0064, r24
  PORTG = 0b00000100;
     d12:	04 e0       	ldi	r16, 0x04	; 4
     d14:	00 93 65 00 	sts	0x0065, r16
  // compare value = 124
  // compare match interrupt freq = (14.7456 MHz / 1024 / 100) = 144 Hz
  // use timer0_counter to get 144 / 144 = 1 Hz

  // enable clear on match interrupt
  TIMSK = ( 1 << OCIE0 );
     d18:	82 e0       	ldi	r24, 0x02	; 2
     d1a:	87 bf       	out	0x37, r24	; 55
  OCR0 = 71;
     d1c:	87 e4       	ldi	r24, 0x47	; 71
     d1e:	81 bf       	out	0x31, r24	; 49

  // enable clear on match mode, set prescalar to 1024
  TCCR0 = ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );
     d20:	8f e0       	ldi	r24, 0x0F	; 15
     d22:	83 bf       	out	0x33, r24	; 51

  timer0_counter[0] = 99;
     d24:	83 e6       	ldi	r24, 0x63	; 99
     d26:	80 93 b9 0e 	sts	0x0EB9, r24
  timer0_counter[1] = 199;
     d2a:	87 ec       	ldi	r24, 0xC7	; 199
     d2c:	80 93 ba 0e 	sts	0x0EBA, r24
  period of interrupts = 28800 / 14400 Hz = 2 s/interrupt
  use timer1_counter to get a total period of 2*65535 =  s (24 hours is 86400 seconds)
  */
  
  // Enable clear on match interrupt for the 16 bit timer/counter 1, register A
  OCR1A = 28800;		//28800 corresponds to 2 seconds
     d30:	80 e8       	ldi	r24, 0x80	; 128
     d32:	90 e7       	ldi	r25, 0x70	; 112
     d34:	9b bd       	out	0x2b, r25	; 43
     d36:	8a bd       	out	0x2a, r24	; 42

  // Enable clear on match mode, set prescalar to 1024.
  // CS[2:0] = 101 (1024 prescalar)
  // WGM[3:0] = 0100 (Clear Timer on Compare (CTC) when timer matches OCR1A)
  
  TCCR1B = ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS10 );
     d38:	8d e0       	ldi	r24, 0x0D	; 13
     d3a:	8e bd       	out	0x2e, r24	; 46
  // Explicit Default Defs
  // TCCR1A |= 0;
  // TCNT1 = 0;
  timer1_counter[0] = CYCLE_COUNTER;	//CYCLE_COUNTER   = 900 for 2 seconds interrupt handler = 1800 secs (30 minutes)
     d3c:	84 e8       	ldi	r24, 0x84	; 132
     d3e:	80 93 e1 10 	sts	0x10E1, r24
  timer1_counter[1] = CYCLE_COUNTER_2;	//CYCLE_COUNTER_2 = 300 for 2 seconds interrupt handler = 600 secs  (10 minutes)
     d42:	8c e2       	ldi	r24, 0x2C	; 44
     d44:	80 93 e2 10 	sts	0x10E2, r24
  //---------------------------------------------------------------------  
  // End of timer 1 Setup
  //--------------------------------------------------------------------- 
  
  // communication
  uart_init();
     d48:	0e 94 07 0b 	call	0x160e	; 0x160e <uart_init>

  // for use in debugging
  // stdout = stdin = stderr = &uart_str;

  tel_packet_size[0] = 0;
     d4c:	10 92 2a 03 	sts	0x032A, r1
     d50:	10 92 29 03 	sts	0x0329, r1
  tel_packet_size[1] = 0;
     d54:	10 92 2c 03 	sts	0x032C, r1
     d58:	10 92 2b 03 	sts	0x032B, r1
  tel_packet_index[0] = 0;
     d5c:	10 92 81 0a 	sts	0x0A81, r1
  tel_packet_index[1] = 0;
     d60:	10 92 82 0a 	sts	0x0A82, r1
  uart_vcp_buff[0] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     d64:	8a e0       	ldi	r24, 0x0A	; 10
     d66:	90 e0       	ldi	r25, 0x00	; 0
     d68:	0e 94 1e 14 	call	0x283c	; 0x283c <malloc>
     d6c:	7c 01       	movw	r14, r24
     d6e:	e9 ee       	ldi	r30, 0xE9	; 233
     d70:	f0 e1       	ldi	r31, 0x10	; 16
     d72:	80 83       	st	Z, r24
     d74:	f1 82       	std	Z+1, r15	; 0x01
  uart_vcp_buff[1] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     d76:	8a e0       	ldi	r24, 0x0A	; 10
     d78:	90 e0       	ldi	r25, 0x00	; 0
     d7a:	0e 94 1e 14 	call	0x283c	; 0x283c <malloc>
     d7e:	cb ee       	ldi	r28, 0xEB	; 235
     d80:	d0 e1       	ldi	r29, 0x10	; 16
     d82:	88 83       	st	Y, r24
     d84:	99 83       	std	Y+1, r25	; 0x01
  vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     d86:	4f ef       	ldi	r20, 0xFF	; 255
     d88:	50 e0       	ldi	r21, 0x00	; 0
     d8a:	62 ec       	ldi	r22, 0xC2	; 194
     d8c:	7e e0       	ldi	r23, 0x0E	; 14
     d8e:	c7 01       	movw	r24, r14
     d90:	0e 94 2d 0b 	call	0x165a	; 0x165a <vcpptr_init>
  vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     d94:	4f ef       	ldi	r20, 0xFF	; 255
     d96:	50 e0       	ldi	r21, 0x00	; 0
     d98:	61 ec       	ldi	r22, 0xC1	; 193
     d9a:	7f e0       	ldi	r23, 0x0F	; 15
     d9c:	88 81       	ld	r24, Y
     d9e:	99 81       	ldd	r25, Y+1	; 0x01
     da0:	0e 94 2d 0b 	call	0x165a	; 0x165a <vcpptr_init>

  rx_flag[0] = 0;
     da4:	10 92 ee 10 	sts	0x10EE, r1
  rx_flag[1] = 0;
     da8:	10 92 ef 10 	sts	0x10EF, r1

  // svit
  initialize_svit();
     dac:	0e 94 44 01 	call	0x288	; 0x288 <initialize_svit>

  // rev up those interrupts
  sei();
     db0:	78 94       	sei

  //ADC conversions
  adc_flag = 1;
     db2:	c1 e0       	ldi	r28, 0x01	; 1
     db4:	c0 93 88 0c 	sts	0x0C88, r28
	adc_component = 0;
     db8:	10 92 37 03 	sts	0x0337, r1
	adc_sensor_type = ADC_INIT;//get default case on first interation as to not enter switch
     dbc:	00 93 95 0c 	sts	0x0C95, r16
  ADC_high = 0;
     dc0:	10 92 a6 0c 	sts	0x0CA6, r1

  V_upper_val_change = 0;
     dc4:	10 92 c0 0e 	sts	0x0EC0, r1
  I_upper_val_change = 0;
     dc8:	10 92 bb 0e 	sts	0x0EBB, r1

  //---------------------------------------------------------------------  
  // SOC Initializations
  //--------------------------------------------------------------------- 
  // and shunt and safe transmit flags
  safe_mode = 0;
     dcc:	10 92 92 0c 	sts	0x0C92, r1
  transmit_safe = 0;
     dd0:	10 92 8d 0c 	sts	0x0C8D, r1
  transmit_shunt = 0;
     dd4:	10 92 c9 10 	sts	0x10C9, r1
  been_to_safe = 0;
     dd8:	10 92 31 03 	sts	0x0331, r1
  been_to_shunt = 0;
     ddc:	10 92 b2 0c 	sts	0x0CB2, r1
  assign_charge_fit();
     de0:	0e 94 2c 05 	call	0xa58	; 0xa58 <assign_charge_fit>
  assign_discharge_fit();
     de4:	0e 94 99 05 	call	0xb32	; 0xb32 <assign_discharge_fit>
  
  // First get battery voltage so that the SoC can
  // accurately determine whether batteries are charging or discharging
  batt1_voltage = 0xff;
     de8:	10 93 b0 0c 	sts	0x0CB0, r17
  batt2_voltage = 0xff;
     dec:	10 93 c1 0e 	sts	0x0EC1, r17
  charging = 0xff;
     df0:	10 93 78 0a 	sts	0x0A78, r17
  chargeforward = 0;
     df4:	10 92 e4 10 	sts	0x10E4, r1
  chargebackward = 0;
     df8:	10 92 36 03 	sts	0x0336, r1
  debug = 0;
     dfc:	10 92 77 0a 	sts	0x0A77, r1
  debug2 = 0;
     e00:	10 92 83 0a 	sts	0x0A83, r1
  percent = 0;
     e04:	10 92 6f 0a 	sts	0x0A6F, r1
     e08:	10 92 70 0a 	sts	0x0A70, r1
     e0c:	10 92 71 0a 	sts	0x0A71, r1
     e10:	10 92 72 0a 	sts	0x0A72, r1
  soc = 0;
     e14:	10 92 f2 12 	sts	0x12F2, r1
  high = 0;
     e18:	10 92 a1 0c 	sts	0x0CA1, r1
  low = 0;
     e1c:	10 92 af 0c 	sts	0x0CAF, r1
  limit_check_overriden = 0; // Initially limit checking is NOT OVERRIDEN
     e20:	10 92 6e 0a 	sts	0x0A6E, r1
  isCharging = 0;
     e24:	10 92 ed 10 	sts	0x10ED, r1
  hasCheckedCurr = 0;
     e28:	10 92 9a 0c 	sts	0x0C9A, r1
  
  coul_percent = 0;
     e2c:	10 92 d0 10 	sts	0x10D0, r1
     e30:	10 92 d1 10 	sts	0x10D1, r1
     e34:	10 92 d2 10 	sts	0x10D2, r1
     e38:	10 92 d3 10 	sts	0x10D3, r1
  total_percent = percent;
     e3c:	10 92 38 03 	sts	0x0338, r1
     e40:	10 92 39 03 	sts	0x0339, r1
     e44:	10 92 3a 03 	sts	0x033A, r1
     e48:	10 92 3b 03 	sts	0x033B, r1
  //--------------------------------------------------------------------- 

  //---------------------------------------------------------------------  
  // Timer Initializations
  //---------------------------------------------------------------------
  cdh_heartbeat_flag = 0;	//Default: do not have flag to restart components on
     e4c:	10 92 24 03 	sts	0x0324, r1
  rad_torq_flag = 1;		//Indicates need to delay radio/torquer on signals later
     e50:	c0 93 0d 03 	sts	0x030D, r28
  SVIT_t *component; 	// Initialize Radios to be OFF
  component = &svit[components[RADIO_1]];
     e54:	a0 91 19 03 	lds	r26, 0x0319
     e58:	c3 e3       	ldi	r28, 0x33	; 51
     e5a:	ca 9f       	mul	r28, r26
     e5c:	d0 01       	movw	r26, r0
     e5e:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     e60:	a4 5c       	subi	r26, 0xC4	; 196
     e62:	bc 4f       	sbci	r27, 0xFC	; 252
     e64:	11 96       	adiw	r26, 0x01	; 1
     e66:	8c 91       	ld	r24, X
     e68:	0e 94 4b 09 	call	0x1296	; 0x1296 <switch_off>
  component = &svit[components[RADIO_2]];
     e6c:	e0 91 1a 03 	lds	r30, 0x031A
     e70:	ce 9f       	mul	r28, r30
     e72:	f0 01       	movw	r30, r0
     e74:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     e76:	e4 5c       	subi	r30, 0xC4	; 196
     e78:	fc 4f       	sbci	r31, 0xFC	; 252
     e7a:	81 81       	ldd	r24, Z+1	; 0x01
     e7c:	0e 94 4b 09 	call	0x1296	; 0x1296 <switch_off>
  component = &svit[TORQUER_1];	// Initialize Torque Coils to be OFF
  component->switch_state = SW_OFF;
     e80:	10 92 a1 06 	sts	0x06A1, r1
  component = &svit[TORQUER_2];
  component->switch_state = SW_OFF;
     e84:	10 92 d4 06 	sts	0x06D4, r1
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
     e88:	10 92 07 07 	sts	0x0707, r1
  torquer_off(TORQUER_1);
     e8c:	81 e1       	ldi	r24, 0x11	; 17
     e8e:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <torquer_off>
  torquer_off(TORQUER_2);
     e92:	82 e1       	ldi	r24, 0x12	; 18
     e94:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <torquer_off>
  torquer_off(TORQUER_3);
     e98:	83 e1       	ldi	r24, 0x13	; 19
  //---------------------------------------------------------------------  
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}
     e9a:	df 91       	pop	r29
     e9c:	cf 91       	pop	r28
     e9e:	1f 91       	pop	r17
     ea0:	0f 91       	pop	r16
     ea2:	ff 90       	pop	r15
     ea4:	ef 90       	pop	r14
  component->switch_state = SW_OFF;
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
  torquer_off(TORQUER_1);
  torquer_off(TORQUER_2);
  torquer_off(TORQUER_3);
     ea6:	0c 94 d1 08 	jmp	0x11a2	; 0x11a2 <torquer_off>

00000eaa <compareVoltage>:
void compareVoltage( void ) {
  SVIT_t *component;
  //component = &svit[BATTERY_1_b];
  //chargebackward = average_samples( component->I_samples );
  component = &svit[BATTERY_1];
  chargeforward= average_samples( component->I_samples );
     eaa:	89 e4       	ldi	r24, 0x49	; 73
     eac:	97 e0       	ldi	r25, 0x07	; 7
     eae:	0e 94 8e 09 	call	0x131c	; 0x131c <average_samples>
     eb2:	80 93 e4 10 	sts	0x10E4, r24
  if (chargeforward > 2){
     eb6:	83 30       	cpi	r24, 0x03	; 3
     eb8:	10 f0       	brcs	.+4      	; 0xebe <compareVoltage+0x14>
    charging = 0xdd;//discharging
     eba:	8d ed       	ldi	r24, 0xDD	; 221
     ebc:	01 c0       	rjmp	.+2      	; 0xec0 <compareVoltage+0x16>
    }
  else{
    charging = 0xcc;
     ebe:	8c ec       	ldi	r24, 0xCC	; 204
     ec0:	80 93 78 0a 	sts	0x0A78, r24
     ec4:	08 95       	ret

00000ec6 <limit_check>:
we should at least get the framework set up for limit checking on arbitrary values.
The power board should have upper and lower limits for vsense and csense data, 
and turn off components if their voltage/current is too high. ONLY CHECKS
BATTERY 1 VOLTAGE LINE RIGHT NOW.
*/
void limit_check( void ) {
     ec6:	cf 92       	push	r12
     ec8:	df 92       	push	r13
     eca:	ef 92       	push	r14
     ecc:	ff 92       	push	r15
     ece:	0f 93       	push	r16
     ed0:	1f 93       	push	r17
     ed2:	cf 93       	push	r28
     ed4:	df 93       	push	r29
	unsigned char sw;
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
     ed6:	c0 90 6f 0a 	lds	r12, 0x0A6F
     eda:	d0 90 70 0a 	lds	r13, 0x0A70
     ede:	e0 90 71 0a 	lds	r14, 0x0A71
     ee2:	f0 90 72 0a 	lds	r15, 0x0A72
     ee6:	20 e0       	ldi	r18, 0x00	; 0
     ee8:	30 e0       	ldi	r19, 0x00	; 0
     eea:	a9 01       	movw	r20, r18
     eec:	c7 01       	movw	r24, r14
     eee:	b6 01       	movw	r22, r12
     ef0:	0e 94 d4 12 	call	0x25a8	; 0x25a8 <__cmpsf2>
     ef4:	87 ff       	sbrs	r24, 7
     ef6:	4c c0       	rjmp	.+152    	; 0xf90 <limit_check+0xca>
     ef8:	29 e2       	ldi	r18, 0x29	; 41
     efa:	3c e5       	ldi	r19, 0x5C	; 92
     efc:	4f e0       	ldi	r20, 0x0F	; 15
     efe:	5f eb       	ldi	r21, 0xBF	; 191
     f00:	c7 01       	movw	r24, r14
     f02:	b6 01       	movw	r22, r12
     f04:	0e 94 d4 12 	call	0x25a8	; 0x25a8 <__cmpsf2>
     f08:	87 ff       	sbrs	r24, 7
     f0a:	0a c0       	rjmp	.+20     	; 0xf20 <limit_check+0x5a>
     f0c:	25 e8       	ldi	r18, 0x85	; 133
     f0e:	3b ee       	ldi	r19, 0xEB	; 235
     f10:	41 e1       	ldi	r20, 0x11	; 17
     f12:	5f eb       	ldi	r21, 0xBF	; 191
     f14:	c7 01       	movw	r24, r14
     f16:	b6 01       	movw	r22, r12
     f18:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <__gesf2>
     f1c:	18 16       	cp	r1, r24
     f1e:	c4 f1       	brlt	.+112    	; 0xf90 <limit_check+0xca>
		safe_mode = 1;
     f20:	81 e0       	ldi	r24, 0x01	; 1
     f22:	80 93 92 0c 	sts	0x0C92, r24
     f26:	0e e0       	ldi	r16, 0x0E	; 14
     f28:	13 e0       	ldi	r17, 0x03	; 3
		for (sw = 0; sw < sizeof(components); sw++) {
			component = &svit[components[sw]];
     f2a:	33 e3       	ldi	r19, 0x33	; 51
     f2c:	f3 2e       	mov	r15, r19
     f2e:	f8 01       	movw	r30, r16
     f30:	c1 91       	ld	r28, Z+
     f32:	8f 01       	movw	r16, r30
     f34:	fc 9e       	mul	r15, r28
     f36:	e0 01       	movw	r28, r0
     f38:	11 24       	eor	r1, r1
     f3a:	c4 5c       	subi	r28, 0xC4	; 196
     f3c:	dc 4f       	sbci	r29, 0xFC	; 252
			switch_off( component->switch_num );
     f3e:	89 81       	ldd	r24, Y+1	; 0x01
     f40:	0e 94 4b 09 	call	0x1296	; 0x1296 <switch_off>
			component->switch_state = SW_OFF;
     f44:	1a 82       	std	Y+2, r1	; 0x02
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
		safe_mode = 1;
		for (sw = 0; sw < sizeof(components); sw++) {
     f46:	f3 e0       	ldi	r31, 0x03	; 3
     f48:	0e 31       	cpi	r16, 0x1E	; 30
     f4a:	1f 07       	cpc	r17, r31
     f4c:	81 f7       	brne	.-32     	; 0xf2e <limit_check+0x68>
			component = &svit[components[sw]];
			switch_off( component->switch_num );
			component->switch_state = SW_OFF;
		}
		component = &svit[TORQUER_1];
		component->switch_state = SW_OFF;
     f4e:	10 92 a1 06 	sts	0x06A1, r1
		component = &svit[TORQUER_2];
		component->switch_state = SW_OFF;
     f52:	10 92 d4 06 	sts	0x06D4, r1
		component = &svit[TORQUER_3];
		component->switch_state = SW_OFF;
     f56:	10 92 07 07 	sts	0x0707, r1
		torquer_off(TORQUER_1);
     f5a:	81 e1       	ldi	r24, 0x11	; 17
     f5c:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <torquer_off>
		torquer_off(TORQUER_2);
     f60:	82 e1       	ldi	r24, 0x12	; 18
     f62:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <torquer_off>
		torquer_off(TORQUER_3);
     f66:	83 e1       	ldi	r24, 0x13	; 19
     f68:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <torquer_off>
		// Only transmit once
		if (!transmit_safe && !been_to_safe) { 
     f6c:	80 91 8d 0c 	lds	r24, 0x0C8D
     f70:	81 11       	cpse	r24, r1
     f72:	08 c0       	rjmp	.+16     	; 0xf84 <limit_check+0xbe>
     f74:	80 91 31 03 	lds	r24, 0x0331
     f78:	81 11       	cpse	r24, r1
     f7a:	04 c0       	rjmp	.+8      	; 0xf84 <limit_check+0xbe>
			transmit_packet( 0, VCP_ACK, SAFE_MODE);
     f7c:	40 e0       	ldi	r20, 0x00	; 0
     f7e:	62 e0       	ldi	r22, 0x02	; 2
     f80:	0e 94 c2 11 	call	0x2384	; 0x2384 <transmit_packet>
			transmit_safe = 1;
		}
		else {}
		been_to_safe = 1;
     f84:	81 e0       	ldi	r24, 0x01	; 1
     f86:	80 93 31 03 	sts	0x0331, r24
		transmit_safe = 1;
     f8a:	80 93 8d 0c 	sts	0x0C8D, r24
     f8e:	28 c0       	rjmp	.+80     	; 0xfe0 <limit_check+0x11a>
	}
	else if (percent > SHUNT_MODE  && isCharging) {
     f90:	20 e0       	ldi	r18, 0x00	; 0
     f92:	30 e0       	ldi	r19, 0x00	; 0
     f94:	48 ec       	ldi	r20, 0xC8	; 200
     f96:	52 e4       	ldi	r21, 0x42	; 66
     f98:	c7 01       	movw	r24, r14
     f9a:	b6 01       	movw	r22, r12
     f9c:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <__gesf2>
     fa0:	18 16       	cp	r1, r24
     fa2:	f4 f4       	brge	.+60     	; 0xfe0 <limit_check+0x11a>
     fa4:	80 91 ed 10 	lds	r24, 0x10ED
     fa8:	88 23       	and	r24, r24
     faa:	d1 f0       	breq	.+52     	; 0xfe0 <limit_check+0x11a>
	    safe_mode = 0;
     fac:	10 92 92 0c 	sts	0x0C92, r1
		// turn on the maestro and send ack_command w/ value of SHUNT_MODE
		component = &svit[MAESTRO];
		switch_on( component->switch_num );
     fb0:	80 91 d4 05 	lds	r24, 0x05D4
     fb4:	0e 94 08 09 	call	0x1210	; 0x1210 <switch_on>
		component->switch_state = SW_ON;
     fb8:	81 e0       	ldi	r24, 0x01	; 1
     fba:	80 93 d5 05 	sts	0x05D5, r24
		// Only transmit once
		if (!transmit_shunt && !been_to_shunt) {
     fbe:	80 91 c9 10 	lds	r24, 0x10C9
     fc2:	81 11       	cpse	r24, r1
     fc4:	08 c0       	rjmp	.+16     	; 0xfd6 <limit_check+0x110>
     fc6:	80 91 b2 0c 	lds	r24, 0x0CB2
     fca:	81 11       	cpse	r24, r1
     fcc:	04 c0       	rjmp	.+8      	; 0xfd6 <limit_check+0x110>
			transmit_packet( 0, VCP_ACK, SHUNT_MODE);
     fce:	44 e6       	ldi	r20, 0x64	; 100
     fd0:	62 e0       	ldi	r22, 0x02	; 2
     fd2:	0e 94 c2 11 	call	0x2384	; 0x2384 <transmit_packet>
		}
		else {}	
		been_to_shunt = 1;
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	80 93 b2 0c 	sts	0x0CB2, r24
		transmit_shunt = 1;	
     fdc:	80 93 c9 10 	sts	0x10C9, r24
	}
	else {} // To avoid annoying compile warning 
}
     fe0:	df 91       	pop	r29
     fe2:	cf 91       	pop	r28
     fe4:	1f 91       	pop	r17
     fe6:	0f 91       	pop	r16
     fe8:	ff 90       	pop	r15
     fea:	ef 90       	pop	r14
     fec:	df 90       	pop	r13
     fee:	cf 90       	pop	r12
     ff0:	08 95       	ret

00000ff2 <main>:


// MAIN
int main( void ) 
{  
  initialize();
     ff2:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <initialize>
  //fprintf( stdout, "uart initialized\n" );
	
  //Testing
  cntr = 0;
     ff6:	10 92 87 0c 	sts	0x0C87, r1

  while(1)
  {
	cntr = 1 - cntr; //Testing
     ffa:	11 e0       	ldi	r17, 0x01	; 1
	
    if ( timer0_counter[1] == 0 )
    {
        timer0_counter[1] = 199;
     ffc:	c7 ec       	ldi	r28, 0xC7	; 199
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     ffe:	dc e2       	ldi	r29, 0x2C	; 44
  //Testing
  cntr = 0;

  while(1)
  {
	cntr = 1 - cntr; //Testing
    1000:	80 91 87 0c 	lds	r24, 0x0C87
    1004:	91 2f       	mov	r25, r17
    1006:	98 1b       	sub	r25, r24
    1008:	90 93 87 0c 	sts	0x0C87, r25
	
    if ( timer0_counter[1] == 0 )
    100c:	80 91 ba 0e 	lds	r24, 0x0EBA
    1010:	81 11       	cpse	r24, r1
    1012:	07 c0       	rjmp	.+14     	; 0x1022 <main+0x30>
    {
        timer0_counter[1] = 199;
    1014:	c0 93 ba 0e 	sts	0x0EBA, r28
        transmit_packet( 1, VCP_POWER_TELEMETRY, 0);
    1018:	40 e0       	ldi	r20, 0x00	; 0
    101a:	60 e0       	ldi	r22, 0x00	; 0
    101c:	81 e0       	ldi	r24, 0x01	; 1
    101e:	0e 94 c2 11 	call	0x2384	; 0x2384 <transmit_packet>
    }
	  if ( timer0_counter[0] == 0 )
    1022:	80 91 b9 0e 	lds	r24, 0x0EB9
    1026:	81 11       	cpse	r24, r1
    1028:	06 c0       	rjmp	.+12     	; 0x1036 <main+0x44>
    {
        timer0_counter[0] = 199;
    102a:	c0 93 b9 0e 	sts	0x0EB9, r28
        transmit_packet( 0, VCP_POWER_TELEMETRY, 0);
    102e:	40 e0       	ldi	r20, 0x00	; 0
    1030:	60 e0       	ldi	r22, 0x00	; 0
    1032:	0e 94 c2 11 	call	0x2384	; 0x2384 <transmit_packet>
    }
	  if ( rx_flag[0] > 0 )
    1036:	80 91 ee 10 	lds	r24, 0x10EE
    103a:	88 23       	and	r24, r24
    103c:	c9 f0       	breq	.+50     	; 0x1070 <main+0x7e>
    {
        rx_flag[0]--;
    103e:	80 91 ee 10 	lds	r24, 0x10EE
    1042:	81 50       	subi	r24, 0x01	; 1
    1044:	80 93 ee 10 	sts	0x10EE, r24
        receive_message( 0, uart_vcp_buff[0]->message, uart_vcp_buff[0]->index );
    1048:	e0 91 e9 10 	lds	r30, 0x10E9
    104c:	f0 91 ea 10 	lds	r31, 0x10EA
    1050:	61 81       	ldd	r22, Z+1	; 0x01
    1052:	72 81       	ldd	r23, Z+2	; 0x02
    1054:	47 81       	ldd	r20, Z+7	; 0x07
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	0e 94 af 03 	call	0x75e	; 0x75e <receive_message>
        vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
    105c:	4f ef       	ldi	r20, 0xFF	; 255
    105e:	50 e0       	ldi	r21, 0x00	; 0
    1060:	62 ec       	ldi	r22, 0xC2	; 194
    1062:	7e e0       	ldi	r23, 0x0E	; 14
    1064:	80 91 e9 10 	lds	r24, 0x10E9
    1068:	90 91 ea 10 	lds	r25, 0x10EA
    106c:	0e 94 2d 0b 	call	0x165a	; 0x165a <vcpptr_init>
    }
	  if ( rx_flag[1] > 0 )
    1070:	80 91 ef 10 	lds	r24, 0x10EF
    1074:	88 23       	and	r24, r24
    1076:	c9 f0       	breq	.+50     	; 0x10aa <main+0xb8>
    {
        rx_flag[1]--;
    1078:	80 91 ef 10 	lds	r24, 0x10EF
    107c:	81 50       	subi	r24, 0x01	; 1
    107e:	80 93 ef 10 	sts	0x10EF, r24
        receive_message( 1, uart_vcp_buff[1]->message, uart_vcp_buff[1]->index );
    1082:	e0 91 eb 10 	lds	r30, 0x10EB
    1086:	f0 91 ec 10 	lds	r31, 0x10EC
    108a:	61 81       	ldd	r22, Z+1	; 0x01
    108c:	72 81       	ldd	r23, Z+2	; 0x02
    108e:	47 81       	ldd	r20, Z+7	; 0x07
    1090:	81 e0       	ldi	r24, 0x01	; 1
    1092:	0e 94 af 03 	call	0x75e	; 0x75e <receive_message>
        vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
    1096:	4f ef       	ldi	r20, 0xFF	; 255
    1098:	50 e0       	ldi	r21, 0x00	; 0
    109a:	61 ec       	ldi	r22, 0xC1	; 193
    109c:	7f e0       	ldi	r23, 0x0F	; 15
    109e:	80 91 eb 10 	lds	r24, 0x10EB
    10a2:	90 91 ec 10 	lds	r25, 0x10EC
    10a6:	0e 94 2d 0b 	call	0x165a	; 0x165a <vcpptr_init>
    }
    if (adc_flag == 1)
    10aa:	80 91 88 0c 	lds	r24, 0x0C88
    10ae:	81 30       	cpi	r24, 0x01	; 1
    10b0:	91 f4       	brne	.+36     	; 0x10d6 <main+0xe4>
    {
        adc_flag = 0;
    10b2:	10 92 88 0c 	sts	0x0C88, r1
        read_VIT();
    10b6:	0e 94 c5 09 	call	0x138a	; 0x138a <read_VIT>
		//calcSOC();
		StateofCharge();
    10ba:	0e 94 58 04 	call	0x8b0	; 0x8b0 <StateofCharge>

		/*
		Manual Override on Limit Checking: The power board must be able to receive a 
		command to disable and/or change the limits in the limit checking code
		*/
		if (!limit_check_overriden) {
    10be:	80 91 6e 0a 	lds	r24, 0x0A6E
    10c2:	81 11       	cpse	r24, r1
    10c4:	02 c0       	rjmp	.+4      	; 0x10ca <main+0xd8>
			limit_check(); // First determine if voltage is within valid range, then switch
    10c6:	0e 94 63 07 	call	0xec6	; 0xec6 <limit_check>
		}

		if ( adc_component == 23 ) 
    10ca:	80 91 37 03 	lds	r24, 0x0337
    10ce:	87 31       	cpi	r24, 0x17	; 23
    10d0:	11 f4       	brne	.+4      	; 0x10d6 <main+0xe4>
      	{ //23ish anything after battery values are calculated
  			  compareVoltage();
    10d2:	0e 94 55 07 	call	0xeaa	; 0xeaa <compareVoltage>
	   	}
    }	
	
	//Restart all board components if CDH-IB heartbeat timeout
	if (cdh_heartbeat_flag == 1){
    10d6:	80 91 24 03 	lds	r24, 0x0324
    10da:	81 30       	cpi	r24, 0x01	; 1
    10dc:	09 f0       	breq	.+2      	; 0x10e0 <main+0xee>
    10de:	90 cf       	rjmp	.-224    	; 0x1000 <main+0xe>
		//Restart all components
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
    10e0:	10 92 24 03 	sts	0x0324, r1
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
    10e4:	d0 93 e2 10 	sts	0x10E2, r29
    10e8:	8b cf       	rjmp	.-234    	; 0x1000 <main+0xe>

000010ea <torquer_off.part.0>:
void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
  {
    case TORQUER_1:
      CLR( PORTC, 0 );
    10ea:	a8 98       	cbi	0x15, 0	; 21
	  CLR( PORTG, 1 );
    10ec:	e5 e6       	ldi	r30, 0x65	; 101
    10ee:	f0 e0       	ldi	r31, 0x00	; 0
    10f0:	80 81       	ld	r24, Z
    10f2:	8d 7f       	andi	r24, 0xFD	; 253
    10f4:	80 83       	st	Z, r24
    10f6:	08 95       	ret

000010f8 <set_mux_sel>:
#include "mcupwr-Defs.h"


void set_mux_sel( uint8_t mux_num, uint8_t mux_sel )
{
  switch( mux_num )
    10f8:	81 30       	cpi	r24, 0x01	; 1
    10fa:	f9 f0       	breq	.+62     	; 0x113a <__stack+0x3b>
    10fc:	20 f0       	brcs	.+8      	; 0x1106 <__stack+0x7>
    10fe:	82 30       	cpi	r24, 0x02	; 2
    1100:	09 f0       	breq	.+2      	; 0x1104 <__stack+0x5>
    1102:	4e c0       	rjmp	.+156    	; 0x11a0 <__stack+0xa1>
    1104:	34 c0       	rjmp	.+104    	; 0x116e <__stack+0x6f>
  {
    case MUX0:
      READ( mux_sel, 4 ) ? SET( PORTA, 7 ) : CLR( PORTA, 7 );
    1106:	64 ff       	sbrs	r22, 4
    1108:	02 c0       	rjmp	.+4      	; 0x110e <__stack+0xf>
    110a:	df 9a       	sbi	0x1b, 7	; 27
    110c:	01 c0       	rjmp	.+2      	; 0x1110 <__stack+0x11>
    110e:	df 98       	cbi	0x1b, 7	; 27
      READ( mux_sel, 3 ) ? SET( PORTA, 6 ) : CLR( PORTA, 6 );
    1110:	63 ff       	sbrs	r22, 3
    1112:	02 c0       	rjmp	.+4      	; 0x1118 <__stack+0x19>
    1114:	de 9a       	sbi	0x1b, 6	; 27
    1116:	01 c0       	rjmp	.+2      	; 0x111a <__stack+0x1b>
    1118:	de 98       	cbi	0x1b, 6	; 27
      READ( mux_sel, 2 ) ? SET( PORTA, 5 ) : CLR( PORTA, 5 );
    111a:	62 ff       	sbrs	r22, 2
    111c:	02 c0       	rjmp	.+4      	; 0x1122 <__stack+0x23>
    111e:	dd 9a       	sbi	0x1b, 5	; 27
    1120:	01 c0       	rjmp	.+2      	; 0x1124 <__stack+0x25>
    1122:	dd 98       	cbi	0x1b, 5	; 27
      READ( mux_sel, 1 ) ? SET( PORTA, 4 ) : CLR( PORTA, 4 );
    1124:	61 ff       	sbrs	r22, 1
    1126:	02 c0       	rjmp	.+4      	; 0x112c <__stack+0x2d>
    1128:	dc 9a       	sbi	0x1b, 4	; 27
    112a:	01 c0       	rjmp	.+2      	; 0x112e <__stack+0x2f>
    112c:	dc 98       	cbi	0x1b, 4	; 27
      READ( mux_sel, 0 ) ? SET( PORTA, 3 ) : CLR( PORTA, 3 );
    112e:	60 ff       	sbrs	r22, 0
    1130:	02 c0       	rjmp	.+4      	; 0x1136 <__stack+0x37>
    1132:	db 9a       	sbi	0x1b, 3	; 27
    1134:	08 95       	ret
    1136:	db 98       	cbi	0x1b, 3	; 27
    1138:	08 95       	ret

      break;

    case MUX1:
      READ( mux_sel, 4 ) ? SET( PORTB, 0 ) : CLR( PORTB, 0 );
    113a:	64 ff       	sbrs	r22, 4
    113c:	02 c0       	rjmp	.+4      	; 0x1142 <__stack+0x43>
    113e:	c0 9a       	sbi	0x18, 0	; 24
    1140:	01 c0       	rjmp	.+2      	; 0x1144 <__stack+0x45>
    1142:	c0 98       	cbi	0x18, 0	; 24
      READ( mux_sel, 3 ) ? SET( PORTB, 1 ) : CLR( PORTB, 1 );
    1144:	63 ff       	sbrs	r22, 3
    1146:	02 c0       	rjmp	.+4      	; 0x114c <__stack+0x4d>
    1148:	c1 9a       	sbi	0x18, 1	; 24
    114a:	01 c0       	rjmp	.+2      	; 0x114e <__stack+0x4f>
    114c:	c1 98       	cbi	0x18, 1	; 24
      READ( mux_sel, 2 ) ? SET( PORTB, 2 ) : CLR( PORTB, 2 );
    114e:	62 ff       	sbrs	r22, 2
    1150:	02 c0       	rjmp	.+4      	; 0x1156 <__stack+0x57>
    1152:	c2 9a       	sbi	0x18, 2	; 24
    1154:	01 c0       	rjmp	.+2      	; 0x1158 <__stack+0x59>
    1156:	c2 98       	cbi	0x18, 2	; 24
      READ( mux_sel, 1 ) ? SET( PORTB, 3 ) : CLR( PORTB, 3 );
    1158:	61 ff       	sbrs	r22, 1
    115a:	02 c0       	rjmp	.+4      	; 0x1160 <__stack+0x61>
    115c:	c3 9a       	sbi	0x18, 3	; 24
    115e:	01 c0       	rjmp	.+2      	; 0x1162 <__stack+0x63>
    1160:	c3 98       	cbi	0x18, 3	; 24
      READ( mux_sel, 0 ) ? SET( PORTB, 4 ) : CLR( PORTB, 4 );
    1162:	60 ff       	sbrs	r22, 0
    1164:	02 c0       	rjmp	.+4      	; 0x116a <__stack+0x6b>
    1166:	c4 9a       	sbi	0x18, 4	; 24
    1168:	08 95       	ret
    116a:	c4 98       	cbi	0x18, 4	; 24
    116c:	08 95       	ret

      break;

    case MUX2:
      READ( mux_sel, 4 ) ? SET( PORTE, 3 ) : CLR( PORTE, 3 );
    116e:	64 ff       	sbrs	r22, 4
    1170:	02 c0       	rjmp	.+4      	; 0x1176 <__stack+0x77>
    1172:	1b 9a       	sbi	0x03, 3	; 3
    1174:	01 c0       	rjmp	.+2      	; 0x1178 <__stack+0x79>
    1176:	1b 98       	cbi	0x03, 3	; 3
      READ( mux_sel, 3 ) ? SET( PORTE, 4 ) : CLR( PORTE, 4 );
    1178:	63 ff       	sbrs	r22, 3
    117a:	02 c0       	rjmp	.+4      	; 0x1180 <__stack+0x81>
    117c:	1c 9a       	sbi	0x03, 4	; 3
    117e:	01 c0       	rjmp	.+2      	; 0x1182 <__stack+0x83>
    1180:	1c 98       	cbi	0x03, 4	; 3
      READ( mux_sel, 2 ) ? SET( PORTE, 5 ) : CLR( PORTE, 5 );
    1182:	62 ff       	sbrs	r22, 2
    1184:	02 c0       	rjmp	.+4      	; 0x118a <__stack+0x8b>
    1186:	1d 9a       	sbi	0x03, 5	; 3
    1188:	01 c0       	rjmp	.+2      	; 0x118c <__stack+0x8d>
    118a:	1d 98       	cbi	0x03, 5	; 3
      READ( mux_sel, 1 ) ? SET( PORTE, 6 ) : CLR( PORTE, 6 );
    118c:	61 ff       	sbrs	r22, 1
    118e:	02 c0       	rjmp	.+4      	; 0x1194 <__stack+0x95>
    1190:	1e 9a       	sbi	0x03, 6	; 3
    1192:	01 c0       	rjmp	.+2      	; 0x1196 <__stack+0x97>
    1194:	1e 98       	cbi	0x03, 6	; 3
      READ( mux_sel, 0 ) ? SET( PORTE, 7 ) : CLR( PORTE, 7 );
    1196:	60 ff       	sbrs	r22, 0
    1198:	02 c0       	rjmp	.+4      	; 0x119e <__stack+0x9f>
    119a:	1f 9a       	sbi	0x03, 7	; 3
    119c:	08 95       	ret
    119e:	1f 98       	cbi	0x03, 7	; 3
    11a0:	08 95       	ret

000011a2 <torquer_off>:
  }
}

void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
    11a2:	82 31       	cpi	r24, 0x12	; 18
    11a4:	31 f0       	breq	.+12     	; 0x11b2 <torquer_off+0x10>
    11a6:	83 31       	cpi	r24, 0x13	; 19
    11a8:	59 f0       	breq	.+22     	; 0x11c0 <torquer_off+0x1e>
    11aa:	81 31       	cpi	r24, 0x11	; 17
    11ac:	99 f4       	brne	.+38     	; 0x11d4 <torquer_off+0x32>
    11ae:	0c 94 75 08 	jmp	0x10ea	; 0x10ea <torquer_off.part.0>
      CLR( PORTC, 0 );
	  CLR( PORTG, 1 );
      break;

    case TORQUER_2:
      CLR( PORTG, 0 );
    11b2:	80 91 65 00 	lds	r24, 0x0065
    11b6:	8e 7f       	andi	r24, 0xFE	; 254
    11b8:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTD, 0 );
    11bc:	90 98       	cbi	0x12, 0	; 18
      break;
    11be:	08 95       	ret

    case TORQUER_3:
      CLR( PORTG, 3 );
    11c0:	80 91 65 00 	lds	r24, 0x0065
    11c4:	87 7f       	andi	r24, 0xF7	; 247
    11c6:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTG, 4 );
    11ca:	80 91 65 00 	lds	r24, 0x0065
    11ce:	8f 7e       	andi	r24, 0xEF	; 239
    11d0:	80 93 65 00 	sts	0x0065, r24
    11d4:	08 95       	ret

000011d6 <torquer_on>:
  }  
}

void torquer_on( uint8_t torquer_num )
{
  switch( torquer_num )
    11d6:	82 31       	cpi	r24, 0x12	; 18
    11d8:	49 f0       	breq	.+18     	; 0x11ec <torquer_on+0x16>
    11da:	83 31       	cpi	r24, 0x13	; 19
    11dc:	71 f0       	breq	.+28     	; 0x11fa <torquer_on+0x24>
    11de:	81 31       	cpi	r24, 0x11	; 17
    11e0:	b1 f4       	brne	.+44     	; 0x120e <torquer_on+0x38>
  {
    case TORQUER_1:
      SET( PORTC, 0 );
    11e2:	a8 9a       	sbi	0x15, 0	; 21
	  SET( PORTG, 1 );
    11e4:	80 91 65 00 	lds	r24, 0x0065
    11e8:	82 60       	ori	r24, 0x02	; 2
    11ea:	0f c0       	rjmp	.+30     	; 0x120a <torquer_on+0x34>
      break;

    case TORQUER_2:
      SET( PORTG, 0 );
    11ec:	80 91 65 00 	lds	r24, 0x0065
    11f0:	81 60       	ori	r24, 0x01	; 1
    11f2:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTD, 0 );
    11f6:	90 9a       	sbi	0x12, 0	; 18
      break;
    11f8:	08 95       	ret

    case TORQUER_3:
      SET( PORTG, 3 );
    11fa:	80 91 65 00 	lds	r24, 0x0065
    11fe:	88 60       	ori	r24, 0x08	; 8
    1200:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTG, 4 );
    1204:	80 91 65 00 	lds	r24, 0x0065
    1208:	80 61       	ori	r24, 0x10	; 16
    120a:	80 93 65 00 	sts	0x0065, r24
    120e:	08 95       	ret

00001210 <switch_on>:
  }
}

void switch_on( uint8_t switch_num )
{
  switch ( switch_num )
    1210:	88 30       	cpi	r24, 0x08	; 8
    1212:	59 f1       	breq	.+86     	; 0x126a <switch_on+0x5a>
    1214:	68 f4       	brcc	.+26     	; 0x1230 <switch_on+0x20>
    1216:	84 30       	cpi	r24, 0x04	; 4
    1218:	01 f1       	breq	.+64     	; 0x125a <switch_on+0x4a>
    121a:	30 f4       	brcc	.+12     	; 0x1228 <switch_on+0x18>
    121c:	82 30       	cpi	r24, 0x02	; 2
    121e:	c9 f0       	breq	.+50     	; 0x1252 <switch_on+0x42>
    1220:	d0 f4       	brcc	.+52     	; 0x1256 <switch_on+0x46>
    1222:	81 30       	cpi	r24, 0x01	; 1
    1224:	b9 f5       	brne	.+110    	; 0x1294 <switch_on+0x84>
    1226:	13 c0       	rjmp	.+38     	; 0x124e <switch_on+0x3e>
    1228:	86 30       	cpi	r24, 0x06	; 6
    122a:	d9 f0       	breq	.+54     	; 0x1262 <switch_on+0x52>
    122c:	e0 f4       	brcc	.+56     	; 0x1266 <switch_on+0x56>
    122e:	17 c0       	rjmp	.+46     	; 0x125e <switch_on+0x4e>
    1230:	8c 30       	cpi	r24, 0x0C	; 12
    1232:	39 f1       	breq	.+78     	; 0x1282 <switch_on+0x72>
    1234:	20 f4       	brcc	.+8      	; 0x123e <switch_on+0x2e>
    1236:	8a 30       	cpi	r24, 0x0A	; 10
    1238:	01 f1       	breq	.+64     	; 0x127a <switch_on+0x6a>
    123a:	08 f5       	brcc	.+66     	; 0x127e <switch_on+0x6e>
    123c:	18 c0       	rjmp	.+48     	; 0x126e <switch_on+0x5e>
    123e:	8e 30       	cpi	r24, 0x0E	; 14
    1240:	21 f1       	breq	.+72     	; 0x128a <switch_on+0x7a>
    1242:	08 f1       	brcs	.+66     	; 0x1286 <switch_on+0x76>
    1244:	8f 30       	cpi	r24, 0x0F	; 15
    1246:	19 f1       	breq	.+70     	; 0x128e <switch_on+0x7e>
    1248:	80 31       	cpi	r24, 0x10	; 16
    124a:	21 f5       	brne	.+72     	; 0x1294 <switch_on+0x84>
    124c:	22 c0       	rjmp	.+68     	; 0x1292 <switch_on+0x82>
  {
    case 1:
      SET( PORTA, 0 );
    124e:	d8 9a       	sbi	0x1b, 0	; 27
      break;
    1250:	08 95       	ret

    case 2:
      SET( PORTA, 1 );
    1252:	d9 9a       	sbi	0x1b, 1	; 27
      break;
    1254:	08 95       	ret

    case 3:
      SET( PORTA, 2 );
    1256:	da 9a       	sbi	0x1b, 2	; 27
      break;
    1258:	08 95       	ret

    case 4:
      SET( PORTB, 5 );
    125a:	c5 9a       	sbi	0x18, 5	; 24
      break;
    125c:	08 95       	ret

    case 5:
      SET( PORTB, 6 );
    125e:	c6 9a       	sbi	0x18, 6	; 24
      break;
    1260:	08 95       	ret

    case 6:
      SET( PORTB, 7 );
    1262:	c7 9a       	sbi	0x18, 7	; 24
      break;
    1264:	08 95       	ret

    case 7:
      SET( PORTD, 4 );
    1266:	94 9a       	sbi	0x12, 4	; 18
      break;
    1268:	08 95       	ret

    case 8:
      SET( PORTD, 5 );
    126a:	95 9a       	sbi	0x12, 5	; 18
      break;
    126c:	08 95       	ret

    case 9:
      SET( PORTG, 2 );
    126e:	80 91 65 00 	lds	r24, 0x0065
    1272:	84 60       	ori	r24, 0x04	; 4
    1274:	80 93 65 00 	sts	0x0065, r24
      break;
    1278:	08 95       	ret

    case 10: 
      SET( PORTC, 7 );
    127a:	af 9a       	sbi	0x15, 7	; 21
      break;
    127c:	08 95       	ret

    case 11:
      SET( PORTC, 6 );
    127e:	ae 9a       	sbi	0x15, 6	; 21
      break;
    1280:	08 95       	ret

    case 12:
      SET( PORTC, 5 );
    1282:	ad 9a       	sbi	0x15, 5	; 21
      break;
    1284:	08 95       	ret

    case 13:
      SET( PORTC, 4 );
    1286:	ac 9a       	sbi	0x15, 4	; 21
      break;
    1288:	08 95       	ret

    case 14:
      SET( PORTC, 3 );
    128a:	ab 9a       	sbi	0x15, 3	; 21
      break;
    128c:	08 95       	ret

    case 15:
      SET( PORTC, 2 );
    128e:	aa 9a       	sbi	0x15, 2	; 21
      break;
    1290:	08 95       	ret

    case 16:
      SET( PORTC, 1 );
    1292:	a9 9a       	sbi	0x15, 1	; 21
    1294:	08 95       	ret

00001296 <switch_off>:
  }
}

void switch_off( uint8_t switch_num )
{
  switch ( switch_num )
    1296:	88 30       	cpi	r24, 0x08	; 8
    1298:	59 f1       	breq	.+86     	; 0x12f0 <switch_off+0x5a>
    129a:	68 f4       	brcc	.+26     	; 0x12b6 <switch_off+0x20>
    129c:	84 30       	cpi	r24, 0x04	; 4
    129e:	01 f1       	breq	.+64     	; 0x12e0 <switch_off+0x4a>
    12a0:	30 f4       	brcc	.+12     	; 0x12ae <switch_off+0x18>
    12a2:	82 30       	cpi	r24, 0x02	; 2
    12a4:	c9 f0       	breq	.+50     	; 0x12d8 <switch_off+0x42>
    12a6:	d0 f4       	brcc	.+52     	; 0x12dc <switch_off+0x46>
    12a8:	81 30       	cpi	r24, 0x01	; 1
    12aa:	b9 f5       	brne	.+110    	; 0x131a <switch_off+0x84>
    12ac:	13 c0       	rjmp	.+38     	; 0x12d4 <switch_off+0x3e>
    12ae:	86 30       	cpi	r24, 0x06	; 6
    12b0:	d9 f0       	breq	.+54     	; 0x12e8 <switch_off+0x52>
    12b2:	e0 f4       	brcc	.+56     	; 0x12ec <switch_off+0x56>
    12b4:	17 c0       	rjmp	.+46     	; 0x12e4 <switch_off+0x4e>
    12b6:	8c 30       	cpi	r24, 0x0C	; 12
    12b8:	39 f1       	breq	.+78     	; 0x1308 <switch_off+0x72>
    12ba:	20 f4       	brcc	.+8      	; 0x12c4 <switch_off+0x2e>
    12bc:	8a 30       	cpi	r24, 0x0A	; 10
    12be:	01 f1       	breq	.+64     	; 0x1300 <switch_off+0x6a>
    12c0:	08 f5       	brcc	.+66     	; 0x1304 <switch_off+0x6e>
    12c2:	18 c0       	rjmp	.+48     	; 0x12f4 <switch_off+0x5e>
    12c4:	8e 30       	cpi	r24, 0x0E	; 14
    12c6:	21 f1       	breq	.+72     	; 0x1310 <switch_off+0x7a>
    12c8:	08 f1       	brcs	.+66     	; 0x130c <switch_off+0x76>
    12ca:	8f 30       	cpi	r24, 0x0F	; 15
    12cc:	19 f1       	breq	.+70     	; 0x1314 <switch_off+0x7e>
    12ce:	80 31       	cpi	r24, 0x10	; 16
    12d0:	21 f5       	brne	.+72     	; 0x131a <switch_off+0x84>
    12d2:	22 c0       	rjmp	.+68     	; 0x1318 <switch_off+0x82>
  {
    case 1:
      CLR( PORTA, 0 );
    12d4:	d8 98       	cbi	0x1b, 0	; 27
      break;
    12d6:	08 95       	ret

    case 2:
      CLR( PORTA, 1 );
    12d8:	d9 98       	cbi	0x1b, 1	; 27
      break;
    12da:	08 95       	ret

    case 3:
      CLR( PORTA, 2 );
    12dc:	da 98       	cbi	0x1b, 2	; 27
      break;
    12de:	08 95       	ret

    case 4:
      CLR( PORTB, 5 );
    12e0:	c5 98       	cbi	0x18, 5	; 24
      break;
    12e2:	08 95       	ret

    case 5:
      CLR( PORTB, 6 );
    12e4:	c6 98       	cbi	0x18, 6	; 24
      break;
    12e6:	08 95       	ret

    case 6:
      CLR( PORTB, 7 );
    12e8:	c7 98       	cbi	0x18, 7	; 24
      break;
    12ea:	08 95       	ret

    case 7:
      CLR( PORTD, 4 );
    12ec:	94 98       	cbi	0x12, 4	; 18
      break;
    12ee:	08 95       	ret

    case 8:
      CLR( PORTD, 5 );
    12f0:	95 98       	cbi	0x12, 5	; 18
      break;
    12f2:	08 95       	ret

    case 9:
      CLR( PORTG, 2 );
    12f4:	80 91 65 00 	lds	r24, 0x0065
    12f8:	8b 7f       	andi	r24, 0xFB	; 251
    12fa:	80 93 65 00 	sts	0x0065, r24
      break;
    12fe:	08 95       	ret

    case 10: 
      CLR( PORTC, 7 );
    1300:	af 98       	cbi	0x15, 7	; 21
      break;
    1302:	08 95       	ret

    case 11:
      CLR( PORTC, 6 );
    1304:	ae 98       	cbi	0x15, 6	; 21
      break;
    1306:	08 95       	ret

    case 12:
      CLR( PORTC, 5 );
    1308:	ad 98       	cbi	0x15, 5	; 21
      break;
    130a:	08 95       	ret

    case 13:
      CLR( PORTC, 4 );
    130c:	ac 98       	cbi	0x15, 4	; 21
      break;
    130e:	08 95       	ret

    case 14:
      CLR( PORTC, 3 );
    1310:	ab 98       	cbi	0x15, 3	; 21
      break;
    1312:	08 95       	ret

    case 15:
      CLR( PORTC, 2 );
    1314:	aa 98       	cbi	0x15, 2	; 21
      break;
    1316:	08 95       	ret

    case 16:
      CLR( PORTC, 1 );
    1318:	a9 98       	cbi	0x15, 1	; 21
    131a:	08 95       	ret

0000131c <average_samples>:
    return  average_samples( component->I_samples );
  }
}

uint8_t average_samples( uint8_t samples[NUM_SAMPLES] )
{
    131c:	fc 01       	movw	r30, r24
  uint8_t average = 0;
  uint16_t sum = 0;

  for(uint8_t avg_index = 0; avg_index < NUM_SAMPLES; avg_index++)
    sum += samples[avg_index];
    131e:	21 81       	ldd	r18, Z+1	; 0x01
    1320:	80 81       	ld	r24, Z
    1322:	90 e0       	ldi	r25, 0x00	; 0
    1324:	82 0f       	add	r24, r18
    1326:	91 1d       	adc	r25, r1
    1328:	22 81       	ldd	r18, Z+2	; 0x02
    132a:	82 0f       	add	r24, r18
    132c:	91 1d       	adc	r25, r1

  average = sum / NUM_SAMPLES;
    132e:	63 e0       	ldi	r22, 0x03	; 3
    1330:	70 e0       	ldi	r23, 0x00	; 0
    1332:	0e 94 f6 13 	call	0x27ec	; 0x27ec <__udivmodhi4>
    1336:	86 2f       	mov	r24, r22

  return average;
}
    1338:	08 95       	ret

0000133a <SVIT_check_I_critical>:
}

uint8_t SVIT_check_I_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    133a:	93 e3       	ldi	r25, 0x33	; 51
    133c:	89 9f       	mul	r24, r25
    133e:	f0 01       	movw	r30, r0
    1340:	11 24       	eor	r1, r1
    1342:	e4 5c       	subi	r30, 0xC4	; 196
    1344:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->I_critical_value != 0 )
    1346:	85 89       	ldd	r24, Z+21	; 0x15
    1348:	88 23       	and	r24, r24
    134a:	11 f0       	breq	.+4      	; 0x1350 <SVIT_check_I_critical+0x16>
  {
    temp= component->I_critical_value;
    component->I_critical_value = 0;
    134c:	15 8a       	std	Z+21, r1	; 0x15
    134e:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->I_samples );
    1350:	cf 01       	movw	r24, r30
    1352:	41 96       	adiw	r24, 0x11	; 17
    1354:	0c 94 8e 09 	jmp	0x131c	; 0x131c <average_samples>

00001358 <SVIT_check_V_critical>:
}

uint8_t SVIT_check_V_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1358:	93 e3       	ldi	r25, 0x33	; 51
    135a:	89 9f       	mul	r24, r25
    135c:	f0 01       	movw	r30, r0
    135e:	11 24       	eor	r1, r1
    1360:	e4 5c       	subi	r30, 0xC4	; 196
    1362:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->V_critical_value != 0 )
    1364:	84 85       	ldd	r24, Z+12	; 0x0c
    1366:	88 23       	and	r24, r24
    1368:	11 f0       	breq	.+4      	; 0x136e <SVIT_check_V_critical+0x16>
  {
    temp= component->V_critical_value;
    component->V_critical_value = 0;
    136a:	14 86       	std	Z+12, r1	; 0x0c
    136c:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->V_samples );
    136e:	cf 01       	movw	r24, r30
    1370:	08 96       	adiw	r24, 0x08	; 8
    1372:	0c 94 8e 09 	jmp	0x131c	; 0x131c <average_samples>

00001376 <perform_ADC>:
}

void perform_ADC( uint8_t mux_num )
{
  // set Vref to AVCC and set the ADC channel to the correct pin ( mux_num )
  ADMUX = (1 << ADLAR) | ( 1 << REFS0 );
    1376:	90 e6       	ldi	r25, 0x60	; 96
    1378:	97 b9       	out	0x07, r25	; 7
  ADMUX &= ~0x3;
    137a:	97 b1       	in	r25, 0x07	; 7
    137c:	9c 7f       	andi	r25, 0xFC	; 252
    137e:	97 b9       	out	0x07, r25	; 7
  ADMUX |= mux_num;
    1380:	97 b1       	in	r25, 0x07	; 7
    1382:	98 2b       	or	r25, r24
    1384:	97 b9       	out	0x07, r25	; 7

  // signal ADC to start a new conversion
  ADCSRA |= ( 1 << ADSC );
    1386:	36 9a       	sbi	0x06, 6	; 6
    1388:	08 95       	ret

0000138a <read_VIT>:

  // when the conversion finishes, the result is stored in ADCL and ADCH
}

void read_VIT( void )
{
    138a:	1f 93       	push	r17
    138c:	cf 93       	push	r28
    138e:	df 93       	push	r29
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type ){
    1390:	80 91 95 0c 	lds	r24, 0x0C95
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1394:	c0 91 37 03 	lds	r28, 0x0337
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type ){
    1398:	82 30       	cpi	r24, 0x02	; 2
    139a:	09 f4       	brne	.+2      	; 0x139e <read_VIT+0x14>
    139c:	6a c0       	rjmp	.+212    	; 0x1472 <read_VIT+0xe8>
    139e:	20 f4       	brcc	.+8      	; 0x13a8 <read_VIT+0x1e>
    13a0:	81 30       	cpi	r24, 0x01	; 1
    13a2:	09 f0       	breq	.+2      	; 0x13a6 <read_VIT+0x1c>
    13a4:	1a c1       	rjmp	.+564    	; 0x15da <read_VIT+0x250>
    13a6:	07 c0       	rjmp	.+14     	; 0x13b6 <read_VIT+0x2c>
    13a8:	83 30       	cpi	r24, 0x03	; 3
    13aa:	09 f4       	brne	.+2      	; 0x13ae <read_VIT+0x24>
    13ac:	da c0       	rjmp	.+436    	; 0x1562 <read_VIT+0x1d8>
    13ae:	84 30       	cpi	r24, 0x04	; 4
    13b0:	09 f0       	breq	.+2      	; 0x13b4 <read_VIT+0x2a>
    13b2:	13 c1       	rjmp	.+550    	; 0x15da <read_VIT+0x250>
    13b4:	fe c0       	rjmp	.+508    	; 0x15b2 <read_VIT+0x228>
		case ADC_VOLTAGE:
			component = &svit[adc_component];
    13b6:	83 e3       	ldi	r24, 0x33	; 51
    13b8:	c8 9f       	mul	r28, r24
    13ba:	e0 01       	movw	r28, r0
    13bc:	11 24       	eor	r1, r1
    13be:	c4 5c       	subi	r28, 0xC4	; 196
    13c0:	dc 4f       	sbci	r29, 0xFC	; 252
			sample_index = component->V_sample_index;
			component->V_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    13c2:	2b 85       	ldd	r18, Y+11	; 0x0b
    13c4:	30 e0       	ldi	r19, 0x00	; 0
    13c6:	c9 01       	movw	r24, r18
    13c8:	01 96       	adiw	r24, 0x01	; 1
    13ca:	63 e0       	ldi	r22, 0x03	; 3
    13cc:	70 e0       	ldi	r23, 0x00	; 0
    13ce:	0e 94 0a 14 	call	0x2814	; 0x2814 <__divmodhi4>
    13d2:	8b 87       	std	Y+11, r24	; 0x0b

			// SoC: If component is a battery, store in different global variable
			if (component->name == BATTERY_1) {
    13d4:	98 81       	ld	r25, Y
    13d6:	94 31       	cpi	r25, 0x14	; 20
    13d8:	89 f4       	brne	.+34     	; 0x13fc <read_VIT+0x72>
				batt1_voltage = ADC_high;
    13da:	80 91 a6 0c 	lds	r24, 0x0CA6
    13de:	80 93 b0 0c 	sts	0x0CB0, r24
				batt1_voltageLow = ADC_low;
    13e2:	80 91 e3 10 	lds	r24, 0x10E3
    13e6:	80 93 c4 10 	sts	0x10C4, r24
				high = ADC_high;
    13ea:	80 91 a6 0c 	lds	r24, 0x0CA6
    13ee:	80 93 a1 0c 	sts	0x0CA1, r24
				low = ADC_low;
    13f2:	80 91 e3 10 	lds	r24, 0x10E3
    13f6:	80 93 af 0c 	sts	0x0CAF, r24
    13fa:	06 c0       	rjmp	.+12     	; 0x1408 <read_VIT+0x7e>
				//debug = adc_component;
			}
			else if (component->name == BATTERY_2) {
    13fc:	95 31       	cpi	r25, 0x15	; 21
    13fe:	21 f4       	brne	.+8      	; 0x1408 <read_VIT+0x7e>
				batt2_voltage = ADC_high;
    1400:	80 91 a6 0c 	lds	r24, 0x0CA6
    1404:	80 93 c1 0e 	sts	0x0EC1, r24
			}
			component->V_samples[sample_index] = ADC_high;
    1408:	80 91 a6 0c 	lds	r24, 0x0CA6
    140c:	fe 01       	movw	r30, r28
    140e:	e2 0f       	add	r30, r18
    1410:	f3 1f       	adc	r31, r19
    1412:	80 87       	std	Z+8, r24	; 0x08
            
			//OverVoltage
	  		if ( ( ADC_high > component->V_upper_limit ) && ( component->force_on != 1 ) ){
    1414:	20 91 a6 0c 	lds	r18, 0x0CA6
    1418:	8e 81       	ldd	r24, Y+6	; 0x06
    141a:	82 17       	cp	r24, r18
    141c:	20 f4       	brcc	.+8      	; 0x1426 <read_VIT+0x9c>
    141e:	8b 81       	ldd	r24, Y+3	; 0x03
    1420:	81 30       	cpi	r24, 0x01	; 1
    1422:	09 f0       	breq	.+2      	; 0x1426 <read_VIT+0x9c>
    1424:	08 c0       	rjmp	.+16     	; 0x1436 <read_VIT+0xac>
  				}
				component->switch_state = SW_OFF;
				component->V_critical_value = ADC_high;
			}
			//UnderVoltage
			else if((ADC_high < component->V_lower_limit) && component->switch_state){
    1426:	20 91 a6 0c 	lds	r18, 0x0CA6
    142a:	8f 81       	ldd	r24, Y+7	; 0x07
    142c:	28 17       	cp	r18, r24
    142e:	d8 f4       	brcc	.+54     	; 0x1466 <read_VIT+0xdc>
    1430:	8a 81       	ldd	r24, Y+2	; 0x02
    1432:	88 23       	and	r24, r24
    1434:	c1 f0       	breq	.+48     	; 0x1466 <read_VIT+0xdc>
				if ( component->switch_num != SW_NULL ){
    1436:	89 81       	ldd	r24, Y+1	; 0x01
    1438:	8f 3f       	cpi	r24, 0xFF	; 255
    143a:	19 f0       	breq	.+6      	; 0x1442 <read_VIT+0xb8>
					switch_off( component->switch_num );
    143c:	0e 94 4b 09 	call	0x1296	; 0x1296 <switch_off>
    1440:	0e c0       	rjmp	.+28     	; 0x145e <read_VIT+0xd4>
				}else {
					switch ( component->name ){
    1442:	92 31       	cpi	r25, 0x12	; 18
    1444:	39 f0       	breq	.+14     	; 0x1454 <read_VIT+0xca>
    1446:	93 31       	cpi	r25, 0x13	; 19
    1448:	39 f0       	breq	.+14     	; 0x1458 <read_VIT+0xce>
    144a:	91 31       	cpi	r25, 0x11	; 17
    144c:	41 f4       	brne	.+16     	; 0x145e <read_VIT+0xd4>
    144e:	0e 94 75 08 	call	0x10ea	; 0x10ea <torquer_off.part.0>
    1452:	05 c0       	rjmp	.+10     	; 0x145e <read_VIT+0xd4>
						case TORQUER_1:
							torquer_off( TORQUER_1 );
							break;
						case TORQUER_2:
							torquer_off( TORQUER_2 );
    1454:	82 e1       	ldi	r24, 0x12	; 18
    1456:	01 c0       	rjmp	.+2      	; 0x145a <read_VIT+0xd0>
							break;
						case TORQUER_3:
							torquer_off( TORQUER_3 );
    1458:	83 e1       	ldi	r24, 0x13	; 19
    145a:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <torquer_off>
							break;
						default:
							break;
					}
				}
				component->switch_state = SW_OFF;
    145e:	1a 82       	std	Y+2, r1	; 0x02
				component->V_critical_value = ADC_high;
    1460:	80 91 a6 0c 	lds	r24, 0x0CA6
    1464:	8c 87       	std	Y+12, r24	; 0x0c
			}
			adc_sensor_type = ADC_CURRENT;
    1466:	82 e0       	ldi	r24, 0x02	; 2
    1468:	80 93 95 0c 	sts	0x0C95, r24

		    //perform next ADC conversion
		    mux_num = component->I_mux_num;
    146c:	1d 85       	ldd	r17, Y+13	; 0x0d
		    mux_sel = component->I_mux_sel;
		    set_mux_sel( mux_num, mux_sel );
    146e:	6e 85       	ldd	r22, Y+14	; 0x0e
    1470:	ab c0       	rjmp	.+342    	; 0x15c8 <read_VIT+0x23e>
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1472:	93 e3       	ldi	r25, 0x33	; 51
    1474:	c9 9f       	mul	r28, r25
    1476:	e0 01       	movw	r28, r0
    1478:	11 24       	eor	r1, r1
    147a:	c4 5c       	subi	r28, 0xC4	; 196
    147c:	dc 4f       	sbci	r29, 0xFC	; 252
	  	sample_index = component->I_sample_index;
	  	component->I_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    147e:	2c 89       	ldd	r18, Y+20	; 0x14
    1480:	30 e0       	ldi	r19, 0x00	; 0
    1482:	c9 01       	movw	r24, r18
    1484:	01 96       	adiw	r24, 0x01	; 1
    1486:	63 e0       	ldi	r22, 0x03	; 3
    1488:	70 e0       	ldi	r23, 0x00	; 0
    148a:	0e 94 0a 14 	call	0x2814	; 0x2814 <__divmodhi4>
    148e:	8c 8b       	std	Y+20, r24	; 0x14
		// SoC hardcode backward current
//		if (adc_component == BATTERY_1_b) {
			//debug = 5;
		//}
		
		if(component->name == SOLAR_1){
    1490:	48 81       	ld	r20, Y
    1492:	47 31       	cpi	r20, 0x17	; 23
    1494:	39 f4       	brne	.+14     	; 0x14a4 <read_VIT+0x11a>
			solar1_current = ADC_high;
    1496:	80 91 a6 0c 	lds	r24, 0x0CA6
    149a:	80 93 b1 0c 	sts	0x0CB1, r24
			hasCheckedCurr = 1;
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	80 93 9a 0c 	sts	0x0C9A, r24
		}

	  	component->I_samples[sample_index] = ADC_high;
    14a4:	80 91 a6 0c 	lds	r24, 0x0CA6
    14a8:	fe 01       	movw	r30, r28
    14aa:	e2 0f       	add	r30, r18
    14ac:	f3 1f       	adc	r31, r19
    14ae:	81 8b       	std	Z+17, r24	; 0x11
		if(coul_count_cnt == 0){
    14b0:	80 91 07 03 	lds	r24, 0x0307
    14b4:	90 91 08 03 	lds	r25, 0x0308
    14b8:	89 2b       	or	r24, r25
    14ba:	99 f4       	brne	.+38     	; 0x14e2 <read_VIT+0x158>
			uint8_t c_samp_idx = component->Coul_sample_index;
    14bc:	88 a9       	ldd	r24, Y+48	; 0x30
			if(c_samp_idx == NUM_SAMPLES){
    14be:	83 30       	cpi	r24, 0x03	; 3
    14c0:	19 f4       	brne	.+6      	; 0x14c8 <read_VIT+0x13e>
				coul_en = 1;
    14c2:	91 e0       	ldi	r25, 0x01	; 1
    14c4:	90 93 86 0a 	sts	0x0A86, r25
			}
			component->Coul_samples[component->Coul_sample_index] = ADC_high;
    14c8:	90 e0       	ldi	r25, 0x00	; 0
    14ca:	20 91 a6 0c 	lds	r18, 0x0CA6
    14ce:	fe 01       	movw	r30, r28
    14d0:	e8 0f       	add	r30, r24
    14d2:	f9 1f       	adc	r31, r25
    14d4:	24 8f       	std	Z+28, r18	; 0x1c
			component->Coul_sample_index = (c_samp_idx + 1) % NUM_SAMPLES;
    14d6:	01 96       	adiw	r24, 0x01	; 1
    14d8:	63 e0       	ldi	r22, 0x03	; 3
    14da:	70 e0       	ldi	r23, 0x00	; 0
    14dc:	0e 94 0a 14 	call	0x2814	; 0x2814 <__divmodhi4>
    14e0:	88 ab       	std	Y+48, r24	; 0x30
		}
	    if ( ( ADC_high > component->I_upper_limit ) && ( component->force_on != 1 ) )
    14e2:	90 91 a6 0c 	lds	r25, 0x0CA6
    14e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    14e8:	89 17       	cp	r24, r25
    14ea:	d8 f4       	brcc	.+54     	; 0x1522 <read_VIT+0x198>
    14ec:	8b 81       	ldd	r24, Y+3	; 0x03
    14ee:	81 30       	cpi	r24, 0x01	; 1
    14f0:	c1 f0       	breq	.+48     	; 0x1522 <read_VIT+0x198>
	  	{
	  		if ( component->switch_num != SW_NULL )
    14f2:	89 81       	ldd	r24, Y+1	; 0x01
    14f4:	8f 3f       	cpi	r24, 0xFF	; 255
    14f6:	19 f0       	breq	.+6      	; 0x14fe <read_VIT+0x174>
	  		{
	  		  switch_off( component->switch_num );
    14f8:	0e 94 4b 09 	call	0x1296	; 0x1296 <switch_off>
    14fc:	0e c0       	rjmp	.+28     	; 0x151a <read_VIT+0x190>
	  		}
	  		else
	  		{
	  		  switch ( component->name )
    14fe:	42 31       	cpi	r20, 0x12	; 18
    1500:	39 f0       	breq	.+14     	; 0x1510 <read_VIT+0x186>
    1502:	43 31       	cpi	r20, 0x13	; 19
    1504:	39 f0       	breq	.+14     	; 0x1514 <read_VIT+0x18a>
    1506:	41 31       	cpi	r20, 0x11	; 17
    1508:	41 f4       	brne	.+16     	; 0x151a <read_VIT+0x190>
    150a:	0e 94 75 08 	call	0x10ea	; 0x10ea <torquer_off.part.0>
    150e:	05 c0       	rjmp	.+10     	; 0x151a <read_VIT+0x190>
		  	  {
  		  		case TORQUER_1:
	  	  		  torquer_off( TORQUER_1 );
		    		  break;
			    	case TORQUER_2:
			  	    torquer_off( TORQUER_2 );
    1510:	82 e1       	ldi	r24, 0x12	; 18
    1512:	01 c0       	rjmp	.+2      	; 0x1516 <read_VIT+0x18c>
			  	    break;
  		  		case TORQUER_3:
	  	  		  torquer_off( TORQUER_3 );
    1514:	83 e1       	ldi	r24, 0x13	; 19
    1516:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <torquer_off>
		    		  break;
			     	default:
				      break;
			    }
			  }
			  component->switch_state = 0;
    151a:	1a 82       	std	Y+2, r1	; 0x02
        component->I_critical_value = ADC_high;
    151c:	80 91 a6 0c 	lds	r24, 0x0CA6
    1520:	8d 8b       	std	Y+21, r24	; 0x15
		  }
      //perform next ADC conversion
      mux_num = component->T_mux_num;
    1522:	1e 89       	ldd	r17, Y+22	; 0x16
      if( mux_num != MUX_NULL )
    1524:	13 30       	cpi	r17, 0x03	; 3
    1526:	29 f0       	breq	.+10     	; 0x1532 <read_VIT+0x1a8>
      {
		    adc_sensor_type = ADC_TEMPERATURE;
    1528:	83 e0       	ldi	r24, 0x03	; 3
    152a:	80 93 95 0c 	sts	0x0C95, r24
        mux_sel = component->T_mux_sel;        
    152e:	6f 89       	ldd	r22, Y+23	; 0x17
    1530:	4b c0       	rjmp	.+150    	; 0x15c8 <read_VIT+0x23e>
		  }
      else
      {
        adc_sensor_type = ADC_VOLTAGE;
    1532:	81 e0       	ldi	r24, 0x01	; 1
    1534:	80 93 95 0c 	sts	0x0C95, r24
		    adc_component = ( adc_component + 1 ) % SVIT_SZ;
    1538:	80 91 37 03 	lds	r24, 0x0337
    153c:	90 e0       	ldi	r25, 0x00	; 0
    153e:	01 96       	adiw	r24, 0x01	; 1
    1540:	64 e2       	ldi	r22, 0x24	; 36
    1542:	70 e0       	ldi	r23, 0x00	; 0
    1544:	0e 94 0a 14 	call	0x2814	; 0x2814 <__divmodhi4>
    1548:	80 93 37 03 	sts	0x0337, r24
        component = &svit[adc_component];
    154c:	23 e3       	ldi	r18, 0x33	; 51
    154e:	28 9f       	mul	r18, r24
    1550:	f0 01       	movw	r30, r0
    1552:	29 9f       	mul	r18, r25
    1554:	f0 0d       	add	r31, r0
    1556:	11 24       	eor	r1, r1
    1558:	e4 5c       	subi	r30, 0xC4	; 196
    155a:	fc 4f       	sbci	r31, 0xFC	; 252
        mux_num = component->V_mux_num;
    155c:	14 81       	ldd	r17, Z+4	; 0x04
        mux_sel = component->V_mux_sel;
    155e:	65 81       	ldd	r22, Z+5	; 0x05
    1560:	33 c0       	rjmp	.+102    	; 0x15c8 <read_VIT+0x23e>
      break;
    //-------------------------------------------------------------------
    // Measure temperature
    //-------------------------------------------------------------------
	  case ADC_TEMPERATURE:
		  component = &svit[adc_component];
    1562:	d0 e0       	ldi	r29, 0x00	; 0
    1564:	43 e3       	ldi	r20, 0x33	; 51
    1566:	4c 9f       	mul	r20, r28
    1568:	f0 01       	movw	r30, r0
    156a:	4d 9f       	mul	r20, r29
    156c:	f0 0d       	add	r31, r0
    156e:	11 24       	eor	r1, r1
    1570:	e4 5c       	subi	r30, 0xC4	; 196
    1572:	fc 4f       	sbci	r31, 0xFC	; 252
		  sample_index = component->T_sample_index;
		  component->T_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    1574:	23 8d       	ldd	r18, Z+27	; 0x1b
    1576:	30 e0       	ldi	r19, 0x00	; 0
    1578:	c9 01       	movw	r24, r18
    157a:	01 96       	adiw	r24, 0x01	; 1
    157c:	63 e0       	ldi	r22, 0x03	; 3
    157e:	70 e0       	ldi	r23, 0x00	; 0
    1580:	0e 94 0a 14 	call	0x2814	; 0x2814 <__divmodhi4>
    1584:	83 8f       	std	Z+27, r24	; 0x1b
		  component->T_samples[sample_index] = ADC_high;
    1586:	80 91 a6 0c 	lds	r24, 0x0CA6
    158a:	e2 0f       	add	r30, r18
    158c:	f3 1f       	adc	r31, r19
    158e:	80 8f       	std	Z+24, r24	; 0x18
      //perform next ADC conversion
  	  adc_sensor_type = ADC_VOLTAGE;
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	80 93 95 0c 	sts	0x0C95, r24
		  adc_component = ( adc_component + 1 ) % SVIT_SZ;
    1596:	ce 01       	movw	r24, r28
    1598:	01 96       	adiw	r24, 0x01	; 1
    159a:	64 e2       	ldi	r22, 0x24	; 36
    159c:	70 e0       	ldi	r23, 0x00	; 0
    159e:	0e 94 0a 14 	call	0x2814	; 0x2814 <__divmodhi4>
    15a2:	80 93 37 03 	sts	0x0337, r24
      component = &svit[adc_component];
    15a6:	48 9f       	mul	r20, r24
    15a8:	f0 01       	movw	r30, r0
    15aa:	49 9f       	mul	r20, r25
    15ac:	f0 0d       	add	r31, r0
    15ae:	11 24       	eor	r1, r1
    15b0:	1d c0       	rjmp	.+58     	; 0x15ec <read_VIT+0x262>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
		  break;
    case ADC_INIT:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    15b2:	81 e0       	ldi	r24, 0x01	; 1
    15b4:	80 93 95 0c 	sts	0x0C95, r24
      component = &svit[adc_component];
    15b8:	93 e3       	ldi	r25, 0x33	; 51
    15ba:	c9 9f       	mul	r28, r25
    15bc:	e0 01       	movw	r28, r0
    15be:	11 24       	eor	r1, r1
    15c0:	c4 5c       	subi	r28, 0xC4	; 196
    15c2:	dc 4f       	sbci	r29, 0xFC	; 252
      mux_num = component->V_mux_num;
    15c4:	1c 81       	ldd	r17, Y+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    15c6:	6d 81       	ldd	r22, Y+5	; 0x05
    15c8:	81 2f       	mov	r24, r17
    15ca:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <set_mux_sel>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    15ce:	83 e3       	ldi	r24, 0x33	; 51
    15d0:	93 e7       	ldi	r25, 0x73	; 115
    15d2:	01 97       	sbiw	r24, 0x01	; 1
    15d4:	f1 f7       	brne	.-4      	; 0x15d2 <read_VIT+0x248>
      //_delay_us(1);
	  //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
    15d6:	81 2f       	mov	r24, r17
    15d8:	15 c0       	rjmp	.+42     	; 0x1604 <read_VIT+0x27a>
      break;
	  default:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    15da:	81 e0       	ldi	r24, 0x01	; 1
    15dc:	80 93 95 0c 	sts	0x0C95, r24
      component = &svit[adc_component];
    15e0:	e0 91 37 03 	lds	r30, 0x0337
    15e4:	93 e3       	ldi	r25, 0x33	; 51
    15e6:	e9 9f       	mul	r30, r25
    15e8:	f0 01       	movw	r30, r0
    15ea:	11 24       	eor	r1, r1
    15ec:	e4 5c       	subi	r30, 0xC4	; 196
    15ee:	fc 4f       	sbci	r31, 0xFC	; 252
      mux_num = component->V_mux_num;
    15f0:	c4 81       	ldd	r28, Z+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    15f2:	65 81       	ldd	r22, Z+5	; 0x05
    15f4:	8c 2f       	mov	r24, r28
    15f6:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <set_mux_sel>
    15fa:	83 e3       	ldi	r24, 0x33	; 51
    15fc:	93 e7       	ldi	r25, 0x73	; 115
    15fe:	01 97       	sbiw	r24, 0x01	; 1
    1600:	f1 f7       	brne	.-4      	; 0x15fe <read_VIT+0x274>
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    1602:	8c 2f       	mov	r24, r28
      break;
  } 
}
    1604:	df 91       	pop	r29
    1606:	cf 91       	pop	r28
    1608:	1f 91       	pop	r17
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    160a:	0c 94 bb 09 	jmp	0x1376	; 0x1376 <perform_ADC>

0000160e <uart_init>:
{
  #if F_CPU < 2000000UL && defined(U2X)
  UCSR0A = UCSR1A = _BV(U2X); /* improve baud rate error by using 2x clk */
  UBRR0L = UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  #else
  UBRR0L = UBRR1L = 7;//(F_CPU / (16UL * UART_BAUD)) - 1;//7;
    160e:	87 e0       	ldi	r24, 0x07	; 7
    1610:	80 93 99 00 	sts	0x0099, r24
    1614:	89 b9       	out	0x09, r24	; 9
  #endif
  UCSR0B = _BV(TXEN0) | _BV(RXEN0); /* tx/rx enable */
    1616:	88 e1       	ldi	r24, 0x18	; 24
    1618:	8a b9       	out	0x0a, r24	; 10
  UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
    161a:	ea e9       	ldi	r30, 0x9A	; 154
    161c:	f0 e0       	ldi	r31, 0x00	; 0
    161e:	80 83       	st	Z, r24


  UCSR1B = UCSR1B | _BV(TXCIE1);
    1620:	80 81       	ld	r24, Z
    1622:	80 64       	ori	r24, 0x40	; 64
    1624:	80 83       	st	Z, r24
  UCSR1B = UCSR1B | _BV(RXCIE1);
    1626:	80 81       	ld	r24, Z
    1628:	80 68       	ori	r24, 0x80	; 128
    162a:	80 83       	st	Z, r24
  UCSR0B = UCSR0B | _BV(TXCIE0);
    162c:	56 9a       	sbi	0x0a, 6	; 10
  UCSR0B = UCSR0B | _BV(RXCIE0);
    162e:	57 9a       	sbi	0x0a, 7	; 10
    1630:	08 95       	ret

00001632 <append_crc16>:
 * Adds a byte of data into the crc calculation using
 * the table above.
 */
void append_crc16(uint8 byte, uint16ptr crc)
{
	*crc = ((*crc) >> 8) ^ ccitt_crc16[((*crc) ^ (byte)) & 0xff];
    1632:	fb 01       	movw	r30, r22
    1634:	20 81       	ld	r18, Z
    1636:	31 81       	ldd	r19, Z+1	; 0x01
    1638:	f9 01       	movw	r30, r18
    163a:	e8 27       	eor	r30, r24
    163c:	ff 27       	eor	r31, r31
    163e:	ee 0f       	add	r30, r30
    1640:	ff 1f       	adc	r31, r31
    1642:	ea 5f       	subi	r30, 0xFA	; 250
    1644:	fe 4f       	sbci	r31, 0xFE	; 254
    1646:	23 2f       	mov	r18, r19
    1648:	33 27       	eor	r19, r19
    164a:	80 81       	ld	r24, Z
    164c:	91 81       	ldd	r25, Z+1	; 0x01
    164e:	82 27       	eor	r24, r18
    1650:	93 27       	eor	r25, r19
    1652:	fb 01       	movw	r30, r22
    1654:	91 83       	std	Z+1, r25	; 0x01
    1656:	80 83       	st	Z, r24
    1658:	08 95       	ret

0000165a <vcpptr_init>:
// Parameters: 
// vcp_ptrbuffer	*buff -					Pointer to the vcp buffer structure
// uint8			*message_buffer -		Pointer to the allocated data buffer
// uint16			message_buffer_size -	Size of the allocated data buffer
void vcpptr_init(vcp_ptrbuffer *buff, uint8 *message_buffer, uint16 message_buffer_size)
{
    165a:	fc 01       	movw	r30, r24
	buff->address =	0;
    165c:	10 82       	st	Z, r1
	buff->message =	message_buffer;
    165e:	72 83       	std	Z+2, r23	; 0x02
    1660:	61 83       	std	Z+1, r22	; 0x01
	buff->size =	message_buffer_size;
    1662:	56 83       	std	Z+6, r21	; 0x06
    1664:	45 83       	std	Z+5, r20	; 0x05
	buff->index	=	0;
    1666:	10 86       	std	Z+8, r1	; 0x08
    1668:	17 82       	std	Z+7, r1	; 0x07
	buff->crc =		CRC16_INIT_VALUE;
    166a:	14 82       	std	Z+4, r1	; 0x04
    166c:	13 82       	std	Z+3, r1	; 0x03
	buff->status =	VCP_IDLE;
    166e:	11 86       	std	Z+9, r1	; 0x09
    1670:	08 95       	ret

00001672 <Create_VCP_frame>:
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
    1672:	4f 92       	push	r4
    1674:	5f 92       	push	r5
    1676:	6f 92       	push	r6
    1678:	7f 92       	push	r7
    167a:	8f 92       	push	r8
    167c:	9f 92       	push	r9
    167e:	af 92       	push	r10
    1680:	bf 92       	push	r11
    1682:	cf 92       	push	r12
    1684:	df 92       	push	r13
    1686:	ef 92       	push	r14
    1688:	ff 92       	push	r15
    168a:	0f 93       	push	r16
    168c:	1f 93       	push	r17
    168e:	cf 93       	push	r28
    1690:	df 93       	push	r29
    1692:	00 d0       	rcall	.+0      	; 0x1694 <Create_VCP_frame+0x22>
    1694:	1f 92       	push	r1
    1696:	cd b7       	in	r28, 0x3d	; 61
    1698:	de b7       	in	r29, 0x3e	; 62
    169a:	6c 01       	movw	r12, r24
    169c:	5b 01       	movw	r10, r22
    169e:	79 01       	movw	r14, r18
	uint16_t crc = CRC16_INIT_VALUE;
    16a0:	1a 82       	std	Y+2, r1	; 0x02
    16a2:	19 82       	std	Y+1, r1	; 0x01
	uint16_t src_index = 0;
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
    16a4:	00 97       	sbiw	r24, 0x00	; 0
    16a6:	09 f4       	brne	.+2      	; 0x16aa <Create_VCP_frame+0x38>
    16a8:	58 c0       	rjmp	.+176    	; 0x175a <Create_VCP_frame+0xe8>
    16aa:	21 15       	cp	r18, r1
    16ac:	31 05       	cpc	r19, r1
    16ae:	09 f4       	brne	.+2      	; 0x16b2 <Create_VCP_frame+0x40>
    16b0:	54 c0       	rjmp	.+168    	; 0x175a <Create_VCP_frame+0xe8>
		return VCP_NULL_ERR;

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
    16b2:	4c 30       	cpi	r20, 0x0C	; 12
    16b4:	18 f0       	brcs	.+6      	; 0x16bc <Create_VCP_frame+0x4a>
    16b6:	48 33       	cpi	r20, 0x38	; 56
    16b8:	09 f0       	breq	.+2      	; 0x16bc <Create_VCP_frame+0x4a>
    16ba:	51 c0       	rjmp	.+162    	; 0x175e <Create_VCP_frame+0xec>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    16bc:	44 24       	eor	r4, r4
    16be:	43 94       	inc	r4
    16c0:	51 2c       	mov	r5, r1
    16c2:	4c 0e       	add	r4, r28
    16c4:	5d 1e       	adc	r5, r29
    16c6:	b2 01       	movw	r22, r4
    16c8:	84 2f       	mov	r24, r20
    16ca:	4b 83       	std	Y+3, r20	; 0x03
    16cc:	0e 94 19 0b 	call	0x1632	; 0x1632 <append_crc16>
// uint8ptr		dst -		Pointer to the destination buffer
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
    16d0:	37 01       	movw	r6, r14
    16d2:	60 0e       	add	r6, r16
    16d4:	71 1e       	adc	r7, r17
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    16d6:	47 01       	movw	r8, r14
    16d8:	07 c0       	rjmp	.+14     	; 0x16e8 <Create_VCP_frame+0x76>
	  append_crc16(src[src_index], &crc);
    16da:	b2 01       	movw	r22, r4
    16dc:	f4 01       	movw	r30, r8
    16de:	81 91       	ld	r24, Z+
    16e0:	4f 01       	movw	r8, r30
    16e2:	4b 83       	std	Y+3, r20	; 0x03
    16e4:	0e 94 19 0b 	call	0x1632	; 0x1632 <append_crc16>
    16e8:	4b 81       	ldd	r20, Y+3	; 0x03
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    16ea:	86 14       	cp	r8, r6
    16ec:	97 04       	cpc	r9, r7
    16ee:	a9 f7       	brne	.-22     	; 0x16da <Create_VCP_frame+0x68>
	  append_crc16(src[src_index], &crc);
	
	// Add CRC to the end of the source buffer
	src[src_index++] = ((crc >> 8) & 0xFF);
    16f0:	89 81       	ldd	r24, Y+1	; 0x01
    16f2:	9a 81       	ldd	r25, Y+2	; 0x02
    16f4:	f7 01       	movw	r30, r14
    16f6:	e0 0f       	add	r30, r16
    16f8:	f1 1f       	adc	r31, r17
    16fa:	90 83       	st	Z, r25
	src[src_index++] = (crc & 0xFF);
    16fc:	81 83       	std	Z+1, r24	; 0x01
    16fe:	0e 5f       	subi	r16, 0xFE	; 254
    1700:	1f 4f       	sbci	r17, 0xFF	; 255
	payload_size = src_index;
	
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
    1702:	80 ec       	ldi	r24, 0xC0	; 192
    1704:	f6 01       	movw	r30, r12
    1706:	80 83       	st	Z, r24
	// then insert VCP address
	dst[dst_index++] =					addr;
    1708:	41 83       	std	Z+1, r20	; 0x01
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    170a:	d7 01       	movw	r26, r14
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
    170c:	42 e0       	ldi	r20, 0x02	; 2
    170e:	50 e0       	ldi	r21, 0x00	; 0
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    1710:	2d ed       	ldi	r18, 0xDD	; 221
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
    1712:	3b ed       	ldi	r19, 0xDB	; 219
			dst[dst_index++] =			TFEND;
    1714:	6c ed       	ldi	r22, 0xDC	; 220
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1716:	0f c0       	rjmp	.+30     	; 0x1736 <Create_VCP_frame+0xc4>
	{
		if (src[src_index] == FEND)
    1718:	8d 91       	ld	r24, X+
    171a:	80 3c       	cpi	r24, 0xC0	; 192
    171c:	19 f4       	brne	.+6      	; 0x1724 <Create_VCP_frame+0xb2>
		{
			dst[dst_index++] =			FESC;
    171e:	30 83       	st	Z, r19
			dst[dst_index++] =			TFEND;
    1720:	61 83       	std	Z+1, r22	; 0x01
    1722:	04 c0       	rjmp	.+8      	; 0x172c <Create_VCP_frame+0xba>
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
    1724:	80 83       	st	Z, r24
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
    1726:	8b 3d       	cpi	r24, 0xDB	; 219
    1728:	21 f4       	brne	.+8      	; 0x1732 <Create_VCP_frame+0xc0>
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    172a:	21 83       	std	Z+1, r18	; 0x01
    172c:	4e 5f       	subi	r20, 0xFE	; 254
    172e:	5f 4f       	sbci	r21, 0xFF	; 255
    1730:	02 c0       	rjmp	.+4      	; 0x1736 <Create_VCP_frame+0xc4>
		}
		else
		{
			dst[dst_index++] =			src[src_index];
    1732:	4f 5f       	subi	r20, 0xFF	; 255
    1734:	5f 4f       	sbci	r21, 0xFF	; 255
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1736:	cd 01       	movw	r24, r26
    1738:	8e 19       	sub	r24, r14
    173a:	9f 09       	sbc	r25, r15
    173c:	f6 01       	movw	r30, r12
    173e:	e4 0f       	add	r30, r20
    1740:	f5 1f       	adc	r31, r21
    1742:	80 17       	cp	r24, r16
    1744:	91 07       	cpc	r25, r17
    1746:	40 f3       	brcs	.-48     	; 0x1718 <Create_VCP_frame+0xa6>
		//if (dst_index >= *dst_size - 1)
			//return VCP_OVR_ERR;
	}
	
	// End the frame with FEND
	dst[dst_index++] =					FEND;
    1748:	80 ec       	ldi	r24, 0xC0	; 192
    174a:	80 83       	st	Z, r24
    174c:	4f 5f       	subi	r20, 0xFF	; 255
    174e:	5f 4f       	sbci	r21, 0xFF	; 255
	
	// Save the frame size
	*dst_size = dst_index;
    1750:	f5 01       	movw	r30, r10
    1752:	51 83       	std	Z+1, r21	; 0x01
    1754:	40 83       	st	Z, r20
	
	// All good
	return VCP_TERM;
    1756:	81 e0       	ldi	r24, 0x01	; 1
    1758:	03 c0       	rjmp	.+6      	; 0x1760 <Create_VCP_frame+0xee>
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
		return VCP_NULL_ERR;
    175a:	85 e0       	ldi	r24, 0x05	; 5
    175c:	01 c0       	rjmp	.+2      	; 0x1760 <Create_VCP_frame+0xee>

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
		return VCP_ADDR_ERR;
    175e:	86 e0       	ldi	r24, 0x06	; 6
	// Save the frame size
	*dst_size = dst_index;
	
	// All good
	return VCP_TERM;
}
    1760:	0f 90       	pop	r0
    1762:	0f 90       	pop	r0
    1764:	0f 90       	pop	r0
    1766:	df 91       	pop	r29
    1768:	cf 91       	pop	r28
    176a:	1f 91       	pop	r17
    176c:	0f 91       	pop	r16
    176e:	ff 90       	pop	r15
    1770:	ef 90       	pop	r14
    1772:	df 90       	pop	r13
    1774:	cf 90       	pop	r12
    1776:	bf 90       	pop	r11
    1778:	af 90       	pop	r10
    177a:	9f 90       	pop	r9
    177c:	8f 90       	pop	r8
    177e:	7f 90       	pop	r7
    1780:	6f 90       	pop	r6
    1782:	5f 90       	pop	r5
    1784:	4f 90       	pop	r4
    1786:	08 95       	ret

00001788 <Receive_VCP_byte>:
// and return VCP status.
// Parameters:
// vcp_ptrbuffer	*buff -	Pointer to the vcp buffer structure
// uint8			byte -	received byte
uint8_t Receive_VCP_byte(vcp_ptrbuffer *buff, uint8 byte)
{
    1788:	cf 92       	push	r12
    178a:	df 92       	push	r13
    178c:	ef 92       	push	r14
    178e:	ff 92       	push	r15
    1790:	0f 93       	push	r16
    1792:	1f 93       	push	r17
    1794:	cf 93       	push	r28
    1796:	df 93       	push	r29
    1798:	ec 01       	movw	r28, r24
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
    179a:	29 81       	ldd	r18, Y+1	; 0x01
    179c:	3a 81       	ldd	r19, Y+2	; 0x02
    179e:	21 15       	cp	r18, r1
    17a0:	31 05       	cpc	r19, r1
    17a2:	09 f4       	brne	.+2      	; 0x17a6 <Receive_VCP_byte+0x1e>
    17a4:	84 c0       	rjmp	.+264    	; 0x18ae <Receive_VCP_byte+0x126>
		return VCP_NULL_ERR;
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
    17a6:	8f 81       	ldd	r24, Y+7	; 0x07
    17a8:	98 85       	ldd	r25, Y+8	; 0x08
    17aa:	4d 81       	ldd	r20, Y+5	; 0x05
    17ac:	5e 81       	ldd	r21, Y+6	; 0x06
    17ae:	41 50       	subi	r20, 0x01	; 1
    17b0:	51 09       	sbc	r21, r1
    17b2:	84 17       	cp	r24, r20
    17b4:	95 07       	cpc	r25, r21
    17b6:	08 f0       	brcs	.+2      	; 0x17ba <Receive_VCP_byte+0x32>
    17b8:	7c c0       	rjmp	.+248    	; 0x18b2 <Receive_VCP_byte+0x12a>
		return VCP_OVR_ERR;
	
	// State Machine
	switch (buff->status)
    17ba:	49 85       	ldd	r20, Y+9	; 0x09
    17bc:	42 30       	cpi	r20, 0x02	; 2
    17be:	39 f1       	breq	.+78     	; 0x180e <Receive_VCP_byte+0x86>
    17c0:	18 f4       	brcc	.+6      	; 0x17c8 <Receive_VCP_byte+0x40>
    17c2:	44 23       	and	r20, r20
    17c4:	31 f0       	breq	.+12     	; 0x17d2 <Receive_VCP_byte+0x4a>
    17c6:	38 c0       	rjmp	.+112    	; 0x1838 <Receive_VCP_byte+0xb0>
    17c8:	40 31       	cpi	r20, 0x10	; 16
    17ca:	31 f0       	breq	.+12     	; 0x17d8 <Receive_VCP_byte+0x50>
    17cc:	40 32       	cpi	r20, 0x20	; 32
    17ce:	a1 f5       	brne	.+104    	; 0x1838 <Receive_VCP_byte+0xb0>
    17d0:	0a c0       	rjmp	.+20     	; 0x17e6 <Receive_VCP_byte+0x5e>
	{
		case VCP_IDLE:										
			if (byte == FEND)
    17d2:	60 3c       	cpi	r22, 0xC0	; 192
    17d4:	91 f5       	brne	.+100    	; 0x183a <Receive_VCP_byte+0xb2>
    17d6:	0d c0       	rjmp	.+26     	; 0x17f2 <Receive_VCP_byte+0x6a>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
    17d8:	6c 30       	cpi	r22, 0x0C	; 12
    17da:	18 f0       	brcs	.+6      	; 0x17e2 <Receive_VCP_byte+0x5a>
    17dc:	68 33       	cpi	r22, 0x38	; 56
    17de:	09 f0       	breq	.+2      	; 0x17e2 <Receive_VCP_byte+0x5a>
    17e0:	6a c0       	rjmp	.+212    	; 0x18b6 <Receive_VCP_byte+0x12e>
				return VCP_ADDR_ERR;
			else
			{
				buff->address = byte;
    17e2:	68 83       	st	Y, r22
    17e4:	26 c0       	rjmp	.+76     	; 0x1832 <Receive_VCP_byte+0xaa>
				buff->status = VCP_RECEIVING;
			}	
			break;
		case VCP_RECEIVING:
			if (byte == FEND)
    17e6:	60 3c       	cpi	r22, 0xC0	; 192
    17e8:	31 f4       	brne	.+12     	; 0x17f6 <Receive_VCP_byte+0x6e>
			{
				if (buff->index > 0)
    17ea:	89 2b       	or	r24, r25
    17ec:	11 f0       	breq	.+4      	; 0x17f2 <Receive_VCP_byte+0x6a>
					// Done
					buff->status = VCP_TERM;
    17ee:	81 e0       	ldi	r24, 0x01	; 1
    17f0:	21 c0       	rjmp	.+66     	; 0x1834 <Receive_VCP_byte+0xac>
				else
					// No data between FENDs - assume lost sync and start over
					buff->status = VCP_ADDRESS;
    17f2:	80 e1       	ldi	r24, 0x10	; 16
    17f4:	1f c0       	rjmp	.+62     	; 0x1834 <Receive_VCP_byte+0xac>
			}
			else if (byte == FESC)
    17f6:	6b 3d       	cpi	r22, 0xDB	; 219
    17f8:	11 f4       	brne	.+4      	; 0x17fe <Receive_VCP_byte+0x76>
				buff->status = VCP_ESC;
    17fa:	82 e0       	ldi	r24, 0x02	; 2
    17fc:	1b c0       	rjmp	.+54     	; 0x1834 <Receive_VCP_byte+0xac>
			else
			{
				buff->message[(buff->index)++] = byte;	
    17fe:	f9 01       	movw	r30, r18
    1800:	e8 0f       	add	r30, r24
    1802:	f9 1f       	adc	r31, r25
    1804:	60 83       	st	Z, r22
    1806:	01 96       	adiw	r24, 0x01	; 1
    1808:	98 87       	std	Y+8, r25	; 0x08
    180a:	8f 83       	std	Y+7, r24	; 0x07
    180c:	16 c0       	rjmp	.+44     	; 0x183a <Receive_VCP_byte+0xb2>
			}						
			break;
		case VCP_ESC:
			if (byte == TFEND)
    180e:	6c 3d       	cpi	r22, 0xDC	; 220
    1810:	29 f4       	brne	.+10     	; 0x181c <Receive_VCP_byte+0x94>
			{
				buff->message[(buff->index)++] = FEND;
    1812:	f9 01       	movw	r30, r18
    1814:	e8 0f       	add	r30, r24
    1816:	f9 1f       	adc	r31, r25
    1818:	40 ec       	ldi	r20, 0xC0	; 192
    181a:	07 c0       	rjmp	.+14     	; 0x182a <Receive_VCP_byte+0xa2>
				buff->status = VCP_RECEIVING;
			}
			else if (byte == TFESC)
    181c:	6d 3d       	cpi	r22, 0xDD	; 221
    181e:	09 f0       	breq	.+2      	; 0x1822 <Receive_VCP_byte+0x9a>
    1820:	4c c0       	rjmp	.+152    	; 0x18ba <Receive_VCP_byte+0x132>
			{
				buff->message[(buff->index)++] = FESC;
    1822:	f9 01       	movw	r30, r18
    1824:	e8 0f       	add	r30, r24
    1826:	f9 1f       	adc	r31, r25
    1828:	4b ed       	ldi	r20, 0xDB	; 219
    182a:	40 83       	st	Z, r20
    182c:	01 96       	adiw	r24, 0x01	; 1
    182e:	98 87       	std	Y+8, r25	; 0x08
    1830:	8f 83       	std	Y+7, r24	; 0x07
				buff->status = VCP_RECEIVING;
    1832:	80 e2       	ldi	r24, 0x20	; 32
    1834:	89 87       	std	Y+9, r24	; 0x09
    1836:	01 c0       	rjmp	.+2      	; 0x183a <Receive_VCP_byte+0xb2>
			}
			else
				return VCP_ESC_ERR;	
			break;
		default:
			buff->status = VCP_IDLE;
    1838:	19 86       	std	Y+9, r1	; 0x09
			break; 
	}
	
	// End of frame
	if (buff->status == VCP_TERM)
    183a:	89 85       	ldd	r24, Y+9	; 0x09
    183c:	81 30       	cpi	r24, 0x01	; 1
    183e:	11 f0       	breq	.+4      	; 0x1844 <Receive_VCP_byte+0xbc>
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
    1840:	89 85       	ldd	r24, Y+9	; 0x09
    1842:	3c c0       	rjmp	.+120    	; 0x18bc <Receive_VCP_byte+0x134>
	
	// End of frame
	if (buff->status == VCP_TERM)
	{
		// Message CRC is last 2 bytes 
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
    1844:	89 81       	ldd	r24, Y+1	; 0x01
    1846:	9a 81       	ldd	r25, Y+2	; 0x02
    1848:	4f 81       	ldd	r20, Y+7	; 0x07
    184a:	58 85       	ldd	r21, Y+8	; 0x08
    184c:	84 0f       	add	r24, r20
    184e:	95 1f       	adc	r25, r21
    1850:	fc 01       	movw	r30, r24
    1852:	32 97       	sbiw	r30, 0x02	; 2
    1854:	30 81       	ld	r19, Z
    1856:	20 e0       	ldi	r18, 0x00	; 0
    1858:	fc 01       	movw	r30, r24
    185a:	31 97       	sbiw	r30, 0x01	; 1
    185c:	80 81       	ld	r24, Z
    185e:	69 01       	movw	r12, r18
    1860:	c8 0e       	add	r12, r24
    1862:	d1 1c       	adc	r13, r1
		// Remove CRC bytes from the message
		buff->index -= 2;
    1864:	42 50       	subi	r20, 0x02	; 2
    1866:	51 09       	sbc	r21, r1
    1868:	58 87       	std	Y+8, r21	; 0x08
    186a:	4f 83       	std	Y+7, r20	; 0x07
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
    186c:	7e 01       	movw	r14, r28
    186e:	83 e0       	ldi	r24, 0x03	; 3
    1870:	e8 0e       	add	r14, r24
    1872:	f1 1c       	adc	r15, r1
    1874:	b7 01       	movw	r22, r14
    1876:	88 81       	ld	r24, Y
    1878:	0e 94 19 0b 	call	0x1632	; 0x1632 <append_crc16>
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    187c:	00 e0       	ldi	r16, 0x00	; 0
    187e:	10 e0       	ldi	r17, 0x00	; 0
    1880:	0a c0       	rjmp	.+20     	; 0x1896 <Receive_VCP_byte+0x10e>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
    1882:	e9 81       	ldd	r30, Y+1	; 0x01
    1884:	fa 81       	ldd	r31, Y+2	; 0x02
    1886:	e0 0f       	add	r30, r16
    1888:	f1 1f       	adc	r31, r17
    188a:	b7 01       	movw	r22, r14
    188c:	80 81       	ld	r24, Z
    188e:	0e 94 19 0b 	call	0x1632	; 0x1632 <append_crc16>
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
		// Remove CRC bytes from the message
		buff->index -= 2;
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    1892:	0f 5f       	subi	r16, 0xFF	; 255
    1894:	1f 4f       	sbci	r17, 0xFF	; 255
    1896:	8f 81       	ldd	r24, Y+7	; 0x07
    1898:	98 85       	ldd	r25, Y+8	; 0x08
    189a:	08 17       	cp	r16, r24
    189c:	19 07       	cpc	r17, r25
    189e:	88 f3       	brcs	.-30     	; 0x1882 <Receive_VCP_byte+0xfa>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
		}
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
    18a0:	8b 81       	ldd	r24, Y+3	; 0x03
    18a2:	9c 81       	ldd	r25, Y+4	; 0x04
    18a4:	8c 15       	cp	r24, r12
    18a6:	9d 05       	cpc	r25, r13
    18a8:	59 f2       	breq	.-106    	; 0x1840 <Receive_VCP_byte+0xb8>
			return VCP_CRC_ERR;
    18aa:	84 e0       	ldi	r24, 0x04	; 4
    18ac:	07 c0       	rjmp	.+14     	; 0x18bc <Receive_VCP_byte+0x134>
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
		return VCP_NULL_ERR;
    18ae:	85 e0       	ldi	r24, 0x05	; 5
    18b0:	05 c0       	rjmp	.+10     	; 0x18bc <Receive_VCP_byte+0x134>
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
		return VCP_OVR_ERR;
    18b2:	83 e0       	ldi	r24, 0x03	; 3
    18b4:	03 c0       	rjmp	.+6      	; 0x18bc <Receive_VCP_byte+0x134>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
				return VCP_ADDR_ERR;
    18b6:	86 e0       	ldi	r24, 0x06	; 6
    18b8:	01 c0       	rjmp	.+2      	; 0x18bc <Receive_VCP_byte+0x134>
			{
				buff->message[(buff->index)++] = FESC;
				buff->status = VCP_RECEIVING;
			}
			else
				return VCP_ESC_ERR;	
    18ba:	87 e0       	ldi	r24, 0x07	; 7
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
}
    18bc:	df 91       	pop	r29
    18be:	cf 91       	pop	r28
    18c0:	1f 91       	pop	r17
    18c2:	0f 91       	pop	r16
    18c4:	ff 90       	pop	r15
    18c6:	ef 90       	pop	r14
    18c8:	df 90       	pop	r13
    18ca:	cf 90       	pop	r12
    18cc:	08 95       	ret

000018ce <tx_put_byte.part.0>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    return;
  if( tel_packet_index[uart] < tel_packet_size[uart] )
    18ce:	28 2f       	mov	r18, r24
    18d0:	30 e0       	ldi	r19, 0x00	; 0
    18d2:	f9 01       	movw	r30, r18
    18d4:	ef 57       	subi	r30, 0x7F	; 127
    18d6:	f5 4f       	sbci	r31, 0xF5	; 245
    18d8:	60 81       	ld	r22, Z
    18da:	d9 01       	movw	r26, r18
    18dc:	aa 0f       	add	r26, r26
    18de:	bb 1f       	adc	r27, r27
    18e0:	a7 5d       	subi	r26, 0xD7	; 215
    18e2:	bc 4f       	sbci	r27, 0xFC	; 252
    18e4:	4d 91       	ld	r20, X+
    18e6:	5c 91       	ld	r21, X
    18e8:	70 e0       	ldi	r23, 0x00	; 0
    18ea:	64 17       	cp	r22, r20
    18ec:	75 07       	cpc	r23, r21
    18ee:	10 f5       	brcc	.+68     	; 0x1934 <tx_put_byte.part.0+0x66>
  {
      if ( uart == 0 )
    18f0:	81 11       	cpse	r24, r1
    18f2:	0e c0       	rjmp	.+28     	; 0x1910 <tx_put_byte.part.0+0x42>
      UDR0 = tel_packet[uart][tel_packet_index[uart]++];
    18f4:	80 81       	ld	r24, Z
    18f6:	9f ef       	ldi	r25, 0xFF	; 255
    18f8:	92 9f       	mul	r25, r18
    18fa:	d0 01       	movw	r26, r0
    18fc:	93 9f       	mul	r25, r19
    18fe:	b0 0d       	add	r27, r0
    1900:	11 24       	eor	r1, r1
    1902:	a8 0f       	add	r26, r24
    1904:	b1 1d       	adc	r27, r1
    1906:	a7 57       	subi	r26, 0x77	; 119
    1908:	b5 4f       	sbci	r27, 0xF5	; 245
    190a:	9c 91       	ld	r25, X
    190c:	9c b9       	out	0x0c, r25	; 12
    190e:	10 c0       	rjmp	.+32     	; 0x1930 <tx_put_byte.part.0+0x62>
    else if ( uart == 1 )
    1910:	81 30       	cpi	r24, 0x01	; 1
    1912:	81 f4       	brne	.+32     	; 0x1934 <tx_put_byte.part.0+0x66>
      UDR1 = tel_packet[uart][tel_packet_index[uart]++];
    1914:	80 81       	ld	r24, Z
    1916:	9f ef       	ldi	r25, 0xFF	; 255
    1918:	92 9f       	mul	r25, r18
    191a:	d0 01       	movw	r26, r0
    191c:	93 9f       	mul	r25, r19
    191e:	b0 0d       	add	r27, r0
    1920:	11 24       	eor	r1, r1
    1922:	a8 0f       	add	r26, r24
    1924:	b1 1d       	adc	r27, r1
    1926:	a7 57       	subi	r26, 0x77	; 119
    1928:	b5 4f       	sbci	r27, 0xF5	; 245
    192a:	9c 91       	ld	r25, X
    192c:	90 93 9c 00 	sts	0x009C, r25
    1930:	8f 5f       	subi	r24, 0xFF	; 255
    1932:	80 83       	st	Z, r24
    1934:	08 95       	ret

00001936 <__vector_15>:
#include "vcp_library.h"
#include "crclib.h"
#include "uart.h"

ISR(TIMER0_COMP_vect)
{
    1936:	1f 92       	push	r1
    1938:	0f 92       	push	r0
    193a:	0f b6       	in	r0, 0x3f	; 63
    193c:	0f 92       	push	r0
    193e:	11 24       	eor	r1, r1
    1940:	8f 93       	push	r24
  if ( timer0_counter[0] > 0 )
    1942:	80 91 b9 0e 	lds	r24, 0x0EB9
    1946:	88 23       	and	r24, r24
    1948:	29 f0       	breq	.+10     	; 0x1954 <__vector_15+0x1e>
    --timer0_counter[0];
    194a:	80 91 b9 0e 	lds	r24, 0x0EB9
    194e:	81 50       	subi	r24, 0x01	; 1
    1950:	80 93 b9 0e 	sts	0x0EB9, r24
  if ( timer0_counter[1] > 0 )
    1954:	80 91 ba 0e 	lds	r24, 0x0EBA
    1958:	88 23       	and	r24, r24
    195a:	29 f0       	breq	.+10     	; 0x1966 <__vector_15+0x30>
    --timer0_counter[1];
    195c:	80 91 ba 0e 	lds	r24, 0x0EBA
    1960:	81 50       	subi	r24, 0x01	; 1
    1962:	80 93 ba 0e 	sts	0x0EBA, r24
	//if (cntr == 0)
	//	PORTC |= 0x01;
	//else
	//	PORTC &= 0xFE;
	//_delay_ms(500);
}
    1966:	8f 91       	pop	r24
    1968:	0f 90       	pop	r0
    196a:	0f be       	out	0x3f, r0	; 63
    196c:	0f 90       	pop	r0
    196e:	1f 90       	pop	r1
    1970:	18 95       	reti

00001972 <__vector_12>:

/* Timer 1(A) routine */
ISR(TIMER1_COMPA_vect)		//Handle Radio & Torquer 30 min delays here; handle 10 min CDH-IB no heartbeat restart
{
    1972:	1f 92       	push	r1
    1974:	0f 92       	push	r0
    1976:	0f b6       	in	r0, 0x3f	; 63
    1978:	0f 92       	push	r0
    197a:	11 24       	eor	r1, r1
    197c:	0b b6       	in	r0, 0x3b	; 59
    197e:	0f 92       	push	r0
    1980:	2f 93       	push	r18
    1982:	3f 93       	push	r19
    1984:	4f 93       	push	r20
    1986:	5f 93       	push	r21
    1988:	6f 93       	push	r22
    198a:	7f 93       	push	r23
    198c:	8f 93       	push	r24
    198e:	9f 93       	push	r25
    1990:	af 93       	push	r26
    1992:	bf 93       	push	r27
    1994:	cf 93       	push	r28
    1996:	ef 93       	push	r30
    1998:	ff 93       	push	r31
	SVIT_t *component;
	
	//Testing
	PORTF ^= 0xFF;
    199a:	80 91 62 00 	lds	r24, 0x0062
    199e:	80 95       	com	r24
    19a0:	80 93 62 00 	sts	0x0062, r24
		
	if (timer1_counter[0] <= 0	  &&     rad_torq_flag){	//provides 30 minute delay			
    19a4:	80 91 e1 10 	lds	r24, 0x10E1
    19a8:	81 11       	cpse	r24, r1
    19aa:	31 c0       	rjmp	.+98     	; 0x1a0e <__vector_12+0x9c>
    19ac:	80 91 0d 03 	lds	r24, 0x030D
    19b0:	88 23       	and	r24, r24
    19b2:	69 f1       	breq	.+90     	; 0x1a0e <__vector_12+0x9c>
	//if ( receive_flag == 1){		//If message is received, reset timer1_counter[0] to CYCLE_COUNTER
	    timer1_counter[0] = CYCLE_COUNTER;
    19b4:	84 e8       	ldi	r24, 0x84	; 132
    19b6:	80 93 e1 10 	sts	0x10E1, r24
		
		//CHECK: Should the ISR do this code or not?
		
		//Turn on radios
		component = &svit[RADIO_1];
		switch_on( component->switch_num );
    19ba:	80 91 6e 05 	lds	r24, 0x056E
    19be:	0e 94 08 09 	call	0x1210	; 0x1210 <switch_on>
		component->switch_state = SW_ON;
    19c2:	c1 e0       	ldi	r28, 0x01	; 1
    19c4:	c0 93 6f 05 	sts	0x056F, r28
		component = &svit[RADIO_2];
		switch_on( component->switch_num );
    19c8:	80 91 a1 05 	lds	r24, 0x05A1
    19cc:	0e 94 08 09 	call	0x1210	; 0x1210 <switch_on>
		component->switch_state = SW_ON;
    19d0:	c0 93 a2 05 	sts	0x05A2, r28
		
		//Turn on torque coils			
		component = &svit[TORQUER_1];
		switch_on( component->switch_num );
    19d4:	80 91 a0 06 	lds	r24, 0x06A0
    19d8:	0e 94 08 09 	call	0x1210	; 0x1210 <switch_on>
		component->switch_state = SW_ON;
    19dc:	c0 93 a1 06 	sts	0x06A1, r28
		component = &svit[TORQUER_2];
		switch_on( component->switch_num );
    19e0:	80 91 d3 06 	lds	r24, 0x06D3
    19e4:	0e 94 08 09 	call	0x1210	; 0x1210 <switch_on>
		component->switch_state = SW_ON;
    19e8:	c0 93 d4 06 	sts	0x06D4, r28
		component = &svit[TORQUER_3];
		switch_on( component->switch_num );
    19ec:	80 91 06 07 	lds	r24, 0x0706
    19f0:	0e 94 08 09 	call	0x1210	; 0x1210 <switch_on>
		component->switch_state = SW_ON;
    19f4:	c0 93 07 07 	sts	0x0707, r28
		torquer_on(TORQUER_1);
    19f8:	81 e1       	ldi	r24, 0x11	; 17
    19fa:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <torquer_on>
		torquer_on(TORQUER_2);
    19fe:	82 e1       	ldi	r24, 0x12	; 18
    1a00:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <torquer_on>
		torquer_on(TORQUER_3);
    1a04:	83 e1       	ldi	r24, 0x13	; 19
    1a06:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <torquer_on>
		
		//PORTC ^= 0x02;	//LED for STK testing
		//PORTC ^= 0x01;
		
		//Don't reexecute this code
		rad_torq_flag = 0;
    1a0a:	10 92 0d 03 	sts	0x030D, r1
	}
	
	if (timer1_counter[1] <= 0   &&   !cdh_heartbeat_flag){		//If heartbeat timer 1 has expired AND we haven't already ordered a restart
    1a0e:	80 91 e2 10 	lds	r24, 0x10E2
    1a12:	81 11       	cpse	r24, r1
    1a14:	07 c0       	rjmp	.+14     	; 0x1a24 <__vector_12+0xb2>
    1a16:	80 91 24 03 	lds	r24, 0x0324
    1a1a:	81 11       	cpse	r24, r1
    1a1c:	03 c0       	rjmp	.+6      	; 0x1a24 <__vector_12+0xb2>
		//Order full component restart
		cdh_heartbeat_flag = 1;
    1a1e:	81 e0       	ldi	r24, 0x01	; 1
    1a20:	80 93 24 03 	sts	0x0324, r24
		
	}
	
	//else{
		PORTC ^= 0x01;		//LED for STK testing at PORTC0
    1a24:	85 b3       	in	r24, 0x15	; 21
    1a26:	91 e0       	ldi	r25, 0x01	; 1
    1a28:	89 27       	eor	r24, r25
    1a2a:	85 bb       	out	0x15, r24	; 21
    1a2c:	2f ef       	ldi	r18, 0xFF	; 255
    1a2e:	8f e7       	ldi	r24, 0x7F	; 127
    1a30:	96 e1       	ldi	r25, 0x16	; 22
    1a32:	21 50       	subi	r18, 0x01	; 1
    1a34:	80 40       	sbci	r24, 0x00	; 0
    1a36:	90 40       	sbci	r25, 0x00	; 0
    1a38:	e1 f7       	brne	.-8      	; 0x1a32 <__vector_12+0xc0>
    1a3a:	00 c0       	rjmp	.+0      	; 0x1a3c <__vector_12+0xca>
    1a3c:	00 00       	nop
		_delay_ms(500);
		--timer1_counter[0];
    1a3e:	80 91 e1 10 	lds	r24, 0x10E1
    1a42:	81 50       	subi	r24, 0x01	; 1
    1a44:	80 93 e1 10 	sts	0x10E1, r24
		--timer1_counter[1];
    1a48:	80 91 e2 10 	lds	r24, 0x10E2
    1a4c:	81 50       	subi	r24, 0x01	; 1
    1a4e:	80 93 e2 10 	sts	0x10E2, r24
	//   volatile float current_sample[t]
	// ADC current sample --> current_sample[t]
	// ADC voltage sample --> voltage_sample[t]
	// t = t + 1;
	// if t = max, make sure we call calc_OCV(method)
}
    1a52:	ff 91       	pop	r31
    1a54:	ef 91       	pop	r30
    1a56:	cf 91       	pop	r28
    1a58:	bf 91       	pop	r27
    1a5a:	af 91       	pop	r26
    1a5c:	9f 91       	pop	r25
    1a5e:	8f 91       	pop	r24
    1a60:	7f 91       	pop	r23
    1a62:	6f 91       	pop	r22
    1a64:	5f 91       	pop	r21
    1a66:	4f 91       	pop	r20
    1a68:	3f 91       	pop	r19
    1a6a:	2f 91       	pop	r18
    1a6c:	0f 90       	pop	r0
    1a6e:	0b be       	out	0x3b, r0	; 59
    1a70:	0f 90       	pop	r0
    1a72:	0f be       	out	0x3f, r0	; 63
    1a74:	0f 90       	pop	r0
    1a76:	1f 90       	pop	r1
    1a78:	18 95       	reti

00001a7a <__vector_32>:

ISR(USART1_TX_vect)
{
    1a7a:	1f 92       	push	r1
    1a7c:	0f 92       	push	r0
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	0f 92       	push	r0
    1a82:	11 24       	eor	r1, r1
    1a84:	0b b6       	in	r0, 0x3b	; 59
    1a86:	0f 92       	push	r0
    1a88:	2f 93       	push	r18
    1a8a:	3f 93       	push	r19
    1a8c:	4f 93       	push	r20
    1a8e:	5f 93       	push	r21
    1a90:	6f 93       	push	r22
    1a92:	7f 93       	push	r23
    1a94:	8f 93       	push	r24
    1a96:	9f 93       	push	r25
    1a98:	af 93       	push	r26
    1a9a:	bf 93       	push	r27
    1a9c:	ef 93       	push	r30
    1a9e:	ff 93       	push	r31
    1aa0:	81 e0       	ldi	r24, 0x01	; 1
    1aa2:	0e 94 67 0c 	call	0x18ce	; 0x18ce <tx_put_byte.part.0>
  tx_put_byte( 1 );
}
    1aa6:	ff 91       	pop	r31
    1aa8:	ef 91       	pop	r30
    1aaa:	bf 91       	pop	r27
    1aac:	af 91       	pop	r26
    1aae:	9f 91       	pop	r25
    1ab0:	8f 91       	pop	r24
    1ab2:	7f 91       	pop	r23
    1ab4:	6f 91       	pop	r22
    1ab6:	5f 91       	pop	r21
    1ab8:	4f 91       	pop	r20
    1aba:	3f 91       	pop	r19
    1abc:	2f 91       	pop	r18
    1abe:	0f 90       	pop	r0
    1ac0:	0b be       	out	0x3b, r0	; 59
    1ac2:	0f 90       	pop	r0
    1ac4:	0f be       	out	0x3f, r0	; 63
    1ac6:	0f 90       	pop	r0
    1ac8:	1f 90       	pop	r1
    1aca:	18 95       	reti

00001acc <__vector_30>:

ISR(USART1_RX_vect)
{
    1acc:	1f 92       	push	r1
    1ace:	0f 92       	push	r0
    1ad0:	0f b6       	in	r0, 0x3f	; 63
    1ad2:	0f 92       	push	r0
    1ad4:	11 24       	eor	r1, r1
    1ad6:	0b b6       	in	r0, 0x3b	; 59
    1ad8:	0f 92       	push	r0
    1ada:	2f 93       	push	r18
    1adc:	3f 93       	push	r19
    1ade:	4f 93       	push	r20
    1ae0:	5f 93       	push	r21
    1ae2:	6f 93       	push	r22
    1ae4:	7f 93       	push	r23
    1ae6:	8f 93       	push	r24
    1ae8:	9f 93       	push	r25
    1aea:	af 93       	push	r26
    1aec:	bf 93       	push	r27
    1aee:	ef 93       	push	r30
    1af0:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[1], UDR1 ) == VCP_TERM )
    1af2:	60 91 9c 00 	lds	r22, 0x009C
    1af6:	80 91 eb 10 	lds	r24, 0x10EB
    1afa:	90 91 ec 10 	lds	r25, 0x10EC
    1afe:	0e 94 c4 0b 	call	0x1788	; 0x1788 <Receive_VCP_byte>
    1b02:	81 30       	cpi	r24, 0x01	; 1
    1b04:	29 f4       	brne	.+10     	; 0x1b10 <__vector_30+0x44>
  {
    rx_flag[1]++;
    1b06:	80 91 ef 10 	lds	r24, 0x10EF
    1b0a:	8f 5f       	subi	r24, 0xFF	; 255
    1b0c:	80 93 ef 10 	sts	0x10EF, r24
  }
}
    1b10:	ff 91       	pop	r31
    1b12:	ef 91       	pop	r30
    1b14:	bf 91       	pop	r27
    1b16:	af 91       	pop	r26
    1b18:	9f 91       	pop	r25
    1b1a:	8f 91       	pop	r24
    1b1c:	7f 91       	pop	r23
    1b1e:	6f 91       	pop	r22
    1b20:	5f 91       	pop	r21
    1b22:	4f 91       	pop	r20
    1b24:	3f 91       	pop	r19
    1b26:	2f 91       	pop	r18
    1b28:	0f 90       	pop	r0
    1b2a:	0b be       	out	0x3b, r0	; 59
    1b2c:	0f 90       	pop	r0
    1b2e:	0f be       	out	0x3f, r0	; 63
    1b30:	0f 90       	pop	r0
    1b32:	1f 90       	pop	r1
    1b34:	18 95       	reti

00001b36 <__vector_21>:

ISR ( ADC_vect )
{
    1b36:	1f 92       	push	r1
    1b38:	0f 92       	push	r0
    1b3a:	0f b6       	in	r0, 0x3f	; 63
    1b3c:	0f 92       	push	r0
    1b3e:	11 24       	eor	r1, r1
    1b40:	5f 93       	push	r21
    1b42:	6f 93       	push	r22
    1b44:	7f 93       	push	r23
    1b46:	8f 93       	push	r24
    1b48:	9f 93       	push	r25
    1b4a:	af 93       	push	r26
    1b4c:	bf 93       	push	r27
  ADC_low = ADCL;	// Left adjusted; read 2 LSB then 8 MSB
    1b4e:	84 b1       	in	r24, 0x04	; 4
    1b50:	80 93 e3 10 	sts	0x10E3, r24
  ADC_high = ADCH;
    1b54:	85 b1       	in	r24, 0x05	; 5
    1b56:	80 93 a6 0c 	sts	0x0CA6, r24
  adc_flag = 1;
    1b5a:	81 e0       	ldi	r24, 0x01	; 1
    1b5c:	80 93 88 0c 	sts	0x0C88, r24
  coul_count_cnt = (coul_count_cnt + 1) % COUL_SAMPLES;
    1b60:	80 91 07 03 	lds	r24, 0x0307
    1b64:	90 91 08 03 	lds	r25, 0x0308
    1b68:	01 96       	adiw	r24, 0x01	; 1
    1b6a:	68 ee       	ldi	r22, 0xE8	; 232
    1b6c:	73 e0       	ldi	r23, 0x03	; 3
    1b6e:	0e 94 f6 13 	call	0x27ec	; 0x27ec <__udivmodhi4>
    1b72:	90 93 08 03 	sts	0x0308, r25
    1b76:	80 93 07 03 	sts	0x0307, r24
}
    1b7a:	bf 91       	pop	r27
    1b7c:	af 91       	pop	r26
    1b7e:	9f 91       	pop	r25
    1b80:	8f 91       	pop	r24
    1b82:	7f 91       	pop	r23
    1b84:	6f 91       	pop	r22
    1b86:	5f 91       	pop	r21
    1b88:	0f 90       	pop	r0
    1b8a:	0f be       	out	0x3f, r0	; 63
    1b8c:	0f 90       	pop	r0
    1b8e:	1f 90       	pop	r1
    1b90:	18 95       	reti

00001b92 <__vector_20>:

ISR( USART0_TX_vect )
{
    1b92:	1f 92       	push	r1
    1b94:	0f 92       	push	r0
    1b96:	0f b6       	in	r0, 0x3f	; 63
    1b98:	0f 92       	push	r0
    1b9a:	11 24       	eor	r1, r1
    1b9c:	0b b6       	in	r0, 0x3b	; 59
    1b9e:	0f 92       	push	r0
    1ba0:	2f 93       	push	r18
    1ba2:	3f 93       	push	r19
    1ba4:	4f 93       	push	r20
    1ba6:	5f 93       	push	r21
    1ba8:	6f 93       	push	r22
    1baa:	7f 93       	push	r23
    1bac:	8f 93       	push	r24
    1bae:	9f 93       	push	r25
    1bb0:	af 93       	push	r26
    1bb2:	bf 93       	push	r27
    1bb4:	ef 93       	push	r30
    1bb6:	ff 93       	push	r31
    1bb8:	80 e0       	ldi	r24, 0x00	; 0
    1bba:	0e 94 67 0c 	call	0x18ce	; 0x18ce <tx_put_byte.part.0>
  tx_put_byte( 0 );
}
    1bbe:	ff 91       	pop	r31
    1bc0:	ef 91       	pop	r30
    1bc2:	bf 91       	pop	r27
    1bc4:	af 91       	pop	r26
    1bc6:	9f 91       	pop	r25
    1bc8:	8f 91       	pop	r24
    1bca:	7f 91       	pop	r23
    1bcc:	6f 91       	pop	r22
    1bce:	5f 91       	pop	r21
    1bd0:	4f 91       	pop	r20
    1bd2:	3f 91       	pop	r19
    1bd4:	2f 91       	pop	r18
    1bd6:	0f 90       	pop	r0
    1bd8:	0b be       	out	0x3b, r0	; 59
    1bda:	0f 90       	pop	r0
    1bdc:	0f be       	out	0x3f, r0	; 63
    1bde:	0f 90       	pop	r0
    1be0:	1f 90       	pop	r1
    1be2:	18 95       	reti

00001be4 <__vector_18>:

ISR( USART0_RX_vect )
{
    1be4:	1f 92       	push	r1
    1be6:	0f 92       	push	r0
    1be8:	0f b6       	in	r0, 0x3f	; 63
    1bea:	0f 92       	push	r0
    1bec:	11 24       	eor	r1, r1
    1bee:	0b b6       	in	r0, 0x3b	; 59
    1bf0:	0f 92       	push	r0
    1bf2:	2f 93       	push	r18
    1bf4:	3f 93       	push	r19
    1bf6:	4f 93       	push	r20
    1bf8:	5f 93       	push	r21
    1bfa:	6f 93       	push	r22
    1bfc:	7f 93       	push	r23
    1bfe:	8f 93       	push	r24
    1c00:	9f 93       	push	r25
    1c02:	af 93       	push	r26
    1c04:	bf 93       	push	r27
    1c06:	ef 93       	push	r30
    1c08:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[0], UDR0 ) == VCP_TERM )
    1c0a:	6c b1       	in	r22, 0x0c	; 12
    1c0c:	80 91 e9 10 	lds	r24, 0x10E9
    1c10:	90 91 ea 10 	lds	r25, 0x10EA
    1c14:	0e 94 c4 0b 	call	0x1788	; 0x1788 <Receive_VCP_byte>
    1c18:	81 30       	cpi	r24, 0x01	; 1
    1c1a:	29 f4       	brne	.+10     	; 0x1c26 <__vector_18+0x42>
  {
    rx_flag[0]++;
    1c1c:	80 91 ee 10 	lds	r24, 0x10EE
    1c20:	8f 5f       	subi	r24, 0xFF	; 255
    1c22:	80 93 ee 10 	sts	0x10EE, r24
  }
}
    1c26:	ff 91       	pop	r31
    1c28:	ef 91       	pop	r30
    1c2a:	bf 91       	pop	r27
    1c2c:	af 91       	pop	r26
    1c2e:	9f 91       	pop	r25
    1c30:	8f 91       	pop	r24
    1c32:	7f 91       	pop	r23
    1c34:	6f 91       	pop	r22
    1c36:	5f 91       	pop	r21
    1c38:	4f 91       	pop	r20
    1c3a:	3f 91       	pop	r19
    1c3c:	2f 91       	pop	r18
    1c3e:	0f 90       	pop	r0
    1c40:	0b be       	out	0x3b, r0	; 59
    1c42:	0f 90       	pop	r0
    1c44:	0f be       	out	0x3f, r0	; 63
    1c46:	0f 90       	pop	r0
    1c48:	1f 90       	pop	r1
    1c4a:	18 95       	reti

00001c4c <tx_put_byte>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    1c4c:	82 30       	cpi	r24, 0x02	; 2
    1c4e:	10 f4       	brcc	.+4      	; 0x1c54 <tx_put_byte+0x8>
    1c50:	0c 94 67 0c 	jmp	0x18ce	; 0x18ce <tx_put_byte.part.0>
    1c54:	08 95       	ret

00001c56 <construct_telemetry_packet>:
  }
}


void construct_telemetry_packet( uint8_t* packet_payload )
{
    1c56:	2f 92       	push	r2
    1c58:	3f 92       	push	r3
    1c5a:	4f 92       	push	r4
    1c5c:	5f 92       	push	r5
    1c5e:	6f 92       	push	r6
    1c60:	7f 92       	push	r7
    1c62:	8f 92       	push	r8
    1c64:	9f 92       	push	r9
    1c66:	af 92       	push	r10
    1c68:	bf 92       	push	r11
    1c6a:	cf 92       	push	r12
    1c6c:	df 92       	push	r13
    1c6e:	ef 92       	push	r14
    1c70:	ff 92       	push	r15
    1c72:	0f 93       	push	r16
    1c74:	1f 93       	push	r17
    1c76:	cf 93       	push	r28
    1c78:	df 93       	push	r29
    1c7a:	cd b7       	in	r28, 0x3d	; 61
    1c7c:	de b7       	in	r29, 0x3e	; 62
    1c7e:	28 97       	sbiw	r28, 0x08	; 8
    1c80:	0f b6       	in	r0, 0x3f	; 63
    1c82:	f8 94       	cli
    1c84:	de bf       	out	0x3e, r29	; 62
    1c86:	0f be       	out	0x3f, r0	; 63
    1c88:	cd bf       	out	0x3d, r28	; 61
    1c8a:	98 87       	std	Y+8, r25	; 0x08
    1c8c:	8f 83       	std	Y+7, r24	; 0x07
  packet_payload[0] = VCP_POWER_TELEMETRY;
    1c8e:	dc 01       	movw	r26, r24
    1c90:	1c 92       	st	X, r1
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
    1c92:	30 91 3c 05 	lds	r19, 0x053C
    1c96:	33 0f       	add	r19, r19
                  ( svit[RADIO_1].switch_state << 2 )    |
    1c98:	80 91 6f 05 	lds	r24, 0x056F
    1c9c:	b4 e0       	ldi	r27, 0x04	; 4
    1c9e:	8b 9f       	mul	r24, r27
    1ca0:	c0 01       	movw	r24, r0
    1ca2:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1ca4:	38 2b       	or	r19, r24
    1ca6:	80 91 09 05 	lds	r24, 0x0509
    1caa:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
    1cac:	80 91 a2 05 	lds	r24, 0x05A2
    1cb0:	e8 e0       	ldi	r30, 0x08	; 8
    1cb2:	8e 9f       	mul	r24, r30
    1cb4:	c0 01       	movw	r24, r0
    1cb6:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1cb8:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
    1cba:	80 91 3b 06 	lds	r24, 0x063B
    1cbe:	f0 e1       	ldi	r31, 0x10	; 16
    1cc0:	8f 9f       	mul	r24, r31
    1cc2:	c0 01       	movw	r24, r0
    1cc4:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1cc6:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;
    1cc8:	80 91 6e 06 	lds	r24, 0x066E
    1ccc:	20 e2       	ldi	r18, 0x20	; 32
    1cce:	82 9f       	mul	r24, r18
    1cd0:	c0 01       	movw	r24, r0
    1cd2:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1cd4:	38 2b       	or	r19, r24
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
    1cd6:	40 91 d4 06 	lds	r20, 0x06D4
    1cda:	44 0f       	add	r20, r20
                  ( svit[TORQUER_3].switch_state << 2 ) |
    1cdc:	80 91 07 07 	lds	r24, 0x0707
    1ce0:	54 e0       	ldi	r21, 0x04	; 4
    1ce2:	85 9f       	mul	r24, r21
    1ce4:	c0 01       	movw	r24, r0
    1ce6:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1ce8:	48 2b       	or	r20, r24
    1cea:	80 91 a1 06 	lds	r24, 0x06A1
    1cee:	48 2b       	or	r20, r24
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );
    1cf0:	e5 ed       	ldi	r30, 0xD5	; 213
    1cf2:	f5 e0       	ldi	r31, 0x05	; 5
    1cf4:	80 81       	ld	r24, Z
    1cf6:	a8 e0       	ldi	r26, 0x08	; 8
    1cf8:	8a 9f       	mul	r24, r26
    1cfa:	c0 01       	movw	r24, r0
    1cfc:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1cfe:	48 2b       	or	r20, r24
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
    1d00:	20 91 71 03 	lds	r18, 0x0371
    1d04:	22 0f       	add	r18, r18
                  ( svit[FC_5V].switch_state << 2 )        |
    1d06:	80 91 a4 03 	lds	r24, 0x03A4
    1d0a:	b4 e0       	ldi	r27, 0x04	; 4
    1d0c:	8b 9f       	mul	r24, r27
    1d0e:	c0 01       	movw	r24, r0
    1d10:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1d12:	28 2b       	or	r18, r24
    1d14:	80 91 3e 03 	lds	r24, 0x033E
    1d18:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
    1d1a:	80 91 0a 04 	lds	r24, 0x040A
    1d1e:	58 e0       	ldi	r21, 0x08	; 8
    1d20:	85 9f       	mul	r24, r21
    1d22:	c0 01       	movw	r24, r0
    1d24:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1d26:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
    1d28:	80 91 3d 04 	lds	r24, 0x043D
    1d2c:	a0 e1       	ldi	r26, 0x10	; 16
    1d2e:	8a 9f       	mul	r24, r26
    1d30:	c0 01       	movw	r24, r0
    1d32:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1d34:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
    1d36:	80 91 70 04 	lds	r24, 0x0470
    1d3a:	b0 e2       	ldi	r27, 0x20	; 32
    1d3c:	8b 9f       	mul	r24, r27
    1d3e:	c0 01       	movw	r24, r0
    1d40:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1d42:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
    1d44:	80 91 a3 04 	lds	r24, 0x04A3
    1d48:	50 e4       	ldi	r21, 0x40	; 64
    1d4a:	85 9f       	mul	r24, r21
    1d4c:	c0 01       	movw	r24, r0
    1d4e:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1d50:	28 2b       	or	r18, r24
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;
    1d52:	80 91 d6 04 	lds	r24, 0x04D6
    1d56:	a0 e8       	ldi	r26, 0x80	; 128
    1d58:	8a 9f       	mul	r24, r26
    1d5a:	c0 01       	movw	r24, r0
    1d5c:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1d5e:	28 2b       	or	r18, r24
  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );

  packet_payload[1] = on_off_state0;
    1d60:	af 81       	ldd	r26, Y+7	; 0x07
    1d62:	b8 85       	ldd	r27, Y+8	; 0x08
    1d64:	11 96       	adiw	r26, 0x01	; 1
    1d66:	2c 93       	st	X, r18
    1d68:	11 97       	sbiw	r26, 0x01	; 1
  packet_payload[2] = on_off_state1;
    1d6a:	12 96       	adiw	r26, 0x02	; 2
    1d6c:	3c 93       	st	X, r19
    1d6e:	12 97       	sbiw	r26, 0x02	; 2
  packet_payload[3] = on_off_state2;
    1d70:	13 96       	adiw	r26, 0x03	; 3
    1d72:	4c 93       	st	X, r20
    1d74:	13 97       	sbiw	r26, 0x03	; 3
  packet_payload[4] = 0x99;
    1d76:	89 e9       	ldi	r24, 0x99	; 153
    1d78:	14 96       	adiw	r26, 0x04	; 4
    1d7a:	8c 93       	st	X, r24
    1d7c:	14 97       	sbiw	r26, 0x04	; 4
  packet_payload[5] = svit[MAESTRO].switch_state;
    1d7e:	80 81       	ld	r24, Z
    1d80:	15 96       	adiw	r26, 0x05	; 5
    1d82:	8c 93       	st	X, r24

  // voltage values (raw ADC output)
  packet_payload[6]  = SVIT_check_V_critical( svit[SPECTROMETER].name );
    1d84:	2c e3       	ldi	r18, 0x3C	; 60
    1d86:	62 2e       	mov	r6, r18
    1d88:	23 e0       	ldi	r18, 0x03	; 3
    1d8a:	72 2e       	mov	r7, r18
    1d8c:	f3 01       	movw	r30, r6
    1d8e:	80 81       	ld	r24, Z
    1d90:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1d94:	af 81       	ldd	r26, Y+7	; 0x07
    1d96:	b8 85       	ldd	r27, Y+8	; 0x08
    1d98:	16 96       	adiw	r26, 0x06	; 6
    1d9a:	8c 93       	st	X, r24
  packet_payload[7]  = SVIT_check_V_critical( svit[STAR_TRACKER].name );
    1d9c:	3f e6       	ldi	r19, 0x6F	; 111
    1d9e:	83 2e       	mov	r8, r19
    1da0:	33 e0       	ldi	r19, 0x03	; 3
    1da2:	93 2e       	mov	r9, r19
    1da4:	f4 01       	movw	r30, r8
    1da6:	80 81       	ld	r24, Z
    1da8:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1dac:	af 81       	ldd	r26, Y+7	; 0x07
    1dae:	b8 85       	ldd	r27, Y+8	; 0x08
    1db0:	17 96       	adiw	r26, 0x07	; 7
    1db2:	8c 93       	st	X, r24
  packet_payload[8]  = SVIT_check_V_critical( svit[FC_5V].name );
    1db4:	42 ea       	ldi	r20, 0xA2	; 162
    1db6:	a4 2e       	mov	r10, r20
    1db8:	43 e0       	ldi	r20, 0x03	; 3
    1dba:	b4 2e       	mov	r11, r20
    1dbc:	f5 01       	movw	r30, r10
    1dbe:	80 81       	ld	r24, Z
    1dc0:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1dc4:	af 81       	ldd	r26, Y+7	; 0x07
    1dc6:	b8 85       	ldd	r27, Y+8	; 0x08
    1dc8:	18 96       	adiw	r26, 0x08	; 8
    1dca:	8c 93       	st	X, r24
  packet_payload[9]  = SVIT_check_V_critical( svit[FC_3_3V].name );
    1dcc:	55 ed       	ldi	r21, 0xD5	; 213
    1dce:	c5 2e       	mov	r12, r21
    1dd0:	53 e0       	ldi	r21, 0x03	; 3
    1dd2:	d5 2e       	mov	r13, r21
    1dd4:	f6 01       	movw	r30, r12
    1dd6:	80 81       	ld	r24, Z
    1dd8:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1ddc:	af 81       	ldd	r26, Y+7	; 0x07
    1dde:	b8 85       	ldd	r27, Y+8	; 0x08
    1de0:	19 96       	adiw	r26, 0x09	; 9
    1de2:	8c 93       	st	X, r24
  packet_payload[10] = SVIT_check_V_critical( svit[GPS_1].name );
    1de4:	68 e0       	ldi	r22, 0x08	; 8
    1de6:	e6 2e       	mov	r14, r22
    1de8:	64 e0       	ldi	r22, 0x04	; 4
    1dea:	f6 2e       	mov	r15, r22
    1dec:	f7 01       	movw	r30, r14
    1dee:	80 81       	ld	r24, Z
    1df0:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1df4:	af 81       	ldd	r26, Y+7	; 0x07
    1df6:	b8 85       	ldd	r27, Y+8	; 0x08
    1df8:	1a 96       	adiw	r26, 0x0a	; 10
    1dfa:	8c 93       	st	X, r24
  packet_payload[11] = SVIT_check_V_critical( svit[CDH_IB].name );
    1dfc:	0e e6       	ldi	r16, 0x6E	; 110
    1dfe:	14 e0       	ldi	r17, 0x04	; 4
    1e00:	f8 01       	movw	r30, r16
    1e02:	80 81       	ld	r24, Z
    1e04:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1e08:	af 81       	ldd	r26, Y+7	; 0x07
    1e0a:	b8 85       	ldd	r27, Y+8	; 0x08
    1e0c:	1b 96       	adiw	r26, 0x0b	; 11
    1e0e:	8c 93       	st	X, r24
  packet_payload[12] = SVIT_check_V_critical( svit[HEATER_1].name );
    1e10:	e1 ea       	ldi	r30, 0xA1	; 161
    1e12:	f4 e0       	ldi	r31, 0x04	; 4
    1e14:	80 81       	ld	r24, Z
    1e16:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1e1a:	af 81       	ldd	r26, Y+7	; 0x07
    1e1c:	b8 85       	ldd	r27, Y+8	; 0x08
    1e1e:	1c 96       	adiw	r26, 0x0c	; 12
    1e20:	8c 93       	st	X, r24
  packet_payload[13] = SVIT_check_V_critical( svit[HEATER_2].name );
    1e22:	74 ed       	ldi	r23, 0xD4	; 212
    1e24:	47 2e       	mov	r4, r23
    1e26:	74 e0       	ldi	r23, 0x04	; 4
    1e28:	57 2e       	mov	r5, r23
    1e2a:	f2 01       	movw	r30, r4
    1e2c:	80 81       	ld	r24, Z
    1e2e:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1e32:	af 81       	ldd	r26, Y+7	; 0x07
    1e34:	b8 85       	ldd	r27, Y+8	; 0x08
    1e36:	1d 96       	adiw	r26, 0x0d	; 13
    1e38:	8c 93       	st	X, r24
  packet_payload[14] = SVIT_check_V_critical( svit[CMG].name );
    1e3a:	e7 e0       	ldi	r30, 0x07	; 7
    1e3c:	2e 2e       	mov	r2, r30
    1e3e:	e5 e0       	ldi	r30, 0x05	; 5
    1e40:	3e 2e       	mov	r3, r30
    1e42:	f1 01       	movw	r30, r2
    1e44:	80 81       	ld	r24, Z
    1e46:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1e4a:	af 81       	ldd	r26, Y+7	; 0x07
    1e4c:	b8 85       	ldd	r27, Y+8	; 0x08
    1e4e:	1e 96       	adiw	r26, 0x0e	; 14
    1e50:	8c 93       	st	X, r24
  packet_payload[15] = SVIT_check_V_critical( svit[SUN_SENSOR].name );
    1e52:	2a e3       	ldi	r18, 0x3A	; 58
    1e54:	35 e0       	ldi	r19, 0x05	; 5
    1e56:	f9 01       	movw	r30, r18
    1e58:	80 81       	ld	r24, Z
    1e5a:	29 83       	std	Y+1, r18	; 0x01
    1e5c:	3a 83       	std	Y+2, r19	; 0x02
    1e5e:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1e62:	af 81       	ldd	r26, Y+7	; 0x07
    1e64:	b8 85       	ldd	r27, Y+8	; 0x08
    1e66:	1f 96       	adiw	r26, 0x0f	; 15
    1e68:	8c 93       	st	X, r24
  packet_payload[16] = SVIT_check_V_critical( svit[RADIO_1].name );
    1e6a:	4d e6       	ldi	r20, 0x6D	; 109
    1e6c:	55 e0       	ldi	r21, 0x05	; 5
    1e6e:	fa 01       	movw	r30, r20
    1e70:	80 81       	ld	r24, Z
    1e72:	4b 83       	std	Y+3, r20	; 0x03
    1e74:	5c 83       	std	Y+4, r21	; 0x04
    1e76:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1e7a:	af 81       	ldd	r26, Y+7	; 0x07
    1e7c:	b8 85       	ldd	r27, Y+8	; 0x08
    1e7e:	50 96       	adiw	r26, 0x10	; 16
    1e80:	8c 93       	st	X, r24
  packet_payload[17] = SVIT_check_V_critical( svit[RADIO_2].name );
    1e82:	60 ea       	ldi	r22, 0xA0	; 160
    1e84:	75 e0       	ldi	r23, 0x05	; 5
    1e86:	fb 01       	movw	r30, r22
    1e88:	80 81       	ld	r24, Z
    1e8a:	6d 83       	std	Y+5, r22	; 0x05
    1e8c:	7e 83       	std	Y+6, r23	; 0x06
    1e8e:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1e92:	af 81       	ldd	r26, Y+7	; 0x07
    1e94:	b8 85       	ldd	r27, Y+8	; 0x08
    1e96:	51 96       	adiw	r26, 0x11	; 17
    1e98:	8c 93       	st	X, r24
  packet_payload[18] = SVIT_check_V_critical( svit[FOG_15V].name );
    1e9a:	e9 e3       	ldi	r30, 0x39	; 57
    1e9c:	f6 e0       	ldi	r31, 0x06	; 6
    1e9e:	80 81       	ld	r24, Z
    1ea0:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1ea4:	af 81       	ldd	r26, Y+7	; 0x07
    1ea6:	b8 85       	ldd	r27, Y+8	; 0x08
    1ea8:	52 96       	adiw	r26, 0x12	; 18
    1eaa:	8c 93       	st	X, r24
  packet_payload[19] = SVIT_check_V_critical( svit[FOG_5V].name );
    1eac:	ec e6       	ldi	r30, 0x6C	; 108
    1eae:	f6 e0       	ldi	r31, 0x06	; 6
    1eb0:	80 81       	ld	r24, Z
    1eb2:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1eb6:	af 81       	ldd	r26, Y+7	; 0x07
    1eb8:	b8 85       	ldd	r27, Y+8	; 0x08
    1eba:	53 96       	adiw	r26, 0x13	; 19
    1ebc:	8c 93       	st	X, r24
  packet_payload[20] = SVIT_check_V_critical( svit[TORQUER_1].name );
    1ebe:	ef e9       	ldi	r30, 0x9F	; 159
    1ec0:	f6 e0       	ldi	r31, 0x06	; 6
    1ec2:	80 81       	ld	r24, Z
    1ec4:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1ec8:	af 81       	ldd	r26, Y+7	; 0x07
    1eca:	b8 85       	ldd	r27, Y+8	; 0x08
    1ecc:	54 96       	adiw	r26, 0x14	; 20
    1ece:	8c 93       	st	X, r24
  packet_payload[21] = SVIT_check_V_critical( svit[TORQUER_2].name );
    1ed0:	e2 ed       	ldi	r30, 0xD2	; 210
    1ed2:	f6 e0       	ldi	r31, 0x06	; 6
    1ed4:	80 81       	ld	r24, Z
    1ed6:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1eda:	af 81       	ldd	r26, Y+7	; 0x07
    1edc:	b8 85       	ldd	r27, Y+8	; 0x08
    1ede:	55 96       	adiw	r26, 0x15	; 21
    1ee0:	8c 93       	st	X, r24
  packet_payload[22] = SVIT_check_V_critical( svit[TORQUER_3].name );
    1ee2:	e5 e0       	ldi	r30, 0x05	; 5
    1ee4:	f7 e0       	ldi	r31, 0x07	; 7
    1ee6:	80 81       	ld	r24, Z
    1ee8:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1eec:	af 81       	ldd	r26, Y+7	; 0x07
    1eee:	b8 85       	ldd	r27, Y+8	; 0x08
    1ef0:	56 96       	adiw	r26, 0x16	; 22
    1ef2:	8c 93       	st	X, r24
  packet_payload[23] = SVIT_check_V_critical( svit[BATTERY_1].name );
    1ef4:	e8 e3       	ldi	r30, 0x38	; 56
    1ef6:	f7 e0       	ldi	r31, 0x07	; 7
    1ef8:	80 81       	ld	r24, Z
    1efa:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1efe:	af 81       	ldd	r26, Y+7	; 0x07
    1f00:	b8 85       	ldd	r27, Y+8	; 0x08
    1f02:	57 96       	adiw	r26, 0x17	; 23
    1f04:	8c 93       	st	X, r24
  packet_payload[24] = SVIT_check_V_critical( svit[BATTERY_2].name );
    1f06:	eb e6       	ldi	r30, 0x6B	; 107
    1f08:	f7 e0       	ldi	r31, 0x07	; 7
    1f0a:	80 81       	ld	r24, Z
    1f0c:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1f10:	af 81       	ldd	r26, Y+7	; 0x07
    1f12:	b8 85       	ldd	r27, Y+8	; 0x08
    1f14:	58 96       	adiw	r26, 0x18	; 24
    1f16:	8c 93       	st	X, r24
  packet_payload[25] = SVIT_check_V_critical( svit[SOLAR_FULL].name );
    1f18:	ee e9       	ldi	r30, 0x9E	; 158
    1f1a:	f7 e0       	ldi	r31, 0x07	; 7
    1f1c:	80 81       	ld	r24, Z
    1f1e:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1f22:	af 81       	ldd	r26, Y+7	; 0x07
    1f24:	b8 85       	ldd	r27, Y+8	; 0x08
    1f26:	59 96       	adiw	r26, 0x19	; 25
    1f28:	8c 93       	st	X, r24
  packet_payload[26] = SVIT_check_V_critical( svit[SOLAR_1].name );
    1f2a:	e1 ed       	ldi	r30, 0xD1	; 209
    1f2c:	f7 e0       	ldi	r31, 0x07	; 7
    1f2e:	80 81       	ld	r24, Z
    1f30:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1f34:	af 81       	ldd	r26, Y+7	; 0x07
    1f36:	b8 85       	ldd	r27, Y+8	; 0x08
    1f38:	5a 96       	adiw	r26, 0x1a	; 26
    1f3a:	8c 93       	st	X, r24
  packet_payload[27] = SVIT_check_V_critical( svit[SOLAR_2].name );
    1f3c:	e4 e0       	ldi	r30, 0x04	; 4
    1f3e:	f8 e0       	ldi	r31, 0x08	; 8
    1f40:	80 81       	ld	r24, Z
    1f42:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1f46:	af 81       	ldd	r26, Y+7	; 0x07
    1f48:	b8 85       	ldd	r27, Y+8	; 0x08
    1f4a:	5b 96       	adiw	r26, 0x1b	; 27
    1f4c:	8c 93       	st	X, r24
  packet_payload[28] = SVIT_check_V_critical( svit[SOLAR_3].name );
    1f4e:	e7 e3       	ldi	r30, 0x37	; 55
    1f50:	f8 e0       	ldi	r31, 0x08	; 8
    1f52:	80 81       	ld	r24, Z
    1f54:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1f58:	af 81       	ldd	r26, Y+7	; 0x07
    1f5a:	b8 85       	ldd	r27, Y+8	; 0x08
    1f5c:	5c 96       	adiw	r26, 0x1c	; 28
    1f5e:	8c 93       	st	X, r24
  packet_payload[29] = SVIT_check_V_critical( svit[SOLAR_4].name );
    1f60:	ea e6       	ldi	r30, 0x6A	; 106
    1f62:	f8 e0       	ldi	r31, 0x08	; 8
    1f64:	80 81       	ld	r24, Z
    1f66:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1f6a:	af 81       	ldd	r26, Y+7	; 0x07
    1f6c:	b8 85       	ldd	r27, Y+8	; 0x08
    1f6e:	5d 96       	adiw	r26, 0x1d	; 29
    1f70:	8c 93       	st	X, r24
  packet_payload[30] = SVIT_check_V_critical( svit[SOLAR_5].name );
    1f72:	ed e9       	ldi	r30, 0x9D	; 157
    1f74:	f8 e0       	ldi	r31, 0x08	; 8
    1f76:	80 81       	ld	r24, Z
    1f78:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1f7c:	af 81       	ldd	r26, Y+7	; 0x07
    1f7e:	b8 85       	ldd	r27, Y+8	; 0x08
    1f80:	5e 96       	adiw	r26, 0x1e	; 30
    1f82:	8c 93       	st	X, r24
  packet_payload[31] = SVIT_check_V_critical( svit[SOLAR_6].name );
    1f84:	e0 ed       	ldi	r30, 0xD0	; 208
    1f86:	f8 e0       	ldi	r31, 0x08	; 8
    1f88:	80 81       	ld	r24, Z
    1f8a:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1f8e:	af 81       	ldd	r26, Y+7	; 0x07
    1f90:	b8 85       	ldd	r27, Y+8	; 0x08
    1f92:	5f 96       	adiw	r26, 0x1f	; 31
    1f94:	8c 93       	st	X, r24
  packet_payload[32] = SVIT_check_V_critical( svit[SOLAR_7].name );
    1f96:	e3 e0       	ldi	r30, 0x03	; 3
    1f98:	f9 e0       	ldi	r31, 0x09	; 9
    1f9a:	80 81       	ld	r24, Z
    1f9c:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1fa0:	af 81       	ldd	r26, Y+7	; 0x07
    1fa2:	b8 85       	ldd	r27, Y+8	; 0x08
    1fa4:	90 96       	adiw	r26, 0x20	; 32
    1fa6:	8c 93       	st	X, r24
  packet_payload[33] = SVIT_check_V_critical( svit[SOLAR_8].name );
    1fa8:	e6 e3       	ldi	r30, 0x36	; 54
    1faa:	f9 e0       	ldi	r31, 0x09	; 9
    1fac:	80 81       	ld	r24, Z
    1fae:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1fb2:	af 81       	ldd	r26, Y+7	; 0x07
    1fb4:	b8 85       	ldd	r27, Y+8	; 0x08
    1fb6:	91 96       	adiw	r26, 0x21	; 33
    1fb8:	8c 93       	st	X, r24
  packet_payload[34] = SVIT_check_V_critical( svit[SOLAR_9].name );
    1fba:	e9 e6       	ldi	r30, 0x69	; 105
    1fbc:	f9 e0       	ldi	r31, 0x09	; 9
    1fbe:	80 81       	ld	r24, Z
    1fc0:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1fc4:	af 81       	ldd	r26, Y+7	; 0x07
    1fc6:	b8 85       	ldd	r27, Y+8	; 0x08
    1fc8:	92 96       	adiw	r26, 0x22	; 34
    1fca:	8c 93       	st	X, r24
  packet_payload[35] = SVIT_check_V_critical( svit[SOLAR_10].name );
    1fcc:	ec e9       	ldi	r30, 0x9C	; 156
    1fce:	f9 e0       	ldi	r31, 0x09	; 9
    1fd0:	80 81       	ld	r24, Z
    1fd2:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1fd6:	af 81       	ldd	r26, Y+7	; 0x07
    1fd8:	b8 85       	ldd	r27, Y+8	; 0x08
    1fda:	93 96       	adiw	r26, 0x23	; 35
    1fdc:	8c 93       	st	X, r24
  packet_payload[36] = SVIT_check_V_critical( svit[SOLAR_11].name );
    1fde:	ef ec       	ldi	r30, 0xCF	; 207
    1fe0:	f9 e0       	ldi	r31, 0x09	; 9
    1fe2:	80 81       	ld	r24, Z
    1fe4:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1fe8:	af 81       	ldd	r26, Y+7	; 0x07
    1fea:	b8 85       	ldd	r27, Y+8	; 0x08
    1fec:	94 96       	adiw	r26, 0x24	; 36
    1fee:	8c 93       	st	X, r24
  packet_payload[37] = SVIT_check_V_critical( svit[SOLAR_12].name );
    1ff0:	e2 e0       	ldi	r30, 0x02	; 2
    1ff2:	fa e0       	ldi	r31, 0x0A	; 10
    1ff4:	80 81       	ld	r24, Z
    1ff6:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    1ffa:	af 81       	ldd	r26, Y+7	; 0x07
    1ffc:	b8 85       	ldd	r27, Y+8	; 0x08
    1ffe:	95 96       	adiw	r26, 0x25	; 37
    2000:	8c 93       	st	X, r24
  packet_payload[38] = SVIT_check_V_critical( svit[POWER_BOARD].name );
    2002:	80 91 35 0a 	lds	r24, 0x0A35
    2006:	0e 94 ac 09 	call	0x1358	; 0x1358 <SVIT_check_V_critical>
    200a:	ef 81       	ldd	r30, Y+7	; 0x07
    200c:	f8 85       	ldd	r31, Y+8	; 0x08
    200e:	86 a3       	std	Z+38, r24	; 0x26
  //uint8_t voltage_error1;
  //uint8_t voltage_error2;
  //uint8_t voltage_error3;
  //uint8_t voltage_error4;
 
  packet_payload[39] = 0;
    2010:	17 a2       	std	Z+39, r1	; 0x27
  packet_payload[40] = 0;
    2012:	10 a6       	std	Z+40, r1	; 0x28
  packet_payload[41] = 0;
    2014:	11 a6       	std	Z+41, r1	; 0x29
  packet_payload[42] = 0;
    2016:	12 a6       	std	Z+42, r1	; 0x2a
  packet_payload[43] = 0;
    2018:	13 a6       	std	Z+43, r1	; 0x2b

  // current values (raw ADC output)
  packet_payload[44] = SVIT_check_I_critical( svit[SPECTROMETER].name );
    201a:	d3 01       	movw	r26, r6
    201c:	8c 91       	ld	r24, X
    201e:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    2022:	ef 81       	ldd	r30, Y+7	; 0x07
    2024:	f8 85       	ldd	r31, Y+8	; 0x08
    2026:	84 a7       	std	Z+44, r24	; 0x2c
  packet_payload[45] = SVIT_check_I_critical( svit[STAR_TRACKER].name );
    2028:	d4 01       	movw	r26, r8
    202a:	8c 91       	ld	r24, X
    202c:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    2030:	ef 81       	ldd	r30, Y+7	; 0x07
    2032:	f8 85       	ldd	r31, Y+8	; 0x08
    2034:	85 a7       	std	Z+45, r24	; 0x2d
  packet_payload[46] = SVIT_check_I_critical( svit[FC_5V].name );
    2036:	d5 01       	movw	r26, r10
    2038:	8c 91       	ld	r24, X
    203a:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    203e:	ef 81       	ldd	r30, Y+7	; 0x07
    2040:	f8 85       	ldd	r31, Y+8	; 0x08
    2042:	86 a7       	std	Z+46, r24	; 0x2e
  packet_payload[47] = SVIT_check_I_critical( svit[FC_3_3V].name );
    2044:	d6 01       	movw	r26, r12
    2046:	8c 91       	ld	r24, X
    2048:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    204c:	ef 81       	ldd	r30, Y+7	; 0x07
    204e:	f8 85       	ldd	r31, Y+8	; 0x08
    2050:	87 a7       	std	Z+47, r24	; 0x2f
  packet_payload[48] = SVIT_check_I_critical( svit[GPS_1].name );
    2052:	d7 01       	movw	r26, r14
    2054:	8c 91       	ld	r24, X
    2056:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    205a:	ef 81       	ldd	r30, Y+7	; 0x07
    205c:	f8 85       	ldd	r31, Y+8	; 0x08
    205e:	80 ab       	std	Z+48, r24	; 0x30
  packet_payload[49] = SVIT_check_I_critical( svit[CDH_IB].name );
    2060:	d8 01       	movw	r26, r16
    2062:	8c 91       	ld	r24, X
    2064:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    2068:	ef 81       	ldd	r30, Y+7	; 0x07
    206a:	f8 85       	ldd	r31, Y+8	; 0x08
    206c:	81 ab       	std	Z+49, r24	; 0x31
  packet_payload[50] = SVIT_check_I_critical( svit[HEATER_1].name );
    206e:	a1 ea       	ldi	r26, 0xA1	; 161
    2070:	b4 e0       	ldi	r27, 0x04	; 4
    2072:	8c 91       	ld	r24, X
    2074:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    2078:	ef 81       	ldd	r30, Y+7	; 0x07
    207a:	f8 85       	ldd	r31, Y+8	; 0x08
    207c:	82 ab       	std	Z+50, r24	; 0x32
  packet_payload[51] = SVIT_check_I_critical( svit[HEATER_2].name );
    207e:	d2 01       	movw	r26, r4
    2080:	8c 91       	ld	r24, X
    2082:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    2086:	ef 81       	ldd	r30, Y+7	; 0x07
    2088:	f8 85       	ldd	r31, Y+8	; 0x08
    208a:	83 ab       	std	Z+51, r24	; 0x33
  packet_payload[52] = SVIT_check_I_critical( svit[CMG].name );
    208c:	d1 01       	movw	r26, r2
    208e:	8c 91       	ld	r24, X
    2090:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    2094:	ef 81       	ldd	r30, Y+7	; 0x07
    2096:	f8 85       	ldd	r31, Y+8	; 0x08
    2098:	84 ab       	std	Z+52, r24	; 0x34
  packet_payload[53] = SVIT_check_I_critical( svit[SUN_SENSOR].name );
    209a:	29 81       	ldd	r18, Y+1	; 0x01
    209c:	3a 81       	ldd	r19, Y+2	; 0x02
    209e:	d9 01       	movw	r26, r18
    20a0:	8c 91       	ld	r24, X
    20a2:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    20a6:	ef 81       	ldd	r30, Y+7	; 0x07
    20a8:	f8 85       	ldd	r31, Y+8	; 0x08
    20aa:	85 ab       	std	Z+53, r24	; 0x35
  packet_payload[54] = SVIT_check_I_critical( svit[RADIO_1].name );
    20ac:	4b 81       	ldd	r20, Y+3	; 0x03
    20ae:	5c 81       	ldd	r21, Y+4	; 0x04
    20b0:	da 01       	movw	r26, r20
    20b2:	8c 91       	ld	r24, X
    20b4:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    20b8:	ef 81       	ldd	r30, Y+7	; 0x07
    20ba:	f8 85       	ldd	r31, Y+8	; 0x08
    20bc:	86 ab       	std	Z+54, r24	; 0x36
  packet_payload[55] = SVIT_check_I_critical( svit[RADIO_2].name );
    20be:	6d 81       	ldd	r22, Y+5	; 0x05
    20c0:	7e 81       	ldd	r23, Y+6	; 0x06
    20c2:	db 01       	movw	r26, r22
    20c4:	8c 91       	ld	r24, X
    20c6:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    20ca:	ef 81       	ldd	r30, Y+7	; 0x07
    20cc:	f8 85       	ldd	r31, Y+8	; 0x08
    20ce:	87 ab       	std	Z+55, r24	; 0x37
  packet_payload[56] = SVIT_check_I_critical( svit[FOG_15V].name );
    20d0:	a9 e3       	ldi	r26, 0x39	; 57
    20d2:	b6 e0       	ldi	r27, 0x06	; 6
    20d4:	8c 91       	ld	r24, X
    20d6:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    20da:	ef 81       	ldd	r30, Y+7	; 0x07
    20dc:	f8 85       	ldd	r31, Y+8	; 0x08
    20de:	80 af       	std	Z+56, r24	; 0x38
  packet_payload[57] = SVIT_check_I_critical( svit[FOG_5V].name );
    20e0:	ac e6       	ldi	r26, 0x6C	; 108
    20e2:	b6 e0       	ldi	r27, 0x06	; 6
    20e4:	8c 91       	ld	r24, X
    20e6:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    20ea:	ef 81       	ldd	r30, Y+7	; 0x07
    20ec:	f8 85       	ldd	r31, Y+8	; 0x08
    20ee:	81 af       	std	Z+57, r24	; 0x39
  packet_payload[58] = SVIT_check_I_critical( svit[TORQUER_1].name );
    20f0:	af e9       	ldi	r26, 0x9F	; 159
    20f2:	b6 e0       	ldi	r27, 0x06	; 6
    20f4:	8c 91       	ld	r24, X
    20f6:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    20fa:	ef 81       	ldd	r30, Y+7	; 0x07
    20fc:	f8 85       	ldd	r31, Y+8	; 0x08
    20fe:	82 af       	std	Z+58, r24	; 0x3a
  packet_payload[59] = SVIT_check_I_critical( svit[TORQUER_2].name );
    2100:	a2 ed       	ldi	r26, 0xD2	; 210
    2102:	b6 e0       	ldi	r27, 0x06	; 6
    2104:	8c 91       	ld	r24, X
    2106:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    210a:	ef 81       	ldd	r30, Y+7	; 0x07
    210c:	f8 85       	ldd	r31, Y+8	; 0x08
    210e:	83 af       	std	Z+59, r24	; 0x3b
  packet_payload[60] = SVIT_check_I_critical( svit[TORQUER_3].name );
    2110:	a5 e0       	ldi	r26, 0x05	; 5
    2112:	b7 e0       	ldi	r27, 0x07	; 7
    2114:	8c 91       	ld	r24, X
    2116:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    211a:	ef 81       	ldd	r30, Y+7	; 0x07
    211c:	f8 85       	ldd	r31, Y+8	; 0x08
    211e:	84 af       	std	Z+60, r24	; 0x3c
  packet_payload[61] = SVIT_check_I_critical( svit[BATTERY_1].name );
    2120:	a8 e3       	ldi	r26, 0x38	; 56
    2122:	b7 e0       	ldi	r27, 0x07	; 7
    2124:	8c 91       	ld	r24, X
    2126:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    212a:	ef 81       	ldd	r30, Y+7	; 0x07
    212c:	f8 85       	ldd	r31, Y+8	; 0x08
    212e:	85 af       	std	Z+61, r24	; 0x3d
  packet_payload[62] = SVIT_check_I_critical( svit[BATTERY_2].name );
    2130:	ab e6       	ldi	r26, 0x6B	; 107
    2132:	b7 e0       	ldi	r27, 0x07	; 7
    2134:	8c 91       	ld	r24, X
    2136:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    213a:	ef 81       	ldd	r30, Y+7	; 0x07
    213c:	f8 85       	ldd	r31, Y+8	; 0x08
    213e:	86 af       	std	Z+62, r24	; 0x3e
  packet_payload[63] = SVIT_check_I_critical( svit[SOLAR_FULL].name );
    2140:	ae e9       	ldi	r26, 0x9E	; 158
    2142:	b7 e0       	ldi	r27, 0x07	; 7
    2144:	8c 91       	ld	r24, X
    2146:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    214a:	ef 81       	ldd	r30, Y+7	; 0x07
    214c:	f8 85       	ldd	r31, Y+8	; 0x08
    214e:	87 af       	std	Z+63, r24	; 0x3f
  packet_payload[64] = SVIT_check_I_critical( svit[SOLAR_1].name );
    2150:	a1 ed       	ldi	r26, 0xD1	; 209
    2152:	b7 e0       	ldi	r27, 0x07	; 7
    2154:	8c 91       	ld	r24, X
    2156:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    215a:	ef 81       	ldd	r30, Y+7	; 0x07
    215c:	f8 85       	ldd	r31, Y+8	; 0x08
    215e:	e0 5c       	subi	r30, 0xC0	; 192
    2160:	ff 4f       	sbci	r31, 0xFF	; 255
    2162:	80 83       	st	Z, r24
  packet_payload[65] = SVIT_check_I_critical( svit[SOLAR_2].name );
    2164:	e4 e0       	ldi	r30, 0x04	; 4
    2166:	f8 e0       	ldi	r31, 0x08	; 8
    2168:	80 81       	ld	r24, Z
    216a:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    216e:	ef 81       	ldd	r30, Y+7	; 0x07
    2170:	f8 85       	ldd	r31, Y+8	; 0x08
    2172:	ef 5b       	subi	r30, 0xBF	; 191
    2174:	ff 4f       	sbci	r31, 0xFF	; 255
    2176:	80 83       	st	Z, r24
  packet_payload[66] = SVIT_check_I_critical( svit[SOLAR_3].name );
    2178:	a7 e3       	ldi	r26, 0x37	; 55
    217a:	b8 e0       	ldi	r27, 0x08	; 8
    217c:	8c 91       	ld	r24, X
    217e:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    2182:	ef 81       	ldd	r30, Y+7	; 0x07
    2184:	f8 85       	ldd	r31, Y+8	; 0x08
    2186:	ee 5b       	subi	r30, 0xBE	; 190
    2188:	ff 4f       	sbci	r31, 0xFF	; 255
    218a:	80 83       	st	Z, r24
  packet_payload[67] = SVIT_check_I_critical( svit[SOLAR_4].name );
    218c:	ea e6       	ldi	r30, 0x6A	; 106
    218e:	f8 e0       	ldi	r31, 0x08	; 8
    2190:	80 81       	ld	r24, Z
    2192:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    2196:	ef 81       	ldd	r30, Y+7	; 0x07
    2198:	f8 85       	ldd	r31, Y+8	; 0x08
    219a:	ed 5b       	subi	r30, 0xBD	; 189
    219c:	ff 4f       	sbci	r31, 0xFF	; 255
    219e:	80 83       	st	Z, r24
  packet_payload[68] = SVIT_check_I_critical( svit[SOLAR_5].name );
    21a0:	ad e9       	ldi	r26, 0x9D	; 157
    21a2:	b8 e0       	ldi	r27, 0x08	; 8
    21a4:	8c 91       	ld	r24, X
    21a6:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    21aa:	ef 81       	ldd	r30, Y+7	; 0x07
    21ac:	f8 85       	ldd	r31, Y+8	; 0x08
    21ae:	ec 5b       	subi	r30, 0xBC	; 188
    21b0:	ff 4f       	sbci	r31, 0xFF	; 255
    21b2:	80 83       	st	Z, r24
  packet_payload[69] = SVIT_check_I_critical( svit[SOLAR_6].name );
    21b4:	e0 ed       	ldi	r30, 0xD0	; 208
    21b6:	f8 e0       	ldi	r31, 0x08	; 8
    21b8:	80 81       	ld	r24, Z
    21ba:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    21be:	ef 81       	ldd	r30, Y+7	; 0x07
    21c0:	f8 85       	ldd	r31, Y+8	; 0x08
    21c2:	eb 5b       	subi	r30, 0xBB	; 187
    21c4:	ff 4f       	sbci	r31, 0xFF	; 255
    21c6:	80 83       	st	Z, r24
  packet_payload[70] = SVIT_check_I_critical( svit[SOLAR_7].name );
    21c8:	a3 e0       	ldi	r26, 0x03	; 3
    21ca:	b9 e0       	ldi	r27, 0x09	; 9
    21cc:	8c 91       	ld	r24, X
    21ce:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    21d2:	ef 81       	ldd	r30, Y+7	; 0x07
    21d4:	f8 85       	ldd	r31, Y+8	; 0x08
    21d6:	ea 5b       	subi	r30, 0xBA	; 186
    21d8:	ff 4f       	sbci	r31, 0xFF	; 255
    21da:	80 83       	st	Z, r24
  packet_payload[71] = SVIT_check_I_critical( svit[SOLAR_8].name );
    21dc:	e6 e3       	ldi	r30, 0x36	; 54
    21de:	f9 e0       	ldi	r31, 0x09	; 9
    21e0:	80 81       	ld	r24, Z
    21e2:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    21e6:	ef 81       	ldd	r30, Y+7	; 0x07
    21e8:	f8 85       	ldd	r31, Y+8	; 0x08
    21ea:	e9 5b       	subi	r30, 0xB9	; 185
    21ec:	ff 4f       	sbci	r31, 0xFF	; 255
    21ee:	80 83       	st	Z, r24
  packet_payload[72] = SVIT_check_I_critical( svit[SOLAR_9].name );
    21f0:	a9 e6       	ldi	r26, 0x69	; 105
    21f2:	b9 e0       	ldi	r27, 0x09	; 9
    21f4:	8c 91       	ld	r24, X
    21f6:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    21fa:	ef 81       	ldd	r30, Y+7	; 0x07
    21fc:	f8 85       	ldd	r31, Y+8	; 0x08
    21fe:	e8 5b       	subi	r30, 0xB8	; 184
    2200:	ff 4f       	sbci	r31, 0xFF	; 255
    2202:	80 83       	st	Z, r24
  packet_payload[73] = SVIT_check_I_critical( svit[SOLAR_10].name );
    2204:	ec e9       	ldi	r30, 0x9C	; 156
    2206:	f9 e0       	ldi	r31, 0x09	; 9
    2208:	80 81       	ld	r24, Z
    220a:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    220e:	ef 81       	ldd	r30, Y+7	; 0x07
    2210:	f8 85       	ldd	r31, Y+8	; 0x08
    2212:	e7 5b       	subi	r30, 0xB7	; 183
    2214:	ff 4f       	sbci	r31, 0xFF	; 255
    2216:	80 83       	st	Z, r24
  packet_payload[74] = SVIT_check_I_critical( svit[SOLAR_11].name );
    2218:	af ec       	ldi	r26, 0xCF	; 207
    221a:	b9 e0       	ldi	r27, 0x09	; 9
    221c:	8c 91       	ld	r24, X
    221e:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    2222:	ef 81       	ldd	r30, Y+7	; 0x07
    2224:	f8 85       	ldd	r31, Y+8	; 0x08
    2226:	e6 5b       	subi	r30, 0xB6	; 182
    2228:	ff 4f       	sbci	r31, 0xFF	; 255
    222a:	80 83       	st	Z, r24
  packet_payload[75] = SVIT_check_I_critical( svit[SOLAR_12].name );
    222c:	e2 e0       	ldi	r30, 0x02	; 2
    222e:	fa e0       	ldi	r31, 0x0A	; 10
    2230:	80 81       	ld	r24, Z
    2232:	0e 94 9d 09 	call	0x133a	; 0x133a <SVIT_check_I_critical>
    2236:	ef 81       	ldd	r30, Y+7	; 0x07
    2238:	f8 85       	ldd	r31, Y+8	; 0x08
    223a:	e5 5b       	subi	r30, 0xB5	; 181
    223c:	ff 4f       	sbci	r31, 0xFF	; 255
    223e:	80 83       	st	Z, r24
  packet_payload[76] = 0xFF;//SVIT_check_I_critical( svit[POWER_BOARD].name );
    2240:	ef 81       	ldd	r30, Y+7	; 0x07
    2242:	f8 85       	ldd	r31, Y+8	; 0x08
    2244:	e4 5b       	subi	r30, 0xB4	; 180
    2246:	ff 4f       	sbci	r31, 0xFF	; 255
    2248:	8f ef       	ldi	r24, 0xFF	; 255
    224a:	80 83       	st	Z, r24
  //uint8_t current_error1;
  //uint8_t current_error2;
  //uint8_t current_error3;
  //uint8_t current_error4;

  packet_payload[77] = batt1_voltage;//V_ack_change();
    224c:	ef 81       	ldd	r30, Y+7	; 0x07
    224e:	f8 85       	ldd	r31, Y+8	; 0x08
    2250:	e3 5b       	subi	r30, 0xB3	; 179
    2252:	ff 4f       	sbci	r31, 0xFF	; 255
    2254:	90 91 b0 0c 	lds	r25, 0x0CB0
    2258:	90 83       	st	Z, r25
  packet_payload[78] = soc;//soc;// I_ack_change();
    225a:	ef 81       	ldd	r30, Y+7	; 0x07
    225c:	f8 85       	ldd	r31, Y+8	; 0x08
    225e:	e2 5b       	subi	r30, 0xB2	; 178
    2260:	ff 4f       	sbci	r31, 0xFF	; 255
    2262:	90 91 f2 12 	lds	r25, 0x12F2
    2266:	90 83       	st	Z, r25
  packet_payload[79] = 0x00;//low >> 6;//safe_mode;
    2268:	ef 81       	ldd	r30, Y+7	; 0x07
    226a:	f8 85       	ldd	r31, Y+8	; 0x08
    226c:	e1 5b       	subi	r30, 0xB1	; 177
    226e:	ff 4f       	sbci	r31, 0xFF	; 255
    2270:	10 82       	st	Z, r1
  packet_payload[80] = 0x00;//charging;
    2272:	ef 81       	ldd	r30, Y+7	; 0x07
    2274:	f8 85       	ldd	r31, Y+8	; 0x08
    2276:	e0 5b       	subi	r30, 0xB0	; 176
    2278:	ff 4f       	sbci	r31, 0xFF	; 255
    227a:	10 82       	st	Z, r1
  packet_payload[81] = 0x00;//chargeforward;
    227c:	ef 81       	ldd	r30, Y+7	; 0x07
    227e:	f8 85       	ldd	r31, Y+8	; 0x08
    2280:	ef 5a       	subi	r30, 0xAF	; 175
    2282:	ff 4f       	sbci	r31, 0xFF	; 255
    2284:	10 82       	st	Z, r1

  // temperature values (raw ADC output)
  packet_payload[82] = debug;//average_samples( svit[STAR_TRACKER].T_samples );
    2286:	ef 81       	ldd	r30, Y+7	; 0x07
    2288:	f8 85       	ldd	r31, Y+8	; 0x08
    228a:	ee 5a       	subi	r30, 0xAE	; 174
    228c:	ff 4f       	sbci	r31, 0xFF	; 255
    228e:	90 91 77 0a 	lds	r25, 0x0A77
    2292:	90 83       	st	Z, r25
  packet_payload[83] = 0xFF;//average_samples( svit[BATTERY_1].T_samples );
    2294:	ef 81       	ldd	r30, Y+7	; 0x07
    2296:	f8 85       	ldd	r31, Y+8	; 0x08
    2298:	ed 5a       	subi	r30, 0xAD	; 173
    229a:	ff 4f       	sbci	r31, 0xFF	; 255
    229c:	80 83       	st	Z, r24
  packet_payload[84] = average_samples( svit[BATTERY_2].T_samples );
    229e:	83 e8       	ldi	r24, 0x83	; 131
    22a0:	97 e0       	ldi	r25, 0x07	; 7
    22a2:	0e 94 8e 09 	call	0x131c	; 0x131c <average_samples>
    22a6:	ef 81       	ldd	r30, Y+7	; 0x07
    22a8:	f8 85       	ldd	r31, Y+8	; 0x08
    22aa:	ec 5a       	subi	r30, 0xAC	; 172
    22ac:	ff 4f       	sbci	r31, 0xFF	; 255
    22ae:	80 83       	st	Z, r24
  packet_payload[85] = average_samples( svit[SOLAR_1].T_samples );
    22b0:	89 ee       	ldi	r24, 0xE9	; 233
    22b2:	97 e0       	ldi	r25, 0x07	; 7
    22b4:	0e 94 8e 09 	call	0x131c	; 0x131c <average_samples>
    22b8:	ef 81       	ldd	r30, Y+7	; 0x07
    22ba:	f8 85       	ldd	r31, Y+8	; 0x08
    22bc:	eb 5a       	subi	r30, 0xAB	; 171
    22be:	ff 4f       	sbci	r31, 0xFF	; 255
    22c0:	80 83       	st	Z, r24
  packet_payload[86] = average_samples( svit[SOLAR_2].T_samples );
    22c2:	8c e1       	ldi	r24, 0x1C	; 28
    22c4:	98 e0       	ldi	r25, 0x08	; 8
    22c6:	0e 94 8e 09 	call	0x131c	; 0x131c <average_samples>
    22ca:	ef 81       	ldd	r30, Y+7	; 0x07
    22cc:	f8 85       	ldd	r31, Y+8	; 0x08
    22ce:	ea 5a       	subi	r30, 0xAA	; 170
    22d0:	ff 4f       	sbci	r31, 0xFF	; 255
    22d2:	80 83       	st	Z, r24
  packet_payload[87] = average_samples( svit[SOLAR_3].T_samples );
    22d4:	8f e4       	ldi	r24, 0x4F	; 79
    22d6:	98 e0       	ldi	r25, 0x08	; 8
    22d8:	0e 94 8e 09 	call	0x131c	; 0x131c <average_samples>
    22dc:	ef 81       	ldd	r30, Y+7	; 0x07
    22de:	f8 85       	ldd	r31, Y+8	; 0x08
    22e0:	e9 5a       	subi	r30, 0xA9	; 169
    22e2:	ff 4f       	sbci	r31, 0xFF	; 255
    22e4:	80 83       	st	Z, r24
  packet_payload[88] = average_samples( svit[SOLAR_4].T_samples );
    22e6:	82 e8       	ldi	r24, 0x82	; 130
    22e8:	98 e0       	ldi	r25, 0x08	; 8
    22ea:	0e 94 8e 09 	call	0x131c	; 0x131c <average_samples>
    22ee:	ef 81       	ldd	r30, Y+7	; 0x07
    22f0:	f8 85       	ldd	r31, Y+8	; 0x08
    22f2:	e8 5a       	subi	r30, 0xA8	; 168
    22f4:	ff 4f       	sbci	r31, 0xFF	; 255
    22f6:	80 83       	st	Z, r24
  packet_payload[89] = average_samples( svit[SOLAR_5].T_samples );
    22f8:	85 eb       	ldi	r24, 0xB5	; 181
    22fa:	98 e0       	ldi	r25, 0x08	; 8
    22fc:	0e 94 8e 09 	call	0x131c	; 0x131c <average_samples>
    2300:	ef 81       	ldd	r30, Y+7	; 0x07
    2302:	f8 85       	ldd	r31, Y+8	; 0x08
    2304:	e7 5a       	subi	r30, 0xA7	; 167
    2306:	ff 4f       	sbci	r31, 0xFF	; 255
    2308:	80 83       	st	Z, r24
  packet_payload[90] = average_samples( svit[SOLAR_9].T_samples );
    230a:	81 e8       	ldi	r24, 0x81	; 129
    230c:	99 e0       	ldi	r25, 0x09	; 9
    230e:	0e 94 8e 09 	call	0x131c	; 0x131c <average_samples>
    2312:	ef 81       	ldd	r30, Y+7	; 0x07
    2314:	f8 85       	ldd	r31, Y+8	; 0x08
    2316:	e6 5a       	subi	r30, 0xA6	; 166
    2318:	ff 4f       	sbci	r31, 0xFF	; 255
    231a:	80 83       	st	Z, r24
  packet_payload[91] = average_samples( svit[POWER_BOARD].T_samples );
    231c:	8d e4       	ldi	r24, 0x4D	; 77
    231e:	9a e0       	ldi	r25, 0x0A	; 10
    2320:	0e 94 8e 09 	call	0x131c	; 0x131c <average_samples>
    2324:	ef 81       	ldd	r30, Y+7	; 0x07
    2326:	f8 85       	ldd	r31, Y+8	; 0x08
    2328:	e5 5a       	subi	r30, 0xA5	; 165
    232a:	ff 4f       	sbci	r31, 0xFF	; 255
    232c:	80 83       	st	Z, r24

uint8_t V_ack_change( void )
{
  uint8_t temp;

  temp = V_upper_val_change;
    232e:	80 91 c0 0e 	lds	r24, 0x0EC0
  V_upper_val_change = 0;
    2332:	10 92 c0 0e 	sts	0x0EC0, r1
  //uint8_t temperature_error1;
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
    2336:	ef 81       	ldd	r30, Y+7	; 0x07
    2338:	f8 85       	ldd	r31, Y+8	; 0x08
    233a:	e4 5a       	subi	r30, 0xA4	; 164
    233c:	ff 4f       	sbci	r31, 0xFF	; 255
    233e:	80 83       	st	Z, r24

uint8_t I_ack_change( void )
{
  uint8_t temp;

  temp = I_upper_val_change;
    2340:	80 91 bb 0e 	lds	r24, 0x0EBB
  I_upper_val_change = 0;
    2344:	10 92 bb 0e 	sts	0x0EBB, r1
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
  packet_payload[93] = I_ack_change();
    2348:	ef 81       	ldd	r30, Y+7	; 0x07
    234a:	f8 85       	ldd	r31, Y+8	; 0x08
    234c:	e3 5a       	subi	r30, 0xA3	; 163
    234e:	ff 4f       	sbci	r31, 0xFF	; 255
    2350:	80 83       	st	Z, r24
}
    2352:	28 96       	adiw	r28, 0x08	; 8
    2354:	0f b6       	in	r0, 0x3f	; 63
    2356:	f8 94       	cli
    2358:	de bf       	out	0x3e, r29	; 62
    235a:	0f be       	out	0x3f, r0	; 63
    235c:	cd bf       	out	0x3d, r28	; 61
    235e:	df 91       	pop	r29
    2360:	cf 91       	pop	r28
    2362:	1f 91       	pop	r17
    2364:	0f 91       	pop	r16
    2366:	ff 90       	pop	r15
    2368:	ef 90       	pop	r14
    236a:	df 90       	pop	r13
    236c:	cf 90       	pop	r12
    236e:	bf 90       	pop	r11
    2370:	af 90       	pop	r10
    2372:	9f 90       	pop	r9
    2374:	8f 90       	pop	r8
    2376:	7f 90       	pop	r7
    2378:	6f 90       	pop	r6
    237a:	5f 90       	pop	r5
    237c:	4f 90       	pop	r4
    237e:	3f 90       	pop	r3
    2380:	2f 90       	pop	r2
    2382:	08 95       	ret

00002384 <transmit_packet>:

void transmit_packet( uint8_t uart, uint8_t packet_type, uint8_t ack_command )
{
    2384:	6f 92       	push	r6
    2386:	7f 92       	push	r7
    2388:	8f 92       	push	r8
    238a:	9f 92       	push	r9
    238c:	bf 92       	push	r11
    238e:	cf 92       	push	r12
    2390:	df 92       	push	r13
    2392:	ef 92       	push	r14
    2394:	ff 92       	push	r15
    2396:	0f 93       	push	r16
    2398:	1f 93       	push	r17
    239a:	cf 93       	push	r28
    239c:	df 93       	push	r29
    239e:	b8 2e       	mov	r11, r24
  uint8_t VCP_tx_status;

  switch( packet_type )
    23a0:	61 30       	cpi	r22, 0x01	; 1
    23a2:	b9 f0       	breq	.+46     	; 0x23d2 <transmit_packet+0x4e>
    23a4:	20 f0       	brcs	.+8      	; 0x23ae <transmit_packet+0x2a>
    23a6:	62 30       	cpi	r22, 0x02	; 2
    23a8:	09 f0       	breq	.+2      	; 0x23ac <transmit_packet+0x28>
    23aa:	8b c0       	rjmp	.+278    	; 0x24c2 <transmit_packet+0x13e>
    23ac:	22 c0       	rjmp	.+68     	; 0x23f2 <transmit_packet+0x6e>
  {
    case VCP_POWER_TELEMETRY:
      construct_telemetry_packet( tel_packet_payload[uart] );
    23ae:	c8 2f       	mov	r28, r24
    23b0:	d0 e0       	ldi	r29, 0x00	; 0
    23b2:	2f ef       	ldi	r18, 0xFF	; 255
    23b4:	82 9f       	mul	r24, r18
    23b6:	c0 01       	movw	r24, r0
    23b8:	11 24       	eor	r1, r1
    23ba:	8c 50       	subi	r24, 0x0C	; 12
    23bc:	9f 4e       	sbci	r25, 0xEF	; 239
    23be:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <construct_telemetry_packet>
      tel_packet_payload_size[uart] = 96;
    23c2:	fe 01       	movw	r30, r28
    23c4:	ee 0f       	add	r30, r30
    23c6:	ff 1f       	adc	r31, r31
    23c8:	e7 58       	subi	r30, 0x87	; 135
    23ca:	f5 4f       	sbci	r31, 0xF5	; 245
    23cc:	80 e6       	ldi	r24, 0x60	; 96
    23ce:	90 e0       	ldi	r25, 0x00	; 0
    23d0:	21 c0       	rjmp	.+66     	; 0x2414 <transmit_packet+0x90>
      break;
    case VCP_INVALID_COMMAND:
      tel_packet_payload[uart][0] = VCP_INVALID_COMMAND;
    23d2:	e8 2f       	mov	r30, r24
    23d4:	f0 e0       	ldi	r31, 0x00	; 0
    23d6:	8f ef       	ldi	r24, 0xFF	; 255
    23d8:	b8 9e       	mul	r11, r24
    23da:	d0 01       	movw	r26, r0
    23dc:	11 24       	eor	r1, r1
    23de:	ac 50       	subi	r26, 0x0C	; 12
    23e0:	bf 4e       	sbci	r27, 0xEF	; 239
    23e2:	6c 93       	st	X, r22
      tel_packet_payload_size[uart] = 1;
    23e4:	ee 0f       	add	r30, r30
    23e6:	ff 1f       	adc	r31, r31
    23e8:	e7 58       	subi	r30, 0x87	; 135
    23ea:	f5 4f       	sbci	r31, 0xF5	; 245
    23ec:	81 e0       	ldi	r24, 0x01	; 1
    23ee:	90 e0       	ldi	r25, 0x00	; 0
    23f0:	11 c0       	rjmp	.+34     	; 0x2414 <transmit_packet+0x90>
      break;
    case VCP_ACK:
      tel_packet_payload[uart][0] = VCP_ACK;
    23f2:	e8 2f       	mov	r30, r24
    23f4:	f0 e0       	ldi	r31, 0x00	; 0
    23f6:	2f ef       	ldi	r18, 0xFF	; 255
    23f8:	82 9f       	mul	r24, r18
    23fa:	d0 01       	movw	r26, r0
    23fc:	11 24       	eor	r1, r1
    23fe:	ac 50       	subi	r26, 0x0C	; 12
    2400:	bf 4e       	sbci	r27, 0xEF	; 239
    2402:	6c 93       	st	X, r22
      tel_packet_payload[uart][1] = ack_command;
    2404:	11 96       	adiw	r26, 0x01	; 1
    2406:	4c 93       	st	X, r20
      tel_packet_payload_size[uart] = 2;
    2408:	ee 0f       	add	r30, r30
    240a:	ff 1f       	adc	r31, r31
    240c:	e7 58       	subi	r30, 0x87	; 135
    240e:	f5 4f       	sbci	r31, 0xF5	; 245
    2410:	82 e0       	ldi	r24, 0x02	; 2
    2412:	90 e0       	ldi	r25, 0x00	; 0
    2414:	91 83       	std	Z+1, r25	; 0x01
    2416:	80 83       	st	Z, r24
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2418:	8b 2c       	mov	r8, r11
    241a:	91 2c       	mov	r9, r1
    241c:	8f ef       	ldi	r24, 0xFF	; 255
    241e:	b8 9e       	mul	r11, r24
    2420:	70 01       	movw	r14, r0
    2422:	11 24       	eor	r1, r1
    2424:	e7 01       	movw	r28, r14
    2426:	c5 54       	subi	r28, 0x45	; 69
    2428:	d3 4f       	sbci	r29, 0xF3	; 243
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
    242a:	64 01       	movw	r12, r8
    242c:	cc 0c       	add	r12, r12
    242e:	dd 1c       	adc	r13, r13
    2430:	f6 01       	movw	r30, r12
    2432:	e7 58       	subi	r30, 0x87	; 135
    2434:	f5 4f       	sbci	r31, 0xF5	; 245
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2436:	00 81       	ld	r16, Z
    2438:	11 81       	ldd	r17, Z+1	; 0x01
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
    243a:	97 01       	movw	r18, r14
    243c:	2c 50       	subi	r18, 0x0C	; 12
    243e:	3f 4e       	sbci	r19, 0xEF	; 239
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2440:	a5 ec       	ldi	r26, 0xC5	; 197
    2442:	6a 2e       	mov	r6, r26
    2444:	a0 e1       	ldi	r26, 0x10	; 16
    2446:	7a 2e       	mov	r7, r26
    2448:	6c 0c       	add	r6, r12
    244a:	7d 1c       	adc	r7, r13
    244c:	41 e0       	ldi	r20, 0x01	; 1
    244e:	b3 01       	movw	r22, r6
    2450:	ce 01       	movw	r24, r28
    2452:	0e 94 39 0b 	call	0x1672	; 0x1672 <Create_VCP_frame>
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
                  );

  // VCP frame creation was successful
  if ( VCP_tx_status == VCP_TERM )
    2456:	81 30       	cpi	r24, 0x01	; 1
    2458:	a1 f5       	brne	.+104    	; 0x24c2 <transmit_packet+0x13e>
  {
    tel_packet_size[uart] = dest_size[uart];
    245a:	f3 01       	movw	r30, r6
    245c:	80 81       	ld	r24, Z
    245e:	91 81       	ldd	r25, Z+1	; 0x01
    2460:	f6 01       	movw	r30, r12
    2462:	e7 5d       	subi	r30, 0xD7	; 215
    2464:	fc 4f       	sbci	r31, 0xFC	; 252
    2466:	91 83       	std	Z+1, r25	; 0x01
    2468:	80 83       	st	Z, r24
    memcpy( tel_packet[uart], dest_data[uart], tel_packet_size[uart] );
    246a:	80 81       	ld	r24, Z
    246c:	91 81       	ldd	r25, Z+1	; 0x01
    246e:	97 01       	movw	r18, r14
    2470:	27 57       	subi	r18, 0x77	; 119
    2472:	35 4f       	sbci	r19, 0xF5	; 245
    2474:	ac 01       	movw	r20, r24
    2476:	be 01       	movw	r22, r28
    2478:	c9 01       	movw	r24, r18
    247a:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <memcpy>
    tel_packet_index[uart] = 0;
    247e:	f4 01       	movw	r30, r8
    2480:	ef 57       	subi	r30, 0x7F	; 127
    2482:	f5 4f       	sbci	r31, 0xF5	; 245
    2484:	10 82       	st	Z, r1
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
    2486:	f1 e0       	ldi	r31, 0x01	; 1
    2488:	bf 12       	cpse	r11, r31
    248a:	06 c0       	rjmp	.+12     	; 0x2498 <transmit_packet+0x114>
    248c:	80 91 9b 00 	lds	r24, 0x009B
    2490:	88 23       	and	r24, r24
    2492:	b9 f0       	breq	.+46     	; 0x24c2 <transmit_packet+0x13e>
      tx_put_byte( uart );
    2494:	81 e0       	ldi	r24, 0x01	; 1
    2496:	06 c0       	rjmp	.+12     	; 0x24a4 <transmit_packet+0x120>
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
    2498:	b1 10       	cpse	r11, r1
    249a:	13 c0       	rjmp	.+38     	; 0x24c2 <transmit_packet+0x13e>
    249c:	8b b1       	in	r24, 0x0b	; 11
    249e:	88 23       	and	r24, r24
    24a0:	81 f0       	breq	.+32     	; 0x24c2 <transmit_packet+0x13e>
      tx_put_byte( uart );
    24a2:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    24a4:	df 91       	pop	r29
    24a6:	cf 91       	pop	r28
    24a8:	1f 91       	pop	r17
    24aa:	0f 91       	pop	r16
    24ac:	ff 90       	pop	r15
    24ae:	ef 90       	pop	r14
    24b0:	df 90       	pop	r13
    24b2:	cf 90       	pop	r12
    24b4:	bf 90       	pop	r11
    24b6:	9f 90       	pop	r9
    24b8:	8f 90       	pop	r8
    24ba:	7f 90       	pop	r7
    24bc:	6f 90       	pop	r6
    tel_packet_index[uart] = 0;
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    24be:	0c 94 26 0e 	jmp	0x1c4c	; 0x1c4c <tx_put_byte>
  }
}
    24c2:	df 91       	pop	r29
    24c4:	cf 91       	pop	r28
    24c6:	1f 91       	pop	r17
    24c8:	0f 91       	pop	r16
    24ca:	ff 90       	pop	r15
    24cc:	ef 90       	pop	r14
    24ce:	df 90       	pop	r13
    24d0:	cf 90       	pop	r12
    24d2:	bf 90       	pop	r11
    24d4:	9f 90       	pop	r9
    24d6:	8f 90       	pop	r8
    24d8:	7f 90       	pop	r7
    24da:	6f 90       	pop	r6
    24dc:	08 95       	ret

000024de <__subsf3>:
    24de:	50 58       	subi	r21, 0x80	; 128

000024e0 <__addsf3>:
    24e0:	bb 27       	eor	r27, r27
    24e2:	aa 27       	eor	r26, r26
    24e4:	0e d0       	rcall	.+28     	; 0x2502 <__addsf3x>
    24e6:	44 c1       	rjmp	.+648    	; 0x2770 <__fp_round>
    24e8:	35 d1       	rcall	.+618    	; 0x2754 <__fp_pscA>
    24ea:	30 f0       	brcs	.+12     	; 0x24f8 <__addsf3+0x18>
    24ec:	3a d1       	rcall	.+628    	; 0x2762 <__fp_pscB>
    24ee:	20 f0       	brcs	.+8      	; 0x24f8 <__addsf3+0x18>
    24f0:	31 f4       	brne	.+12     	; 0x24fe <__addsf3+0x1e>
    24f2:	9f 3f       	cpi	r25, 0xFF	; 255
    24f4:	11 f4       	brne	.+4      	; 0x24fa <__addsf3+0x1a>
    24f6:	1e f4       	brtc	.+6      	; 0x24fe <__addsf3+0x1e>
    24f8:	2a c1       	rjmp	.+596    	; 0x274e <__fp_nan>
    24fa:	0e f4       	brtc	.+2      	; 0x24fe <__addsf3+0x1e>
    24fc:	e0 95       	com	r30
    24fe:	e7 fb       	bst	r30, 7
    2500:	20 c1       	rjmp	.+576    	; 0x2742 <__fp_inf>

00002502 <__addsf3x>:
    2502:	e9 2f       	mov	r30, r25
    2504:	46 d1       	rcall	.+652    	; 0x2792 <__fp_split3>
    2506:	80 f3       	brcs	.-32     	; 0x24e8 <__addsf3+0x8>
    2508:	ba 17       	cp	r27, r26
    250a:	62 07       	cpc	r22, r18
    250c:	73 07       	cpc	r23, r19
    250e:	84 07       	cpc	r24, r20
    2510:	95 07       	cpc	r25, r21
    2512:	18 f0       	brcs	.+6      	; 0x251a <__addsf3x+0x18>
    2514:	71 f4       	brne	.+28     	; 0x2532 <__addsf3x+0x30>
    2516:	9e f5       	brtc	.+102    	; 0x257e <__addsf3x+0x7c>
    2518:	5e c1       	rjmp	.+700    	; 0x27d6 <__fp_zero>
    251a:	0e f4       	brtc	.+2      	; 0x251e <__addsf3x+0x1c>
    251c:	e0 95       	com	r30
    251e:	0b 2e       	mov	r0, r27
    2520:	ba 2f       	mov	r27, r26
    2522:	a0 2d       	mov	r26, r0
    2524:	0b 01       	movw	r0, r22
    2526:	b9 01       	movw	r22, r18
    2528:	90 01       	movw	r18, r0
    252a:	0c 01       	movw	r0, r24
    252c:	ca 01       	movw	r24, r20
    252e:	a0 01       	movw	r20, r0
    2530:	11 24       	eor	r1, r1
    2532:	ff 27       	eor	r31, r31
    2534:	59 1b       	sub	r21, r25
    2536:	99 f0       	breq	.+38     	; 0x255e <__addsf3x+0x5c>
    2538:	59 3f       	cpi	r21, 0xF9	; 249
    253a:	50 f4       	brcc	.+20     	; 0x2550 <__addsf3x+0x4e>
    253c:	50 3e       	cpi	r21, 0xE0	; 224
    253e:	68 f1       	brcs	.+90     	; 0x259a <__addsf3x+0x98>
    2540:	1a 16       	cp	r1, r26
    2542:	f0 40       	sbci	r31, 0x00	; 0
    2544:	a2 2f       	mov	r26, r18
    2546:	23 2f       	mov	r18, r19
    2548:	34 2f       	mov	r19, r20
    254a:	44 27       	eor	r20, r20
    254c:	58 5f       	subi	r21, 0xF8	; 248
    254e:	f3 cf       	rjmp	.-26     	; 0x2536 <__addsf3x+0x34>
    2550:	46 95       	lsr	r20
    2552:	37 95       	ror	r19
    2554:	27 95       	ror	r18
    2556:	a7 95       	ror	r26
    2558:	f0 40       	sbci	r31, 0x00	; 0
    255a:	53 95       	inc	r21
    255c:	c9 f7       	brne	.-14     	; 0x2550 <__addsf3x+0x4e>
    255e:	7e f4       	brtc	.+30     	; 0x257e <__addsf3x+0x7c>
    2560:	1f 16       	cp	r1, r31
    2562:	ba 0b       	sbc	r27, r26
    2564:	62 0b       	sbc	r22, r18
    2566:	73 0b       	sbc	r23, r19
    2568:	84 0b       	sbc	r24, r20
    256a:	ba f0       	brmi	.+46     	; 0x259a <__addsf3x+0x98>
    256c:	91 50       	subi	r25, 0x01	; 1
    256e:	a1 f0       	breq	.+40     	; 0x2598 <__addsf3x+0x96>
    2570:	ff 0f       	add	r31, r31
    2572:	bb 1f       	adc	r27, r27
    2574:	66 1f       	adc	r22, r22
    2576:	77 1f       	adc	r23, r23
    2578:	88 1f       	adc	r24, r24
    257a:	c2 f7       	brpl	.-16     	; 0x256c <__addsf3x+0x6a>
    257c:	0e c0       	rjmp	.+28     	; 0x259a <__addsf3x+0x98>
    257e:	ba 0f       	add	r27, r26
    2580:	62 1f       	adc	r22, r18
    2582:	73 1f       	adc	r23, r19
    2584:	84 1f       	adc	r24, r20
    2586:	48 f4       	brcc	.+18     	; 0x259a <__addsf3x+0x98>
    2588:	87 95       	ror	r24
    258a:	77 95       	ror	r23
    258c:	67 95       	ror	r22
    258e:	b7 95       	ror	r27
    2590:	f7 95       	ror	r31
    2592:	9e 3f       	cpi	r25, 0xFE	; 254
    2594:	08 f0       	brcs	.+2      	; 0x2598 <__addsf3x+0x96>
    2596:	b3 cf       	rjmp	.-154    	; 0x24fe <__addsf3+0x1e>
    2598:	93 95       	inc	r25
    259a:	88 0f       	add	r24, r24
    259c:	08 f0       	brcs	.+2      	; 0x25a0 <__addsf3x+0x9e>
    259e:	99 27       	eor	r25, r25
    25a0:	ee 0f       	add	r30, r30
    25a2:	97 95       	ror	r25
    25a4:	87 95       	ror	r24
    25a6:	08 95       	ret

000025a8 <__cmpsf2>:
    25a8:	a8 d0       	rcall	.+336    	; 0x26fa <__fp_cmp>
    25aa:	08 f4       	brcc	.+2      	; 0x25ae <__cmpsf2+0x6>
    25ac:	81 e0       	ldi	r24, 0x01	; 1
    25ae:	08 95       	ret

000025b0 <__divsf3>:
    25b0:	0c d0       	rcall	.+24     	; 0x25ca <__divsf3x>
    25b2:	de c0       	rjmp	.+444    	; 0x2770 <__fp_round>
    25b4:	d6 d0       	rcall	.+428    	; 0x2762 <__fp_pscB>
    25b6:	40 f0       	brcs	.+16     	; 0x25c8 <__divsf3+0x18>
    25b8:	cd d0       	rcall	.+410    	; 0x2754 <__fp_pscA>
    25ba:	30 f0       	brcs	.+12     	; 0x25c8 <__divsf3+0x18>
    25bc:	21 f4       	brne	.+8      	; 0x25c6 <__divsf3+0x16>
    25be:	5f 3f       	cpi	r21, 0xFF	; 255
    25c0:	19 f0       	breq	.+6      	; 0x25c8 <__divsf3+0x18>
    25c2:	bf c0       	rjmp	.+382    	; 0x2742 <__fp_inf>
    25c4:	51 11       	cpse	r21, r1
    25c6:	08 c1       	rjmp	.+528    	; 0x27d8 <__fp_szero>
    25c8:	c2 c0       	rjmp	.+388    	; 0x274e <__fp_nan>

000025ca <__divsf3x>:
    25ca:	e3 d0       	rcall	.+454    	; 0x2792 <__fp_split3>
    25cc:	98 f3       	brcs	.-26     	; 0x25b4 <__divsf3+0x4>

000025ce <__divsf3_pse>:
    25ce:	99 23       	and	r25, r25
    25d0:	c9 f3       	breq	.-14     	; 0x25c4 <__divsf3+0x14>
    25d2:	55 23       	and	r21, r21
    25d4:	b1 f3       	breq	.-20     	; 0x25c2 <__divsf3+0x12>
    25d6:	95 1b       	sub	r25, r21
    25d8:	55 0b       	sbc	r21, r21
    25da:	bb 27       	eor	r27, r27
    25dc:	aa 27       	eor	r26, r26
    25de:	62 17       	cp	r22, r18
    25e0:	73 07       	cpc	r23, r19
    25e2:	84 07       	cpc	r24, r20
    25e4:	38 f0       	brcs	.+14     	; 0x25f4 <__divsf3_pse+0x26>
    25e6:	9f 5f       	subi	r25, 0xFF	; 255
    25e8:	5f 4f       	sbci	r21, 0xFF	; 255
    25ea:	22 0f       	add	r18, r18
    25ec:	33 1f       	adc	r19, r19
    25ee:	44 1f       	adc	r20, r20
    25f0:	aa 1f       	adc	r26, r26
    25f2:	a9 f3       	breq	.-22     	; 0x25de <__divsf3_pse+0x10>
    25f4:	33 d0       	rcall	.+102    	; 0x265c <__divsf3_pse+0x8e>
    25f6:	0e 2e       	mov	r0, r30
    25f8:	3a f0       	brmi	.+14     	; 0x2608 <__divsf3_pse+0x3a>
    25fa:	e0 e8       	ldi	r30, 0x80	; 128
    25fc:	30 d0       	rcall	.+96     	; 0x265e <__divsf3_pse+0x90>
    25fe:	91 50       	subi	r25, 0x01	; 1
    2600:	50 40       	sbci	r21, 0x00	; 0
    2602:	e6 95       	lsr	r30
    2604:	00 1c       	adc	r0, r0
    2606:	ca f7       	brpl	.-14     	; 0x25fa <__divsf3_pse+0x2c>
    2608:	29 d0       	rcall	.+82     	; 0x265c <__divsf3_pse+0x8e>
    260a:	fe 2f       	mov	r31, r30
    260c:	27 d0       	rcall	.+78     	; 0x265c <__divsf3_pse+0x8e>
    260e:	66 0f       	add	r22, r22
    2610:	77 1f       	adc	r23, r23
    2612:	88 1f       	adc	r24, r24
    2614:	bb 1f       	adc	r27, r27
    2616:	26 17       	cp	r18, r22
    2618:	37 07       	cpc	r19, r23
    261a:	48 07       	cpc	r20, r24
    261c:	ab 07       	cpc	r26, r27
    261e:	b0 e8       	ldi	r27, 0x80	; 128
    2620:	09 f0       	breq	.+2      	; 0x2624 <__divsf3_pse+0x56>
    2622:	bb 0b       	sbc	r27, r27
    2624:	80 2d       	mov	r24, r0
    2626:	bf 01       	movw	r22, r30
    2628:	ff 27       	eor	r31, r31
    262a:	93 58       	subi	r25, 0x83	; 131
    262c:	5f 4f       	sbci	r21, 0xFF	; 255
    262e:	2a f0       	brmi	.+10     	; 0x263a <__divsf3_pse+0x6c>
    2630:	9e 3f       	cpi	r25, 0xFE	; 254
    2632:	51 05       	cpc	r21, r1
    2634:	68 f0       	brcs	.+26     	; 0x2650 <__divsf3_pse+0x82>
    2636:	85 c0       	rjmp	.+266    	; 0x2742 <__fp_inf>
    2638:	cf c0       	rjmp	.+414    	; 0x27d8 <__fp_szero>
    263a:	5f 3f       	cpi	r21, 0xFF	; 255
    263c:	ec f3       	brlt	.-6      	; 0x2638 <__divsf3_pse+0x6a>
    263e:	98 3e       	cpi	r25, 0xE8	; 232
    2640:	dc f3       	brlt	.-10     	; 0x2638 <__divsf3_pse+0x6a>
    2642:	86 95       	lsr	r24
    2644:	77 95       	ror	r23
    2646:	67 95       	ror	r22
    2648:	b7 95       	ror	r27
    264a:	f7 95       	ror	r31
    264c:	9f 5f       	subi	r25, 0xFF	; 255
    264e:	c9 f7       	brne	.-14     	; 0x2642 <__divsf3_pse+0x74>
    2650:	88 0f       	add	r24, r24
    2652:	91 1d       	adc	r25, r1
    2654:	96 95       	lsr	r25
    2656:	87 95       	ror	r24
    2658:	97 f9       	bld	r25, 7
    265a:	08 95       	ret
    265c:	e1 e0       	ldi	r30, 0x01	; 1
    265e:	66 0f       	add	r22, r22
    2660:	77 1f       	adc	r23, r23
    2662:	88 1f       	adc	r24, r24
    2664:	bb 1f       	adc	r27, r27
    2666:	62 17       	cp	r22, r18
    2668:	73 07       	cpc	r23, r19
    266a:	84 07       	cpc	r24, r20
    266c:	ba 07       	cpc	r27, r26
    266e:	20 f0       	brcs	.+8      	; 0x2678 <__divsf3_pse+0xaa>
    2670:	62 1b       	sub	r22, r18
    2672:	73 0b       	sbc	r23, r19
    2674:	84 0b       	sbc	r24, r20
    2676:	ba 0b       	sbc	r27, r26
    2678:	ee 1f       	adc	r30, r30
    267a:	88 f7       	brcc	.-30     	; 0x265e <__divsf3_pse+0x90>
    267c:	e0 95       	com	r30
    267e:	08 95       	ret

00002680 <__floatunsisf>:
    2680:	e8 94       	clt
    2682:	09 c0       	rjmp	.+18     	; 0x2696 <__floatsisf+0x12>

00002684 <__floatsisf>:
    2684:	97 fb       	bst	r25, 7
    2686:	3e f4       	brtc	.+14     	; 0x2696 <__floatsisf+0x12>
    2688:	90 95       	com	r25
    268a:	80 95       	com	r24
    268c:	70 95       	com	r23
    268e:	61 95       	neg	r22
    2690:	7f 4f       	sbci	r23, 0xFF	; 255
    2692:	8f 4f       	sbci	r24, 0xFF	; 255
    2694:	9f 4f       	sbci	r25, 0xFF	; 255
    2696:	99 23       	and	r25, r25
    2698:	a9 f0       	breq	.+42     	; 0x26c4 <__floatsisf+0x40>
    269a:	f9 2f       	mov	r31, r25
    269c:	96 e9       	ldi	r25, 0x96	; 150
    269e:	bb 27       	eor	r27, r27
    26a0:	93 95       	inc	r25
    26a2:	f6 95       	lsr	r31
    26a4:	87 95       	ror	r24
    26a6:	77 95       	ror	r23
    26a8:	67 95       	ror	r22
    26aa:	b7 95       	ror	r27
    26ac:	f1 11       	cpse	r31, r1
    26ae:	f8 cf       	rjmp	.-16     	; 0x26a0 <__floatsisf+0x1c>
    26b0:	fa f4       	brpl	.+62     	; 0x26f0 <__floatsisf+0x6c>
    26b2:	bb 0f       	add	r27, r27
    26b4:	11 f4       	brne	.+4      	; 0x26ba <__floatsisf+0x36>
    26b6:	60 ff       	sbrs	r22, 0
    26b8:	1b c0       	rjmp	.+54     	; 0x26f0 <__floatsisf+0x6c>
    26ba:	6f 5f       	subi	r22, 0xFF	; 255
    26bc:	7f 4f       	sbci	r23, 0xFF	; 255
    26be:	8f 4f       	sbci	r24, 0xFF	; 255
    26c0:	9f 4f       	sbci	r25, 0xFF	; 255
    26c2:	16 c0       	rjmp	.+44     	; 0x26f0 <__floatsisf+0x6c>
    26c4:	88 23       	and	r24, r24
    26c6:	11 f0       	breq	.+4      	; 0x26cc <__floatsisf+0x48>
    26c8:	96 e9       	ldi	r25, 0x96	; 150
    26ca:	11 c0       	rjmp	.+34     	; 0x26ee <__floatsisf+0x6a>
    26cc:	77 23       	and	r23, r23
    26ce:	21 f0       	breq	.+8      	; 0x26d8 <__floatsisf+0x54>
    26d0:	9e e8       	ldi	r25, 0x8E	; 142
    26d2:	87 2f       	mov	r24, r23
    26d4:	76 2f       	mov	r23, r22
    26d6:	05 c0       	rjmp	.+10     	; 0x26e2 <__floatsisf+0x5e>
    26d8:	66 23       	and	r22, r22
    26da:	71 f0       	breq	.+28     	; 0x26f8 <__floatsisf+0x74>
    26dc:	96 e8       	ldi	r25, 0x86	; 134
    26de:	86 2f       	mov	r24, r22
    26e0:	70 e0       	ldi	r23, 0x00	; 0
    26e2:	60 e0       	ldi	r22, 0x00	; 0
    26e4:	2a f0       	brmi	.+10     	; 0x26f0 <__floatsisf+0x6c>
    26e6:	9a 95       	dec	r25
    26e8:	66 0f       	add	r22, r22
    26ea:	77 1f       	adc	r23, r23
    26ec:	88 1f       	adc	r24, r24
    26ee:	da f7       	brpl	.-10     	; 0x26e6 <__floatsisf+0x62>
    26f0:	88 0f       	add	r24, r24
    26f2:	96 95       	lsr	r25
    26f4:	87 95       	ror	r24
    26f6:	97 f9       	bld	r25, 7
    26f8:	08 95       	ret

000026fa <__fp_cmp>:
    26fa:	99 0f       	add	r25, r25
    26fc:	00 08       	sbc	r0, r0
    26fe:	55 0f       	add	r21, r21
    2700:	aa 0b       	sbc	r26, r26
    2702:	e0 e8       	ldi	r30, 0x80	; 128
    2704:	fe ef       	ldi	r31, 0xFE	; 254
    2706:	16 16       	cp	r1, r22
    2708:	17 06       	cpc	r1, r23
    270a:	e8 07       	cpc	r30, r24
    270c:	f9 07       	cpc	r31, r25
    270e:	c0 f0       	brcs	.+48     	; 0x2740 <__fp_cmp+0x46>
    2710:	12 16       	cp	r1, r18
    2712:	13 06       	cpc	r1, r19
    2714:	e4 07       	cpc	r30, r20
    2716:	f5 07       	cpc	r31, r21
    2718:	98 f0       	brcs	.+38     	; 0x2740 <__fp_cmp+0x46>
    271a:	62 1b       	sub	r22, r18
    271c:	73 0b       	sbc	r23, r19
    271e:	84 0b       	sbc	r24, r20
    2720:	95 0b       	sbc	r25, r21
    2722:	39 f4       	brne	.+14     	; 0x2732 <__fp_cmp+0x38>
    2724:	0a 26       	eor	r0, r26
    2726:	61 f0       	breq	.+24     	; 0x2740 <__fp_cmp+0x46>
    2728:	23 2b       	or	r18, r19
    272a:	24 2b       	or	r18, r20
    272c:	25 2b       	or	r18, r21
    272e:	21 f4       	brne	.+8      	; 0x2738 <__fp_cmp+0x3e>
    2730:	08 95       	ret
    2732:	0a 26       	eor	r0, r26
    2734:	09 f4       	brne	.+2      	; 0x2738 <__fp_cmp+0x3e>
    2736:	a1 40       	sbci	r26, 0x01	; 1
    2738:	a6 95       	lsr	r26
    273a:	8f ef       	ldi	r24, 0xFF	; 255
    273c:	81 1d       	adc	r24, r1
    273e:	81 1d       	adc	r24, r1
    2740:	08 95       	ret

00002742 <__fp_inf>:
    2742:	97 f9       	bld	r25, 7
    2744:	9f 67       	ori	r25, 0x7F	; 127
    2746:	80 e8       	ldi	r24, 0x80	; 128
    2748:	70 e0       	ldi	r23, 0x00	; 0
    274a:	60 e0       	ldi	r22, 0x00	; 0
    274c:	08 95       	ret

0000274e <__fp_nan>:
    274e:	9f ef       	ldi	r25, 0xFF	; 255
    2750:	80 ec       	ldi	r24, 0xC0	; 192
    2752:	08 95       	ret

00002754 <__fp_pscA>:
    2754:	00 24       	eor	r0, r0
    2756:	0a 94       	dec	r0
    2758:	16 16       	cp	r1, r22
    275a:	17 06       	cpc	r1, r23
    275c:	18 06       	cpc	r1, r24
    275e:	09 06       	cpc	r0, r25
    2760:	08 95       	ret

00002762 <__fp_pscB>:
    2762:	00 24       	eor	r0, r0
    2764:	0a 94       	dec	r0
    2766:	12 16       	cp	r1, r18
    2768:	13 06       	cpc	r1, r19
    276a:	14 06       	cpc	r1, r20
    276c:	05 06       	cpc	r0, r21
    276e:	08 95       	ret

00002770 <__fp_round>:
    2770:	09 2e       	mov	r0, r25
    2772:	03 94       	inc	r0
    2774:	00 0c       	add	r0, r0
    2776:	11 f4       	brne	.+4      	; 0x277c <__fp_round+0xc>
    2778:	88 23       	and	r24, r24
    277a:	52 f0       	brmi	.+20     	; 0x2790 <__fp_round+0x20>
    277c:	bb 0f       	add	r27, r27
    277e:	40 f4       	brcc	.+16     	; 0x2790 <__fp_round+0x20>
    2780:	bf 2b       	or	r27, r31
    2782:	11 f4       	brne	.+4      	; 0x2788 <__fp_round+0x18>
    2784:	60 ff       	sbrs	r22, 0
    2786:	04 c0       	rjmp	.+8      	; 0x2790 <__fp_round+0x20>
    2788:	6f 5f       	subi	r22, 0xFF	; 255
    278a:	7f 4f       	sbci	r23, 0xFF	; 255
    278c:	8f 4f       	sbci	r24, 0xFF	; 255
    278e:	9f 4f       	sbci	r25, 0xFF	; 255
    2790:	08 95       	ret

00002792 <__fp_split3>:
    2792:	57 fd       	sbrc	r21, 7
    2794:	90 58       	subi	r25, 0x80	; 128
    2796:	44 0f       	add	r20, r20
    2798:	55 1f       	adc	r21, r21
    279a:	59 f0       	breq	.+22     	; 0x27b2 <__fp_splitA+0x10>
    279c:	5f 3f       	cpi	r21, 0xFF	; 255
    279e:	71 f0       	breq	.+28     	; 0x27bc <__fp_splitA+0x1a>
    27a0:	47 95       	ror	r20

000027a2 <__fp_splitA>:
    27a2:	88 0f       	add	r24, r24
    27a4:	97 fb       	bst	r25, 7
    27a6:	99 1f       	adc	r25, r25
    27a8:	61 f0       	breq	.+24     	; 0x27c2 <__fp_splitA+0x20>
    27aa:	9f 3f       	cpi	r25, 0xFF	; 255
    27ac:	79 f0       	breq	.+30     	; 0x27cc <__fp_splitA+0x2a>
    27ae:	87 95       	ror	r24
    27b0:	08 95       	ret
    27b2:	12 16       	cp	r1, r18
    27b4:	13 06       	cpc	r1, r19
    27b6:	14 06       	cpc	r1, r20
    27b8:	55 1f       	adc	r21, r21
    27ba:	f2 cf       	rjmp	.-28     	; 0x27a0 <__fp_split3+0xe>
    27bc:	46 95       	lsr	r20
    27be:	f1 df       	rcall	.-30     	; 0x27a2 <__fp_splitA>
    27c0:	08 c0       	rjmp	.+16     	; 0x27d2 <__fp_splitA+0x30>
    27c2:	16 16       	cp	r1, r22
    27c4:	17 06       	cpc	r1, r23
    27c6:	18 06       	cpc	r1, r24
    27c8:	99 1f       	adc	r25, r25
    27ca:	f1 cf       	rjmp	.-30     	; 0x27ae <__fp_splitA+0xc>
    27cc:	86 95       	lsr	r24
    27ce:	71 05       	cpc	r23, r1
    27d0:	61 05       	cpc	r22, r1
    27d2:	08 94       	sec
    27d4:	08 95       	ret

000027d6 <__fp_zero>:
    27d6:	e8 94       	clt

000027d8 <__fp_szero>:
    27d8:	bb 27       	eor	r27, r27
    27da:	66 27       	eor	r22, r22
    27dc:	77 27       	eor	r23, r23
    27de:	cb 01       	movw	r24, r22
    27e0:	97 f9       	bld	r25, 7
    27e2:	08 95       	ret

000027e4 <__gesf2>:
    27e4:	8a df       	rcall	.-236    	; 0x26fa <__fp_cmp>
    27e6:	08 f4       	brcc	.+2      	; 0x27ea <__gesf2+0x6>
    27e8:	8f ef       	ldi	r24, 0xFF	; 255
    27ea:	08 95       	ret

000027ec <__udivmodhi4>:
    27ec:	aa 1b       	sub	r26, r26
    27ee:	bb 1b       	sub	r27, r27
    27f0:	51 e1       	ldi	r21, 0x11	; 17
    27f2:	07 c0       	rjmp	.+14     	; 0x2802 <__udivmodhi4_ep>

000027f4 <__udivmodhi4_loop>:
    27f4:	aa 1f       	adc	r26, r26
    27f6:	bb 1f       	adc	r27, r27
    27f8:	a6 17       	cp	r26, r22
    27fa:	b7 07       	cpc	r27, r23
    27fc:	10 f0       	brcs	.+4      	; 0x2802 <__udivmodhi4_ep>
    27fe:	a6 1b       	sub	r26, r22
    2800:	b7 0b       	sbc	r27, r23

00002802 <__udivmodhi4_ep>:
    2802:	88 1f       	adc	r24, r24
    2804:	99 1f       	adc	r25, r25
    2806:	5a 95       	dec	r21
    2808:	a9 f7       	brne	.-22     	; 0x27f4 <__udivmodhi4_loop>
    280a:	80 95       	com	r24
    280c:	90 95       	com	r25
    280e:	bc 01       	movw	r22, r24
    2810:	cd 01       	movw	r24, r26
    2812:	08 95       	ret

00002814 <__divmodhi4>:
    2814:	97 fb       	bst	r25, 7
    2816:	07 2e       	mov	r0, r23
    2818:	16 f4       	brtc	.+4      	; 0x281e <__divmodhi4+0xa>
    281a:	00 94       	com	r0
    281c:	07 d0       	rcall	.+14     	; 0x282c <__divmodhi4_neg1>
    281e:	77 fd       	sbrc	r23, 7
    2820:	09 d0       	rcall	.+18     	; 0x2834 <__divmodhi4_neg2>
    2822:	0e 94 f6 13 	call	0x27ec	; 0x27ec <__udivmodhi4>
    2826:	07 fc       	sbrc	r0, 7
    2828:	05 d0       	rcall	.+10     	; 0x2834 <__divmodhi4_neg2>
    282a:	3e f4       	brtc	.+14     	; 0x283a <__divmodhi4_exit>

0000282c <__divmodhi4_neg1>:
    282c:	90 95       	com	r25
    282e:	81 95       	neg	r24
    2830:	9f 4f       	sbci	r25, 0xFF	; 255
    2832:	08 95       	ret

00002834 <__divmodhi4_neg2>:
    2834:	70 95       	com	r23
    2836:	61 95       	neg	r22
    2838:	7f 4f       	sbci	r23, 0xFF	; 255

0000283a <__divmodhi4_exit>:
    283a:	08 95       	ret

0000283c <malloc>:
    283c:	0f 93       	push	r16
    283e:	1f 93       	push	r17
    2840:	cf 93       	push	r28
    2842:	df 93       	push	r29
    2844:	82 30       	cpi	r24, 0x02	; 2
    2846:	91 05       	cpc	r25, r1
    2848:	10 f4       	brcc	.+4      	; 0x284e <malloc+0x12>
    284a:	82 e0       	ldi	r24, 0x02	; 2
    284c:	90 e0       	ldi	r25, 0x00	; 0
    284e:	e0 91 f5 12 	lds	r30, 0x12F5
    2852:	f0 91 f6 12 	lds	r31, 0x12F6
    2856:	20 e0       	ldi	r18, 0x00	; 0
    2858:	30 e0       	ldi	r19, 0x00	; 0
    285a:	c0 e0       	ldi	r28, 0x00	; 0
    285c:	d0 e0       	ldi	r29, 0x00	; 0
    285e:	23 c0       	rjmp	.+70     	; 0x28a6 <malloc+0x6a>
    2860:	40 81       	ld	r20, Z
    2862:	51 81       	ldd	r21, Z+1	; 0x01
    2864:	48 17       	cp	r20, r24
    2866:	59 07       	cpc	r21, r25
    2868:	a8 f0       	brcs	.+42     	; 0x2894 <malloc+0x58>
    286a:	48 17       	cp	r20, r24
    286c:	59 07       	cpc	r21, r25
    286e:	61 f4       	brne	.+24     	; 0x2888 <malloc+0x4c>
    2870:	82 81       	ldd	r24, Z+2	; 0x02
    2872:	93 81       	ldd	r25, Z+3	; 0x03
    2874:	20 97       	sbiw	r28, 0x00	; 0
    2876:	19 f0       	breq	.+6      	; 0x287e <malloc+0x42>
    2878:	9b 83       	std	Y+3, r25	; 0x03
    287a:	8a 83       	std	Y+2, r24	; 0x02
    287c:	2e c0       	rjmp	.+92     	; 0x28da <malloc+0x9e>
    287e:	90 93 f6 12 	sts	0x12F6, r25
    2882:	80 93 f5 12 	sts	0x12F5, r24
    2886:	29 c0       	rjmp	.+82     	; 0x28da <malloc+0x9e>
    2888:	21 15       	cp	r18, r1
    288a:	31 05       	cpc	r19, r1
    288c:	29 f0       	breq	.+10     	; 0x2898 <malloc+0x5c>
    288e:	42 17       	cp	r20, r18
    2890:	53 07       	cpc	r21, r19
    2892:	10 f0       	brcs	.+4      	; 0x2898 <malloc+0x5c>
    2894:	a9 01       	movw	r20, r18
    2896:	02 c0       	rjmp	.+4      	; 0x289c <malloc+0x60>
    2898:	be 01       	movw	r22, r28
    289a:	df 01       	movw	r26, r30
    289c:	02 81       	ldd	r16, Z+2	; 0x02
    289e:	13 81       	ldd	r17, Z+3	; 0x03
    28a0:	ef 01       	movw	r28, r30
    28a2:	9a 01       	movw	r18, r20
    28a4:	f8 01       	movw	r30, r16
    28a6:	30 97       	sbiw	r30, 0x00	; 0
    28a8:	d9 f6       	brne	.-74     	; 0x2860 <malloc+0x24>
    28aa:	21 15       	cp	r18, r1
    28ac:	31 05       	cpc	r19, r1
    28ae:	09 f1       	breq	.+66     	; 0x28f2 <malloc+0xb6>
    28b0:	28 1b       	sub	r18, r24
    28b2:	39 0b       	sbc	r19, r25
    28b4:	24 30       	cpi	r18, 0x04	; 4
    28b6:	31 05       	cpc	r19, r1
    28b8:	90 f4       	brcc	.+36     	; 0x28de <malloc+0xa2>
    28ba:	12 96       	adiw	r26, 0x02	; 2
    28bc:	8d 91       	ld	r24, X+
    28be:	9c 91       	ld	r25, X
    28c0:	13 97       	sbiw	r26, 0x03	; 3
    28c2:	61 15       	cp	r22, r1
    28c4:	71 05       	cpc	r23, r1
    28c6:	21 f0       	breq	.+8      	; 0x28d0 <malloc+0x94>
    28c8:	fb 01       	movw	r30, r22
    28ca:	93 83       	std	Z+3, r25	; 0x03
    28cc:	82 83       	std	Z+2, r24	; 0x02
    28ce:	04 c0       	rjmp	.+8      	; 0x28d8 <malloc+0x9c>
    28d0:	90 93 f6 12 	sts	0x12F6, r25
    28d4:	80 93 f5 12 	sts	0x12F5, r24
    28d8:	fd 01       	movw	r30, r26
    28da:	32 96       	adiw	r30, 0x02	; 2
    28dc:	44 c0       	rjmp	.+136    	; 0x2966 <malloc+0x12a>
    28de:	fd 01       	movw	r30, r26
    28e0:	e2 0f       	add	r30, r18
    28e2:	f3 1f       	adc	r31, r19
    28e4:	81 93       	st	Z+, r24
    28e6:	91 93       	st	Z+, r25
    28e8:	22 50       	subi	r18, 0x02	; 2
    28ea:	31 09       	sbc	r19, r1
    28ec:	2d 93       	st	X+, r18
    28ee:	3c 93       	st	X, r19
    28f0:	3a c0       	rjmp	.+116    	; 0x2966 <malloc+0x12a>
    28f2:	20 91 f3 12 	lds	r18, 0x12F3
    28f6:	30 91 f4 12 	lds	r19, 0x12F4
    28fa:	23 2b       	or	r18, r19
    28fc:	41 f4       	brne	.+16     	; 0x290e <malloc+0xd2>
    28fe:	20 91 02 01 	lds	r18, 0x0102
    2902:	30 91 03 01 	lds	r19, 0x0103
    2906:	30 93 f4 12 	sts	0x12F4, r19
    290a:	20 93 f3 12 	sts	0x12F3, r18
    290e:	20 91 00 01 	lds	r18, 0x0100
    2912:	30 91 01 01 	lds	r19, 0x0101
    2916:	21 15       	cp	r18, r1
    2918:	31 05       	cpc	r19, r1
    291a:	41 f4       	brne	.+16     	; 0x292c <malloc+0xf0>
    291c:	2d b7       	in	r18, 0x3d	; 61
    291e:	3e b7       	in	r19, 0x3e	; 62
    2920:	40 91 04 01 	lds	r20, 0x0104
    2924:	50 91 05 01 	lds	r21, 0x0105
    2928:	24 1b       	sub	r18, r20
    292a:	35 0b       	sbc	r19, r21
    292c:	e0 91 f3 12 	lds	r30, 0x12F3
    2930:	f0 91 f4 12 	lds	r31, 0x12F4
    2934:	e2 17       	cp	r30, r18
    2936:	f3 07       	cpc	r31, r19
    2938:	a0 f4       	brcc	.+40     	; 0x2962 <malloc+0x126>
    293a:	2e 1b       	sub	r18, r30
    293c:	3f 0b       	sbc	r19, r31
    293e:	28 17       	cp	r18, r24
    2940:	39 07       	cpc	r19, r25
    2942:	78 f0       	brcs	.+30     	; 0x2962 <malloc+0x126>
    2944:	ac 01       	movw	r20, r24
    2946:	4e 5f       	subi	r20, 0xFE	; 254
    2948:	5f 4f       	sbci	r21, 0xFF	; 255
    294a:	24 17       	cp	r18, r20
    294c:	35 07       	cpc	r19, r21
    294e:	48 f0       	brcs	.+18     	; 0x2962 <malloc+0x126>
    2950:	4e 0f       	add	r20, r30
    2952:	5f 1f       	adc	r21, r31
    2954:	50 93 f4 12 	sts	0x12F4, r21
    2958:	40 93 f3 12 	sts	0x12F3, r20
    295c:	81 93       	st	Z+, r24
    295e:	91 93       	st	Z+, r25
    2960:	02 c0       	rjmp	.+4      	; 0x2966 <malloc+0x12a>
    2962:	e0 e0       	ldi	r30, 0x00	; 0
    2964:	f0 e0       	ldi	r31, 0x00	; 0
    2966:	cf 01       	movw	r24, r30
    2968:	df 91       	pop	r29
    296a:	cf 91       	pop	r28
    296c:	1f 91       	pop	r17
    296e:	0f 91       	pop	r16
    2970:	08 95       	ret

00002972 <free>:
    2972:	ef 92       	push	r14
    2974:	ff 92       	push	r15
    2976:	0f 93       	push	r16
    2978:	1f 93       	push	r17
    297a:	cf 93       	push	r28
    297c:	df 93       	push	r29
    297e:	00 97       	sbiw	r24, 0x00	; 0
    2980:	09 f4       	brne	.+2      	; 0x2984 <free+0x12>
    2982:	8f c0       	rjmp	.+286    	; 0x2aa2 <free+0x130>
    2984:	dc 01       	movw	r26, r24
    2986:	12 97       	sbiw	r26, 0x02	; 2
    2988:	13 96       	adiw	r26, 0x03	; 3
    298a:	1c 92       	st	X, r1
    298c:	1e 92       	st	-X, r1
    298e:	12 97       	sbiw	r26, 0x02	; 2
    2990:	e0 90 f5 12 	lds	r14, 0x12F5
    2994:	f0 90 f6 12 	lds	r15, 0x12F6
    2998:	e1 14       	cp	r14, r1
    299a:	f1 04       	cpc	r15, r1
    299c:	89 f4       	brne	.+34     	; 0x29c0 <free+0x4e>
    299e:	2d 91       	ld	r18, X+
    29a0:	3c 91       	ld	r19, X
    29a2:	11 97       	sbiw	r26, 0x01	; 1
    29a4:	28 0f       	add	r18, r24
    29a6:	39 1f       	adc	r19, r25
    29a8:	80 91 f3 12 	lds	r24, 0x12F3
    29ac:	90 91 f4 12 	lds	r25, 0x12F4
    29b0:	82 17       	cp	r24, r18
    29b2:	93 07       	cpc	r25, r19
    29b4:	89 f5       	brne	.+98     	; 0x2a18 <free+0xa6>
    29b6:	b0 93 f4 12 	sts	0x12F4, r27
    29ba:	a0 93 f3 12 	sts	0x12F3, r26
    29be:	71 c0       	rjmp	.+226    	; 0x2aa2 <free+0x130>
    29c0:	e7 01       	movw	r28, r14
    29c2:	20 e0       	ldi	r18, 0x00	; 0
    29c4:	30 e0       	ldi	r19, 0x00	; 0
    29c6:	01 c0       	rjmp	.+2      	; 0x29ca <free+0x58>
    29c8:	ea 01       	movw	r28, r20
    29ca:	ca 17       	cp	r28, r26
    29cc:	db 07       	cpc	r29, r27
    29ce:	38 f4       	brcc	.+14     	; 0x29de <free+0x6c>
    29d0:	4a 81       	ldd	r20, Y+2	; 0x02
    29d2:	5b 81       	ldd	r21, Y+3	; 0x03
    29d4:	9e 01       	movw	r18, r28
    29d6:	41 15       	cp	r20, r1
    29d8:	51 05       	cpc	r21, r1
    29da:	b1 f7       	brne	.-20     	; 0x29c8 <free+0x56>
    29dc:	22 c0       	rjmp	.+68     	; 0x2a22 <free+0xb0>
    29de:	bc 01       	movw	r22, r24
    29e0:	62 50       	subi	r22, 0x02	; 2
    29e2:	71 09       	sbc	r23, r1
    29e4:	fb 01       	movw	r30, r22
    29e6:	d3 83       	std	Z+3, r29	; 0x03
    29e8:	c2 83       	std	Z+2, r28	; 0x02
    29ea:	00 81       	ld	r16, Z
    29ec:	11 81       	ldd	r17, Z+1	; 0x01
    29ee:	ac 01       	movw	r20, r24
    29f0:	40 0f       	add	r20, r16
    29f2:	51 1f       	adc	r21, r17
    29f4:	4c 17       	cp	r20, r28
    29f6:	5d 07       	cpc	r21, r29
    29f8:	61 f4       	brne	.+24     	; 0x2a12 <free+0xa0>
    29fa:	48 81       	ld	r20, Y
    29fc:	59 81       	ldd	r21, Y+1	; 0x01
    29fe:	40 0f       	add	r20, r16
    2a00:	51 1f       	adc	r21, r17
    2a02:	4e 5f       	subi	r20, 0xFE	; 254
    2a04:	5f 4f       	sbci	r21, 0xFF	; 255
    2a06:	51 83       	std	Z+1, r21	; 0x01
    2a08:	40 83       	st	Z, r20
    2a0a:	4a 81       	ldd	r20, Y+2	; 0x02
    2a0c:	5b 81       	ldd	r21, Y+3	; 0x03
    2a0e:	53 83       	std	Z+3, r21	; 0x03
    2a10:	42 83       	std	Z+2, r20	; 0x02
    2a12:	21 15       	cp	r18, r1
    2a14:	31 05       	cpc	r19, r1
    2a16:	29 f4       	brne	.+10     	; 0x2a22 <free+0xb0>
    2a18:	b0 93 f6 12 	sts	0x12F6, r27
    2a1c:	a0 93 f5 12 	sts	0x12F5, r26
    2a20:	40 c0       	rjmp	.+128    	; 0x2aa2 <free+0x130>
    2a22:	f9 01       	movw	r30, r18
    2a24:	b3 83       	std	Z+3, r27	; 0x03
    2a26:	a2 83       	std	Z+2, r26	; 0x02
    2a28:	e9 01       	movw	r28, r18
    2a2a:	69 91       	ld	r22, Y+
    2a2c:	79 91       	ld	r23, Y+
    2a2e:	c6 0f       	add	r28, r22
    2a30:	d7 1f       	adc	r29, r23
    2a32:	ac 17       	cp	r26, r28
    2a34:	bd 07       	cpc	r27, r29
    2a36:	79 f4       	brne	.+30     	; 0x2a56 <free+0xe4>
    2a38:	dc 01       	movw	r26, r24
    2a3a:	5e 91       	ld	r21, -X
    2a3c:	4e 91       	ld	r20, -X
    2a3e:	46 0f       	add	r20, r22
    2a40:	57 1f       	adc	r21, r23
    2a42:	4e 5f       	subi	r20, 0xFE	; 254
    2a44:	5f 4f       	sbci	r21, 0xFF	; 255
    2a46:	51 83       	std	Z+1, r21	; 0x01
    2a48:	40 83       	st	Z, r20
    2a4a:	12 96       	adiw	r26, 0x02	; 2
    2a4c:	8d 91       	ld	r24, X+
    2a4e:	9c 91       	ld	r25, X
    2a50:	13 97       	sbiw	r26, 0x03	; 3
    2a52:	93 83       	std	Z+3, r25	; 0x03
    2a54:	82 83       	std	Z+2, r24	; 0x02
    2a56:	a0 e0       	ldi	r26, 0x00	; 0
    2a58:	b0 e0       	ldi	r27, 0x00	; 0
    2a5a:	02 c0       	rjmp	.+4      	; 0x2a60 <free+0xee>
    2a5c:	d7 01       	movw	r26, r14
    2a5e:	7c 01       	movw	r14, r24
    2a60:	f7 01       	movw	r30, r14
    2a62:	82 81       	ldd	r24, Z+2	; 0x02
    2a64:	93 81       	ldd	r25, Z+3	; 0x03
    2a66:	00 97       	sbiw	r24, 0x00	; 0
    2a68:	c9 f7       	brne	.-14     	; 0x2a5c <free+0xea>
    2a6a:	c7 01       	movw	r24, r14
    2a6c:	02 96       	adiw	r24, 0x02	; 2
    2a6e:	20 81       	ld	r18, Z
    2a70:	31 81       	ldd	r19, Z+1	; 0x01
    2a72:	82 0f       	add	r24, r18
    2a74:	93 1f       	adc	r25, r19
    2a76:	20 91 f3 12 	lds	r18, 0x12F3
    2a7a:	30 91 f4 12 	lds	r19, 0x12F4
    2a7e:	28 17       	cp	r18, r24
    2a80:	39 07       	cpc	r19, r25
    2a82:	79 f4       	brne	.+30     	; 0x2aa2 <free+0x130>
    2a84:	10 97       	sbiw	r26, 0x00	; 0
    2a86:	29 f4       	brne	.+10     	; 0x2a92 <free+0x120>
    2a88:	10 92 f6 12 	sts	0x12F6, r1
    2a8c:	10 92 f5 12 	sts	0x12F5, r1
    2a90:	04 c0       	rjmp	.+8      	; 0x2a9a <free+0x128>
    2a92:	13 96       	adiw	r26, 0x03	; 3
    2a94:	1c 92       	st	X, r1
    2a96:	1e 92       	st	-X, r1
    2a98:	12 97       	sbiw	r26, 0x02	; 2
    2a9a:	f0 92 f4 12 	sts	0x12F4, r15
    2a9e:	e0 92 f3 12 	sts	0x12F3, r14
    2aa2:	df 91       	pop	r29
    2aa4:	cf 91       	pop	r28
    2aa6:	1f 91       	pop	r17
    2aa8:	0f 91       	pop	r16
    2aaa:	ff 90       	pop	r15
    2aac:	ef 90       	pop	r14
    2aae:	08 95       	ret

00002ab0 <memcpy>:
    2ab0:	fb 01       	movw	r30, r22
    2ab2:	dc 01       	movw	r26, r24
    2ab4:	02 c0       	rjmp	.+4      	; 0x2aba <memcpy+0xa>
    2ab6:	01 90       	ld	r0, Z+
    2ab8:	0d 92       	st	X+, r0
    2aba:	41 50       	subi	r20, 0x01	; 1
    2abc:	50 40       	sbci	r21, 0x00	; 0
    2abe:	d8 f7       	brcc	.-10     	; 0x2ab6 <memcpy+0x6>
    2ac0:	08 95       	ret

00002ac2 <_exit>:
    2ac2:	f8 94       	cli

00002ac4 <__stop_program>:
    2ac4:	ff cf       	rjmp	.-2      	; 0x2ac4 <__stop_program>
