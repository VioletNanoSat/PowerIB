
violet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000206  00800100  00002e6a  00002efe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e6a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000dce  00800306  00800306  00003104  2**0
                  ALLOC
  3 .stab         00002460  00000000  00000000  00003104  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000932  00000000  00000000  00005564  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00005e96  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000280  00000000  00000000  00005ec5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00005173  00000000  00000000  00006145  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000010ba  00000000  00000000  0000b2b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001423  00000000  00000000  0000c372  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000ac4  00000000  00000000  0000d798  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b5e  00000000  00000000  0000e25c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000030e2  00000000  00000000  0000edba  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000208  00000000  00000000  00011e9c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
{
       0:	0c 94 f4 00 	jmp	0x1e8	; 0x1e8 <__ctors_end>
       4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
       8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
       c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      10:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 * insert_str
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
      14:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      18:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
{
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
      1c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      20:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      24:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      28:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
		output[i] = input[i - start_index];

	return i;
}
      2c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      30:	0c 94 fc 0d 	jmp	0x1bf8	; 0x1bf8 <__vector_12>
      34:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      38:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      3c:	0c 94 de 0d 	jmp	0x1bbc	; 0x1bbc <__vector_15>
      40:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      44:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      48:	0c 94 35 0f 	jmp	0x1e6a	; 0x1e6a <__vector_18>
      4c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      50:	0c 94 0c 0f 	jmp	0x1e18	; 0x1e18 <__vector_20>
      54:	0c 94 de 0e 	jmp	0x1dbc	; 0x1dbc <__vector_21>
      58:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      5c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      60:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      64:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      68:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      6c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      70:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      74:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      78:	0c 94 a9 0e 	jmp	0x1d52	; 0x1d52 <__vector_30>
      7c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      80:	0c 94 80 0e 	jmp	0x1d00	; 0x1d00 <__vector_32>
      84:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      88:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>

0000008c <charge20Pc>:
      8c:	08 00 09 00 09 00 0a 00 0b 00 0c 00 0d 00 0d 00     ................
      9c:	0e 00 0f 00 10 00 11 00 12 00 13 00 14 00 15 00     ................
      ac:	16 00 17 00 19 00 1a 00 1b 00 1d 00 1e 00 1f 00     ................
      bc:	21 00 22 00 24 00 25 00 27 00 28 00 2b 00 2c 00     !.".$.%.'.(.+.,.
      cc:	2e 00 30 00 32 00 34 00 36 00 38 00 3b 00 3e 00     ..0.2.4.6.8.;.>.
      dc:	3f 00 42 00 45 00 48 00 4c 00 50 00 59 00 6b 00     ?.B.E.H.L.P.Y.k.
      ec:	7f 00 8a 00 9c 00 a8 00 b3 00 c1 00 ce 00 dd 00     ................
      fc:	ea 00 f9 00 0d 01 1f 01 2b 01 3f 01 7e 01 a9 01     ........+.?.~...
     10c:	b7 01 e1 01 ff 01 18 02 28 02 3d 02 4d 02 62 02     ........(.=.M.b.
     11c:	7d 02 90 02 b8 02 c5 02 d6 02 e9 02 fa 02 08 03     }...............
     12c:	16 03 25 03 32 03 40 03 4d 03 60 03 6f 03 77 03     ..%.2.@.M.`.o.w.
     13c:	83 03 95 03 9f 03 aa 03 b4 03 c0 03 c9 03 d5 03     ................
     14c:	df 03 eb 03 f5 03 00 04 05 04 12 04 19 04 22 04     ..............".
     15c:	2c 04 34 04 37 04 40 04 74 04 7e 04                 ,.4.7.@.t.~.

00000168 <discharge20Pc>:
     168:	00 00 03 00 03 00 03 00 03 00 03 00 03 00 03 00     ................
     178:	03 00 03 00 03 00 03 00 03 00 03 00 03 00 03 00     ................
     188:	03 00 04 00 04 00 04 00 04 00 18 00 18 00 18 00     ................
     198:	18 00 40 00 40 00 40 00 40 00 68 00 68 00 68 00     ..@.@.@.@.h.h.h.
     1a8:	68 00 99 00 99 00 99 00 99 00 cd 00 cd 00 cd 00     h...............
     1b8:	cd 00 ff 00 ff 00 ff 00 ff 00 39 01 39 01 39 01     ..........9.9.9.
     1c8:	39 01 97 01 97 01 97 01 97 01 26 02 a9 02 40 03     9.........&...@.
     1d8:	91 03 ef 03 18 04 2a 04 34 04 3e 04 45 04 4d 04     ......*.4.>.E.M.

000001e8 <__ctors_end>:
     1e8:	11 24       	eor	r1, r1
     1ea:	1f be       	out	0x3f, r1	; 63
     1ec:	cf ef       	ldi	r28, 0xFF	; 255
     1ee:	d0 e1       	ldi	r29, 0x10	; 16
     1f0:	de bf       	out	0x3e, r29	; 62
     1f2:	cd bf       	out	0x3d, r28	; 61

000001f4 <__do_copy_data>:
     1f4:	13 e0       	ldi	r17, 0x03	; 3
     1f6:	a0 e0       	ldi	r26, 0x00	; 0
     1f8:	b1 e0       	ldi	r27, 0x01	; 1
     1fa:	ea e6       	ldi	r30, 0x6A	; 106
     1fc:	fe e2       	ldi	r31, 0x2E	; 46
     1fe:	00 e0       	ldi	r16, 0x00	; 0
     200:	0b bf       	out	0x3b, r16	; 59
     202:	02 c0       	rjmp	.+4      	; 0x208 <__do_copy_data+0x14>
     204:	07 90       	elpm	r0, Z+
     206:	0d 92       	st	X+, r0
     208:	a6 30       	cpi	r26, 0x06	; 6
     20a:	b1 07       	cpc	r27, r17
     20c:	d9 f7       	brne	.-10     	; 0x204 <__do_copy_data+0x10>

0000020e <__do_clear_bss>:
     20e:	20 e1       	ldi	r18, 0x10	; 16
     210:	a6 e0       	ldi	r26, 0x06	; 6
     212:	b3 e0       	ldi	r27, 0x03	; 3
     214:	01 c0       	rjmp	.+2      	; 0x218 <.do_clear_bss_start>

00000216 <.do_clear_bss_loop>:
     216:	1d 92       	st	X+, r1

00000218 <.do_clear_bss_start>:
     218:	a4 3d       	cpi	r26, 0xD4	; 212
     21a:	b2 07       	cpc	r27, r18
     21c:	e1 f7       	brne	.-8      	; 0x216 <.do_clear_bss_loop>
     21e:	0e 94 15 09 	call	0x122a	; 0x122a <main>
     222:	0c 94 33 17 	jmp	0x2e66	; 0x2e66 <_exit>

00000226 <__bad_interrupt>:
     226:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000022a <set_component>:

// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t V_lower_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t I_lower_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
     22a:	8f 92       	push	r8
     22c:	af 92       	push	r10
     22e:	cf 92       	push	r12
     230:	ef 92       	push	r14
     232:	0f 93       	push	r16
     234:	cf 93       	push	r28
     236:	df 93       	push	r29
     238:	cd b7       	in	r28, 0x3d	; 61
     23a:	de b7       	in	r29, 0x3e	; 62
  svit[svit_index].name = name;
     23c:	94 e2       	ldi	r25, 0x24	; 36
     23e:	89 9f       	mul	r24, r25
     240:	f0 01       	movw	r30, r0
     242:	11 24       	eor	r1, r1
     244:	e4 5c       	subi	r30, 0xC4	; 196
     246:	fc 4f       	sbci	r31, 0xFC	; 252
     248:	60 83       	st	Z, r22
  svit[svit_index].switch_num = switch_num;
     24a:	41 83       	std	Z+1, r20	; 0x01
  svit[svit_index].switch_state = switch_state;
     24c:	22 83       	std	Z+2, r18	; 0x02
  svit[svit_index].force_on = 0;
     24e:	13 82       	std	Z+3, r1	; 0x03

  svit[svit_index].V_mux_num = V_mux_num;
     250:	04 83       	std	Z+4, r16	; 0x04
  svit[svit_index].V_mux_sel = V_mux_sel;
     252:	e5 82       	std	Z+5, r14	; 0x05
  svit[svit_index].V_upper_limit = V_upper_limit;
     254:	c6 82       	std	Z+6, r12	; 0x06
  svit[svit_index].V_lower_limit = V_lower_limit;
     256:	a7 82       	std	Z+7, r10	; 0x07
  svit[svit_index].V_sample_index = 0;
     258:	13 86       	std	Z+11, r1	; 0x0b
  svit[svit_index].V_critical_value = 0;
     25a:	14 86       	std	Z+12, r1	; 0x0c

  svit[svit_index].I_mux_num = I_mux_num;
     25c:	85 86       	std	Z+13, r8	; 0x0d
  svit[svit_index].I_mux_sel = I_mux_sel;
     25e:	8a 85       	ldd	r24, Y+10	; 0x0a
     260:	86 87       	std	Z+14, r24	; 0x0e
  svit[svit_index].I_upper_limit = I_upper_limit;
     262:	8b 85       	ldd	r24, Y+11	; 0x0b
     264:	87 87       	std	Z+15, r24	; 0x0f
  svit[svit_index].I_lower_limit = I_lower_limit;
     266:	8c 85       	ldd	r24, Y+12	; 0x0c
     268:	80 8b       	std	Z+16, r24	; 0x10
  svit[svit_index].I_sample_index = 0;
     26a:	14 8a       	std	Z+20, r1	; 0x14
  svit[svit_index].I_critical_value = 0;
     26c:	15 8a       	std	Z+21, r1	; 0x15
  svit[svit_index].T_mux_num = T_mux_num;
     26e:	8d 85       	ldd	r24, Y+13	; 0x0d
     270:	86 8b       	std	Z+22, r24	; 0x16
  svit[svit_index].T_mux_sel = T_mux_sel;
     272:	8e 85       	ldd	r24, Y+14	; 0x0e
     274:	87 8b       	std	Z+23, r24	; 0x17
  svit[svit_index].T_sample_index = 0;
     276:	13 8e       	std	Z+27, r1	; 0x1b
  
  svit[svit_index].Coul_sample_index = 0;
     278:	11 a2       	std	Z+33, r1	; 0x21
}
     27a:	df 91       	pop	r29
     27c:	cf 91       	pop	r28
     27e:	0f 91       	pop	r16
     280:	ef 90       	pop	r14
     282:	cf 90       	pop	r12
     284:	af 90       	pop	r10
     286:	8f 90       	pop	r8
     288:	08 95       	ret

0000028a <initialize_svit>:

void initialize_svit( void )
{ 
     28a:	5f 92       	push	r5
     28c:	6f 92       	push	r6
     28e:	7f 92       	push	r7
     290:	8f 92       	push	r8
     292:	9f 92       	push	r9
     294:	af 92       	push	r10
     296:	bf 92       	push	r11
     298:	cf 92       	push	r12
     29a:	df 92       	push	r13
     29c:	ef 92       	push	r14
     29e:	ff 92       	push	r15
     2a0:	0f 93       	push	r16
     2a2:	1f 93       	push	r17
     2a4:	cf 93       	push	r28
     2a6:	df 93       	push	r29
  // ADC
  // Vref = AVCC = 5 V
  // ADC clock = 16 MHz / 128 = 125 kHz

  // set Vref to AVCC, left-adjust result into ADCH
  ADMUX = ( 1 << ADLAR ) | ( 1 << REFS0 );
     2a8:	80 e6       	ldi	r24, 0x60	; 96
     2aa:	87 b9       	out	0x07, r24	; 7

  // enable ADC and set ADC division factor to 128
  ADCSRA = ( 1 << ADEN ) | ( 1 << ADIE ) | ( 1 << ADPS2 ) | ( 1 << ADPS1 ) | ( 1 << ADPS0 );
     2ac:	8f e8       	ldi	r24, 0x8F	; 143
     2ae:	86 b9       	out	0x06, r24	; 6

  //sample_index = 0;
  svit_index = 0;

  //                index           name      switch_num  switch_state   V_mux_num   V_mux_sel     V_upper_limit		 I_mux_num  I_mux_sel     I_upper_limit      T_mux_num   T_mux_sel
  set_component( svit_index++,  SPECTROMETER,  SW_EN7 ,     SW_ON,          MUX0,       11,      V_THRESHOLD_VALUE, V_UNDER_VALUE,       MUX0,        6 ,    I_THRESHOLD_VALUE,   I_UNDER_VALUE,    MUX_NULL,       0     );
     2b0:	1f 92       	push	r1
     2b2:	13 e0       	ldi	r17, 0x03	; 3
     2b4:	1f 93       	push	r17
     2b6:	c0 e1       	ldi	r28, 0x10	; 16
     2b8:	cf 93       	push	r28
     2ba:	d0 ea       	ldi	r29, 0xA0	; 160
     2bc:	df 93       	push	r29
     2be:	86 e0       	ldi	r24, 0x06	; 6
     2c0:	d8 2e       	mov	r13, r24
     2c2:	df 92       	push	r13
     2c4:	81 2c       	mov	r8, r1
     2c6:	90 e1       	ldi	r25, 0x10	; 16
     2c8:	a9 2e       	mov	r10, r25
     2ca:	20 ea       	ldi	r18, 0xA0	; 160
     2cc:	c2 2e       	mov	r12, r18
     2ce:	3b e0       	ldi	r19, 0x0B	; 11
     2d0:	e3 2e       	mov	r14, r19
     2d2:	00 e0       	ldi	r16, 0x00	; 0
     2d4:	21 e0       	ldi	r18, 0x01	; 1
     2d6:	47 e0       	ldi	r20, 0x07	; 7
     2d8:	60 e0       	ldi	r22, 0x00	; 0
     2da:	80 e0       	ldi	r24, 0x00	; 0
     2dc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  STAR_TRACKER,  SW_EN8 ,     SW_ON,          MUX0,       23,      V_THRESHOLD_VALUE,  V_UNDER_VALUE,     MUX0,        7 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,    MUX1    ,       7     );        
     2e0:	87 e0       	ldi	r24, 0x07	; 7
     2e2:	8f 93       	push	r24
     2e4:	bb 24       	eor	r11, r11
     2e6:	b3 94       	inc	r11
     2e8:	bf 92       	push	r11
     2ea:	cf 93       	push	r28
     2ec:	df 93       	push	r29
     2ee:	8f 93       	push	r24
     2f0:	47 e1       	ldi	r20, 0x17	; 23
     2f2:	e4 2e       	mov	r14, r20
     2f4:	21 e0       	ldi	r18, 0x01	; 1
     2f6:	48 e0       	ldi	r20, 0x08	; 8
     2f8:	61 e0       	ldi	r22, 0x01	; 1
     2fa:	81 e0       	ldi	r24, 0x01	; 1
     2fc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  FC_5V       ,  SW_EN1 ,     SW_ON,          MUX1,       19,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,    MUX1,        0 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,    MUX_NULL,       0     );        
     300:	1f 92       	push	r1
     302:	1f 93       	push	r17
     304:	cf 93       	push	r28
     306:	df 93       	push	r29
     308:	1f 92       	push	r1
     30a:	88 24       	eor	r8, r8
     30c:	83 94       	inc	r8
     30e:	53 e1       	ldi	r21, 0x13	; 19
     310:	e5 2e       	mov	r14, r21
     312:	01 e0       	ldi	r16, 0x01	; 1
     314:	21 e0       	ldi	r18, 0x01	; 1
     316:	41 e0       	ldi	r20, 0x01	; 1
     318:	62 e0       	ldi	r22, 0x02	; 2
     31a:	82 e0       	ldi	r24, 0x02	; 2
     31c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  FC_3_3V     ,  SW_EN1 ,     SW_ON,          MUX2,       13,      V_THRESHOLD_VALUE,    V_UNDER_VALUE,   MUX2,        14,    I_THRESHOLD_VALUE, I_UNDER_VALUE,  MUX_NULL,       0     );        
     320:	1f 92       	push	r1
     322:	1f 93       	push	r17
     324:	cf 93       	push	r28
     326:	df 93       	push	r29
     328:	8e e0       	ldi	r24, 0x0E	; 14
     32a:	8f 93       	push	r24
     32c:	62 e0       	ldi	r22, 0x02	; 2
     32e:	86 2e       	mov	r8, r22
     330:	7d e0       	ldi	r23, 0x0D	; 13
     332:	e7 2e       	mov	r14, r23
     334:	02 e0       	ldi	r16, 0x02	; 2
     336:	21 e0       	ldi	r18, 0x01	; 1
     338:	41 e0       	ldi	r20, 0x01	; 1
     33a:	63 e0       	ldi	r22, 0x03	; 3
     33c:	83 e0       	ldi	r24, 0x03	; 3
     33e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  GPS_1       ,  SW_EN2 ,     SW_ON,          MUX1,       21,      V_THRESHOLD_VALUE,  V_UNDER_VALUE,    MUX1,        1 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
     342:	1f 92       	push	r1
     344:	1f 93       	push	r17
     346:	cf 93       	push	r28
     348:	df 93       	push	r29
     34a:	bf 92       	push	r11
     34c:	88 24       	eor	r8, r8
     34e:	83 94       	inc	r8
     350:	e5 e1       	ldi	r30, 0x15	; 21
     352:	ee 2e       	mov	r14, r30
     354:	01 e0       	ldi	r16, 0x01	; 1
     356:	21 e0       	ldi	r18, 0x01	; 1
     358:	42 e0       	ldi	r20, 0x02	; 2
     35a:	64 e0       	ldi	r22, 0x04	; 4
     35c:	84 e0       	ldi	r24, 0x04	; 4
     35e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  GPS_2       ,  SW_EN3 ,     SW_ON,          MUX1,       26,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,    MUX1,        2 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );    
     362:	1f 92       	push	r1
     364:	1f 93       	push	r17
     366:	cf 93       	push	r28
     368:	df 93       	push	r29
     36a:	f2 e0       	ldi	r31, 0x02	; 2
     36c:	ff 2e       	mov	r15, r31
     36e:	ff 92       	push	r15
     370:	aa e1       	ldi	r26, 0x1A	; 26
     372:	ea 2e       	mov	r14, r26
     374:	21 e0       	ldi	r18, 0x01	; 1
     376:	43 e0       	ldi	r20, 0x03	; 3
     378:	65 e0       	ldi	r22, 0x05	; 5
     37a:	85 e0       	ldi	r24, 0x05	; 5
     37c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  CDH_IB      ,  SW_EN4 ,     SW_ON,          MUX1,       29,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,    MUX1,        3 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
     380:	1f 92       	push	r1
     382:	1f 93       	push	r17
     384:	cf 93       	push	r28
     386:	df 93       	push	r29
     388:	1f 93       	push	r17
     38a:	bd e1       	ldi	r27, 0x1D	; 29
     38c:	eb 2e       	mov	r14, r27
     38e:	21 e0       	ldi	r18, 0x01	; 1
     390:	44 e0       	ldi	r20, 0x04	; 4
     392:	66 e0       	ldi	r22, 0x06	; 6
     394:	86 e0       	ldi	r24, 0x06	; 6
     396:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  HEATER_1    ,  SW_EN5 ,     SW_ON,          MUX1,       14,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX1,        31,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     ); 
     39a:	8d b7       	in	r24, 0x3d	; 61
     39c:	9e b7       	in	r25, 0x3e	; 62
     39e:	83 96       	adiw	r24, 0x23	; 35
     3a0:	0f b6       	in	r0, 0x3f	; 63
     3a2:	f8 94       	cli
     3a4:	9e bf       	out	0x3e, r25	; 62
     3a6:	0f be       	out	0x3f, r0	; 63
     3a8:	8d bf       	out	0x3d, r24	; 61
     3aa:	1f 92       	push	r1
     3ac:	1f 93       	push	r17
     3ae:	cf 93       	push	r28
     3b0:	df 93       	push	r29
     3b2:	8f e1       	ldi	r24, 0x1F	; 31
     3b4:	98 2e       	mov	r9, r24
     3b6:	9f 92       	push	r9
     3b8:	9e e0       	ldi	r25, 0x0E	; 14
     3ba:	e9 2e       	mov	r14, r25
     3bc:	21 e0       	ldi	r18, 0x01	; 1
     3be:	45 e0       	ldi	r20, 0x05	; 5
     3c0:	67 e0       	ldi	r22, 0x07	; 7
     3c2:	87 e0       	ldi	r24, 0x07	; 7
     3c4:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  HEATER_2    ,  SW_EN6 ,     SW_ON,          MUX1,       27,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX1,        4 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
     3c8:	1f 92       	push	r1
     3ca:	1f 93       	push	r17
     3cc:	cf 93       	push	r28
     3ce:	df 93       	push	r29
     3d0:	24 e0       	ldi	r18, 0x04	; 4
     3d2:	52 2e       	mov	r5, r18
     3d4:	5f 92       	push	r5
     3d6:	3b e1       	ldi	r19, 0x1B	; 27
     3d8:	e3 2e       	mov	r14, r19
     3da:	21 e0       	ldi	r18, 0x01	; 1
     3dc:	46 e0       	ldi	r20, 0x06	; 6
     3de:	68 e0       	ldi	r22, 0x08	; 8
     3e0:	88 e0       	ldi	r24, 0x08	; 8
     3e2:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  CMG         ,  SW_EN9 ,     SW_ON,          MUX1,       15,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX1,        8 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     ); 
     3e6:	1f 92       	push	r1
     3e8:	1f 93       	push	r17
     3ea:	cf 93       	push	r28
     3ec:	df 93       	push	r29
     3ee:	48 e0       	ldi	r20, 0x08	; 8
     3f0:	64 2e       	mov	r6, r20
     3f2:	6f 92       	push	r6
     3f4:	5f e0       	ldi	r21, 0x0F	; 15
     3f6:	e5 2e       	mov	r14, r21
     3f8:	21 e0       	ldi	r18, 0x01	; 1
     3fa:	49 e0       	ldi	r20, 0x09	; 9
     3fc:	69 e0       	ldi	r22, 0x09	; 9
     3fe:	89 e0       	ldi	r24, 0x09	; 9
     400:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SUN_SENSOR  ,  SW_EN10,     SW_ON,          MUX1,       25,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX1,        9 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
     404:	1f 92       	push	r1
     406:	1f 93       	push	r17
     408:	cf 93       	push	r28
     40a:	df 93       	push	r29
     40c:	69 e0       	ldi	r22, 0x09	; 9
     40e:	76 2e       	mov	r7, r22
     410:	7f 92       	push	r7
     412:	79 e1       	ldi	r23, 0x19	; 25
     414:	e7 2e       	mov	r14, r23
     416:	21 e0       	ldi	r18, 0x01	; 1
     418:	4a e0       	ldi	r20, 0x0A	; 10
     41a:	6a e0       	ldi	r22, 0x0A	; 10
     41c:	8a e0       	ldi	r24, 0x0A	; 10
     41e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  RADIO_1     ,  SW_EN11,     SW_OFF,          MUX1,       24,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX1,        10,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     ); 
     422:	1f 92       	push	r1
     424:	1f 93       	push	r17
     426:	cf 93       	push	r28
     428:	df 93       	push	r29
     42a:	8a e0       	ldi	r24, 0x0A	; 10
     42c:	8f 93       	push	r24
     42e:	e8 e1       	ldi	r30, 0x18	; 24
     430:	ee 2e       	mov	r14, r30
     432:	20 e0       	ldi	r18, 0x00	; 0
     434:	4b e0       	ldi	r20, 0x0B	; 11
     436:	6b e0       	ldi	r22, 0x0B	; 11
     438:	8b e0       	ldi	r24, 0x0B	; 11
     43a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  RADIO_2     ,  SW_EN12,     SW_OFF,          MUX1,       17,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX1,        16,    I_THRESHOLD_VALUE, I_UNDER_VALUE,    MUX_NULL,       0     );   
     43e:	1f 92       	push	r1
     440:	1f 93       	push	r17
     442:	cf 93       	push	r28
     444:	df 93       	push	r29
     446:	cf 93       	push	r28
     448:	f1 e1       	ldi	r31, 0x11	; 17
     44a:	ef 2e       	mov	r14, r31
     44c:	20 e0       	ldi	r18, 0x00	; 0
     44e:	4c e0       	ldi	r20, 0x0C	; 12
     450:	6c e0       	ldi	r22, 0x0C	; 12
     452:	8c e0       	ldi	r24, 0x0C	; 12
     454:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  MAESTRO     ,  SW_EN13,     SW_ON,          MUX1,       22,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX1,        12,    I_THRESHOLD_VALUE, I_UNDER_VALUE,    MUX2    ,       8     );  
     458:	6f 92       	push	r6
     45a:	ff 92       	push	r15
     45c:	cf 93       	push	r28
     45e:	df 93       	push	r29
     460:	8c e0       	ldi	r24, 0x0C	; 12
     462:	8f 93       	push	r24
     464:	a6 e1       	ldi	r26, 0x16	; 22
     466:	ea 2e       	mov	r14, r26
     468:	21 e0       	ldi	r18, 0x01	; 1
     46a:	4d e0       	ldi	r20, 0x0D	; 13
     46c:	6d e0       	ldi	r22, 0x0D	; 13
     46e:	8d e0       	ldi	r24, 0x0D	; 13
     470:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  MAGNETOM    ,  SW_EN14,     SW_ON,          MUX0,       4 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        6 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,  MUX_NULL,       0     );    
     474:	8d b7       	in	r24, 0x3d	; 61
     476:	9e b7       	in	r25, 0x3e	; 62
     478:	83 96       	adiw	r24, 0x23	; 35
     47a:	0f b6       	in	r0, 0x3f	; 63
     47c:	f8 94       	cli
     47e:	9e bf       	out	0x3e, r25	; 62
     480:	0f be       	out	0x3f, r0	; 63
     482:	8d bf       	out	0x3d, r24	; 61
     484:	1f 92       	push	r1
     486:	1f 93       	push	r17
     488:	cf 93       	push	r28
     48a:	df 93       	push	r29
     48c:	df 92       	push	r13
     48e:	81 2c       	mov	r8, r1
     490:	b4 e0       	ldi	r27, 0x04	; 4
     492:	eb 2e       	mov	r14, r27
     494:	00 e0       	ldi	r16, 0x00	; 0
     496:	21 e0       	ldi	r18, 0x01	; 1
     498:	4e e0       	ldi	r20, 0x0E	; 14
     49a:	6e e0       	ldi	r22, 0x0E	; 14
     49c:	8e e0       	ldi	r24, 0x0E	; 14
     49e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  FOG_15V     ,  SW_EN16,     SW_ON,          MUX2,       21,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX_NULL,    0,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  // Fake Data changed mux 2 20 to mux null 0
     4a2:	1f 92       	push	r1
     4a4:	1f 93       	push	r17
     4a6:	cf 93       	push	r28
     4a8:	df 93       	push	r29
     4aa:	1f 92       	push	r1
     4ac:	03 e0       	ldi	r16, 0x03	; 3
     4ae:	80 2e       	mov	r8, r16
     4b0:	85 e1       	ldi	r24, 0x15	; 21
     4b2:	e8 2e       	mov	r14, r24
     4b4:	02 e0       	ldi	r16, 0x02	; 2
     4b6:	21 e0       	ldi	r18, 0x01	; 1
     4b8:	40 e1       	ldi	r20, 0x10	; 16
     4ba:	6f e0       	ldi	r22, 0x0F	; 15
     4bc:	8f e0       	ldi	r24, 0x0F	; 15
     4be:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  FOG_5V      ,  SW_EN15,     SW_ON,          MUX1,       18,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX1,        13,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  // Fake Data
     4c2:	1f 92       	push	r1
     4c4:	1f 93       	push	r17
     4c6:	cf 93       	push	r28
     4c8:	df 93       	push	r29
     4ca:	8d e0       	ldi	r24, 0x0D	; 13
     4cc:	8f 93       	push	r24
     4ce:	88 24       	eor	r8, r8
     4d0:	83 94       	inc	r8
     4d2:	92 e1       	ldi	r25, 0x12	; 18
     4d4:	e9 2e       	mov	r14, r25
     4d6:	01 e0       	ldi	r16, 0x01	; 1
     4d8:	21 e0       	ldi	r18, 0x01	; 1
     4da:	4f e0       	ldi	r20, 0x0F	; 15
     4dc:	60 e1       	ldi	r22, 0x10	; 16
     4de:	80 e1       	ldi	r24, 0x10	; 16
     4e0:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  TORQUER_1   ,  SW_NULL,     SW_OFF,          MUX1,       28,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX1,        5 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
     4e4:	1f 92       	push	r1
     4e6:	1f 93       	push	r17
     4e8:	cf 93       	push	r28
     4ea:	df 93       	push	r29
     4ec:	25 e0       	ldi	r18, 0x05	; 5
     4ee:	62 2e       	mov	r6, r18
     4f0:	6f 92       	push	r6
     4f2:	3c e1       	ldi	r19, 0x1C	; 28
     4f4:	e3 2e       	mov	r14, r19
     4f6:	20 e0       	ldi	r18, 0x00	; 0
     4f8:	4f ef       	ldi	r20, 0xFF	; 255
     4fa:	61 e1       	ldi	r22, 0x11	; 17
     4fc:	81 e1       	ldi	r24, 0x11	; 17
     4fe:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  TORQUER_2   ,  SW_NULL,     SW_OFF,          MUX2,       15,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX2,        16,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     ); 
     502:	1f 92       	push	r1
     504:	1f 93       	push	r17
     506:	cf 93       	push	r28
     508:	df 93       	push	r29
     50a:	cf 93       	push	r28
     50c:	42 e0       	ldi	r20, 0x02	; 2
     50e:	84 2e       	mov	r8, r20
     510:	5f e0       	ldi	r21, 0x0F	; 15
     512:	e5 2e       	mov	r14, r21
     514:	02 e0       	ldi	r16, 0x02	; 2
     516:	20 e0       	ldi	r18, 0x00	; 0
     518:	4f ef       	ldi	r20, 0xFF	; 255
     51a:	62 e1       	ldi	r22, 0x12	; 18
     51c:	82 e1       	ldi	r24, 0x12	; 18
     51e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  TORQUER_3   ,  SW_NULL,     SW_OFF,          MUX2,       17,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX2,        18,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     ); 
     522:	1f 92       	push	r1
     524:	1f 93       	push	r17
     526:	cf 93       	push	r28
     528:	df 93       	push	r29
     52a:	82 e1       	ldi	r24, 0x12	; 18
     52c:	8f 93       	push	r24
     52e:	61 e1       	ldi	r22, 0x11	; 17
     530:	e6 2e       	mov	r14, r22
     532:	20 e0       	ldi	r18, 0x00	; 0
     534:	4f ef       	ldi	r20, 0xFF	; 255
     536:	63 e1       	ldi	r22, 0x13	; 19
     538:	83 e1       	ldi	r24, 0x13	; 19
     53a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  BATTERY_1   ,  SW_NULL,     SW_ON,          MUX0,       1 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        2 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       9     );  // Fake Data  
     53e:	7f 92       	push	r7
     540:	ff 92       	push	r15
     542:	cf 93       	push	r28
     544:	df 93       	push	r29
     546:	ff 92       	push	r15
     548:	81 2c       	mov	r8, r1
     54a:	ee 24       	eor	r14, r14
     54c:	e3 94       	inc	r14
     54e:	00 e0       	ldi	r16, 0x00	; 0
     550:	21 e0       	ldi	r18, 0x01	; 1
     552:	4f ef       	ldi	r20, 0xFF	; 255
     554:	64 e1       	ldi	r22, 0x14	; 20
     556:	84 e1       	ldi	r24, 0x14	; 20
     558:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  //set_component( svit_index++,  BATTERY_1_b  ,  SW_NULL,     SW_ON,          MUX0,       1 ,      V_THRESHOLD_VALUE,      MUX1,        23 ,    I_THRESHOLD_VALUE,    MUX2    ,       9     );  // Fake Data  
  set_component( svit_index++,  BATTERY_2   ,  SW_NULL,     SW_ON,          MUX2,       20,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX2,        30,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       11    );  // Fake Data  
     55c:	8d b7       	in	r24, 0x3d	; 61
     55e:	9e b7       	in	r25, 0x3e	; 62
     560:	83 96       	adiw	r24, 0x23	; 35
     562:	0f b6       	in	r0, 0x3f	; 63
     564:	f8 94       	cli
     566:	9e bf       	out	0x3e, r25	; 62
     568:	0f be       	out	0x3f, r0	; 63
     56a:	8d bf       	out	0x3d, r24	; 61
     56c:	8b e0       	ldi	r24, 0x0B	; 11
     56e:	8f 93       	push	r24
     570:	ff 92       	push	r15
     572:	cf 93       	push	r28
     574:	df 93       	push	r29
     576:	7e e1       	ldi	r23, 0x1E	; 30
     578:	77 2e       	mov	r7, r23
     57a:	7f 92       	push	r7
     57c:	e2 e0       	ldi	r30, 0x02	; 2
     57e:	8e 2e       	mov	r8, r30
     580:	f4 e1       	ldi	r31, 0x14	; 20
     582:	ef 2e       	mov	r14, r31
     584:	02 e0       	ldi	r16, 0x02	; 2
     586:	21 e0       	ldi	r18, 0x01	; 1
     588:	4f ef       	ldi	r20, 0xFF	; 255
     58a:	65 e1       	ldi	r22, 0x15	; 21
     58c:	85 e1       	ldi	r24, 0x15	; 21
     58e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_FULL  ,  SW_NULL,     SW_ON,          MUX0,       7 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        3 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );
     592:	1f 92       	push	r1
     594:	1f 93       	push	r17
     596:	cf 93       	push	r28
     598:	df 93       	push	r29
     59a:	1f 93       	push	r17
     59c:	81 2c       	mov	r8, r1
     59e:	a7 e0       	ldi	r26, 0x07	; 7
     5a0:	ea 2e       	mov	r14, r26
     5a2:	00 e0       	ldi	r16, 0x00	; 0
     5a4:	21 e0       	ldi	r18, 0x01	; 1
     5a6:	4f ef       	ldi	r20, 0xFF	; 255
     5a8:	66 e1       	ldi	r22, 0x16	; 22
     5aa:	86 e1       	ldi	r24, 0x16	; 22
     5ac:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_1     ,  SW_NULL,     SW_ON,          MUX0,       18,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        20,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       0     );  
     5b0:	1f 92       	push	r1
     5b2:	ff 92       	push	r15
     5b4:	cf 93       	push	r28
     5b6:	df 93       	push	r29
     5b8:	84 e1       	ldi	r24, 0x14	; 20
     5ba:	8f 93       	push	r24
     5bc:	b2 e1       	ldi	r27, 0x12	; 18
     5be:	eb 2e       	mov	r14, r27
     5c0:	21 e0       	ldi	r18, 0x01	; 1
     5c2:	4f ef       	ldi	r20, 0xFF	; 255
     5c4:	67 e1       	ldi	r22, 0x17	; 23
     5c6:	87 e1       	ldi	r24, 0x17	; 23
     5c8:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_2     ,  SW_NULL,     SW_ON,          MUX0,       19,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        21,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       1     ); 
     5cc:	bf 92       	push	r11
     5ce:	ff 92       	push	r15
     5d0:	cf 93       	push	r28
     5d2:	df 93       	push	r29
     5d4:	85 e1       	ldi	r24, 0x15	; 21
     5d6:	8f 93       	push	r24
     5d8:	83 e1       	ldi	r24, 0x13	; 19
     5da:	e8 2e       	mov	r14, r24
     5dc:	21 e0       	ldi	r18, 0x01	; 1
     5de:	4f ef       	ldi	r20, 0xFF	; 255
     5e0:	68 e1       	ldi	r22, 0x18	; 24
     5e2:	88 e1       	ldi	r24, 0x18	; 24
     5e4:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_3     ,  SW_NULL,     SW_ON,          MUX0,       10,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        22,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       2     );  
     5e8:	ff 92       	push	r15
     5ea:	ff 92       	push	r15
     5ec:	cf 93       	push	r28
     5ee:	df 93       	push	r29
     5f0:	86 e1       	ldi	r24, 0x16	; 22
     5f2:	8f 93       	push	r24
     5f4:	9a e0       	ldi	r25, 0x0A	; 10
     5f6:	e9 2e       	mov	r14, r25
     5f8:	21 e0       	ldi	r18, 0x01	; 1
     5fa:	4f ef       	ldi	r20, 0xFF	; 255
     5fc:	69 e1       	ldi	r22, 0x19	; 25
     5fe:	89 e1       	ldi	r24, 0x19	; 25
     600:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_4     ,  SW_NULL,     SW_ON,          MUX0,       15,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        23,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       3     );  
     604:	1f 93       	push	r17
     606:	ff 92       	push	r15
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	87 e1       	ldi	r24, 0x17	; 23
     60e:	8f 93       	push	r24
     610:	2f e0       	ldi	r18, 0x0F	; 15
     612:	e2 2e       	mov	r14, r18
     614:	21 e0       	ldi	r18, 0x01	; 1
     616:	4f ef       	ldi	r20, 0xFF	; 255
     618:	6a e1       	ldi	r22, 0x1A	; 26
     61a:	8a e1       	ldi	r24, 0x1A	; 26
     61c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_5     ,  SW_NULL,     SW_ON,          MUX0,       9 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        24,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       4     );  
     620:	5f 92       	push	r5
     622:	ff 92       	push	r15
     624:	cf 93       	push	r28
     626:	df 93       	push	r29
     628:	88 e1       	ldi	r24, 0x18	; 24
     62a:	8f 93       	push	r24
     62c:	39 e0       	ldi	r19, 0x09	; 9
     62e:	e3 2e       	mov	r14, r19
     630:	21 e0       	ldi	r18, 0x01	; 1
     632:	4f ef       	ldi	r20, 0xFF	; 255
     634:	6b e1       	ldi	r22, 0x1B	; 27
     636:	8b e1       	ldi	r24, 0x1B	; 27
     638:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_6     ,  SW_NULL,     SW_ON,          MUX0,       14,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        25,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     ); 
     63c:	8d b7       	in	r24, 0x3d	; 61
     63e:	9e b7       	in	r25, 0x3e	; 62
     640:	83 96       	adiw	r24, 0x23	; 35
     642:	0f b6       	in	r0, 0x3f	; 63
     644:	f8 94       	cli
     646:	9e bf       	out	0x3e, r25	; 62
     648:	0f be       	out	0x3f, r0	; 63
     64a:	8d bf       	out	0x3d, r24	; 61
     64c:	1f 92       	push	r1
     64e:	1f 93       	push	r17
     650:	cf 93       	push	r28
     652:	df 93       	push	r29
     654:	89 e1       	ldi	r24, 0x19	; 25
     656:	8f 93       	push	r24
     658:	4e e0       	ldi	r20, 0x0E	; 14
     65a:	e4 2e       	mov	r14, r20
     65c:	21 e0       	ldi	r18, 0x01	; 1
     65e:	4f ef       	ldi	r20, 0xFF	; 255
     660:	6c e1       	ldi	r22, 0x1C	; 28
     662:	8c e1       	ldi	r24, 0x1C	; 28
     664:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_7     ,  SW_NULL,     SW_ON,          MUX0,       16,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        26,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
     668:	1f 92       	push	r1
     66a:	1f 93       	push	r17
     66c:	cf 93       	push	r28
     66e:	df 93       	push	r29
     670:	8a e1       	ldi	r24, 0x1A	; 26
     672:	8f 93       	push	r24
     674:	50 e1       	ldi	r21, 0x10	; 16
     676:	e5 2e       	mov	r14, r21
     678:	21 e0       	ldi	r18, 0x01	; 1
     67a:	4f ef       	ldi	r20, 0xFF	; 255
     67c:	6d e1       	ldi	r22, 0x1D	; 29
     67e:	8d e1       	ldi	r24, 0x1D	; 29
     680:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_8     ,  SW_NULL,     SW_ON,          MUX0,       8 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        27,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
     684:	1f 92       	push	r1
     686:	1f 93       	push	r17
     688:	cf 93       	push	r28
     68a:	df 93       	push	r29
     68c:	8b e1       	ldi	r24, 0x1B	; 27
     68e:	8f 93       	push	r24
     690:	68 e0       	ldi	r22, 0x08	; 8
     692:	e6 2e       	mov	r14, r22
     694:	21 e0       	ldi	r18, 0x01	; 1
     696:	4f ef       	ldi	r20, 0xFF	; 255
     698:	6e e1       	ldi	r22, 0x1E	; 30
     69a:	8e e1       	ldi	r24, 0x1E	; 30
     69c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_9     ,  SW_NULL,     SW_ON,          MUX0,       13,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        28,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       5     );  
     6a0:	6f 92       	push	r6
     6a2:	ff 92       	push	r15
     6a4:	cf 93       	push	r28
     6a6:	df 93       	push	r29
     6a8:	8c e1       	ldi	r24, 0x1C	; 28
     6aa:	8f 93       	push	r24
     6ac:	7d e0       	ldi	r23, 0x0D	; 13
     6ae:	e7 2e       	mov	r14, r23
     6b0:	21 e0       	ldi	r18, 0x01	; 1
     6b2:	4f ef       	ldi	r20, 0xFF	; 255
     6b4:	6f e1       	ldi	r22, 0x1F	; 31
     6b6:	8f e1       	ldi	r24, 0x1F	; 31
     6b8:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_10    ,  SW_NULL,     SW_ON,          MUX0,       12,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        29,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
     6bc:	1f 92       	push	r1
     6be:	1f 93       	push	r17
     6c0:	cf 93       	push	r28
     6c2:	df 93       	push	r29
     6c4:	8d e1       	ldi	r24, 0x1D	; 29
     6c6:	8f 93       	push	r24
     6c8:	ec e0       	ldi	r30, 0x0C	; 12
     6ca:	ee 2e       	mov	r14, r30
     6cc:	21 e0       	ldi	r18, 0x01	; 1
     6ce:	4f ef       	ldi	r20, 0xFF	; 255
     6d0:	60 e2       	ldi	r22, 0x20	; 32
     6d2:	80 e2       	ldi	r24, 0x20	; 32
     6d4:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_11    ,  SW_NULL,     SW_ON,          MUX0,       11,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        30,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
     6d8:	1f 92       	push	r1
     6da:	1f 93       	push	r17
     6dc:	cf 93       	push	r28
     6de:	df 93       	push	r29
     6e0:	7f 92       	push	r7
     6e2:	fb e0       	ldi	r31, 0x0B	; 11
     6e4:	ef 2e       	mov	r14, r31
     6e6:	21 e0       	ldi	r18, 0x01	; 1
     6e8:	4f ef       	ldi	r20, 0xFF	; 255
     6ea:	61 e2       	ldi	r22, 0x21	; 33
     6ec:	81 e2       	ldi	r24, 0x21	; 33
     6ee:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
     6f2:	1f 92       	push	r1
     6f4:	1f 93       	push	r17
     6f6:	cf 93       	push	r28
     6f8:	df 93       	push	r29
     6fa:	9f 92       	push	r9
     6fc:	a1 e1       	ldi	r26, 0x11	; 17
     6fe:	ea 2e       	mov	r14, r26
     700:	21 e0       	ldi	r18, 0x01	; 1
     702:	4f ef       	ldi	r20, 0xFF	; 255
     704:	62 e2       	ldi	r22, 0x22	; 34
     706:	82 e2       	ldi	r24, 0x22	; 34
     708:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       6     );  // Fake Data
     70c:	8d b7       	in	r24, 0x3d	; 61
     70e:	9e b7       	in	r25, 0x3e	; 62
     710:	83 96       	adiw	r24, 0x23	; 35
     712:	0f b6       	in	r0, 0x3f	; 63
     714:	f8 94       	cli
     716:	9e bf       	out	0x3e, r25	; 62
     718:	0f be       	out	0x3f, r0	; 63
     71a:	8d bf       	out	0x3d, r24	; 61
     71c:	df 92       	push	r13
     71e:	ff 92       	push	r15
     720:	cf 93       	push	r28
     722:	df 93       	push	r29
     724:	1f 92       	push	r1
     726:	b5 e0       	ldi	r27, 0x05	; 5
     728:	eb 2e       	mov	r14, r27
     72a:	21 e0       	ldi	r18, 0x01	; 1
     72c:	4f ef       	ldi	r20, 0xFF	; 255
     72e:	63 e2       	ldi	r22, 0x23	; 35
     730:	83 e2       	ldi	r24, 0x23	; 35
     732:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     736:	0f 90       	pop	r0
     738:	0f 90       	pop	r0
     73a:	0f 90       	pop	r0
     73c:	0f 90       	pop	r0
     73e:	0f 90       	pop	r0
}
     740:	df 91       	pop	r29
     742:	cf 91       	pop	r28
     744:	1f 91       	pop	r17
     746:	0f 91       	pop	r16
     748:	ff 90       	pop	r15
     74a:	ef 90       	pop	r14
     74c:	df 90       	pop	r13
     74e:	cf 90       	pop	r12
     750:	bf 90       	pop	r11
     752:	af 90       	pop	r10
     754:	9f 90       	pop	r9
     756:	8f 90       	pop	r8
     758:	7f 90       	pop	r7
     75a:	6f 90       	pop	r6
     75c:	5f 90       	pop	r5
     75e:	08 95       	ret

00000760 <receive_message>:
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}

inline void receive_message( uint8_t uart, uint8_t* message, uint8_t message_size )//was inline
{
     760:	ff 92       	push	r15
     762:	0f 93       	push	r16
     764:	1f 93       	push	r17
     766:	cf 93       	push	r28
     768:	df 93       	push	r29
     76a:	f8 2e       	mov	r15, r24
     76c:	fb 01       	movw	r30, r22
  uint8_t command = message[VCP_COMMAND_FIELD];
  uint8_t payload = message[VCP_PAYLOAD_FIELD];
     76e:	c1 81       	ldd	r28, Z+1	; 0x01

  switch(command)
     770:	90 81       	ld	r25, Z
     772:	93 30       	cpi	r25, 0x03	; 3
     774:	09 f4       	brne	.+2      	; 0x778 <receive_message+0x18>
     776:	5a c0       	rjmp	.+180    	; 0x82c <receive_message+0xcc>
     778:	30 f4       	brcc	.+12     	; 0x786 <receive_message+0x26>
     77a:	0c 2f       	mov	r16, r28
     77c:	10 e0       	ldi	r17, 0x00	; 0
     77e:	91 30       	cpi	r25, 0x01	; 1
     780:	11 f1       	breq	.+68     	; 0x7c6 <receive_message+0x66>
     782:	90 f5       	brcc	.+100    	; 0x7e8 <receive_message+0x88>
     784:	0c c0       	rjmp	.+24     	; 0x79e <receive_message+0x3e>
     786:	95 30       	cpi	r25, 0x05	; 5
     788:	09 f4       	brne	.+2      	; 0x78c <receive_message+0x2c>
     78a:	55 c0       	rjmp	.+170    	; 0x836 <receive_message+0xd6>
     78c:	08 f4       	brcc	.+2      	; 0x790 <receive_message+0x30>
     78e:	50 c0       	rjmp	.+160    	; 0x830 <receive_message+0xd0>
     790:	96 30       	cpi	r25, 0x06	; 6
     792:	09 f4       	brne	.+2      	; 0x796 <receive_message+0x36>
     794:	60 c0       	rjmp	.+192    	; 0x856 <receive_message+0xf6>
     796:	97 30       	cpi	r25, 0x07	; 7
     798:	09 f0       	breq	.+2      	; 0x79c <receive_message+0x3c>
     79a:	7b c0       	rjmp	.+246    	; 0x892 <receive_message+0x132>
     79c:	6b c0       	rjmp	.+214    	; 0x874 <receive_message+0x114>
  {
    case VCP_COMPONENT_ON:
	
	  // Reset CDH IB Heartbeat timer
	  timer1_counter[1] = CYCLE_COUNTER_2;
     79e:	8c e2       	ldi	r24, 0x2C	; 44
     7a0:	80 93 bf 0e 	sts	0x0EBF, r24
	  
      if ( svit[payload].switch_num != SW_NULL )
     7a4:	84 e2       	ldi	r24, 0x24	; 36
     7a6:	80 9f       	mul	r24, r16
     7a8:	e0 01       	movw	r28, r0
     7aa:	81 9f       	mul	r24, r17
     7ac:	d0 0d       	add	r29, r0
     7ae:	11 24       	eor	r1, r1
     7b0:	c4 5c       	subi	r28, 0xC4	; 196
     7b2:	dc 4f       	sbci	r29, 0xFC	; 252
     7b4:	89 81       	ldd	r24, Y+1	; 0x01
     7b6:	8f 3f       	cpi	r24, 0xFF	; 255
     7b8:	21 f0       	breq	.+8      	; 0x7c2 <receive_message+0x62>
      {
        switch_on( svit[payload].switch_num );
     7ba:	0e 94 28 0a 	call	0x1450	; 0x1450 <switch_on>
        svit[payload].switch_state = 1;
     7be:	81 e0       	ldi	r24, 0x01	; 1
     7c0:	8a 83       	std	Y+2, r24	; 0x02
      }
      transmit_packet( uart, VCP_ACK, command );
     7c2:	40 e0       	ldi	r20, 0x00	; 0
     7c4:	0f c0       	rjmp	.+30     	; 0x7e4 <receive_message+0x84>
      break;
    case VCP_COMPONENT_OFF:
      if ( svit[payload].switch_num != SW_NULL )
     7c6:	84 e2       	ldi	r24, 0x24	; 36
     7c8:	80 9f       	mul	r24, r16
     7ca:	e0 01       	movw	r28, r0
     7cc:	81 9f       	mul	r24, r17
     7ce:	d0 0d       	add	r29, r0
     7d0:	11 24       	eor	r1, r1
     7d2:	c4 5c       	subi	r28, 0xC4	; 196
     7d4:	dc 4f       	sbci	r29, 0xFC	; 252
     7d6:	89 81       	ldd	r24, Y+1	; 0x01
     7d8:	8f 3f       	cpi	r24, 0xFF	; 255
     7da:	19 f0       	breq	.+6      	; 0x7e2 <receive_message+0x82>
      {
        switch_off( svit[payload].switch_num );
     7dc:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <switch_off>
        svit[payload].switch_state = 0;
     7e0:	1a 82       	std	Y+2, r1	; 0x02
      }
      transmit_packet( uart, VCP_ACK, command );
     7e2:	41 e0       	ldi	r20, 0x01	; 1
     7e4:	62 e0       	ldi	r22, 0x02	; 2
     7e6:	57 c0       	rjmp	.+174    	; 0x896 <receive_message+0x136>
      break;
    case VCP_POWER_CYCLE:
      if ( svit[payload].switch_num != SW_NULL )
     7e8:	84 e2       	ldi	r24, 0x24	; 36
     7ea:	80 9f       	mul	r24, r16
     7ec:	e0 01       	movw	r28, r0
     7ee:	81 9f       	mul	r24, r17
     7f0:	d0 0d       	add	r29, r0
     7f2:	11 24       	eor	r1, r1
     7f4:	c4 5c       	subi	r28, 0xC4	; 196
     7f6:	dc 4f       	sbci	r29, 0xFC	; 252
     7f8:	89 81       	ldd	r24, Y+1	; 0x01
     7fa:	8f 3f       	cpi	r24, 0xFF	; 255
     7fc:	19 f0       	breq	.+6      	; 0x804 <receive_message+0xa4>
      {
        switch_off( svit[payload].switch_num );
     7fe:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <switch_off>
        svit[payload].switch_state = 0;
     802:	1a 82       	std	Y+2, r1	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     804:	85 e0       	ldi	r24, 0x05	; 5
     806:	8a 95       	dec	r24
     808:	f1 f7       	brne	.-4      	; 0x806 <receive_message+0xa6>
      }
      _delay_us(1);
      if ( svit[payload].switch_num != SW_NULL )
     80a:	84 e2       	ldi	r24, 0x24	; 36
     80c:	80 9f       	mul	r24, r16
     80e:	e0 01       	movw	r28, r0
     810:	81 9f       	mul	r24, r17
     812:	d0 0d       	add	r29, r0
     814:	11 24       	eor	r1, r1
     816:	c4 5c       	subi	r28, 0xC4	; 196
     818:	dc 4f       	sbci	r29, 0xFC	; 252
     81a:	89 81       	ldd	r24, Y+1	; 0x01
     81c:	8f 3f       	cpi	r24, 0xFF	; 255
     81e:	21 f0       	breq	.+8      	; 0x828 <receive_message+0xc8>
      {
        switch_on( svit[payload].switch_num );
     820:	0e 94 28 0a 	call	0x1450	; 0x1450 <switch_on>
        svit[payload].switch_state = 1;
     824:	81 e0       	ldi	r24, 0x01	; 1
     826:	8a 83       	std	Y+2, r24	; 0x02
      }
      transmit_packet( uart, VCP_ACK, command );
     828:	42 e0       	ldi	r20, 0x02	; 2
     82a:	dc cf       	rjmp	.-72     	; 0x7e4 <receive_message+0x84>
      break;
    case VCP_TORQ_CTRL:
      transmit_packet( uart, VCP_ACK, command );
     82c:	43 e0       	ldi	r20, 0x03	; 3
     82e:	da cf       	rjmp	.-76     	; 0x7e4 <receive_message+0x84>
      break;
    case VCP_GET_TELEMETRY:
      transmit_packet( uart, VCP_POWER_TELEMETRY, 0);
     830:	40 e0       	ldi	r20, 0x00	; 0
     832:	60 e0       	ldi	r22, 0x00	; 0
     834:	30 c0       	rjmp	.+96     	; 0x896 <receive_message+0x136>
      break;
    case VCP_FORCE_ON:
      if ( svit[payload].switch_num != SW_NULL )
     836:	84 e2       	ldi	r24, 0x24	; 36
     838:	c8 9f       	mul	r28, r24
     83a:	e0 01       	movw	r28, r0
     83c:	11 24       	eor	r1, r1
     83e:	c4 5c       	subi	r28, 0xC4	; 196
     840:	dc 4f       	sbci	r29, 0xFC	; 252
     842:	89 81       	ldd	r24, Y+1	; 0x01
     844:	8f 3f       	cpi	r24, 0xFF	; 255
     846:	29 f0       	breq	.+10     	; 0x852 <receive_message+0xf2>
      {
        switch_on( svit[payload].switch_num );
     848:	0e 94 28 0a 	call	0x1450	; 0x1450 <switch_on>
        svit[payload].switch_state = 1;
     84c:	81 e0       	ldi	r24, 0x01	; 1
     84e:	8a 83       	std	Y+2, r24	; 0x02
        svit[payload].force_on = 1;  
     850:	8b 83       	std	Y+3, r24	; 0x03
      }
      transmit_packet( uart, VCP_ACK, command );                                                            
     852:	45 e0       	ldi	r20, 0x05	; 5
     854:	c7 cf       	rjmp	.-114    	; 0x7e4 <receive_message+0x84>
      break;
    case VCP_CRIT_V_CHANGE:
      if ( svit[payload].switch_num != SW_NULL )
     856:	84 e2       	ldi	r24, 0x24	; 36
     858:	c8 9f       	mul	r28, r24
     85a:	e0 01       	movw	r28, r0
     85c:	11 24       	eor	r1, r1
     85e:	c4 5c       	subi	r28, 0xC4	; 196
     860:	dc 4f       	sbci	r29, 0xFC	; 252
     862:	89 81       	ldd	r24, Y+1	; 0x01
     864:	8f 3f       	cpi	r24, 0xFF	; 255
     866:	f9 f0       	breq	.+62     	; 0x8a6 <receive_message+0x146>
      {
        svit[payload].V_upper_limit = message[VCP_PAYLOAD_FIELD + 1];
     868:	82 81       	ldd	r24, Z+2	; 0x02
     86a:	8e 83       	std	Y+6, r24	; 0x06
        V_upper_val_change= message[VCP_PAYLOAD_FIELD + 1];
     86c:	82 81       	ldd	r24, Z+2	; 0x02
     86e:	80 93 9d 0c 	sts	0x0C9D, r24
     872:	19 c0       	rjmp	.+50     	; 0x8a6 <receive_message+0x146>
      }
      //transmit_packet( uart, VCP_ACK, 0);
      break;
        case VCP_CRIT_I_CHANGE:
      if ( svit[payload].switch_num != SW_NULL )
     874:	84 e2       	ldi	r24, 0x24	; 36
     876:	c8 9f       	mul	r28, r24
     878:	e0 01       	movw	r28, r0
     87a:	11 24       	eor	r1, r1
     87c:	c4 5c       	subi	r28, 0xC4	; 196
     87e:	dc 4f       	sbci	r29, 0xFC	; 252
     880:	89 81       	ldd	r24, Y+1	; 0x01
     882:	8f 3f       	cpi	r24, 0xFF	; 255
     884:	81 f0       	breq	.+32     	; 0x8a6 <receive_message+0x146>
      {
        svit[payload].I_upper_limit = message[VCP_PAYLOAD_FIELD + 1];
     886:	82 81       	ldd	r24, Z+2	; 0x02
     888:	8f 87       	std	Y+15, r24	; 0x0f
        I_upper_val_change= message[VCP_PAYLOAD_FIELD + 1];
     88a:	82 81       	ldd	r24, Z+2	; 0x02
     88c:	80 93 98 0c 	sts	0x0C98, r24
     890:	0a c0       	rjmp	.+20     	; 0x8a6 <receive_message+0x146>
      }
      //transmit_packet( uart, VCP_ACK, 0);
      break;
    default:
      transmit_packet( uart, VCP_INVALID_COMMAND, 0 );
     892:	40 e0       	ldi	r20, 0x00	; 0
     894:	61 e0       	ldi	r22, 0x01	; 1
     896:	8f 2d       	mov	r24, r15
      break;
  }
}
     898:	df 91       	pop	r29
     89a:	cf 91       	pop	r28
     89c:	1f 91       	pop	r17
     89e:	0f 91       	pop	r16
     8a0:	ff 90       	pop	r15
        I_upper_val_change= message[VCP_PAYLOAD_FIELD + 1];
      }
      //transmit_packet( uart, VCP_ACK, 0);
      break;
    default:
      transmit_packet( uart, VCP_INVALID_COMMAND, 0 );
     8a2:	0c 94 05 13 	jmp	0x260a	; 0x260a <transmit_packet>
      break;
  }
}
     8a6:	df 91       	pop	r29
     8a8:	cf 91       	pop	r28
     8aa:	1f 91       	pop	r17
     8ac:	0f 91       	pop	r16
     8ae:	ff 90       	pop	r15
     8b0:	08 95       	ret

000008b2 <StateofCharge>:


uint8_t antioptimizer = 0;
void StateofCharge(void){
     8b2:	cf 93       	push	r28
	
	
	if(batt1_voltage < 0xFF  &&  hasCheckedCurr){
     8b4:	20 91 90 0a 	lds	r18, 0x0A90
     8b8:	30 91 91 0a 	lds	r19, 0x0A91
     8bc:	2f 3f       	cpi	r18, 0xFF	; 255
     8be:	31 05       	cpc	r19, r1
     8c0:	08 f0       	brcs	.+2      	; 0x8c4 <StateofCharge+0x12>
     8c2:	d1 c0       	rjmp	.+418    	; 0xa66 <StateofCharge+0x1b4>
     8c4:	80 91 7e 0a 	lds	r24, 0x0A7E
     8c8:	88 23       	and	r24, r24
     8ca:	09 f4       	brne	.+2      	; 0x8ce <StateofCharge+0x1c>
     8cc:	cc c0       	rjmp	.+408    	; 0xa66 <StateofCharge+0x1b4>
		
		if(solar1_current > 0x00){
     8ce:	80 91 92 0a 	lds	r24, 0x0A92
     8d2:	88 23       	and	r24, r24
     8d4:	21 f0       	breq	.+8      	; 0x8de <StateofCharge+0x2c>
			isCharging = 1;
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	80 93 ca 0e 	sts	0x0ECA, r24
     8dc:	02 c0       	rjmp	.+4      	; 0x8e2 <StateofCharge+0x30>
		}else{
			isCharging = 0;
     8de:	10 92 ca 0e 	sts	0x0ECA, r1
		}
	
		
		if(  (isCharging && (batt1_voltage <= 0x7E) && (batt1_voltage > 0x64)) || (!isCharging && (batt1_voltage <= 0x77) && (batt1_voltage > 0x64)) ){
     8e2:	80 91 ca 0e 	lds	r24, 0x0ECA
     8e6:	88 23       	and	r24, r24
     8e8:	21 f0       	breq	.+8      	; 0x8f2 <StateofCharge+0x40>
     8ea:	2f 37       	cpi	r18, 0x7F	; 127
     8ec:	31 05       	cpc	r19, r1
     8ee:	28 f0       	brcs	.+10     	; 0x8fa <StateofCharge+0x48>
     8f0:	ae c0       	rjmp	.+348    	; 0xa4e <StateofCharge+0x19c>
     8f2:	28 37       	cpi	r18, 0x78	; 120
     8f4:	31 05       	cpc	r19, r1
     8f6:	08 f0       	brcs	.+2      	; 0x8fa <StateofCharge+0x48>
     8f8:	aa c0       	rjmp	.+340    	; 0xa4e <StateofCharge+0x19c>
     8fa:	25 36       	cpi	r18, 0x65	; 101
     8fc:	31 05       	cpc	r19, r1
     8fe:	08 f4       	brcc	.+2      	; 0x902 <StateofCharge+0x50>
     900:	a1 c0       	rjmp	.+322    	; 0xa44 <StateofCharge+0x192>
			antioptimizer++;
     902:	c0 91 06 03 	lds	r28, 0x0306
     906:	9c 2f       	mov	r25, r28
     908:	9f 5f       	subi	r25, 0xFF	; 255
     90a:	90 93 06 03 	sts	0x0306, r25
			if(isCharging){
     90e:	88 23       	and	r24, r24
     910:	09 f4       	brne	.+2      	; 0x914 <StateofCharge+0x62>
     912:	46 c0       	rjmp	.+140    	; 0x9a0 <StateofCharge+0xee>
     914:	40 91 a1 0e 	lds	r20, 0x0EA1
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     918:	2a 36       	cpi	r18, 0x6A	; 106
     91a:	31 05       	cpc	r19, r1
     91c:	28 f4       	brcc	.+10     	; 0x928 <StateofCharge+0x76>
     91e:	84 2f       	mov	r24, r20
     920:	82 95       	swap	r24
     922:	86 95       	lsr	r24
     924:	86 95       	lsr	r24
     926:	12 c0       	rjmp	.+36     	; 0x94c <StateofCharge+0x9a>
				            ((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
     928:	c9 01       	movw	r24, r18
     92a:	8a 56       	subi	r24, 0x6A	; 106
     92c:	91 09       	sbc	r25, r1
		
		if(  (isCharging && (batt1_voltage <= 0x7E) && (batt1_voltage > 0x64)) || (!isCharging && (batt1_voltage <= 0x77) && (batt1_voltage > 0x64)) ){
			antioptimizer++;
			if(isCharging){
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     92e:	0a 97       	sbiw	r24, 0x0a	; 10
     930:	38 f4       	brcc	.+14     	; 0x940 <StateofCharge+0x8e>
				            ((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
     932:	84 2f       	mov	r24, r20
     934:	82 95       	swap	r24
     936:	86 95       	lsr	r24
     938:	86 95       	lsr	r24
     93a:	83 70       	andi	r24, 0x03	; 3
     93c:	8f 5f       	subi	r24, 0xFF	; 255
     93e:	06 c0       	rjmp	.+12     	; 0x94c <StateofCharge+0x9a>
							(batt1_voltage >= 0x74) ? (((batt1_voltageLow >> 6) + 2) % 0x04) :
     940:	84 2f       	mov	r24, r20
     942:	82 95       	swap	r24
     944:	86 95       	lsr	r24
     946:	86 95       	lsr	r24
     948:	83 70       	andi	r24, 0x03	; 3
     94a:	8e 5f       	subi	r24, 0xFE	; 254
		
		if(  (isCharging && (batt1_voltage <= 0x7E) && (batt1_voltage > 0x64)) || (!isCharging && (batt1_voltage <= 0x77) && (batt1_voltage > 0x64)) ){
			antioptimizer++;
			if(isCharging){
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     94c:	83 70       	andi	r24, 0x03	; 3
     94e:	80 93 bd 0e 	sts	0x0EBD, r24
				            ((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
							(batt1_voltage >= 0x74) ? (((batt1_voltageLow >> 6) + 2) % 0x04) :
							0x00; 
				percent = (charge20Pc[(batt1_voltage - 0x65)*4 + ltOffset] - 11) / (10.57);
     952:	f9 01       	movw	r30, r18
     954:	e5 56       	subi	r30, 0x65	; 101
     956:	f0 4c       	sbci	r31, 0xC0	; 192
     958:	ee 0f       	add	r30, r30
     95a:	ff 1f       	adc	r31, r31
     95c:	ee 0f       	add	r30, r30
     95e:	ff 1f       	adc	r31, r31
     960:	e8 0f       	add	r30, r24
     962:	f1 1d       	adc	r31, r1
     964:	ee 0f       	add	r30, r30
     966:	ff 1f       	adc	r31, r31
     968:	e4 57       	subi	r30, 0x74	; 116
     96a:	ff 4f       	sbci	r31, 0xFF	; 255
     96c:	65 91       	lpm	r22, Z+
     96e:	74 91       	lpm	r23, Z
     970:	6b 50       	subi	r22, 0x0B	; 11
     972:	71 09       	sbc	r23, r1
     974:	80 e0       	ldi	r24, 0x00	; 0
     976:	90 e0       	ldi	r25, 0x00	; 0
     978:	0e 94 af 14 	call	0x295e	; 0x295e <__floatunsisf>
     97c:	28 eb       	ldi	r18, 0xB8	; 184
     97e:	3e e1       	ldi	r19, 0x1E	; 30
     980:	49 e2       	ldi	r20, 0x29	; 41
     982:	51 e4       	ldi	r21, 0x41	; 65
     984:	0e 94 1b 14 	call	0x2836	; 0x2836 <__divsf3>
     988:	60 93 53 08 	sts	0x0853, r22
     98c:	70 93 54 08 	sts	0x0854, r23
     990:	80 93 55 08 	sts	0x0855, r24
     994:	90 93 56 08 	sts	0x0856, r25
				antioptimizer+=6;
     998:	c9 5f       	subi	r28, 0xF9	; 249
     99a:	c0 93 06 03 	sts	0x0306, r28
     99e:	63 c0       	rjmp	.+198    	; 0xa66 <StateofCharge+0x1b4>
				
			}else{
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     9a0:	2a 36       	cpi	r18, 0x6A	; 106
     9a2:	31 05       	cpc	r19, r1
     9a4:	30 f4       	brcc	.+12     	; 0x9b2 <StateofCharge+0x100>
     9a6:	80 91 a1 0e 	lds	r24, 0x0EA1
     9aa:	82 95       	swap	r24
     9ac:	86 95       	lsr	r24
     9ae:	86 95       	lsr	r24
     9b0:	19 c0       	rjmp	.+50     	; 0x9e4 <StateofCharge+0x132>
							((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
     9b2:	c9 01       	movw	r24, r18
     9b4:	8a 56       	subi	r24, 0x6A	; 106
     9b6:	91 09       	sbc	r25, r1
				percent = (charge20Pc[(batt1_voltage - 0x65)*4 + ltOffset] - 11) / (10.57);
				antioptimizer+=6;
				
			}else{
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     9b8:	0a 97       	sbiw	r24, 0x0a	; 10
     9ba:	40 f4       	brcc	.+16     	; 0x9cc <StateofCharge+0x11a>
							((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
     9bc:	80 91 a1 0e 	lds	r24, 0x0EA1
     9c0:	82 95       	swap	r24
     9c2:	86 95       	lsr	r24
     9c4:	86 95       	lsr	r24
     9c6:	83 70       	andi	r24, 0x03	; 3
     9c8:	8f 5f       	subi	r24, 0xFF	; 255
     9ca:	0c c0       	rjmp	.+24     	; 0x9e4 <StateofCharge+0x132>
							((batt1_voltage >= 0x74) && (batt1_voltage <= 0x76)) ? (((batt1_voltageLow >> 6) + 2) % 0x04) :
     9cc:	c9 01       	movw	r24, r18
     9ce:	84 57       	subi	r24, 0x74	; 116
     9d0:	91 09       	sbc	r25, r1
				percent = (charge20Pc[(batt1_voltage - 0x65)*4 + ltOffset] - 11) / (10.57);
				antioptimizer+=6;
				
			}else{
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     9d2:	03 97       	sbiw	r24, 0x03	; 3
     9d4:	48 f4       	brcc	.+18     	; 0x9e8 <StateofCharge+0x136>
							((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
							((batt1_voltage >= 0x74) && (batt1_voltage <= 0x76)) ? (((batt1_voltageLow >> 6) + 2) % 0x04) :
     9d6:	80 91 a1 0e 	lds	r24, 0x0EA1
     9da:	82 95       	swap	r24
     9dc:	86 95       	lsr	r24
     9de:	86 95       	lsr	r24
     9e0:	83 70       	andi	r24, 0x03	; 3
     9e2:	8e 5f       	subi	r24, 0xFE	; 254
				percent = (charge20Pc[(batt1_voltage - 0x65)*4 + ltOffset] - 11) / (10.57);
				antioptimizer+=6;
				
			}else{
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     9e4:	83 70       	andi	r24, 0x03	; 3
     9e6:	01 c0       	rjmp	.+2      	; 0x9ea <StateofCharge+0x138>
     9e8:	80 e0       	ldi	r24, 0x00	; 0
     9ea:	80 93 bd 0e 	sts	0x0EBD, r24
							((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
							((batt1_voltage >= 0x74) && (batt1_voltage <= 0x76)) ? (((batt1_voltageLow >> 6) + 2) % 0x04) :
							0x00;
				
				percent = 100 - ((discharge20Pc[(0x77 - batt1_voltage)*4 - ltOffset]) ) / (10.07);
     9ee:	4c ef       	ldi	r20, 0xFC	; 252
     9f0:	42 03       	mulsu	r20, r18
     9f2:	f0 01       	movw	r30, r0
     9f4:	43 9f       	mul	r20, r19
     9f6:	f0 0d       	add	r31, r0
     9f8:	11 24       	eor	r1, r1
     9fa:	e4 52       	subi	r30, 0x24	; 36
     9fc:	fe 4f       	sbci	r31, 0xFE	; 254
     9fe:	e8 1b       	sub	r30, r24
     a00:	f1 09       	sbc	r31, r1
     a02:	ee 0f       	add	r30, r30
     a04:	ff 1f       	adc	r31, r31
     a06:	e8 59       	subi	r30, 0x98	; 152
     a08:	fe 4f       	sbci	r31, 0xFE	; 254
     a0a:	65 91       	lpm	r22, Z+
     a0c:	74 91       	lpm	r23, Z
     a0e:	80 e0       	ldi	r24, 0x00	; 0
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	0e 94 af 14 	call	0x295e	; 0x295e <__floatunsisf>
     a16:	28 eb       	ldi	r18, 0xB8	; 184
     a18:	3e e1       	ldi	r19, 0x1E	; 30
     a1a:	41 e2       	ldi	r20, 0x21	; 33
     a1c:	51 e4       	ldi	r21, 0x41	; 65
     a1e:	0e 94 1b 14 	call	0x2836	; 0x2836 <__divsf3>
     a22:	9b 01       	movw	r18, r22
     a24:	ac 01       	movw	r20, r24
     a26:	60 e0       	ldi	r22, 0x00	; 0
     a28:	70 e0       	ldi	r23, 0x00	; 0
     a2a:	88 ec       	ldi	r24, 0xC8	; 200
     a2c:	92 e4       	ldi	r25, 0x42	; 66
     a2e:	0e 94 b2 13 	call	0x2764	; 0x2764 <__subsf3>
     a32:	60 93 53 08 	sts	0x0853, r22
     a36:	70 93 54 08 	sts	0x0854, r23
     a3a:	80 93 55 08 	sts	0x0855, r24
     a3e:	90 93 56 08 	sts	0x0856, r25
     a42:	11 c0       	rjmp	.+34     	; 0xa66 <StateofCharge+0x1b4>
			}
		}else if(batt1_voltage <= 0x64){
			percent = -1;
     a44:	80 e0       	ldi	r24, 0x00	; 0
     a46:	90 e0       	ldi	r25, 0x00	; 0
     a48:	a0 e8       	ldi	r26, 0x80	; 128
     a4a:	bf eb       	ldi	r27, 0xBF	; 191
     a4c:	04 c0       	rjmp	.+8      	; 0xa56 <StateofCharge+0x1a4>
		}else if(  ((batt1_voltage > 0x7E)&&isCharging) || ((!isCharging)&&(batt1_voltage > 0x77)) ){
			percent = 108;
     a4e:	80 e0       	ldi	r24, 0x00	; 0
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	a8 ed       	ldi	r26, 0xD8	; 216
     a54:	b2 e4       	ldi	r27, 0x42	; 66
     a56:	80 93 53 08 	sts	0x0853, r24
     a5a:	90 93 54 08 	sts	0x0854, r25
     a5e:	a0 93 55 08 	sts	0x0855, r26
     a62:	b0 93 56 08 	sts	0x0856, r27
		}
		
	}
	
	if(solar1_current < 0xFF && solar1_current > 0x00){
     a66:	80 91 92 0a 	lds	r24, 0x0A92
     a6a:	81 50       	subi	r24, 0x01	; 1
     a6c:	8e 3f       	cpi	r24, 0xFE	; 254
     a6e:	28 f4       	brcc	.+10     	; 0xa7a <StateofCharge+0x1c8>
		antioptimizer++;
     a70:	80 91 06 03 	lds	r24, 0x0306
     a74:	8f 5f       	subi	r24, 0xFF	; 255
     a76:	80 93 06 03 	sts	0x0306, r24
	}
	
	
}
     a7a:	cf 91       	pop	r28
     a7c:	08 95       	ret

00000a7e <assign_charge_fit>:



/* Assigns values to the Fourier coefficients of the charge approximation */
void assign_charge_fit( void ) {
  charge_max_time = 10188;
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	90 e3       	ldi	r25, 0x30	; 48
     a82:	af e1       	ldi	r26, 0x1F	; 31
     a84:	b6 e4       	ldi	r27, 0x46	; 70
     a86:	80 93 94 0a 	sts	0x0A94, r24
     a8a:	90 93 95 0a 	sts	0x0A95, r25
     a8e:	a0 93 96 0a 	sts	0x0A96, r26
     a92:	b0 93 97 0a 	sts	0x0A97, r27
  // x is normalized by mean 13.13 and std 0.1754
  p1 = 18.57;
     a96:	8c e5       	ldi	r24, 0x5C	; 92
     a98:	9f e8       	ldi	r25, 0x8F	; 143
     a9a:	a4 e9       	ldi	r26, 0x94	; 148
     a9c:	b1 e4       	ldi	r27, 0x41	; 65
     a9e:	80 93 6d 0a 	sts	0x0A6D, r24
     aa2:	90 93 6e 0a 	sts	0x0A6E, r25
     aa6:	a0 93 6f 0a 	sts	0x0A6F, r26
     aaa:	b0 93 70 0a 	sts	0x0A70, r27
  p2 = 184.8;
     aae:	8d ec       	ldi	r24, 0xCD	; 205
     ab0:	9c ec       	ldi	r25, 0xCC	; 204
     ab2:	a8 e3       	ldi	r26, 0x38	; 56
     ab4:	b3 e4       	ldi	r27, 0x43	; 67
     ab6:	80 93 25 03 	sts	0x0325, r24
     aba:	90 93 26 03 	sts	0x0326, r25
     abe:	a0 93 27 03 	sts	0x0327, r26
     ac2:	b0 93 28 03 	sts	0x0328, r27
  p3 = 663.6;
     ac6:	86 e6       	ldi	r24, 0x66	; 102
     ac8:	96 ee       	ldi	r25, 0xE6	; 230
     aca:	a5 e2       	ldi	r26, 0x25	; 37
     acc:	b4 e4       	ldi	r27, 0x44	; 68
     ace:	80 93 b1 0e 	sts	0x0EB1, r24
     ad2:	90 93 b2 0e 	sts	0x0EB2, r25
     ad6:	a0 93 b3 0e 	sts	0x0EB3, r26
     ada:	b0 93 b4 0e 	sts	0x0EB4, r27
  p4 = 838.6;
     ade:	86 e6       	ldi	r24, 0x66	; 102
     ae0:	96 ea       	ldi	r25, 0xA6	; 166
     ae2:	a1 e5       	ldi	r26, 0x51	; 81
     ae4:	b4 e4       	ldi	r27, 0x44	; 68
     ae6:	80 93 cd 0e 	sts	0x0ECD, r24
     aea:	90 93 ce 0e 	sts	0x0ECE, r25
     aee:	a0 93 cf 0e 	sts	0x0ECF, r26
     af2:	b0 93 d0 0e 	sts	0x0ED0, r27
  //where x is normalized by mean 13.7 and std 0.1558
  q1 = 78.49;
     af6:	81 ee       	ldi	r24, 0xE1	; 225
     af8:	9a ef       	ldi	r25, 0xFA	; 250
     afa:	ac e9       	ldi	r26, 0x9C	; 156
     afc:	b2 e4       	ldi	r27, 0x42	; 66
     afe:	80 93 8b 0a 	sts	0x0A8B, r24
     b02:	90 93 8c 0a 	sts	0x0A8C, r25
     b06:	a0 93 8d 0a 	sts	0x0A8D, r26
     b0a:	b0 93 8e 0a 	sts	0x0A8E, r27
  q2 = 543.1;
     b0e:	86 e6       	ldi	r24, 0x66	; 102
     b10:	96 ec       	ldi	r25, 0xC6	; 198
     b12:	a7 e0       	ldi	r26, 0x07	; 7
     b14:	b4 e4       	ldi	r27, 0x44	; 68
     b16:	80 93 4c 08 	sts	0x084C, r24
     b1a:	90 93 4d 08 	sts	0x084D, r25
     b1e:	a0 93 4e 08 	sts	0x084E, r26
     b22:	b0 93 4f 08 	sts	0x084F, r27
  q3 = 2427;
     b26:	80 e0       	ldi	r24, 0x00	; 0
     b28:	90 eb       	ldi	r25, 0xB0	; 176
     b2a:	a7 e1       	ldi	r26, 0x17	; 23
     b2c:	b5 e4       	ldi	r27, 0x45	; 69
     b2e:	80 93 87 0a 	sts	0x0A87, r24
     b32:	90 93 88 0a 	sts	0x0A88, r25
     b36:	a0 93 89 0a 	sts	0x0A89, r26
     b3a:	b0 93 8a 0a 	sts	0x0A8A, r27
  q4 = 5587;
     b3e:	80 e0       	ldi	r24, 0x00	; 0
     b40:	98 e9       	ldi	r25, 0x98	; 152
     b42:	ae ea       	ldi	r26, 0xAE	; 174
     b44:	b5 e4       	ldi	r27, 0x45	; 69
     b46:	80 93 c2 0e 	sts	0x0EC2, r24
     b4a:	90 93 c3 0e 	sts	0x0EC3, r25
     b4e:	a0 93 c4 0e 	sts	0x0EC4, r26
     b52:	b0 93 c5 0e 	sts	0x0EC5, r27
     b56:	08 95       	ret

00000b58 <assign_discharge_fit>:
}

/* Assigns values to the Fourier coefficients of the discharge approximation */

void assign_discharge_fit( void ) {
  discharge_max_time = 17547;
     b58:	80 e0       	ldi	r24, 0x00	; 0
     b5a:	96 e1       	ldi	r25, 0x16	; 22
     b5c:	a9 e8       	ldi	r26, 0x89	; 137
     b5e:	b6 e4       	ldi	r27, 0x46	; 70
     b60:	80 93 61 08 	sts	0x0861, r24
     b64:	90 93 62 08 	sts	0x0862, r25
     b68:	a0 93 63 08 	sts	0x0863, r26
     b6c:	b0 93 64 08 	sts	0x0864, r27
  f0 = -1.543291233254410E4;
     b70:	88 eb       	ldi	r24, 0xB8	; 184
     b72:	93 ec       	ldi	r25, 0xC3	; 195
     b74:	90 93 aa 0e 	sts	0x0EAA, r25
     b78:	80 93 a9 0e 	sts	0x0EA9, r24
  f1 = -1.819810644993805E4;
     b7c:	8a ee       	ldi	r24, 0xEA	; 234
     b7e:	98 eb       	ldi	r25, 0xB8	; 184
     b80:	90 93 b8 0e 	sts	0x0EB8, r25
     b84:	80 93 b7 0e 	sts	0x0EB7, r24
  b1 = -2.548949173344369E4;
     b88:	8f e6       	ldi	r24, 0x6F	; 111
     b8a:	9c e9       	ldi	r25, 0x9C	; 156
     b8c:	90 93 51 08 	sts	0x0851, r25
     b90:	80 93 50 08 	sts	0x0850, r24
  f2 = 1.141365113433748E4;
     b94:	85 e9       	ldi	r24, 0x95	; 149
     b96:	9c e2       	ldi	r25, 0x2C	; 44
     b98:	90 93 84 0a 	sts	0x0A84, r25
     b9c:	80 93 83 0a 	sts	0x0A83, r24
  b2 = -2.190399298389397E4;
     ba0:	81 e7       	ldi	r24, 0x71	; 113
     ba2:	9a ea       	ldi	r25, 0xAA	; 170
     ba4:	90 93 23 03 	sts	0x0323, r25
     ba8:	80 93 22 03 	sts	0x0322, r24
  f3 = 1.453849538420288E4;
     bac:	8a ec       	ldi	r24, 0xCA	; 202
     bae:	98 e3       	ldi	r25, 0x38	; 56
     bb0:	90 93 78 0a 	sts	0x0A78, r25
     bb4:	80 93 77 0a 	sts	0x0A77, r24
  b3 = 7.700208204268025E2;
     bb8:	82 e0       	ldi	r24, 0x02	; 2
     bba:	93 e0       	ldi	r25, 0x03	; 3
     bbc:	90 93 ac 0e 	sts	0x0EAC, r25
     bc0:	80 93 ab 0e 	sts	0x0EAB, r24
  f4 = 1.965482651710955E3;
     bc4:	8d ea       	ldi	r24, 0xAD	; 173
     bc6:	97 e0       	ldi	r25, 0x07	; 7
     bc8:	90 93 b6 0e 	sts	0x0EB6, r25
     bcc:	80 93 b5 0e 	sts	0x0EB5, r24
  b4 = 5.504490550919407E3;
     bd0:	80 e8       	ldi	r24, 0x80	; 128
     bd2:	95 e1       	ldi	r25, 0x15	; 21
     bd4:	90 93 6c 08 	sts	0x086C, r25
     bd8:	80 93 6b 08 	sts	0x086B, r24
  f5 = -9.466488439471518E2;
     bdc:	8e e4       	ldi	r24, 0x4E	; 78
     bde:	9c ef       	ldi	r25, 0xFC	; 252
     be0:	90 93 69 08 	sts	0x0869, r25
     be4:	80 93 68 08 	sts	0x0868, r24
  b5 = 8.270458368650347E2;
     be8:	8b e3       	ldi	r24, 0x3B	; 59
     bea:	93 e0       	ldi	r25, 0x03	; 3
     bec:	90 93 a8 0e 	sts	0x0EA8, r25
     bf0:	80 93 a7 0e 	sts	0x0EA7, r24
  w = 2.725333178515558;
     bf4:	8c ed       	ldi	r24, 0xDC	; 220
     bf6:	9b e6       	ldi	r25, 0x6B	; 107
     bf8:	ae e2       	ldi	r26, 0x2E	; 46
     bfa:	b0 e4       	ldi	r27, 0x40	; 64
     bfc:	80 93 57 08 	sts	0x0857, r24
     c00:	90 93 58 08 	sts	0x0858, r25
     c04:	a0 93 59 08 	sts	0x0859, r26
     c08:	b0 93 5a 08 	sts	0x085A, r27
  
  h0 = 2.979485572689352E8;
     c0c:	80 e8       	ldi	r24, 0x80	; 128
     c0e:	95 e5       	ldi	r25, 0x55	; 85
     c10:	a2 ec       	ldi	r26, 0xC2	; 194
     c12:	b1 e1       	ldi	r27, 0x11	; 17
     c14:	80 93 7f 0a 	sts	0x0A7F, r24
     c18:	90 93 80 0a 	sts	0x0A80, r25
     c1c:	a0 93 81 0a 	sts	0x0A81, r26
     c20:	b0 93 82 0a 	sts	0x0A82, r27
  h1 = 2.088787459098652E8;
     c24:	80 ea       	ldi	r24, 0xA0	; 160
     c26:	9c e3       	ldi	r25, 0x3C	; 60
     c28:	a3 e7       	ldi	r26, 0x73	; 115
     c2a:	bc e0       	ldi	r27, 0x0C	; 12
     c2c:	80 93 2d 03 	sts	0x032D, r24
     c30:	90 93 2e 03 	sts	0x032E, r25
     c34:	a0 93 2f 03 	sts	0x032F, r26
     c38:	b0 93 30 03 	sts	0x0330, r27
  g1 = 4.359717315569648E8;
     c3c:	80 ea       	ldi	r24, 0xA0	; 160
     c3e:	96 e6       	ldi	r25, 0x66	; 102
     c40:	ac ef       	ldi	r26, 0xFC	; 252
     c42:	b9 e1       	ldi	r27, 0x19	; 25
     c44:	80 93 32 03 	sts	0x0332, r24
     c48:	90 93 33 03 	sts	0x0333, r25
     c4c:	a0 93 34 03 	sts	0x0334, r26
     c50:	b0 93 35 03 	sts	0x0335, r27
  h2 =  -1.569778955752849E8;
     c54:	80 e2       	ldi	r24, 0x20	; 32
     c56:	95 eb       	ldi	r25, 0xB5	; 181
     c58:	a4 ea       	ldi	r26, 0xA4	; 164
     c5a:	b6 ef       	ldi	r27, 0xF6	; 246
     c5c:	80 93 7a 0a 	sts	0x0A7A, r24
     c60:	90 93 7b 0a 	sts	0x0A7B, r25
     c64:	a0 93 7c 0a 	sts	0x0A7C, r26
     c68:	b0 93 7d 0a 	sts	0x0A7D, r27
  g2 =  1.969854815603661E8;
     c6c:	80 e9       	ldi	r24, 0x90	; 144
     c6e:	92 ec       	ldi	r25, 0xC2	; 194
     c70:	ad eb       	ldi	r26, 0xBD	; 189
     c72:	bb e0       	ldi	r27, 0x0B	; 11
     c74:	80 93 72 0a 	sts	0x0A72, r24
     c78:	90 93 73 0a 	sts	0x0A73, r25
     c7c:	a0 93 74 0a 	sts	0x0A74, r26
     c80:	b0 93 75 0a 	sts	0x0A75, r27
  h3 =  -7.513816845838763E7;
     c84:	88 e8       	ldi	r24, 0x88	; 136
     c86:	9b e7       	ldi	r25, 0x7B	; 123
     c88:	a5 e8       	ldi	r26, 0x85	; 133
     c8a:	bb ef       	ldi	r27, 0xFB	; 251
     c8c:	80 93 b9 0e 	sts	0x0EB9, r24
     c90:	90 93 ba 0e 	sts	0x0EBA, r25
     c94:	a0 93 bb 0e 	sts	0x0EBB, r26
     c98:	b0 93 bc 0e 	sts	0x0EBC, r27
  g3 =  -1.633385950799686E7;
     c9c:	8c ed       	ldi	r24, 0xDC	; 220
     c9e:	93 ec       	ldi	r25, 0xC3	; 195
     ca0:	a6 e0       	ldi	r26, 0x06	; 6
     ca2:	bf ef       	ldi	r27, 0xFF	; 255
     ca4:	80 93 1e 03 	sts	0x031E, r24
     ca8:	90 93 1f 03 	sts	0x031F, r25
     cac:	a0 93 20 03 	sts	0x0320, r26
     cb0:	b0 93 21 03 	sts	0x0321, r27
  h4 =   -2.642581886559125E6;
     cb4:	8a e6       	ldi	r24, 0x6A	; 106
     cb6:	9d ea       	ldi	r25, 0xAD	; 173
     cb8:	a7 ed       	ldi	r26, 0xD7	; 215
     cba:	bf ef       	ldi	r27, 0xFF	; 255
     cbc:	80 93 9d 0e 	sts	0x0E9D, r24
     cc0:	90 93 9e 0e 	sts	0x0E9E, r25
     cc4:	a0 93 9f 0e 	sts	0x0E9F, r26
     cc8:	b0 93 a0 0e 	sts	0x0EA0, r27
  g4 =   -1.016608352073227E7;
     ccc:	8c eb       	ldi	r24, 0xBC	; 188
     cce:	90 ee       	ldi	r25, 0xE0	; 224
     cd0:	a4 e6       	ldi	r26, 0x64	; 100
     cd2:	bf ef       	ldi	r27, 0xFF	; 255
     cd4:	80 93 09 03 	sts	0x0309, r24
     cd8:	90 93 0a 03 	sts	0x030A, r25
     cdc:	a0 93 0b 03 	sts	0x030B, r26
     ce0:	b0 93 0c 03 	sts	0x030C, r27
  w2 =  0.364797662747743;
     ce4:	82 ec       	ldi	r24, 0xC2	; 194
     ce6:	96 ec       	ldi	r25, 0xC6	; 198
     ce8:	aa eb       	ldi	r26, 0xBA	; 186
     cea:	be e3       	ldi	r27, 0x3E	; 62
     cec:	80 93 99 0c 	sts	0x0C99, r24
     cf0:	90 93 9a 0c 	sts	0x0C9A, r25
     cf4:	a0 93 9b 0c 	sts	0x0C9B, r26
     cf8:	b0 93 9c 0c 	sts	0x0C9C, r27
     cfc:	08 95       	ret

00000cfe <initialize>:
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       6     );  // Fake Data
}

void initialize( void )
{
     cfe:	ef 92       	push	r14
     d00:	ff 92       	push	r15
     d02:	0f 93       	push	r16
     d04:	1f 93       	push	r17
     d06:	cf 93       	push	r28
     d08:	df 93       	push	r29
   // pin initialization
  DDRA  = 0b11111111;
     d0a:	1f ef       	ldi	r17, 0xFF	; 255
     d0c:	1a bb       	out	0x1a, r17	; 26
  PORTA = 0b00000111;
     d0e:	87 e0       	ldi	r24, 0x07	; 7
     d10:	8b bb       	out	0x1b, r24	; 27

  DDRB  = 0b11111111;
     d12:	17 bb       	out	0x17, r17	; 23
  PORTB = 0b11100000;
     d14:	80 ee       	ldi	r24, 0xE0	; 224
     d16:	88 bb       	out	0x18, r24	; 24

  DDRC  = 0b11111111;
     d18:	14 bb       	out	0x14, r17	; 20
  PORTC = 0b11111111;
     d1a:	15 bb       	out	0x15, r17	; 21

  DDRD  = 0b11111011;
     d1c:	8b ef       	ldi	r24, 0xFB	; 251
     d1e:	81 bb       	out	0x11, r24	; 17
  PORTD = 0b11110000;
     d20:	80 ef       	ldi	r24, 0xF0	; 240
     d22:	82 bb       	out	0x12, r24	; 18

  DDRE  = 0b11111110;
     d24:	8e ef       	ldi	r24, 0xFE	; 254
     d26:	82 b9       	out	0x02, r24	; 2
  PORTE = 0b00000000;
     d28:	13 b8       	out	0x03, r1	; 3

  DDRF  = //0b11110000;
     d2a:	10 93 61 00 	sts	0x0061, r17
  0b11111111;	//testing
  PORTF = 0b00000000;
     d2e:	10 92 62 00 	sts	0x0062, r1

  DDRG  = 0b00011111;
     d32:	8f e1       	ldi	r24, 0x1F	; 31
     d34:	80 93 64 00 	sts	0x0064, r24
  PORTG = 0b00000100;
     d38:	04 e0       	ldi	r16, 0x04	; 4
     d3a:	00 93 65 00 	sts	0x0065, r16
  // compare value = 124
  // compare match interrupt freq = (14.7456 MHz / 1024 / 100) = 144 Hz
  // use timer0_counter to get 144 / 144 = 1 Hz

  // enable clear on match interrupt
  TIMSK = ( 1 << OCIE0 );
     d3e:	82 e0       	ldi	r24, 0x02	; 2
     d40:	87 bf       	out	0x37, r24	; 55
  OCR0 = 71;
     d42:	87 e4       	ldi	r24, 0x47	; 71
     d44:	81 bf       	out	0x31, r24	; 49

  // enable clear on match mode, set prescalar to 1024
  TCCR0 = ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );
     d46:	8f e0       	ldi	r24, 0x0F	; 15
     d48:	83 bf       	out	0x33, r24	; 51

  timer0_counter[0] = 99;
     d4a:	83 e6       	ldi	r24, 0x63	; 99
     d4c:	80 93 96 0c 	sts	0x0C96, r24
  timer0_counter[1] = 199;
     d50:	87 ec       	ldi	r24, 0xC7	; 199
     d52:	80 93 97 0c 	sts	0x0C97, r24
  period of interrupts = 28800 / 14400 Hz = 2 s/interrupt
  use timer1_counter to get a total period of 2*65535 =  s (24 hours is 86400 seconds)
  */
  
  // Enable clear on match interrupt for the 16 bit timer/counter 1, register A
  OCR1A = 28800;		//28800 corresponds to 2 seconds
     d56:	80 e8       	ldi	r24, 0x80	; 128
     d58:	90 e7       	ldi	r25, 0x70	; 112
     d5a:	9b bd       	out	0x2b, r25	; 43
     d5c:	8a bd       	out	0x2a, r24	; 42

  // Enable clear on match mode, set prescalar to 1024.
  // CS[2:0] = 101 (1024 prescalar)
  // WGM[3:0] = 0100 (Clear Timer on Compare (CTC) when timer matches OCR1A)
  
  TCCR1B = ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS10 );
     d5e:	8d e0       	ldi	r24, 0x0D	; 13
     d60:	8e bd       	out	0x2e, r24	; 46
  // Explicit Default Defs
  // TCCR1A |= 0;
  // TCNT1 = 0;
  timer1_counter[0] = CYCLE_COUNTER;	//CYCLE_COUNTER   = 900 for 2 seconds interrupt handler = 1800 secs (30 minutes)
     d62:	84 e8       	ldi	r24, 0x84	; 132
     d64:	80 93 be 0e 	sts	0x0EBE, r24
  timer1_counter[1] = CYCLE_COUNTER_2;	//CYCLE_COUNTER_2 = 300 for 2 seconds interrupt handler = 600 secs  (10 minutes)
     d68:	8c e2       	ldi	r24, 0x2C	; 44
     d6a:	80 93 bf 0e 	sts	0x0EBF, r24
  //---------------------------------------------------------------------  
  // End of timer 1 Setup
  //--------------------------------------------------------------------- 
  
  // communication
  uart_init();
     d6e:	0e 94 4a 0c 	call	0x1894	; 0x1894 <uart_init>

  // for use in debugging
  // stdout = stdin = stderr = &uart_str;

  tel_packet_size[0] = 0;
     d72:	10 92 2a 03 	sts	0x032A, r1
     d76:	10 92 29 03 	sts	0x0329, r1
  tel_packet_size[1] = 0;
     d7a:	10 92 2c 03 	sts	0x032C, r1
     d7e:	10 92 2b 03 	sts	0x032B, r1
  tel_packet_index[0] = 0;
     d82:	10 92 65 08 	sts	0x0865, r1
  tel_packet_index[1] = 0;
     d86:	10 92 66 08 	sts	0x0866, r1
  uart_vcp_buff[0] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     d8a:	8a e0       	ldi	r24, 0x0A	; 10
     d8c:	90 e0       	ldi	r25, 0x00	; 0
     d8e:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <malloc>
     d92:	7c 01       	movw	r14, r24
     d94:	e6 ec       	ldi	r30, 0xC6	; 198
     d96:	fe e0       	ldi	r31, 0x0E	; 14
     d98:	80 83       	st	Z, r24
     d9a:	f1 82       	std	Z+1, r15	; 0x01
  uart_vcp_buff[1] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     d9c:	8a e0       	ldi	r24, 0x0A	; 10
     d9e:	90 e0       	ldi	r25, 0x00	; 0
     da0:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <malloc>
     da4:	c8 ec       	ldi	r28, 0xC8	; 200
     da6:	de e0       	ldi	r29, 0x0E	; 14
     da8:	88 83       	st	Y, r24
     daa:	99 83       	std	Y+1, r25	; 0x01
  vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     dac:	4f ef       	ldi	r20, 0xFF	; 255
     dae:	50 e0       	ldi	r21, 0x00	; 0
     db0:	6f e9       	ldi	r22, 0x9F	; 159
     db2:	7c e0       	ldi	r23, 0x0C	; 12
     db4:	c7 01       	movw	r24, r14
     db6:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vcpptr_init>
  vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     dba:	4f ef       	ldi	r20, 0xFF	; 255
     dbc:	50 e0       	ldi	r21, 0x00	; 0
     dbe:	6e e9       	ldi	r22, 0x9E	; 158
     dc0:	7d e0       	ldi	r23, 0x0D	; 13
     dc2:	88 81       	ld	r24, Y
     dc4:	99 81       	ldd	r25, Y+1	; 0x01
     dc6:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vcpptr_init>

  rx_flag[0] = 0;
     dca:	10 92 cb 0e 	sts	0x0ECB, r1
  rx_flag[1] = 0;
     dce:	10 92 cc 0e 	sts	0x0ECC, r1

  // svit
  initialize_svit();
     dd2:	0e 94 45 01 	call	0x28a	; 0x28a <initialize_svit>

  // rev up those interrupts
  sei();
     dd6:	78 94       	sei

  //ADC conversions
  adc_flag = 1;
     dd8:	c1 e0       	ldi	r28, 0x01	; 1
     dda:	c0 93 6c 0a 	sts	0x0A6C, r28
	adc_component = 0;
     dde:	10 92 37 03 	sts	0x0337, r1
	adc_sensor_type = ADC_INIT;//get default case on first interation as to not enter switch
     de2:	00 93 79 0a 	sts	0x0A79, r16
  ADC_high = 0;
     de6:	10 92 86 0a 	sts	0x0A86, r1

  V_upper_val_change = 0;
     dea:	10 92 9d 0c 	sts	0x0C9D, r1
  I_upper_val_change = 0;
     dee:	10 92 98 0c 	sts	0x0C98, r1

  //---------------------------------------------------------------------  
  // SOC Initializations
  //--------------------------------------------------------------------- 
  // and shunt and safe transmit flags
  safe_mode = 0;
     df2:	10 92 76 0a 	sts	0x0A76, r1
  transmit_safe = 0;
     df6:	10 92 71 0a 	sts	0x0A71, r1
  transmit_shunt = 0;
     dfa:	10 92 a6 0e 	sts	0x0EA6, r1
  been_to_safe = 0;
     dfe:	10 92 31 03 	sts	0x0331, r1
  been_to_shunt = 0;
     e02:	10 92 93 0a 	sts	0x0A93, r1
  assign_charge_fit();
     e06:	0e 94 3f 05 	call	0xa7e	; 0xa7e <assign_charge_fit>
  assign_discharge_fit();
     e0a:	0e 94 ac 05 	call	0xb58	; 0xb58 <assign_discharge_fit>
  
  // First get battery voltage so that the SoC can
  // accurately determine whether batteries are charging or discharging
  batt1_voltage = 0xff;
     e0e:	8f ef       	ldi	r24, 0xFF	; 255
     e10:	90 e0       	ldi	r25, 0x00	; 0
     e12:	90 93 91 0a 	sts	0x0A91, r25
     e16:	80 93 90 0a 	sts	0x0A90, r24
  batt2_voltage = 0xff;
     e1a:	10 93 9e 0c 	sts	0x0C9E, r17
  charging = 0xff;
     e1e:	10 93 5c 08 	sts	0x085C, r17
  chargeforward = 0;
     e22:	10 92 c1 0e 	sts	0x0EC1, r1
  chargebackward = 0;
     e26:	10 92 36 03 	sts	0x0336, r1
  debug = 0;
     e2a:	10 92 5b 08 	sts	0x085B, r1
  debug2 = 0;
     e2e:	10 92 67 08 	sts	0x0867, r1
  percent = 0;
     e32:	10 92 53 08 	sts	0x0853, r1
     e36:	10 92 54 08 	sts	0x0854, r1
     e3a:	10 92 55 08 	sts	0x0855, r1
     e3e:	10 92 56 08 	sts	0x0856, r1
  soc = 0;
     e42:	10 92 cf 10 	sts	0x10CF, r1
  high = 0;
     e46:	10 92 85 0a 	sts	0x0A85, r1
  low = 0;
     e4a:	10 92 8f 0a 	sts	0x0A8F, r1
  limit_check_overriden = 0; // Initially limit checking is NOT OVERRIDEN
     e4e:	10 92 52 08 	sts	0x0852, r1
  isCharging = 0;
     e52:	10 92 ca 0e 	sts	0x0ECA, r1
  hasCheckedCurr = 0;
     e56:	10 92 7e 0a 	sts	0x0A7E, r1
  
  coul_percent = 0;
     e5a:	10 92 ad 0e 	sts	0x0EAD, r1
     e5e:	10 92 ae 0e 	sts	0x0EAE, r1
     e62:	10 92 af 0e 	sts	0x0EAF, r1
     e66:	10 92 b0 0e 	sts	0x0EB0, r1
  total_percent = percent;
     e6a:	10 92 38 03 	sts	0x0338, r1
     e6e:	10 92 39 03 	sts	0x0339, r1
     e72:	10 92 3a 03 	sts	0x033A, r1
     e76:	10 92 3b 03 	sts	0x033B, r1
  //--------------------------------------------------------------------- 

  //---------------------------------------------------------------------  
  // Timer Initializations
  //---------------------------------------------------------------------
  cdh_heartbeat_flag = 0;	//Default: do not have flag to restart components on
     e7a:	10 92 24 03 	sts	0x0324, r1
  rad_torq_flag = 1;		//Indicates need to delay radio/torquer on signals later
     e7e:	c0 93 0d 03 	sts	0x030D, r28
  SVIT_t *component; 	// Initialize Radios to be OFF
  component = &svit[components[RADIO_1]];
     e82:	a0 91 19 03 	lds	r26, 0x0319
     e86:	c4 e2       	ldi	r28, 0x24	; 36
     e88:	ca 9f       	mul	r28, r26
     e8a:	d0 01       	movw	r26, r0
     e8c:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     e8e:	a4 5c       	subi	r26, 0xC4	; 196
     e90:	bc 4f       	sbci	r27, 0xFC	; 252
     e92:	11 96       	adiw	r26, 0x01	; 1
     e94:	8c 91       	ld	r24, X
     e96:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <switch_off>
  component = &svit[components[RADIO_2]];
     e9a:	e0 91 1a 03 	lds	r30, 0x031A
     e9e:	ce 9f       	mul	r28, r30
     ea0:	f0 01       	movw	r30, r0
     ea2:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     ea4:	e4 5c       	subi	r30, 0xC4	; 196
     ea6:	fc 4f       	sbci	r31, 0xFC	; 252
     ea8:	81 81       	ldd	r24, Z+1	; 0x01
     eaa:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <switch_off>
  component = &svit[TORQUER_1];	// Initialize Torque Coils to be OFF
  component->switch_state = SW_OFF;
     eae:	10 92 a2 05 	sts	0x05A2, r1
  component = &svit[TORQUER_2];
  component->switch_state = SW_OFF;
     eb2:	10 92 c6 05 	sts	0x05C6, r1
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
     eb6:	10 92 ea 05 	sts	0x05EA, r1
  torquer_off(TORQUER_1);
     eba:	81 e1       	ldi	r24, 0x11	; 17
     ebc:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <torquer_off>
  torquer_off(TORQUER_2);
     ec0:	82 e1       	ldi	r24, 0x12	; 18
     ec2:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <torquer_off>
  torquer_off(TORQUER_3);
     ec6:	83 e1       	ldi	r24, 0x13	; 19
  //---------------------------------------------------------------------  
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}
     ec8:	df 91       	pop	r29
     eca:	cf 91       	pop	r28
     ecc:	1f 91       	pop	r17
     ece:	0f 91       	pop	r16
     ed0:	ff 90       	pop	r15
     ed2:	ef 90       	pop	r14
  component->switch_state = SW_OFF;
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
  torquer_off(TORQUER_1);
  torquer_off(TORQUER_2);
  torquer_off(TORQUER_3);
     ed4:	0c 94 f1 09 	jmp	0x13e2	; 0x13e2 <torquer_off>

00000ed8 <compareVoltage>:
void compareVoltage( void ) {
  SVIT_t *component;
  //component = &svit[BATTERY_1_b];
  //chargebackward = average_samples( component->I_samples );
  component = &svit[BATTERY_1];
  chargeforward= average_samples( component->I_samples );
     ed8:	8d e1       	ldi	r24, 0x1D	; 29
     eda:	96 e0       	ldi	r25, 0x06	; 6
     edc:	0e 94 ae 0a 	call	0x155c	; 0x155c <average_samples>
     ee0:	80 93 c1 0e 	sts	0x0EC1, r24
  if (chargeforward > 2){
     ee4:	83 30       	cpi	r24, 0x03	; 3
     ee6:	10 f0       	brcs	.+4      	; 0xeec <compareVoltage+0x14>
    charging = 0xdd;//discharging
     ee8:	8d ed       	ldi	r24, 0xDD	; 221
     eea:	01 c0       	rjmp	.+2      	; 0xeee <compareVoltage+0x16>
    }
  else{
    charging = 0xcc;
     eec:	8c ec       	ldi	r24, 0xCC	; 204
     eee:	80 93 5c 08 	sts	0x085C, r24
     ef2:	08 95       	ret

00000ef4 <limit_check>:
we should at least get the framework set up for limit checking on arbitrary values.
The power board should have upper and lower limits for vsense and csense data, 
and turn off components if their voltage/current is too high. ONLY CHECKS
BATTERY 1 VOLTAGE LINE RIGHT NOW.
*/
void limit_check( void ) {
     ef4:	cf 92       	push	r12
     ef6:	df 92       	push	r13
     ef8:	ef 92       	push	r14
     efa:	ff 92       	push	r15
     efc:	0f 93       	push	r16
     efe:	1f 93       	push	r17
     f00:	cf 93       	push	r28
     f02:	df 93       	push	r29
	unsigned char sw;
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
     f04:	c0 90 53 08 	lds	r12, 0x0853
     f08:	d0 90 54 08 	lds	r13, 0x0854
     f0c:	e0 90 55 08 	lds	r14, 0x0855
     f10:	f0 90 56 08 	lds	r15, 0x0856
     f14:	20 e0       	ldi	r18, 0x00	; 0
     f16:	30 e0       	ldi	r19, 0x00	; 0
     f18:	a9 01       	movw	r20, r18
     f1a:	c7 01       	movw	r24, r14
     f1c:	b6 01       	movw	r22, r12
     f1e:	0e 94 17 14 	call	0x282e	; 0x282e <__cmpsf2>
     f22:	87 ff       	sbrs	r24, 7
     f24:	4c c0       	rjmp	.+152    	; 0xfbe <limit_check+0xca>
     f26:	29 e2       	ldi	r18, 0x29	; 41
     f28:	3c e5       	ldi	r19, 0x5C	; 92
     f2a:	4f e0       	ldi	r20, 0x0F	; 15
     f2c:	5f eb       	ldi	r21, 0xBF	; 191
     f2e:	c7 01       	movw	r24, r14
     f30:	b6 01       	movw	r22, r12
     f32:	0e 94 17 14 	call	0x282e	; 0x282e <__cmpsf2>
     f36:	87 ff       	sbrs	r24, 7
     f38:	0a c0       	rjmp	.+20     	; 0xf4e <limit_check+0x5a>
     f3a:	25 e8       	ldi	r18, 0x85	; 133
     f3c:	3b ee       	ldi	r19, 0xEB	; 235
     f3e:	41 e1       	ldi	r20, 0x11	; 17
     f40:	5f eb       	ldi	r21, 0xBF	; 191
     f42:	c7 01       	movw	r24, r14
     f44:	b6 01       	movw	r22, r12
     f46:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <__gesf2>
     f4a:	18 16       	cp	r1, r24
     f4c:	c4 f1       	brlt	.+112    	; 0xfbe <limit_check+0xca>
		safe_mode = 1;
     f4e:	81 e0       	ldi	r24, 0x01	; 1
     f50:	80 93 76 0a 	sts	0x0A76, r24
     f54:	0e e0       	ldi	r16, 0x0E	; 14
     f56:	13 e0       	ldi	r17, 0x03	; 3
		for (sw = 0; sw < sizeof(components); sw++) {
			component = &svit[components[sw]];
     f58:	34 e2       	ldi	r19, 0x24	; 36
     f5a:	f3 2e       	mov	r15, r19
     f5c:	f8 01       	movw	r30, r16
     f5e:	c1 91       	ld	r28, Z+
     f60:	8f 01       	movw	r16, r30
     f62:	fc 9e       	mul	r15, r28
     f64:	e0 01       	movw	r28, r0
     f66:	11 24       	eor	r1, r1
     f68:	c4 5c       	subi	r28, 0xC4	; 196
     f6a:	dc 4f       	sbci	r29, 0xFC	; 252
			switch_off( component->switch_num );
     f6c:	89 81       	ldd	r24, Y+1	; 0x01
     f6e:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <switch_off>
			component->switch_state = SW_OFF;
     f72:	1a 82       	std	Y+2, r1	; 0x02
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
		safe_mode = 1;
		for (sw = 0; sw < sizeof(components); sw++) {
     f74:	f3 e0       	ldi	r31, 0x03	; 3
     f76:	0e 31       	cpi	r16, 0x1E	; 30
     f78:	1f 07       	cpc	r17, r31
     f7a:	81 f7       	brne	.-32     	; 0xf5c <limit_check+0x68>
			component = &svit[components[sw]];
			switch_off( component->switch_num );
			component->switch_state = SW_OFF;
		}
		component = &svit[TORQUER_1];
		component->switch_state = SW_OFF;
     f7c:	10 92 a2 05 	sts	0x05A2, r1
		component = &svit[TORQUER_2];
		component->switch_state = SW_OFF;
     f80:	10 92 c6 05 	sts	0x05C6, r1
		component = &svit[TORQUER_3];
		component->switch_state = SW_OFF;
     f84:	10 92 ea 05 	sts	0x05EA, r1
		torquer_off(TORQUER_1);
     f88:	81 e1       	ldi	r24, 0x11	; 17
     f8a:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <torquer_off>
		torquer_off(TORQUER_2);
     f8e:	82 e1       	ldi	r24, 0x12	; 18
     f90:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <torquer_off>
		torquer_off(TORQUER_3);
     f94:	83 e1       	ldi	r24, 0x13	; 19
     f96:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <torquer_off>
		// Only transmit once
		if (!transmit_safe && !been_to_safe) { 
     f9a:	80 91 71 0a 	lds	r24, 0x0A71
     f9e:	81 11       	cpse	r24, r1
     fa0:	08 c0       	rjmp	.+16     	; 0xfb2 <limit_check+0xbe>
     fa2:	80 91 31 03 	lds	r24, 0x0331
     fa6:	81 11       	cpse	r24, r1
     fa8:	04 c0       	rjmp	.+8      	; 0xfb2 <limit_check+0xbe>
			transmit_packet( 0, VCP_ACK, SAFE_MODE);
     faa:	40 e0       	ldi	r20, 0x00	; 0
     fac:	62 e0       	ldi	r22, 0x02	; 2
     fae:	0e 94 05 13 	call	0x260a	; 0x260a <transmit_packet>
			transmit_safe = 1;
		}
		else {}
		been_to_safe = 1;
     fb2:	81 e0       	ldi	r24, 0x01	; 1
     fb4:	80 93 31 03 	sts	0x0331, r24
		transmit_safe = 1;
     fb8:	80 93 71 0a 	sts	0x0A71, r24
     fbc:	28 c0       	rjmp	.+80     	; 0x100e <limit_check+0x11a>
	}
	else if (percent > SHUNT_MODE  && isCharging) {
     fbe:	20 e0       	ldi	r18, 0x00	; 0
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	48 ec       	ldi	r20, 0xC8	; 200
     fc4:	52 e4       	ldi	r21, 0x42	; 66
     fc6:	c7 01       	movw	r24, r14
     fc8:	b6 01       	movw	r22, r12
     fca:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <__gesf2>
     fce:	18 16       	cp	r1, r24
     fd0:	f4 f4       	brge	.+60     	; 0x100e <limit_check+0x11a>
     fd2:	80 91 ca 0e 	lds	r24, 0x0ECA
     fd6:	88 23       	and	r24, r24
     fd8:	d1 f0       	breq	.+52     	; 0x100e <limit_check+0x11a>
	    safe_mode = 0;
     fda:	10 92 76 0a 	sts	0x0A76, r1
		// turn on the maestro and send ack_command w/ value of SHUNT_MODE
		component = &svit[MAESTRO];
		switch_on( component->switch_num );
     fde:	80 91 11 05 	lds	r24, 0x0511
     fe2:	0e 94 28 0a 	call	0x1450	; 0x1450 <switch_on>
		component->switch_state = SW_ON;
     fe6:	81 e0       	ldi	r24, 0x01	; 1
     fe8:	80 93 12 05 	sts	0x0512, r24
		// Only transmit once
		if (!transmit_shunt && !been_to_shunt) {
     fec:	80 91 a6 0e 	lds	r24, 0x0EA6
     ff0:	81 11       	cpse	r24, r1
     ff2:	08 c0       	rjmp	.+16     	; 0x1004 <limit_check+0x110>
     ff4:	80 91 93 0a 	lds	r24, 0x0A93
     ff8:	81 11       	cpse	r24, r1
     ffa:	04 c0       	rjmp	.+8      	; 0x1004 <limit_check+0x110>
			transmit_packet( 0, VCP_ACK, SHUNT_MODE);
     ffc:	44 e6       	ldi	r20, 0x64	; 100
     ffe:	62 e0       	ldi	r22, 0x02	; 2
    1000:	0e 94 05 13 	call	0x260a	; 0x260a <transmit_packet>
		}
		else {}	
		been_to_shunt = 1;
    1004:	81 e0       	ldi	r24, 0x01	; 1
    1006:	80 93 93 0a 	sts	0x0A93, r24
		transmit_shunt = 1;	
    100a:	80 93 a6 0e 	sts	0x0EA6, r24
	}
	else {} // To avoid annoying compile warning 
}
    100e:	df 91       	pop	r29
    1010:	cf 91       	pop	r28
    1012:	1f 91       	pop	r17
    1014:	0f 91       	pop	r16
    1016:	ff 90       	pop	r15
    1018:	ef 90       	pop	r14
    101a:	df 90       	pop	r13
    101c:	cf 90       	pop	r12
    101e:	08 95       	ret

00001020 <coulombCount>:


void coulombCount( void ){
    1020:	8f 92       	push	r8
    1022:	9f 92       	push	r9
    1024:	af 92       	push	r10
    1026:	bf 92       	push	r11
    1028:	cf 92       	push	r12
    102a:	df 92       	push	r13
    102c:	ef 92       	push	r14
    102e:	ff 92       	push	r15
    1030:	0f 93       	push	r16
    1032:	1f 93       	push	r17
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
	SVIT_t *component;
	uint8_t sampled_i;
	float acc_curr;
	component = &svit[BATTERY_1];
	//MaxCharge = 17275 * 2.2;
	if(coul_en == 1){
    1038:	80 91 6a 08 	lds	r24, 0x086A
    103c:	81 30       	cpi	r24, 0x01	; 1
    103e:	09 f0       	breq	.+2      	; 0x1042 <coulombCount+0x22>
    1040:	96 c0       	rjmp	.+300    	; 0x116e <__stack+0x6f>
		coul_en=0;
    1042:	10 92 6a 08 	sts	0x086A, r1
		acc_curr = percent / 100 * MAX_CHARGE;
    1046:	20 e0       	ldi	r18, 0x00	; 0
    1048:	30 e0       	ldi	r19, 0x00	; 0
    104a:	48 ec       	ldi	r20, 0xC8	; 200
    104c:	52 e4       	ldi	r21, 0x42	; 66
    104e:	60 91 53 08 	lds	r22, 0x0853
    1052:	70 91 54 08 	lds	r23, 0x0854
    1056:	80 91 55 08 	lds	r24, 0x0855
    105a:	90 91 56 08 	lds	r25, 0x0856
    105e:	0e 94 1b 14 	call	0x2836	; 0x2836 <__divsf3>
    1062:	20 e0       	ldi	r18, 0x00	; 0
    1064:	35 e7       	ldi	r19, 0x75	; 117
    1066:	44 e1       	ldi	r20, 0x14	; 20
    1068:	57 e4       	ldi	r21, 0x47	; 71
    106a:	0e 94 65 15 	call	0x2aca	; 0x2aca <__mulsf3>
    106e:	6b 01       	movw	r12, r22
    1070:	7c 01       	movw	r14, r24
    1072:	0d e1       	ldi	r16, 0x1D	; 29
    1074:	16 e0       	ldi	r17, 0x06	; 6
    1076:	4b 01       	movw	r8, r22
    1078:	5c 01       	movw	r10, r24
		int i;
		for (i=0;i<CURRENT_SAMPLES;i++){
    107a:	c0 e0       	ldi	r28, 0x00	; 0
    107c:	d0 e0       	ldi	r29, 0x00	; 0
			sampled_i = component->I_samples[i];
    107e:	f8 01       	movw	r30, r16
    1080:	81 91       	ld	r24, Z+
    1082:	8f 01       	movw	r16, r30
			acc_curr = sampled_i * i + acc_curr;
    1084:	8c 9f       	mul	r24, r28
    1086:	b0 01       	movw	r22, r0
    1088:	8d 9f       	mul	r24, r29
    108a:	70 0d       	add	r23, r0
    108c:	11 24       	eor	r1, r1
    108e:	88 27       	eor	r24, r24
    1090:	77 fd       	sbrc	r23, 7
    1092:	80 95       	com	r24
    1094:	98 2f       	mov	r25, r24
    1096:	0e 94 b1 14 	call	0x2962	; 0x2962 <__floatsisf>
    109a:	9b 01       	movw	r18, r22
    109c:	ac 01       	movw	r20, r24
    109e:	68 2d       	mov	r22, r8
    10a0:	79 2d       	mov	r23, r9
    10a2:	8a 2d       	mov	r24, r10
    10a4:	9b 2d       	mov	r25, r11
    10a6:	0e 94 b3 13 	call	0x2766	; 0x2766 <__addsf3>
    10aa:	4b 01       	movw	r8, r22
    10ac:	5c 01       	movw	r10, r24
	//MaxCharge = 17275 * 2.2;
	if(coul_en == 1){
		coul_en=0;
		acc_curr = percent / 100 * MAX_CHARGE;
		int i;
		for (i=0;i<CURRENT_SAMPLES;i++){
    10ae:	21 96       	adiw	r28, 0x01	; 1
    10b0:	c5 30       	cpi	r28, 0x05	; 5
    10b2:	d1 05       	cpc	r29, r1
    10b4:	21 f7       	brne	.-56     	; 0x107e <coulombCount+0x5e>
			sampled_i = component->I_samples[i];
			acc_curr = sampled_i * i + acc_curr;
		}
		acc_curr /= 251;
    10b6:	20 e0       	ldi	r18, 0x00	; 0
    10b8:	30 e0       	ldi	r19, 0x00	; 0
    10ba:	4b e7       	ldi	r20, 0x7B	; 123
    10bc:	53 e4       	ldi	r21, 0x43	; 67
    10be:	79 2d       	mov	r23, r9
    10c0:	9b 2d       	mov	r25, r11
    10c2:	0e 94 1b 14 	call	0x2836	; 0x2836 <__divsf3>
		acc_curr = (float) acc_curr * SAMPLE_TIME_MS / 1000;
    10c6:	20 e0       	ldi	r18, 0x00	; 0
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	48 ec       	ldi	r20, 0xC8	; 200
    10cc:	52 e4       	ldi	r21, 0x42	; 66
    10ce:	0e 94 65 15 	call	0x2aca	; 0x2aca <__mulsf3>
    10d2:	20 e0       	ldi	r18, 0x00	; 0
    10d4:	30 e0       	ldi	r19, 0x00	; 0
    10d6:	4a e7       	ldi	r20, 0x7A	; 122
    10d8:	54 e4       	ldi	r21, 0x44	; 68
    10da:	0e 94 1b 14 	call	0x2836	; 0x2836 <__divsf3>
		acc_curr = percent / 100 * MAX_CHARGE + acc_curr;
    10de:	26 2f       	mov	r18, r22
    10e0:	37 2f       	mov	r19, r23
    10e2:	48 2f       	mov	r20, r24
    10e4:	59 2f       	mov	r21, r25
    10e6:	6c 2d       	mov	r22, r12
    10e8:	7d 2d       	mov	r23, r13
    10ea:	8e 2d       	mov	r24, r14
    10ec:	9f 2d       	mov	r25, r15
    10ee:	0e 94 b3 13 	call	0x2766	; 0x2766 <__addsf3>
    10f2:	8b 01       	movw	r16, r22
    10f4:	d8 2f       	mov	r29, r24
    10f6:	c9 2f       	mov	r28, r25
		if (acc_curr < 0){
    10f8:	20 e0       	ldi	r18, 0x00	; 0
    10fa:	30 e0       	ldi	r19, 0x00	; 0
    10fc:	a9 01       	movw	r20, r18
    10fe:	fe 01       	movw	r30, r28
    1100:	71 2f       	mov	r23, r17
    1102:	8f 2f       	mov	r24, r31
    1104:	9e 2f       	mov	r25, r30
    1106:	0e 94 17 14 	call	0x282e	; 0x282e <__cmpsf2>
    110a:	87 fd       	sbrc	r24, 7
    110c:	0e c0       	rjmp	.+28     	; 0x112a <__stack+0x2b>
			acc_curr = 0;
		}
		else if(acc_curr > MAX_CHARGE){
    110e:	20 e0       	ldi	r18, 0x00	; 0
    1110:	35 e7       	ldi	r19, 0x75	; 117
    1112:	44 e1       	ldi	r20, 0x14	; 20
    1114:	57 e4       	ldi	r21, 0x47	; 71
    1116:	fe 01       	movw	r30, r28
    1118:	60 2f       	mov	r22, r16
    111a:	71 2f       	mov	r23, r17
    111c:	8f 2f       	mov	r24, r31
    111e:	9e 2f       	mov	r25, r30
    1120:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <__gesf2>
    1124:	18 16       	cp	r1, r24
    1126:	34 f0       	brlt	.+12     	; 0x1134 <__stack+0x35>
    1128:	09 c0       	rjmp	.+18     	; 0x113c <__stack+0x3d>
		}
		acc_curr /= 251;
		acc_curr = (float) acc_curr * SAMPLE_TIME_MS / 1000;
		acc_curr = percent / 100 * MAX_CHARGE + acc_curr;
		if (acc_curr < 0){
			acc_curr = 0;
    112a:	00 e0       	ldi	r16, 0x00	; 0
    112c:	10 e0       	ldi	r17, 0x00	; 0
    112e:	d0 e0       	ldi	r29, 0x00	; 0
    1130:	c0 e0       	ldi	r28, 0x00	; 0
    1132:	04 c0       	rjmp	.+8      	; 0x113c <__stack+0x3d>
		}
		else if(acc_curr > MAX_CHARGE){
			acc_curr = MAX_CHARGE;
    1134:	00 e0       	ldi	r16, 0x00	; 0
    1136:	15 e7       	ldi	r17, 0x75	; 117
    1138:	d4 e1       	ldi	r29, 0x14	; 20
    113a:	c7 e4       	ldi	r28, 0x47	; 71
		}
		coul_percent = acc_curr / MAX_CHARGE * 100;
    113c:	20 e0       	ldi	r18, 0x00	; 0
    113e:	35 e7       	ldi	r19, 0x75	; 117
    1140:	44 e1       	ldi	r20, 0x14	; 20
    1142:	57 e4       	ldi	r21, 0x47	; 71
    1144:	fe 01       	movw	r30, r28
    1146:	60 2f       	mov	r22, r16
    1148:	71 2f       	mov	r23, r17
    114a:	8f 2f       	mov	r24, r31
    114c:	9c 2f       	mov	r25, r28
    114e:	0e 94 1b 14 	call	0x2836	; 0x2836 <__divsf3>
    1152:	20 e0       	ldi	r18, 0x00	; 0
    1154:	30 e0       	ldi	r19, 0x00	; 0
    1156:	48 ec       	ldi	r20, 0xC8	; 200
    1158:	52 e4       	ldi	r21, 0x42	; 66
    115a:	0e 94 65 15 	call	0x2aca	; 0x2aca <__mulsf3>
    115e:	60 93 ad 0e 	sts	0x0EAD, r22
    1162:	70 93 ae 0e 	sts	0x0EAE, r23
    1166:	80 93 af 0e 	sts	0x0EAF, r24
    116a:	90 93 b0 0e 	sts	0x0EB0, r25
	}
}
    116e:	df 91       	pop	r29
    1170:	cf 91       	pop	r28
    1172:	1f 91       	pop	r17
    1174:	0f 91       	pop	r16
    1176:	ff 90       	pop	r15
    1178:	ef 90       	pop	r14
    117a:	df 90       	pop	r13
    117c:	cf 90       	pop	r12
    117e:	bf 90       	pop	r11
    1180:	af 90       	pop	r10
    1182:	9f 90       	pop	r9
    1184:	8f 90       	pop	r8
    1186:	08 95       	ret

00001188 <consolidatePercent>:

void consolidatePercent( void ){
    1188:	cf 92       	push	r12
    118a:	df 92       	push	r13
    118c:	ef 92       	push	r14
    118e:	ff 92       	push	r15
	if(coul_percent > 0){
    1190:	c0 90 ad 0e 	lds	r12, 0x0EAD
    1194:	d0 90 ae 0e 	lds	r13, 0x0EAE
    1198:	e0 90 af 0e 	lds	r14, 0x0EAF
    119c:	f0 90 b0 0e 	lds	r15, 0x0EB0
    11a0:	20 e0       	ldi	r18, 0x00	; 0
    11a2:	30 e0       	ldi	r19, 0x00	; 0
    11a4:	a9 01       	movw	r20, r18
    11a6:	c7 01       	movw	r24, r14
    11a8:	b6 01       	movw	r22, r12
    11aa:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <__gesf2>
    11ae:	18 16       	cp	r1, r24
    11b0:	3c f5       	brge	.+78     	; 0x1200 <consolidatePercent+0x78>
		total_percent = .4*coul_percent + .6*percent;
    11b2:	2d ec       	ldi	r18, 0xCD	; 205
    11b4:	3c ec       	ldi	r19, 0xCC	; 204
    11b6:	4c ec       	ldi	r20, 0xCC	; 204
    11b8:	5e e3       	ldi	r21, 0x3E	; 62
    11ba:	c7 01       	movw	r24, r14
    11bc:	b6 01       	movw	r22, r12
    11be:	0e 94 65 15 	call	0x2aca	; 0x2aca <__mulsf3>
    11c2:	6b 01       	movw	r12, r22
    11c4:	7c 01       	movw	r14, r24
    11c6:	2a e9       	ldi	r18, 0x9A	; 154
    11c8:	39 e9       	ldi	r19, 0x99	; 153
    11ca:	49 e1       	ldi	r20, 0x19	; 25
    11cc:	5f e3       	ldi	r21, 0x3F	; 63
    11ce:	60 91 53 08 	lds	r22, 0x0853
    11d2:	70 91 54 08 	lds	r23, 0x0854
    11d6:	80 91 55 08 	lds	r24, 0x0855
    11da:	90 91 56 08 	lds	r25, 0x0856
    11de:	0e 94 65 15 	call	0x2aca	; 0x2aca <__mulsf3>
    11e2:	9b 01       	movw	r18, r22
    11e4:	ac 01       	movw	r20, r24
    11e6:	c7 01       	movw	r24, r14
    11e8:	b6 01       	movw	r22, r12
    11ea:	0e 94 b3 13 	call	0x2766	; 0x2766 <__addsf3>
    11ee:	60 93 38 03 	sts	0x0338, r22
    11f2:	70 93 39 03 	sts	0x0339, r23
    11f6:	80 93 3a 03 	sts	0x033A, r24
    11fa:	90 93 3b 03 	sts	0x033B, r25
    11fe:	10 c0       	rjmp	.+32     	; 0x1220 <consolidatePercent+0x98>
	}
	else{
		total_percent = percent;
    1200:	80 91 53 08 	lds	r24, 0x0853
    1204:	90 91 54 08 	lds	r25, 0x0854
    1208:	a0 91 55 08 	lds	r26, 0x0855
    120c:	b0 91 56 08 	lds	r27, 0x0856
    1210:	80 93 38 03 	sts	0x0338, r24
    1214:	90 93 39 03 	sts	0x0339, r25
    1218:	a0 93 3a 03 	sts	0x033A, r26
    121c:	b0 93 3b 03 	sts	0x033B, r27
	}
}
    1220:	ff 90       	pop	r15
    1222:	ef 90       	pop	r14
    1224:	df 90       	pop	r13
    1226:	cf 90       	pop	r12
    1228:	08 95       	ret

0000122a <main>:


// MAIN
int main( void ) 
{  
  initialize();
    122a:	0e 94 7f 06 	call	0xcfe	; 0xcfe <initialize>
  //fprintf( stdout, "uart initialized\n" );
	
  //Testing
  cntr = 0;
    122e:	10 92 6b 0a 	sts	0x0A6B, r1

  while(1)
  {
	cntr = 1 - cntr; //Testing
    1232:	11 e0       	ldi	r17, 0x01	; 1
	
    if ( timer0_counter[1] == 0 )
    {
        timer0_counter[1] = 199;
    1234:	c7 ec       	ldi	r28, 0xC7	; 199
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
    1236:	dc e2       	ldi	r29, 0x2C	; 44
  //Testing
  cntr = 0;

  while(1)
  {
	cntr = 1 - cntr; //Testing
    1238:	80 91 6b 0a 	lds	r24, 0x0A6B
    123c:	91 2f       	mov	r25, r17
    123e:	98 1b       	sub	r25, r24
    1240:	90 93 6b 0a 	sts	0x0A6B, r25
	
    if ( timer0_counter[1] == 0 )
    1244:	80 91 97 0c 	lds	r24, 0x0C97
    1248:	81 11       	cpse	r24, r1
    124a:	07 c0       	rjmp	.+14     	; 0x125a <main+0x30>
    {
        timer0_counter[1] = 199;
    124c:	c0 93 97 0c 	sts	0x0C97, r28
        transmit_packet( 1, VCP_POWER_TELEMETRY, 0);
    1250:	40 e0       	ldi	r20, 0x00	; 0
    1252:	60 e0       	ldi	r22, 0x00	; 0
    1254:	81 e0       	ldi	r24, 0x01	; 1
    1256:	0e 94 05 13 	call	0x260a	; 0x260a <transmit_packet>
    }
	  if ( timer0_counter[0] == 0 )
    125a:	80 91 96 0c 	lds	r24, 0x0C96
    125e:	81 11       	cpse	r24, r1
    1260:	06 c0       	rjmp	.+12     	; 0x126e <main+0x44>
    {
        timer0_counter[0] = 199;
    1262:	c0 93 96 0c 	sts	0x0C96, r28
        transmit_packet( 0, VCP_POWER_TELEMETRY, 0);
    1266:	40 e0       	ldi	r20, 0x00	; 0
    1268:	60 e0       	ldi	r22, 0x00	; 0
    126a:	0e 94 05 13 	call	0x260a	; 0x260a <transmit_packet>
    }
	  if ( rx_flag[0] > 0 )
    126e:	80 91 cb 0e 	lds	r24, 0x0ECB
    1272:	88 23       	and	r24, r24
    1274:	c9 f0       	breq	.+50     	; 0x12a8 <main+0x7e>
    {
        rx_flag[0]--;
    1276:	80 91 cb 0e 	lds	r24, 0x0ECB
    127a:	81 50       	subi	r24, 0x01	; 1
    127c:	80 93 cb 0e 	sts	0x0ECB, r24
        receive_message( 0, uart_vcp_buff[0]->message, uart_vcp_buff[0]->index );
    1280:	e0 91 c6 0e 	lds	r30, 0x0EC6
    1284:	f0 91 c7 0e 	lds	r31, 0x0EC7
    1288:	61 81       	ldd	r22, Z+1	; 0x01
    128a:	72 81       	ldd	r23, Z+2	; 0x02
    128c:	47 81       	ldd	r20, Z+7	; 0x07
    128e:	80 e0       	ldi	r24, 0x00	; 0
    1290:	0e 94 b0 03 	call	0x760	; 0x760 <receive_message>
        vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
    1294:	4f ef       	ldi	r20, 0xFF	; 255
    1296:	50 e0       	ldi	r21, 0x00	; 0
    1298:	6f e9       	ldi	r22, 0x9F	; 159
    129a:	7c e0       	ldi	r23, 0x0C	; 12
    129c:	80 91 c6 0e 	lds	r24, 0x0EC6
    12a0:	90 91 c7 0e 	lds	r25, 0x0EC7
    12a4:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vcpptr_init>
    }
	  if ( rx_flag[1] > 0 )
    12a8:	80 91 cc 0e 	lds	r24, 0x0ECC
    12ac:	88 23       	and	r24, r24
    12ae:	c9 f0       	breq	.+50     	; 0x12e2 <main+0xb8>
    {
        rx_flag[1]--;
    12b0:	80 91 cc 0e 	lds	r24, 0x0ECC
    12b4:	81 50       	subi	r24, 0x01	; 1
    12b6:	80 93 cc 0e 	sts	0x0ECC, r24
        receive_message( 1, uart_vcp_buff[1]->message, uart_vcp_buff[1]->index );
    12ba:	e0 91 c8 0e 	lds	r30, 0x0EC8
    12be:	f0 91 c9 0e 	lds	r31, 0x0EC9
    12c2:	61 81       	ldd	r22, Z+1	; 0x01
    12c4:	72 81       	ldd	r23, Z+2	; 0x02
    12c6:	47 81       	ldd	r20, Z+7	; 0x07
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	0e 94 b0 03 	call	0x760	; 0x760 <receive_message>
        vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
    12ce:	4f ef       	ldi	r20, 0xFF	; 255
    12d0:	50 e0       	ldi	r21, 0x00	; 0
    12d2:	6e e9       	ldi	r22, 0x9E	; 158
    12d4:	7d e0       	ldi	r23, 0x0D	; 13
    12d6:	80 91 c8 0e 	lds	r24, 0x0EC8
    12da:	90 91 c9 0e 	lds	r25, 0x0EC9
    12de:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <vcpptr_init>
    }
    if (adc_flag == 1)
    12e2:	80 91 6c 0a 	lds	r24, 0x0A6C
    12e6:	81 30       	cpi	r24, 0x01	; 1
    12e8:	b1 f4       	brne	.+44     	; 0x1316 <main+0xec>
    {
        adc_flag = 0;
    12ea:	10 92 6c 0a 	sts	0x0A6C, r1
        read_VIT();
    12ee:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <read_VIT>
		//calcSOC();
		StateofCharge();
    12f2:	0e 94 59 04 	call	0x8b2	; 0x8b2 <StateofCharge>
		coulombCount();
    12f6:	0e 94 10 08 	call	0x1020	; 0x1020 <coulombCount>
		consolidatePercent();
    12fa:	0e 94 c4 08 	call	0x1188	; 0x1188 <consolidatePercent>
		/*
		Manual Override on Limit Checking: The power board must be able to receive a 
		command to disable and/or change the limits in the limit checking code
		*/
		if (!limit_check_overriden) {
    12fe:	80 91 52 08 	lds	r24, 0x0852
    1302:	81 11       	cpse	r24, r1
    1304:	02 c0       	rjmp	.+4      	; 0x130a <main+0xe0>
			limit_check(); // First determine if voltage is within valid range, then switch
    1306:	0e 94 7a 07 	call	0xef4	; 0xef4 <limit_check>
		}

		if ( adc_component == 23 ) 
    130a:	80 91 37 03 	lds	r24, 0x0337
    130e:	87 31       	cpi	r24, 0x17	; 23
    1310:	11 f4       	brne	.+4      	; 0x1316 <main+0xec>
      	{ //23ish anything after battery values are calculated
  			  compareVoltage();
    1312:	0e 94 6c 07 	call	0xed8	; 0xed8 <compareVoltage>
	   	}
    }	
	
	//Restart all board components if CDH-IB heartbeat timeout
	if (cdh_heartbeat_flag == 1){
    1316:	80 91 24 03 	lds	r24, 0x0324
    131a:	81 30       	cpi	r24, 0x01	; 1
    131c:	09 f0       	breq	.+2      	; 0x1320 <main+0xf6>
    131e:	8c cf       	rjmp	.-232    	; 0x1238 <main+0xe>
		//Restart all components
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
    1320:	10 92 24 03 	sts	0x0324, r1
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
    1324:	d0 93 bf 0e 	sts	0x0EBF, r29
    1328:	87 cf       	rjmp	.-242    	; 0x1238 <main+0xe>

0000132a <torquer_off.part.0>:
void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
  {
    case TORQUER_1:
      CLR( PORTC, 0 );
    132a:	a8 98       	cbi	0x15, 0	; 21
	  CLR( PORTG, 1 );
    132c:	e5 e6       	ldi	r30, 0x65	; 101
    132e:	f0 e0       	ldi	r31, 0x00	; 0
    1330:	80 81       	ld	r24, Z
    1332:	8d 7f       	andi	r24, 0xFD	; 253
    1334:	80 83       	st	Z, r24
    1336:	08 95       	ret

00001338 <set_mux_sel>:
#include "mcupwr-Defs.h"


void set_mux_sel( uint8_t mux_num, uint8_t mux_sel )
{
  switch( mux_num )
    1338:	81 30       	cpi	r24, 0x01	; 1
    133a:	f9 f0       	breq	.+62     	; 0x137a <set_mux_sel+0x42>
    133c:	20 f0       	brcs	.+8      	; 0x1346 <set_mux_sel+0xe>
    133e:	82 30       	cpi	r24, 0x02	; 2
    1340:	09 f0       	breq	.+2      	; 0x1344 <set_mux_sel+0xc>
    1342:	4e c0       	rjmp	.+156    	; 0x13e0 <set_mux_sel+0xa8>
    1344:	34 c0       	rjmp	.+104    	; 0x13ae <set_mux_sel+0x76>
  {
    case MUX0:
      READ( mux_sel, 4 ) ? SET( PORTA, 7 ) : CLR( PORTA, 7 );
    1346:	64 ff       	sbrs	r22, 4
    1348:	02 c0       	rjmp	.+4      	; 0x134e <set_mux_sel+0x16>
    134a:	df 9a       	sbi	0x1b, 7	; 27
    134c:	01 c0       	rjmp	.+2      	; 0x1350 <set_mux_sel+0x18>
    134e:	df 98       	cbi	0x1b, 7	; 27
      READ( mux_sel, 3 ) ? SET( PORTA, 6 ) : CLR( PORTA, 6 );
    1350:	63 ff       	sbrs	r22, 3
    1352:	02 c0       	rjmp	.+4      	; 0x1358 <set_mux_sel+0x20>
    1354:	de 9a       	sbi	0x1b, 6	; 27
    1356:	01 c0       	rjmp	.+2      	; 0x135a <set_mux_sel+0x22>
    1358:	de 98       	cbi	0x1b, 6	; 27
      READ( mux_sel, 2 ) ? SET( PORTA, 5 ) : CLR( PORTA, 5 );
    135a:	62 ff       	sbrs	r22, 2
    135c:	02 c0       	rjmp	.+4      	; 0x1362 <set_mux_sel+0x2a>
    135e:	dd 9a       	sbi	0x1b, 5	; 27
    1360:	01 c0       	rjmp	.+2      	; 0x1364 <set_mux_sel+0x2c>
    1362:	dd 98       	cbi	0x1b, 5	; 27
      READ( mux_sel, 1 ) ? SET( PORTA, 4 ) : CLR( PORTA, 4 );
    1364:	61 ff       	sbrs	r22, 1
    1366:	02 c0       	rjmp	.+4      	; 0x136c <set_mux_sel+0x34>
    1368:	dc 9a       	sbi	0x1b, 4	; 27
    136a:	01 c0       	rjmp	.+2      	; 0x136e <set_mux_sel+0x36>
    136c:	dc 98       	cbi	0x1b, 4	; 27
      READ( mux_sel, 0 ) ? SET( PORTA, 3 ) : CLR( PORTA, 3 );
    136e:	60 ff       	sbrs	r22, 0
    1370:	02 c0       	rjmp	.+4      	; 0x1376 <set_mux_sel+0x3e>
    1372:	db 9a       	sbi	0x1b, 3	; 27
    1374:	08 95       	ret
    1376:	db 98       	cbi	0x1b, 3	; 27
    1378:	08 95       	ret

      break;

    case MUX1:
      READ( mux_sel, 4 ) ? SET( PORTB, 0 ) : CLR( PORTB, 0 );
    137a:	64 ff       	sbrs	r22, 4
    137c:	02 c0       	rjmp	.+4      	; 0x1382 <set_mux_sel+0x4a>
    137e:	c0 9a       	sbi	0x18, 0	; 24
    1380:	01 c0       	rjmp	.+2      	; 0x1384 <set_mux_sel+0x4c>
    1382:	c0 98       	cbi	0x18, 0	; 24
      READ( mux_sel, 3 ) ? SET( PORTB, 1 ) : CLR( PORTB, 1 );
    1384:	63 ff       	sbrs	r22, 3
    1386:	02 c0       	rjmp	.+4      	; 0x138c <set_mux_sel+0x54>
    1388:	c1 9a       	sbi	0x18, 1	; 24
    138a:	01 c0       	rjmp	.+2      	; 0x138e <set_mux_sel+0x56>
    138c:	c1 98       	cbi	0x18, 1	; 24
      READ( mux_sel, 2 ) ? SET( PORTB, 2 ) : CLR( PORTB, 2 );
    138e:	62 ff       	sbrs	r22, 2
    1390:	02 c0       	rjmp	.+4      	; 0x1396 <set_mux_sel+0x5e>
    1392:	c2 9a       	sbi	0x18, 2	; 24
    1394:	01 c0       	rjmp	.+2      	; 0x1398 <set_mux_sel+0x60>
    1396:	c2 98       	cbi	0x18, 2	; 24
      READ( mux_sel, 1 ) ? SET( PORTB, 3 ) : CLR( PORTB, 3 );
    1398:	61 ff       	sbrs	r22, 1
    139a:	02 c0       	rjmp	.+4      	; 0x13a0 <set_mux_sel+0x68>
    139c:	c3 9a       	sbi	0x18, 3	; 24
    139e:	01 c0       	rjmp	.+2      	; 0x13a2 <set_mux_sel+0x6a>
    13a0:	c3 98       	cbi	0x18, 3	; 24
      READ( mux_sel, 0 ) ? SET( PORTB, 4 ) : CLR( PORTB, 4 );
    13a2:	60 ff       	sbrs	r22, 0
    13a4:	02 c0       	rjmp	.+4      	; 0x13aa <set_mux_sel+0x72>
    13a6:	c4 9a       	sbi	0x18, 4	; 24
    13a8:	08 95       	ret
    13aa:	c4 98       	cbi	0x18, 4	; 24
    13ac:	08 95       	ret

      break;

    case MUX2:
      READ( mux_sel, 4 ) ? SET( PORTE, 3 ) : CLR( PORTE, 3 );
    13ae:	64 ff       	sbrs	r22, 4
    13b0:	02 c0       	rjmp	.+4      	; 0x13b6 <set_mux_sel+0x7e>
    13b2:	1b 9a       	sbi	0x03, 3	; 3
    13b4:	01 c0       	rjmp	.+2      	; 0x13b8 <set_mux_sel+0x80>
    13b6:	1b 98       	cbi	0x03, 3	; 3
      READ( mux_sel, 3 ) ? SET( PORTE, 4 ) : CLR( PORTE, 4 );
    13b8:	63 ff       	sbrs	r22, 3
    13ba:	02 c0       	rjmp	.+4      	; 0x13c0 <set_mux_sel+0x88>
    13bc:	1c 9a       	sbi	0x03, 4	; 3
    13be:	01 c0       	rjmp	.+2      	; 0x13c2 <set_mux_sel+0x8a>
    13c0:	1c 98       	cbi	0x03, 4	; 3
      READ( mux_sel, 2 ) ? SET( PORTE, 5 ) : CLR( PORTE, 5 );
    13c2:	62 ff       	sbrs	r22, 2
    13c4:	02 c0       	rjmp	.+4      	; 0x13ca <set_mux_sel+0x92>
    13c6:	1d 9a       	sbi	0x03, 5	; 3
    13c8:	01 c0       	rjmp	.+2      	; 0x13cc <set_mux_sel+0x94>
    13ca:	1d 98       	cbi	0x03, 5	; 3
      READ( mux_sel, 1 ) ? SET( PORTE, 6 ) : CLR( PORTE, 6 );
    13cc:	61 ff       	sbrs	r22, 1
    13ce:	02 c0       	rjmp	.+4      	; 0x13d4 <set_mux_sel+0x9c>
    13d0:	1e 9a       	sbi	0x03, 6	; 3
    13d2:	01 c0       	rjmp	.+2      	; 0x13d6 <set_mux_sel+0x9e>
    13d4:	1e 98       	cbi	0x03, 6	; 3
      READ( mux_sel, 0 ) ? SET( PORTE, 7 ) : CLR( PORTE, 7 );
    13d6:	60 ff       	sbrs	r22, 0
    13d8:	02 c0       	rjmp	.+4      	; 0x13de <set_mux_sel+0xa6>
    13da:	1f 9a       	sbi	0x03, 7	; 3
    13dc:	08 95       	ret
    13de:	1f 98       	cbi	0x03, 7	; 3
    13e0:	08 95       	ret

000013e2 <torquer_off>:
  }
}

void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
    13e2:	82 31       	cpi	r24, 0x12	; 18
    13e4:	31 f0       	breq	.+12     	; 0x13f2 <torquer_off+0x10>
    13e6:	83 31       	cpi	r24, 0x13	; 19
    13e8:	59 f0       	breq	.+22     	; 0x1400 <torquer_off+0x1e>
    13ea:	81 31       	cpi	r24, 0x11	; 17
    13ec:	99 f4       	brne	.+38     	; 0x1414 <torquer_off+0x32>
    13ee:	0c 94 95 09 	jmp	0x132a	; 0x132a <torquer_off.part.0>
      CLR( PORTC, 0 );
	  CLR( PORTG, 1 );
      break;

    case TORQUER_2:
      CLR( PORTG, 0 );
    13f2:	80 91 65 00 	lds	r24, 0x0065
    13f6:	8e 7f       	andi	r24, 0xFE	; 254
    13f8:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTD, 0 );
    13fc:	90 98       	cbi	0x12, 0	; 18
      break;
    13fe:	08 95       	ret

    case TORQUER_3:
      CLR( PORTG, 3 );
    1400:	80 91 65 00 	lds	r24, 0x0065
    1404:	87 7f       	andi	r24, 0xF7	; 247
    1406:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTG, 4 );
    140a:	80 91 65 00 	lds	r24, 0x0065
    140e:	8f 7e       	andi	r24, 0xEF	; 239
    1410:	80 93 65 00 	sts	0x0065, r24
    1414:	08 95       	ret

00001416 <torquer_on>:
  }  
}

void torquer_on( uint8_t torquer_num )
{
  switch( torquer_num )
    1416:	82 31       	cpi	r24, 0x12	; 18
    1418:	49 f0       	breq	.+18     	; 0x142c <torquer_on+0x16>
    141a:	83 31       	cpi	r24, 0x13	; 19
    141c:	71 f0       	breq	.+28     	; 0x143a <torquer_on+0x24>
    141e:	81 31       	cpi	r24, 0x11	; 17
    1420:	b1 f4       	brne	.+44     	; 0x144e <torquer_on+0x38>
  {
    case TORQUER_1:
      SET( PORTC, 0 );
    1422:	a8 9a       	sbi	0x15, 0	; 21
	  SET( PORTG, 1 );
    1424:	80 91 65 00 	lds	r24, 0x0065
    1428:	82 60       	ori	r24, 0x02	; 2
    142a:	0f c0       	rjmp	.+30     	; 0x144a <torquer_on+0x34>
      break;

    case TORQUER_2:
      SET( PORTG, 0 );
    142c:	80 91 65 00 	lds	r24, 0x0065
    1430:	81 60       	ori	r24, 0x01	; 1
    1432:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTD, 0 );
    1436:	90 9a       	sbi	0x12, 0	; 18
      break;
    1438:	08 95       	ret

    case TORQUER_3:
      SET( PORTG, 3 );
    143a:	80 91 65 00 	lds	r24, 0x0065
    143e:	88 60       	ori	r24, 0x08	; 8
    1440:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTG, 4 );
    1444:	80 91 65 00 	lds	r24, 0x0065
    1448:	80 61       	ori	r24, 0x10	; 16
    144a:	80 93 65 00 	sts	0x0065, r24
    144e:	08 95       	ret

00001450 <switch_on>:
  }
}

void switch_on( uint8_t switch_num )
{
  switch ( switch_num )
    1450:	88 30       	cpi	r24, 0x08	; 8
    1452:	59 f1       	breq	.+86     	; 0x14aa <switch_on+0x5a>
    1454:	68 f4       	brcc	.+26     	; 0x1470 <switch_on+0x20>
    1456:	84 30       	cpi	r24, 0x04	; 4
    1458:	01 f1       	breq	.+64     	; 0x149a <switch_on+0x4a>
    145a:	30 f4       	brcc	.+12     	; 0x1468 <switch_on+0x18>
    145c:	82 30       	cpi	r24, 0x02	; 2
    145e:	c9 f0       	breq	.+50     	; 0x1492 <switch_on+0x42>
    1460:	d0 f4       	brcc	.+52     	; 0x1496 <switch_on+0x46>
    1462:	81 30       	cpi	r24, 0x01	; 1
    1464:	b9 f5       	brne	.+110    	; 0x14d4 <switch_on+0x84>
    1466:	13 c0       	rjmp	.+38     	; 0x148e <switch_on+0x3e>
    1468:	86 30       	cpi	r24, 0x06	; 6
    146a:	d9 f0       	breq	.+54     	; 0x14a2 <switch_on+0x52>
    146c:	e0 f4       	brcc	.+56     	; 0x14a6 <switch_on+0x56>
    146e:	17 c0       	rjmp	.+46     	; 0x149e <switch_on+0x4e>
    1470:	8c 30       	cpi	r24, 0x0C	; 12
    1472:	39 f1       	breq	.+78     	; 0x14c2 <switch_on+0x72>
    1474:	20 f4       	brcc	.+8      	; 0x147e <switch_on+0x2e>
    1476:	8a 30       	cpi	r24, 0x0A	; 10
    1478:	01 f1       	breq	.+64     	; 0x14ba <switch_on+0x6a>
    147a:	08 f5       	brcc	.+66     	; 0x14be <switch_on+0x6e>
    147c:	18 c0       	rjmp	.+48     	; 0x14ae <switch_on+0x5e>
    147e:	8e 30       	cpi	r24, 0x0E	; 14
    1480:	21 f1       	breq	.+72     	; 0x14ca <switch_on+0x7a>
    1482:	08 f1       	brcs	.+66     	; 0x14c6 <switch_on+0x76>
    1484:	8f 30       	cpi	r24, 0x0F	; 15
    1486:	19 f1       	breq	.+70     	; 0x14ce <switch_on+0x7e>
    1488:	80 31       	cpi	r24, 0x10	; 16
    148a:	21 f5       	brne	.+72     	; 0x14d4 <switch_on+0x84>
    148c:	22 c0       	rjmp	.+68     	; 0x14d2 <switch_on+0x82>
  {
    case 1:
      SET( PORTA, 0 );
    148e:	d8 9a       	sbi	0x1b, 0	; 27
      break;
    1490:	08 95       	ret

    case 2:
      SET( PORTA, 1 );
    1492:	d9 9a       	sbi	0x1b, 1	; 27
      break;
    1494:	08 95       	ret

    case 3:
      SET( PORTA, 2 );
    1496:	da 9a       	sbi	0x1b, 2	; 27
      break;
    1498:	08 95       	ret

    case 4:
      SET( PORTB, 5 );
    149a:	c5 9a       	sbi	0x18, 5	; 24
      break;
    149c:	08 95       	ret

    case 5:
      SET( PORTB, 6 );
    149e:	c6 9a       	sbi	0x18, 6	; 24
      break;
    14a0:	08 95       	ret

    case 6:
      SET( PORTB, 7 );
    14a2:	c7 9a       	sbi	0x18, 7	; 24
      break;
    14a4:	08 95       	ret

    case 7:
      SET( PORTD, 4 );
    14a6:	94 9a       	sbi	0x12, 4	; 18
      break;
    14a8:	08 95       	ret

    case 8:
      SET( PORTD, 5 );
    14aa:	95 9a       	sbi	0x12, 5	; 18
      break;
    14ac:	08 95       	ret

    case 9:
      SET( PORTG, 2 );
    14ae:	80 91 65 00 	lds	r24, 0x0065
    14b2:	84 60       	ori	r24, 0x04	; 4
    14b4:	80 93 65 00 	sts	0x0065, r24
      break;
    14b8:	08 95       	ret

    case 10: 
      SET( PORTC, 7 );
    14ba:	af 9a       	sbi	0x15, 7	; 21
      break;
    14bc:	08 95       	ret

    case 11:
      SET( PORTC, 6 );
    14be:	ae 9a       	sbi	0x15, 6	; 21
      break;
    14c0:	08 95       	ret

    case 12:
      SET( PORTC, 5 );
    14c2:	ad 9a       	sbi	0x15, 5	; 21
      break;
    14c4:	08 95       	ret

    case 13:
      SET( PORTC, 4 );
    14c6:	ac 9a       	sbi	0x15, 4	; 21
      break;
    14c8:	08 95       	ret

    case 14:
      SET( PORTC, 3 );
    14ca:	ab 9a       	sbi	0x15, 3	; 21
      break;
    14cc:	08 95       	ret

    case 15:
      SET( PORTC, 2 );
    14ce:	aa 9a       	sbi	0x15, 2	; 21
      break;
    14d0:	08 95       	ret

    case 16:
      SET( PORTC, 1 );
    14d2:	a9 9a       	sbi	0x15, 1	; 21
    14d4:	08 95       	ret

000014d6 <switch_off>:
  }
}

void switch_off( uint8_t switch_num )
{
  switch ( switch_num )
    14d6:	88 30       	cpi	r24, 0x08	; 8
    14d8:	59 f1       	breq	.+86     	; 0x1530 <switch_off+0x5a>
    14da:	68 f4       	brcc	.+26     	; 0x14f6 <switch_off+0x20>
    14dc:	84 30       	cpi	r24, 0x04	; 4
    14de:	01 f1       	breq	.+64     	; 0x1520 <switch_off+0x4a>
    14e0:	30 f4       	brcc	.+12     	; 0x14ee <switch_off+0x18>
    14e2:	82 30       	cpi	r24, 0x02	; 2
    14e4:	c9 f0       	breq	.+50     	; 0x1518 <switch_off+0x42>
    14e6:	d0 f4       	brcc	.+52     	; 0x151c <switch_off+0x46>
    14e8:	81 30       	cpi	r24, 0x01	; 1
    14ea:	b9 f5       	brne	.+110    	; 0x155a <switch_off+0x84>
    14ec:	13 c0       	rjmp	.+38     	; 0x1514 <switch_off+0x3e>
    14ee:	86 30       	cpi	r24, 0x06	; 6
    14f0:	d9 f0       	breq	.+54     	; 0x1528 <switch_off+0x52>
    14f2:	e0 f4       	brcc	.+56     	; 0x152c <switch_off+0x56>
    14f4:	17 c0       	rjmp	.+46     	; 0x1524 <switch_off+0x4e>
    14f6:	8c 30       	cpi	r24, 0x0C	; 12
    14f8:	39 f1       	breq	.+78     	; 0x1548 <switch_off+0x72>
    14fa:	20 f4       	brcc	.+8      	; 0x1504 <switch_off+0x2e>
    14fc:	8a 30       	cpi	r24, 0x0A	; 10
    14fe:	01 f1       	breq	.+64     	; 0x1540 <switch_off+0x6a>
    1500:	08 f5       	brcc	.+66     	; 0x1544 <switch_off+0x6e>
    1502:	18 c0       	rjmp	.+48     	; 0x1534 <switch_off+0x5e>
    1504:	8e 30       	cpi	r24, 0x0E	; 14
    1506:	21 f1       	breq	.+72     	; 0x1550 <switch_off+0x7a>
    1508:	08 f1       	brcs	.+66     	; 0x154c <switch_off+0x76>
    150a:	8f 30       	cpi	r24, 0x0F	; 15
    150c:	19 f1       	breq	.+70     	; 0x1554 <switch_off+0x7e>
    150e:	80 31       	cpi	r24, 0x10	; 16
    1510:	21 f5       	brne	.+72     	; 0x155a <switch_off+0x84>
    1512:	22 c0       	rjmp	.+68     	; 0x1558 <switch_off+0x82>
  {
    case 1:
      CLR( PORTA, 0 );
    1514:	d8 98       	cbi	0x1b, 0	; 27
      break;
    1516:	08 95       	ret

    case 2:
      CLR( PORTA, 1 );
    1518:	d9 98       	cbi	0x1b, 1	; 27
      break;
    151a:	08 95       	ret

    case 3:
      CLR( PORTA, 2 );
    151c:	da 98       	cbi	0x1b, 2	; 27
      break;
    151e:	08 95       	ret

    case 4:
      CLR( PORTB, 5 );
    1520:	c5 98       	cbi	0x18, 5	; 24
      break;
    1522:	08 95       	ret

    case 5:
      CLR( PORTB, 6 );
    1524:	c6 98       	cbi	0x18, 6	; 24
      break;
    1526:	08 95       	ret

    case 6:
      CLR( PORTB, 7 );
    1528:	c7 98       	cbi	0x18, 7	; 24
      break;
    152a:	08 95       	ret

    case 7:
      CLR( PORTD, 4 );
    152c:	94 98       	cbi	0x12, 4	; 18
      break;
    152e:	08 95       	ret

    case 8:
      CLR( PORTD, 5 );
    1530:	95 98       	cbi	0x12, 5	; 18
      break;
    1532:	08 95       	ret

    case 9:
      CLR( PORTG, 2 );
    1534:	80 91 65 00 	lds	r24, 0x0065
    1538:	8b 7f       	andi	r24, 0xFB	; 251
    153a:	80 93 65 00 	sts	0x0065, r24
      break;
    153e:	08 95       	ret

    case 10: 
      CLR( PORTC, 7 );
    1540:	af 98       	cbi	0x15, 7	; 21
      break;
    1542:	08 95       	ret

    case 11:
      CLR( PORTC, 6 );
    1544:	ae 98       	cbi	0x15, 6	; 21
      break;
    1546:	08 95       	ret

    case 12:
      CLR( PORTC, 5 );
    1548:	ad 98       	cbi	0x15, 5	; 21
      break;
    154a:	08 95       	ret

    case 13:
      CLR( PORTC, 4 );
    154c:	ac 98       	cbi	0x15, 4	; 21
      break;
    154e:	08 95       	ret

    case 14:
      CLR( PORTC, 3 );
    1550:	ab 98       	cbi	0x15, 3	; 21
      break;
    1552:	08 95       	ret

    case 15:
      CLR( PORTC, 2 );
    1554:	aa 98       	cbi	0x15, 2	; 21
      break;
    1556:	08 95       	ret

    case 16:
      CLR( PORTC, 1 );
    1558:	a9 98       	cbi	0x15, 1	; 21
    155a:	08 95       	ret

0000155c <average_samples>:
    return  average_samples( component->I_samples );
  }
}

uint8_t average_samples( uint8_t samples[NUM_SAMPLES] )
{
    155c:	fc 01       	movw	r30, r24
  uint8_t average = 0;
  uint16_t sum = 0;

  for(uint8_t avg_index = 0; avg_index < NUM_SAMPLES; avg_index++)
    sum += samples[avg_index];
    155e:	21 81       	ldd	r18, Z+1	; 0x01
    1560:	80 81       	ld	r24, Z
    1562:	90 e0       	ldi	r25, 0x00	; 0
    1564:	82 0f       	add	r24, r18
    1566:	91 1d       	adc	r25, r1
    1568:	22 81       	ldd	r18, Z+2	; 0x02
    156a:	82 0f       	add	r24, r18
    156c:	91 1d       	adc	r25, r1

  average = sum / NUM_SAMPLES;
    156e:	63 e0       	ldi	r22, 0x03	; 3
    1570:	70 e0       	ldi	r23, 0x00	; 0
    1572:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <__udivmodhi4>
    1576:	86 2f       	mov	r24, r22

  return average;
}
    1578:	08 95       	ret

0000157a <SVIT_check_I_critical>:
}

uint8_t SVIT_check_I_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    157a:	94 e2       	ldi	r25, 0x24	; 36
    157c:	89 9f       	mul	r24, r25
    157e:	f0 01       	movw	r30, r0
    1580:	11 24       	eor	r1, r1
    1582:	e4 5c       	subi	r30, 0xC4	; 196
    1584:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->I_critical_value != 0 )
    1586:	85 89       	ldd	r24, Z+21	; 0x15
    1588:	88 23       	and	r24, r24
    158a:	11 f0       	breq	.+4      	; 0x1590 <SVIT_check_I_critical+0x16>
  {
    temp= component->I_critical_value;
    component->I_critical_value = 0;
    158c:	15 8a       	std	Z+21, r1	; 0x15
    158e:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->I_samples );
    1590:	cf 01       	movw	r24, r30
    1592:	41 96       	adiw	r24, 0x11	; 17
    1594:	0c 94 ae 0a 	jmp	0x155c	; 0x155c <average_samples>

00001598 <SVIT_check_V_critical>:
}

uint8_t SVIT_check_V_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1598:	94 e2       	ldi	r25, 0x24	; 36
    159a:	89 9f       	mul	r24, r25
    159c:	f0 01       	movw	r30, r0
    159e:	11 24       	eor	r1, r1
    15a0:	e4 5c       	subi	r30, 0xC4	; 196
    15a2:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->V_critical_value != 0 )
    15a4:	84 85       	ldd	r24, Z+12	; 0x0c
    15a6:	88 23       	and	r24, r24
    15a8:	11 f0       	breq	.+4      	; 0x15ae <SVIT_check_V_critical+0x16>
  {
    temp= component->V_critical_value;
    component->V_critical_value = 0;
    15aa:	14 86       	std	Z+12, r1	; 0x0c
    15ac:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->V_samples );
    15ae:	cf 01       	movw	r24, r30
    15b0:	08 96       	adiw	r24, 0x08	; 8
    15b2:	0c 94 ae 0a 	jmp	0x155c	; 0x155c <average_samples>

000015b6 <perform_ADC>:
}

void perform_ADC( uint8_t mux_num )
{
  // set Vref to AVCC and set the ADC channel to the correct pin ( mux_num )
  ADMUX = (1 << ADLAR) | ( 1 << REFS0 );
    15b6:	90 e6       	ldi	r25, 0x60	; 96
    15b8:	97 b9       	out	0x07, r25	; 7
  ADMUX &= ~0x3;
    15ba:	97 b1       	in	r25, 0x07	; 7
    15bc:	9c 7f       	andi	r25, 0xFC	; 252
    15be:	97 b9       	out	0x07, r25	; 7
  ADMUX |= mux_num;
    15c0:	97 b1       	in	r25, 0x07	; 7
    15c2:	98 2b       	or	r25, r24
    15c4:	97 b9       	out	0x07, r25	; 7

  // signal ADC to start a new conversion
  ADCSRA |= ( 1 << ADSC );
    15c6:	36 9a       	sbi	0x06, 6	; 6
    15c8:	08 95       	ret

000015ca <read_VIT>:

  // when the conversion finishes, the result is stored in ADCL and ADCH
}

void read_VIT( void )
{
    15ca:	cf 92       	push	r12
    15cc:	df 92       	push	r13
    15ce:	ef 92       	push	r14
    15d0:	ff 92       	push	r15
    15d2:	0f 93       	push	r16
    15d4:	1f 93       	push	r17
    15d6:	cf 93       	push	r28
    15d8:	df 93       	push	r29
    15da:	1f 92       	push	r1
    15dc:	cd b7       	in	r28, 0x3d	; 61
    15de:	de b7       	in	r29, 0x3e	; 62
  SVIT_t* component;
  uint8_t sample_index;
  uint8_t c_samp_idx;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type ){
    15e0:	80 91 79 0a 	lds	r24, 0x0A79
    15e4:	82 30       	cpi	r24, 0x02	; 2
    15e6:	09 f4       	brne	.+2      	; 0x15ea <read_VIT+0x20>
    15e8:	78 c0       	rjmp	.+240    	; 0x16da <read_VIT+0x110>
    15ea:	e0 91 37 03 	lds	r30, 0x0337
    15ee:	83 30       	cpi	r24, 0x03	; 3
    15f0:	20 f4       	brcc	.+8      	; 0x15fa <read_VIT+0x30>
    15f2:	81 30       	cpi	r24, 0x01	; 1
    15f4:	09 f0       	breq	.+2      	; 0x15f8 <read_VIT+0x2e>
    15f6:	2e c1       	rjmp	.+604    	; 0x1854 <read_VIT+0x28a>
    15f8:	07 c0       	rjmp	.+14     	; 0x1608 <read_VIT+0x3e>
    15fa:	83 30       	cpi	r24, 0x03	; 3
    15fc:	09 f4       	brne	.+2      	; 0x1600 <read_VIT+0x36>
    15fe:	fd c0       	rjmp	.+506    	; 0x17fa <read_VIT+0x230>
    1600:	84 30       	cpi	r24, 0x04	; 4
    1602:	09 f0       	breq	.+2      	; 0x1606 <read_VIT+0x3c>
    1604:	27 c1       	rjmp	.+590    	; 0x1854 <read_VIT+0x28a>
    1606:	22 c1       	rjmp	.+580    	; 0x184c <read_VIT+0x282>
		case ADC_VOLTAGE:
			component = &svit[adc_component];
    1608:	84 e2       	ldi	r24, 0x24	; 36
    160a:	e8 9f       	mul	r30, r24
    160c:	70 01       	movw	r14, r0
    160e:	11 24       	eor	r1, r1
    1610:	ec e3       	ldi	r30, 0x3C	; 60
    1612:	f3 e0       	ldi	r31, 0x03	; 3
    1614:	ee 0e       	add	r14, r30
    1616:	ff 1e       	adc	r15, r31
			sample_index = component->V_sample_index;
			component->V_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    1618:	f7 01       	movw	r30, r14
    161a:	23 85       	ldd	r18, Z+11	; 0x0b
    161c:	30 e0       	ldi	r19, 0x00	; 0
    161e:	c9 01       	movw	r24, r18
    1620:	01 96       	adiw	r24, 0x01	; 1
    1622:	63 e0       	ldi	r22, 0x03	; 3
    1624:	70 e0       	ldi	r23, 0x00	; 0
    1626:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <__divmodhi4>
    162a:	83 87       	std	Z+11, r24	; 0x0b

			// SoC: If component is a battery, store in different global variable
			if (component->name == BATTERY_1) {
    162c:	40 81       	ld	r20, Z
    162e:	44 31       	cpi	r20, 0x14	; 20
    1630:	a9 f4       	brne	.+42     	; 0x165c <read_VIT+0x92>
				batt1_voltage = ADC_high + 11;
    1632:	80 91 86 0a 	lds	r24, 0x0A86
    1636:	90 e0       	ldi	r25, 0x00	; 0
    1638:	0b 96       	adiw	r24, 0x0b	; 11
    163a:	90 93 91 0a 	sts	0x0A91, r25
    163e:	80 93 90 0a 	sts	0x0A90, r24
				batt1_voltageLow = ADC_low;
    1642:	80 91 c0 0e 	lds	r24, 0x0EC0
    1646:	80 93 a1 0e 	sts	0x0EA1, r24
				high = ADC_high;
    164a:	80 91 86 0a 	lds	r24, 0x0A86
    164e:	80 93 85 0a 	sts	0x0A85, r24
				low = ADC_low;
    1652:	80 91 c0 0e 	lds	r24, 0x0EC0
    1656:	80 93 8f 0a 	sts	0x0A8F, r24
    165a:	06 c0       	rjmp	.+12     	; 0x1668 <read_VIT+0x9e>
				//batt1_voltage = (ADC_high << 8) + ADC_low;
				//debug = adc_component;
			}
			else if (component->name == BATTERY_2) {
    165c:	45 31       	cpi	r20, 0x15	; 21
    165e:	21 f4       	brne	.+8      	; 0x1668 <read_VIT+0x9e>
				batt2_voltage = ADC_high;
    1660:	80 91 86 0a 	lds	r24, 0x0A86
    1664:	80 93 9e 0c 	sts	0x0C9E, r24
			}
			component->V_samples[sample_index] = ADC_high;
    1668:	80 91 86 0a 	lds	r24, 0x0A86
    166c:	f7 01       	movw	r30, r14
    166e:	e2 0f       	add	r30, r18
    1670:	f3 1f       	adc	r31, r19
    1672:	80 87       	std	Z+8, r24	; 0x08
            
			//OverVoltage
	  		if ( ( ADC_high > component->V_upper_limit ) && ( component->force_on != 1 ) ){
    1674:	90 91 86 0a 	lds	r25, 0x0A86
    1678:	f7 01       	movw	r30, r14
    167a:	86 81       	ldd	r24, Z+6	; 0x06
    167c:	89 17       	cp	r24, r25
    167e:	20 f4       	brcc	.+8      	; 0x1688 <read_VIT+0xbe>
    1680:	83 81       	ldd	r24, Z+3	; 0x03
    1682:	81 30       	cpi	r24, 0x01	; 1
    1684:	09 f0       	breq	.+2      	; 0x1688 <read_VIT+0xbe>
    1686:	09 c0       	rjmp	.+18     	; 0x169a <read_VIT+0xd0>
  				}
				component->switch_state = SW_OFF;
				component->V_critical_value = ADC_high;
			}
			//UnderVoltage
			else if((ADC_high < component->V_lower_limit) && component->switch_state){
    1688:	90 91 86 0a 	lds	r25, 0x0A86
    168c:	f7 01       	movw	r30, r14
    168e:	87 81       	ldd	r24, Z+7	; 0x07
    1690:	98 17       	cp	r25, r24
    1692:	e0 f4       	brcc	.+56     	; 0x16cc <read_VIT+0x102>
    1694:	82 81       	ldd	r24, Z+2	; 0x02
    1696:	88 23       	and	r24, r24
    1698:	c9 f0       	breq	.+50     	; 0x16cc <read_VIT+0x102>
				if ( component->switch_num != SW_NULL ){
    169a:	81 81       	ldd	r24, Z+1	; 0x01
    169c:	8f 3f       	cpi	r24, 0xFF	; 255
    169e:	19 f0       	breq	.+6      	; 0x16a6 <read_VIT+0xdc>
					switch_off( component->switch_num );
    16a0:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <switch_off>
    16a4:	0e c0       	rjmp	.+28     	; 0x16c2 <read_VIT+0xf8>
				}else {
					switch ( component->name ){
    16a6:	42 31       	cpi	r20, 0x12	; 18
    16a8:	39 f0       	breq	.+14     	; 0x16b8 <read_VIT+0xee>
    16aa:	43 31       	cpi	r20, 0x13	; 19
    16ac:	39 f0       	breq	.+14     	; 0x16bc <read_VIT+0xf2>
    16ae:	41 31       	cpi	r20, 0x11	; 17
    16b0:	41 f4       	brne	.+16     	; 0x16c2 <read_VIT+0xf8>
    16b2:	0e 94 95 09 	call	0x132a	; 0x132a <torquer_off.part.0>
    16b6:	05 c0       	rjmp	.+10     	; 0x16c2 <read_VIT+0xf8>
						case TORQUER_1:
							torquer_off( TORQUER_1 );
							break;
						case TORQUER_2:
							torquer_off( TORQUER_2 );
    16b8:	82 e1       	ldi	r24, 0x12	; 18
    16ba:	01 c0       	rjmp	.+2      	; 0x16be <read_VIT+0xf4>
							break;
						case TORQUER_3:
							torquer_off( TORQUER_3 );
    16bc:	83 e1       	ldi	r24, 0x13	; 19
    16be:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <torquer_off>
							break;
						default:
							break;
					}
				}
				component->switch_state = SW_OFF;
    16c2:	f7 01       	movw	r30, r14
    16c4:	12 82       	std	Z+2, r1	; 0x02
				component->V_critical_value = ADC_high;
    16c6:	80 91 86 0a 	lds	r24, 0x0A86
    16ca:	84 87       	std	Z+12, r24	; 0x0c
			}
			adc_sensor_type = ADC_CURRENT;
    16cc:	82 e0       	ldi	r24, 0x02	; 2
    16ce:	80 93 79 0a 	sts	0x0A79, r24

		    //perform next ADC conversion
		    mux_num = component->I_mux_num;
    16d2:	f7 01       	movw	r30, r14
    16d4:	15 85       	ldd	r17, Z+13	; 0x0d
		    mux_sel = component->I_mux_sel;
		    set_mux_sel( mux_num, mux_sel );
    16d6:	66 85       	ldd	r22, Z+14	; 0x0e
    16d8:	88 c0       	rjmp	.+272    	; 0x17ea <read_VIT+0x220>
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    16da:	c0 90 37 03 	lds	r12, 0x0337
    16de:	94 e2       	ldi	r25, 0x24	; 36
    16e0:	c9 9e       	mul	r12, r25
    16e2:	60 01       	movw	r12, r0
    16e4:	11 24       	eor	r1, r1
    16e6:	ec e3       	ldi	r30, 0x3C	; 60
    16e8:	f3 e0       	ldi	r31, 0x03	; 3
    16ea:	ce 0e       	add	r12, r30
    16ec:	df 1e       	adc	r13, r31
	  	sample_index = component->I_sample_index;
	  	component->I_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    16ee:	f6 01       	movw	r30, r12
    16f0:	24 89       	ldd	r18, Z+20	; 0x14
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	c9 01       	movw	r24, r18
    16f6:	01 96       	adiw	r24, 0x01	; 1
    16f8:	63 e0       	ldi	r22, 0x03	; 3
    16fa:	70 e0       	ldi	r23, 0x00	; 0
    16fc:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <__divmodhi4>
    1700:	84 8b       	std	Z+20, r24	; 0x14
		// SoC hardcode backward current
//		if (adc_component == BATTERY_1_b) {
			//debug = 5;
		//}
		
		if(component->name == SOLAR_1){
    1702:	40 81       	ld	r20, Z
    1704:	47 31       	cpi	r20, 0x17	; 23
    1706:	39 f4       	brne	.+14     	; 0x1716 <read_VIT+0x14c>
			solar1_current = ADC_high;
    1708:	80 91 86 0a 	lds	r24, 0x0A86
    170c:	80 93 92 0a 	sts	0x0A92, r24
			hasCheckedCurr = 1;
    1710:	81 e0       	ldi	r24, 0x01	; 1
    1712:	80 93 7e 0a 	sts	0x0A7E, r24
		}

	  	component->I_samples[sample_index] = ADC_high;
    1716:	80 91 86 0a 	lds	r24, 0x0A86
    171a:	f6 01       	movw	r30, r12
    171c:	e2 0f       	add	r30, r18
    171e:	f3 1f       	adc	r31, r19
    1720:	81 8b       	std	Z+17, r24	; 0x11
		
			if(component->name == BATTERY_1){
    1722:	44 31       	cpi	r20, 0x14	; 20
    1724:	01 f5       	brne	.+64     	; 0x1766 <read_VIT+0x19c>
				c_samp_idx = component->Coul_sample_index;
    1726:	f6 01       	movw	r30, r12
    1728:	01 a1       	ldd	r16, Z+33	; 0x21
				if(c_samp_idx == CURRENT_SAMPLES-1){
    172a:	04 30       	cpi	r16, 0x04	; 4
    172c:	19 f4       	brne	.+6      	; 0x1734 <read_VIT+0x16a>
					coul_en = 1;
    172e:	81 e0       	ldi	r24, 0x01	; 1
    1730:	80 93 6a 08 	sts	0x086A, r24
				}

				component->Coul_samples[c_samp_idx] = (float) ADC_high;
    1734:	10 e0       	ldi	r17, 0x00	; 0
    1736:	60 91 86 0a 	lds	r22, 0x0A86
    173a:	76 01       	movw	r14, r12
    173c:	e0 0e       	add	r14, r16
    173e:	f1 1e       	adc	r15, r17
    1740:	70 e0       	ldi	r23, 0x00	; 0
    1742:	80 e0       	ldi	r24, 0x00	; 0
    1744:	90 e0       	ldi	r25, 0x00	; 0
    1746:	49 83       	std	Y+1, r20	; 0x01
    1748:	0e 94 af 14 	call	0x295e	; 0x295e <__floatunsisf>
    174c:	0e 94 83 14 	call	0x2906	; 0x2906 <__fixunssfsi>
    1750:	f7 01       	movw	r30, r14
    1752:	64 8f       	std	Z+28, r22	; 0x1c
				component->Coul_sample_index = (c_samp_idx + 1) % CURRENT_SAMPLES;
    1754:	c8 01       	movw	r24, r16
    1756:	01 96       	adiw	r24, 0x01	; 1
    1758:	65 e0       	ldi	r22, 0x05	; 5
    175a:	70 e0       	ldi	r23, 0x00	; 0
    175c:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <__divmodhi4>
    1760:	f6 01       	movw	r30, r12
    1762:	81 a3       	std	Z+33, r24	; 0x21
    1764:	49 81       	ldd	r20, Y+1	; 0x01
			}	
		
	    if ( ( ADC_high > component->I_upper_limit ) && ( component->force_on != 1 ) )
    1766:	90 91 86 0a 	lds	r25, 0x0A86
    176a:	f6 01       	movw	r30, r12
    176c:	87 85       	ldd	r24, Z+15	; 0x0f
    176e:	89 17       	cp	r24, r25
    1770:	e0 f4       	brcc	.+56     	; 0x17aa <read_VIT+0x1e0>
    1772:	83 81       	ldd	r24, Z+3	; 0x03
    1774:	81 30       	cpi	r24, 0x01	; 1
    1776:	c9 f0       	breq	.+50     	; 0x17aa <read_VIT+0x1e0>
	  	{
	  		if ( component->switch_num != SW_NULL )
    1778:	81 81       	ldd	r24, Z+1	; 0x01
    177a:	8f 3f       	cpi	r24, 0xFF	; 255
    177c:	19 f0       	breq	.+6      	; 0x1784 <read_VIT+0x1ba>
	  		{
	  		  switch_off( component->switch_num );
    177e:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <switch_off>
    1782:	0e c0       	rjmp	.+28     	; 0x17a0 <read_VIT+0x1d6>
	  		}
	  		else
	  		{
	  		  switch ( component->name )
    1784:	42 31       	cpi	r20, 0x12	; 18
    1786:	39 f0       	breq	.+14     	; 0x1796 <read_VIT+0x1cc>
    1788:	43 31       	cpi	r20, 0x13	; 19
    178a:	39 f0       	breq	.+14     	; 0x179a <read_VIT+0x1d0>
    178c:	41 31       	cpi	r20, 0x11	; 17
    178e:	41 f4       	brne	.+16     	; 0x17a0 <read_VIT+0x1d6>
    1790:	0e 94 95 09 	call	0x132a	; 0x132a <torquer_off.part.0>
    1794:	05 c0       	rjmp	.+10     	; 0x17a0 <read_VIT+0x1d6>
		  	  {
  		  		case TORQUER_1:
	  	  		  torquer_off( TORQUER_1 );
		    		  break;
			    	case TORQUER_2:
			  	    torquer_off( TORQUER_2 );
    1796:	82 e1       	ldi	r24, 0x12	; 18
    1798:	01 c0       	rjmp	.+2      	; 0x179c <read_VIT+0x1d2>
			  	    break;
  		  		case TORQUER_3:
	  	  		  torquer_off( TORQUER_3 );
    179a:	83 e1       	ldi	r24, 0x13	; 19
    179c:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <torquer_off>
		    		  break;
			     	default:
				      break;
			    }
			  }
			  component->switch_state = 0;
    17a0:	f6 01       	movw	r30, r12
    17a2:	12 82       	std	Z+2, r1	; 0x02
        component->I_critical_value = ADC_high;
    17a4:	80 91 86 0a 	lds	r24, 0x0A86
    17a8:	85 8b       	std	Z+21, r24	; 0x15
		  }
      //perform next ADC conversion
      mux_num = component->T_mux_num;
    17aa:	f6 01       	movw	r30, r12
    17ac:	16 89       	ldd	r17, Z+22	; 0x16
      if( mux_num != MUX_NULL )
    17ae:	13 30       	cpi	r17, 0x03	; 3
    17b0:	29 f0       	breq	.+10     	; 0x17bc <read_VIT+0x1f2>
      {
		    adc_sensor_type = ADC_TEMPERATURE;
    17b2:	83 e0       	ldi	r24, 0x03	; 3
    17b4:	80 93 79 0a 	sts	0x0A79, r24
        mux_sel = component->T_mux_sel;        
    17b8:	67 89       	ldd	r22, Z+23	; 0x17
    17ba:	17 c0       	rjmp	.+46     	; 0x17ea <read_VIT+0x220>
		  }
      else
      {
        adc_sensor_type = ADC_VOLTAGE;
    17bc:	81 e0       	ldi	r24, 0x01	; 1
    17be:	80 93 79 0a 	sts	0x0A79, r24
		    adc_component = ( adc_component + 1 ) % SVIT_SZ;
    17c2:	80 91 37 03 	lds	r24, 0x0337
    17c6:	90 e0       	ldi	r25, 0x00	; 0
    17c8:	01 96       	adiw	r24, 0x01	; 1
    17ca:	64 e2       	ldi	r22, 0x24	; 36
    17cc:	70 e0       	ldi	r23, 0x00	; 0
    17ce:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <__divmodhi4>
    17d2:	80 93 37 03 	sts	0x0337, r24
        component = &svit[adc_component];
    17d6:	24 e2       	ldi	r18, 0x24	; 36
    17d8:	28 9f       	mul	r18, r24
    17da:	f0 01       	movw	r30, r0
    17dc:	29 9f       	mul	r18, r25
    17de:	f0 0d       	add	r31, r0
    17e0:	11 24       	eor	r1, r1
    17e2:	e4 5c       	subi	r30, 0xC4	; 196
    17e4:	fc 4f       	sbci	r31, 0xFC	; 252
        mux_num = component->V_mux_num;
    17e6:	14 81       	ldd	r17, Z+4	; 0x04
        mux_sel = component->V_mux_sel;
    17e8:	65 81       	ldd	r22, Z+5	; 0x05
      }
      set_mux_sel( mux_num, mux_sel );
    17ea:	81 2f       	mov	r24, r17
    17ec:	0e 94 9c 09 	call	0x1338	; 0x1338 <set_mux_sel>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    17f0:	83 e3       	ldi	r24, 0x33	; 51
    17f2:	93 e7       	ldi	r25, 0x73	; 115
    17f4:	01 97       	sbiw	r24, 0x01	; 1
    17f6:	f1 f7       	brne	.-4      	; 0x17f4 <read_VIT+0x22a>
    17f8:	41 c0       	rjmp	.+130    	; 0x187c <read_VIT+0x2b2>
      break;
    //-------------------------------------------------------------------
    // Measure temperature
    //-------------------------------------------------------------------
	  case ADC_TEMPERATURE:
		  component = &svit[adc_component];
    17fa:	0e 2f       	mov	r16, r30
    17fc:	10 e0       	ldi	r17, 0x00	; 0
    17fe:	44 e2       	ldi	r20, 0x24	; 36
    1800:	40 9f       	mul	r20, r16
    1802:	f0 01       	movw	r30, r0
    1804:	41 9f       	mul	r20, r17
    1806:	f0 0d       	add	r31, r0
    1808:	11 24       	eor	r1, r1
    180a:	e4 5c       	subi	r30, 0xC4	; 196
    180c:	fc 4f       	sbci	r31, 0xFC	; 252
		  sample_index = component->T_sample_index;
		  component->T_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    180e:	23 8d       	ldd	r18, Z+27	; 0x1b
    1810:	30 e0       	ldi	r19, 0x00	; 0
    1812:	c9 01       	movw	r24, r18
    1814:	01 96       	adiw	r24, 0x01	; 1
    1816:	63 e0       	ldi	r22, 0x03	; 3
    1818:	70 e0       	ldi	r23, 0x00	; 0
    181a:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <__divmodhi4>
    181e:	83 8f       	std	Z+27, r24	; 0x1b
		  component->T_samples[sample_index] = ADC_high;
    1820:	80 91 86 0a 	lds	r24, 0x0A86
    1824:	e2 0f       	add	r30, r18
    1826:	f3 1f       	adc	r31, r19
    1828:	80 8f       	std	Z+24, r24	; 0x18
      //perform next ADC conversion
  	  adc_sensor_type = ADC_VOLTAGE;
    182a:	81 e0       	ldi	r24, 0x01	; 1
    182c:	80 93 79 0a 	sts	0x0A79, r24
		  adc_component = ( adc_component + 1 ) % SVIT_SZ;
    1830:	c8 01       	movw	r24, r16
    1832:	01 96       	adiw	r24, 0x01	; 1
    1834:	64 e2       	ldi	r22, 0x24	; 36
    1836:	70 e0       	ldi	r23, 0x00	; 0
    1838:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <__divmodhi4>
    183c:	80 93 37 03 	sts	0x0337, r24
      component = &svit[adc_component];
    1840:	48 9f       	mul	r20, r24
    1842:	f0 01       	movw	r30, r0
    1844:	49 9f       	mul	r20, r25
    1846:	f0 0d       	add	r31, r0
    1848:	11 24       	eor	r1, r1
    184a:	0d c0       	rjmp	.+26     	; 0x1866 <read_VIT+0x29c>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
		  break;
    case ADC_INIT:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    184c:	81 e0       	ldi	r24, 0x01	; 1
    184e:	80 93 79 0a 	sts	0x0A79, r24
    1852:	05 c0       	rjmp	.+10     	; 0x185e <read_VIT+0x294>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
      break;
	  default:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    1854:	81 e0       	ldi	r24, 0x01	; 1
    1856:	80 93 79 0a 	sts	0x0A79, r24
      component = &svit[adc_component];
    185a:	e0 91 37 03 	lds	r30, 0x0337
    185e:	84 e2       	ldi	r24, 0x24	; 36
    1860:	e8 9f       	mul	r30, r24
    1862:	f0 01       	movw	r30, r0
    1864:	11 24       	eor	r1, r1
    1866:	e4 5c       	subi	r30, 0xC4	; 196
    1868:	fc 4f       	sbci	r31, 0xFC	; 252
      mux_num = component->V_mux_num;
    186a:	14 81       	ldd	r17, Z+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    186c:	65 81       	ldd	r22, Z+5	; 0x05
    186e:	81 2f       	mov	r24, r17
    1870:	0e 94 9c 09 	call	0x1338	; 0x1338 <set_mux_sel>
    1874:	e3 e3       	ldi	r30, 0x33	; 51
    1876:	f3 e7       	ldi	r31, 0x73	; 115
    1878:	31 97       	sbiw	r30, 0x01	; 1
    187a:	f1 f7       	brne	.-4      	; 0x1878 <read_VIT+0x2ae>
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    187c:	81 2f       	mov	r24, r17
      break;
  } 
}
    187e:	0f 90       	pop	r0
    1880:	df 91       	pop	r29
    1882:	cf 91       	pop	r28
    1884:	1f 91       	pop	r17
    1886:	0f 91       	pop	r16
    1888:	ff 90       	pop	r15
    188a:	ef 90       	pop	r14
    188c:	df 90       	pop	r13
    188e:	cf 90       	pop	r12
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    1890:	0c 94 db 0a 	jmp	0x15b6	; 0x15b6 <perform_ADC>

00001894 <uart_init>:
{
  #if F_CPU < 2000000UL && defined(U2X)
  UCSR0A = UCSR1A = _BV(U2X); /* improve baud rate error by using 2x clk */
  UBRR0L = UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  #else
  UBRR0L = UBRR1L = 7;//(F_CPU / (16UL * UART_BAUD)) - 1;//7;
    1894:	87 e0       	ldi	r24, 0x07	; 7
    1896:	80 93 99 00 	sts	0x0099, r24
    189a:	89 b9       	out	0x09, r24	; 9
  #endif
  UCSR0B = _BV(TXEN0) | _BV(RXEN0); /* tx/rx enable */
    189c:	88 e1       	ldi	r24, 0x18	; 24
    189e:	8a b9       	out	0x0a, r24	; 10
  UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
    18a0:	ea e9       	ldi	r30, 0x9A	; 154
    18a2:	f0 e0       	ldi	r31, 0x00	; 0
    18a4:	80 83       	st	Z, r24


  UCSR1B = UCSR1B | _BV(TXCIE1);
    18a6:	80 81       	ld	r24, Z
    18a8:	80 64       	ori	r24, 0x40	; 64
    18aa:	80 83       	st	Z, r24
  UCSR1B = UCSR1B | _BV(RXCIE1);
    18ac:	80 81       	ld	r24, Z
    18ae:	80 68       	ori	r24, 0x80	; 128
    18b0:	80 83       	st	Z, r24
  UCSR0B = UCSR0B | _BV(TXCIE0);
    18b2:	56 9a       	sbi	0x0a, 6	; 10
  UCSR0B = UCSR0B | _BV(RXCIE0);
    18b4:	57 9a       	sbi	0x0a, 7	; 10
    18b6:	08 95       	ret

000018b8 <append_crc16>:
 * Adds a byte of data into the crc calculation using
 * the table above.
 */
void append_crc16(uint8 byte, uint16ptr crc)
{
	*crc = ((*crc) >> 8) ^ ccitt_crc16[((*crc) ^ (byte)) & 0xff];
    18b8:	fb 01       	movw	r30, r22
    18ba:	20 81       	ld	r18, Z
    18bc:	31 81       	ldd	r19, Z+1	; 0x01
    18be:	f9 01       	movw	r30, r18
    18c0:	e8 27       	eor	r30, r24
    18c2:	ff 27       	eor	r31, r31
    18c4:	ee 0f       	add	r30, r30
    18c6:	ff 1f       	adc	r31, r31
    18c8:	ea 5f       	subi	r30, 0xFA	; 250
    18ca:	fe 4f       	sbci	r31, 0xFE	; 254
    18cc:	23 2f       	mov	r18, r19
    18ce:	33 27       	eor	r19, r19
    18d0:	80 81       	ld	r24, Z
    18d2:	91 81       	ldd	r25, Z+1	; 0x01
    18d4:	82 27       	eor	r24, r18
    18d6:	93 27       	eor	r25, r19
    18d8:	fb 01       	movw	r30, r22
    18da:	91 83       	std	Z+1, r25	; 0x01
    18dc:	80 83       	st	Z, r24
    18de:	08 95       	ret

000018e0 <vcpptr_init>:
// Parameters: 
// vcp_ptrbuffer	*buff -					Pointer to the vcp buffer structure
// uint8			*message_buffer -		Pointer to the allocated data buffer
// uint16			message_buffer_size -	Size of the allocated data buffer
void vcpptr_init(vcp_ptrbuffer *buff, uint8 *message_buffer, uint16 message_buffer_size)
{
    18e0:	fc 01       	movw	r30, r24
	buff->address =	0;
    18e2:	10 82       	st	Z, r1
	buff->message =	message_buffer;
    18e4:	72 83       	std	Z+2, r23	; 0x02
    18e6:	61 83       	std	Z+1, r22	; 0x01
	buff->size =	message_buffer_size;
    18e8:	56 83       	std	Z+6, r21	; 0x06
    18ea:	45 83       	std	Z+5, r20	; 0x05
	buff->index	=	0;
    18ec:	10 86       	std	Z+8, r1	; 0x08
    18ee:	17 82       	std	Z+7, r1	; 0x07
	buff->crc =		CRC16_INIT_VALUE;
    18f0:	14 82       	std	Z+4, r1	; 0x04
    18f2:	13 82       	std	Z+3, r1	; 0x03
	buff->status =	VCP_IDLE;
    18f4:	11 86       	std	Z+9, r1	; 0x09
    18f6:	08 95       	ret

000018f8 <Create_VCP_frame>:
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
    18f8:	4f 92       	push	r4
    18fa:	5f 92       	push	r5
    18fc:	6f 92       	push	r6
    18fe:	7f 92       	push	r7
    1900:	8f 92       	push	r8
    1902:	9f 92       	push	r9
    1904:	af 92       	push	r10
    1906:	bf 92       	push	r11
    1908:	cf 92       	push	r12
    190a:	df 92       	push	r13
    190c:	ef 92       	push	r14
    190e:	ff 92       	push	r15
    1910:	0f 93       	push	r16
    1912:	1f 93       	push	r17
    1914:	cf 93       	push	r28
    1916:	df 93       	push	r29
    1918:	00 d0       	rcall	.+0      	; 0x191a <Create_VCP_frame+0x22>
    191a:	1f 92       	push	r1
    191c:	cd b7       	in	r28, 0x3d	; 61
    191e:	de b7       	in	r29, 0x3e	; 62
    1920:	6c 01       	movw	r12, r24
    1922:	5b 01       	movw	r10, r22
    1924:	79 01       	movw	r14, r18
	uint16_t crc = CRC16_INIT_VALUE;
    1926:	1a 82       	std	Y+2, r1	; 0x02
    1928:	19 82       	std	Y+1, r1	; 0x01
	uint16_t src_index = 0;
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
    192a:	00 97       	sbiw	r24, 0x00	; 0
    192c:	09 f4       	brne	.+2      	; 0x1930 <Create_VCP_frame+0x38>
    192e:	58 c0       	rjmp	.+176    	; 0x19e0 <Create_VCP_frame+0xe8>
    1930:	21 15       	cp	r18, r1
    1932:	31 05       	cpc	r19, r1
    1934:	09 f4       	brne	.+2      	; 0x1938 <Create_VCP_frame+0x40>
    1936:	54 c0       	rjmp	.+168    	; 0x19e0 <Create_VCP_frame+0xe8>
		return VCP_NULL_ERR;

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
    1938:	4c 30       	cpi	r20, 0x0C	; 12
    193a:	18 f0       	brcs	.+6      	; 0x1942 <Create_VCP_frame+0x4a>
    193c:	48 33       	cpi	r20, 0x38	; 56
    193e:	09 f0       	breq	.+2      	; 0x1942 <Create_VCP_frame+0x4a>
    1940:	51 c0       	rjmp	.+162    	; 0x19e4 <Create_VCP_frame+0xec>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    1942:	44 24       	eor	r4, r4
    1944:	43 94       	inc	r4
    1946:	51 2c       	mov	r5, r1
    1948:	4c 0e       	add	r4, r28
    194a:	5d 1e       	adc	r5, r29
    194c:	b2 01       	movw	r22, r4
    194e:	84 2f       	mov	r24, r20
    1950:	4b 83       	std	Y+3, r20	; 0x03
    1952:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <append_crc16>
// uint8ptr		dst -		Pointer to the destination buffer
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
    1956:	37 01       	movw	r6, r14
    1958:	60 0e       	add	r6, r16
    195a:	71 1e       	adc	r7, r17
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    195c:	47 01       	movw	r8, r14
    195e:	07 c0       	rjmp	.+14     	; 0x196e <Create_VCP_frame+0x76>
	  append_crc16(src[src_index], &crc);
    1960:	b2 01       	movw	r22, r4
    1962:	f4 01       	movw	r30, r8
    1964:	81 91       	ld	r24, Z+
    1966:	4f 01       	movw	r8, r30
    1968:	4b 83       	std	Y+3, r20	; 0x03
    196a:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <append_crc16>
    196e:	4b 81       	ldd	r20, Y+3	; 0x03
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    1970:	86 14       	cp	r8, r6
    1972:	97 04       	cpc	r9, r7
    1974:	a9 f7       	brne	.-22     	; 0x1960 <Create_VCP_frame+0x68>
	  append_crc16(src[src_index], &crc);
	
	// Add CRC to the end of the source buffer
	src[src_index++] = ((crc >> 8) & 0xFF);
    1976:	89 81       	ldd	r24, Y+1	; 0x01
    1978:	9a 81       	ldd	r25, Y+2	; 0x02
    197a:	f7 01       	movw	r30, r14
    197c:	e0 0f       	add	r30, r16
    197e:	f1 1f       	adc	r31, r17
    1980:	90 83       	st	Z, r25
	src[src_index++] = (crc & 0xFF);
    1982:	81 83       	std	Z+1, r24	; 0x01
    1984:	0e 5f       	subi	r16, 0xFE	; 254
    1986:	1f 4f       	sbci	r17, 0xFF	; 255
	payload_size = src_index;
	
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
    1988:	80 ec       	ldi	r24, 0xC0	; 192
    198a:	f6 01       	movw	r30, r12
    198c:	80 83       	st	Z, r24
	// then insert VCP address
	dst[dst_index++] =					addr;
    198e:	41 83       	std	Z+1, r20	; 0x01
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1990:	d7 01       	movw	r26, r14
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
    1992:	42 e0       	ldi	r20, 0x02	; 2
    1994:	50 e0       	ldi	r21, 0x00	; 0
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    1996:	2d ed       	ldi	r18, 0xDD	; 221
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
    1998:	3b ed       	ldi	r19, 0xDB	; 219
			dst[dst_index++] =			TFEND;
    199a:	6c ed       	ldi	r22, 0xDC	; 220
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    199c:	0f c0       	rjmp	.+30     	; 0x19bc <Create_VCP_frame+0xc4>
	{
		if (src[src_index] == FEND)
    199e:	8d 91       	ld	r24, X+
    19a0:	80 3c       	cpi	r24, 0xC0	; 192
    19a2:	19 f4       	brne	.+6      	; 0x19aa <Create_VCP_frame+0xb2>
		{
			dst[dst_index++] =			FESC;
    19a4:	30 83       	st	Z, r19
			dst[dst_index++] =			TFEND;
    19a6:	61 83       	std	Z+1, r22	; 0x01
    19a8:	04 c0       	rjmp	.+8      	; 0x19b2 <Create_VCP_frame+0xba>
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
    19aa:	80 83       	st	Z, r24
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
    19ac:	8b 3d       	cpi	r24, 0xDB	; 219
    19ae:	21 f4       	brne	.+8      	; 0x19b8 <Create_VCP_frame+0xc0>
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    19b0:	21 83       	std	Z+1, r18	; 0x01
    19b2:	4e 5f       	subi	r20, 0xFE	; 254
    19b4:	5f 4f       	sbci	r21, 0xFF	; 255
    19b6:	02 c0       	rjmp	.+4      	; 0x19bc <Create_VCP_frame+0xc4>
		}
		else
		{
			dst[dst_index++] =			src[src_index];
    19b8:	4f 5f       	subi	r20, 0xFF	; 255
    19ba:	5f 4f       	sbci	r21, 0xFF	; 255
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    19bc:	cd 01       	movw	r24, r26
    19be:	8e 19       	sub	r24, r14
    19c0:	9f 09       	sbc	r25, r15
    19c2:	f6 01       	movw	r30, r12
    19c4:	e4 0f       	add	r30, r20
    19c6:	f5 1f       	adc	r31, r21
    19c8:	80 17       	cp	r24, r16
    19ca:	91 07       	cpc	r25, r17
    19cc:	40 f3       	brcs	.-48     	; 0x199e <Create_VCP_frame+0xa6>
		//if (dst_index >= *dst_size - 1)
			//return VCP_OVR_ERR;
	}
	
	// End the frame with FEND
	dst[dst_index++] =					FEND;
    19ce:	80 ec       	ldi	r24, 0xC0	; 192
    19d0:	80 83       	st	Z, r24
    19d2:	4f 5f       	subi	r20, 0xFF	; 255
    19d4:	5f 4f       	sbci	r21, 0xFF	; 255
	
	// Save the frame size
	*dst_size = dst_index;
    19d6:	f5 01       	movw	r30, r10
    19d8:	51 83       	std	Z+1, r21	; 0x01
    19da:	40 83       	st	Z, r20
	
	// All good
	return VCP_TERM;
    19dc:	81 e0       	ldi	r24, 0x01	; 1
    19de:	03 c0       	rjmp	.+6      	; 0x19e6 <Create_VCP_frame+0xee>
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
		return VCP_NULL_ERR;
    19e0:	85 e0       	ldi	r24, 0x05	; 5
    19e2:	01 c0       	rjmp	.+2      	; 0x19e6 <Create_VCP_frame+0xee>

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
		return VCP_ADDR_ERR;
    19e4:	86 e0       	ldi	r24, 0x06	; 6
	// Save the frame size
	*dst_size = dst_index;
	
	// All good
	return VCP_TERM;
}
    19e6:	0f 90       	pop	r0
    19e8:	0f 90       	pop	r0
    19ea:	0f 90       	pop	r0
    19ec:	df 91       	pop	r29
    19ee:	cf 91       	pop	r28
    19f0:	1f 91       	pop	r17
    19f2:	0f 91       	pop	r16
    19f4:	ff 90       	pop	r15
    19f6:	ef 90       	pop	r14
    19f8:	df 90       	pop	r13
    19fa:	cf 90       	pop	r12
    19fc:	bf 90       	pop	r11
    19fe:	af 90       	pop	r10
    1a00:	9f 90       	pop	r9
    1a02:	8f 90       	pop	r8
    1a04:	7f 90       	pop	r7
    1a06:	6f 90       	pop	r6
    1a08:	5f 90       	pop	r5
    1a0a:	4f 90       	pop	r4
    1a0c:	08 95       	ret

00001a0e <Receive_VCP_byte>:
// and return VCP status.
// Parameters:
// vcp_ptrbuffer	*buff -	Pointer to the vcp buffer structure
// uint8			byte -	received byte
uint8_t Receive_VCP_byte(vcp_ptrbuffer *buff, uint8 byte)
{
    1a0e:	cf 92       	push	r12
    1a10:	df 92       	push	r13
    1a12:	ef 92       	push	r14
    1a14:	ff 92       	push	r15
    1a16:	0f 93       	push	r16
    1a18:	1f 93       	push	r17
    1a1a:	cf 93       	push	r28
    1a1c:	df 93       	push	r29
    1a1e:	ec 01       	movw	r28, r24
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
    1a20:	29 81       	ldd	r18, Y+1	; 0x01
    1a22:	3a 81       	ldd	r19, Y+2	; 0x02
    1a24:	21 15       	cp	r18, r1
    1a26:	31 05       	cpc	r19, r1
    1a28:	09 f4       	brne	.+2      	; 0x1a2c <Receive_VCP_byte+0x1e>
    1a2a:	84 c0       	rjmp	.+264    	; 0x1b34 <Receive_VCP_byte+0x126>
		return VCP_NULL_ERR;
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
    1a2c:	8f 81       	ldd	r24, Y+7	; 0x07
    1a2e:	98 85       	ldd	r25, Y+8	; 0x08
    1a30:	4d 81       	ldd	r20, Y+5	; 0x05
    1a32:	5e 81       	ldd	r21, Y+6	; 0x06
    1a34:	41 50       	subi	r20, 0x01	; 1
    1a36:	51 09       	sbc	r21, r1
    1a38:	84 17       	cp	r24, r20
    1a3a:	95 07       	cpc	r25, r21
    1a3c:	08 f0       	brcs	.+2      	; 0x1a40 <Receive_VCP_byte+0x32>
    1a3e:	7c c0       	rjmp	.+248    	; 0x1b38 <Receive_VCP_byte+0x12a>
		return VCP_OVR_ERR;
	
	// State Machine
	switch (buff->status)
    1a40:	49 85       	ldd	r20, Y+9	; 0x09
    1a42:	42 30       	cpi	r20, 0x02	; 2
    1a44:	39 f1       	breq	.+78     	; 0x1a94 <Receive_VCP_byte+0x86>
    1a46:	18 f4       	brcc	.+6      	; 0x1a4e <Receive_VCP_byte+0x40>
    1a48:	44 23       	and	r20, r20
    1a4a:	31 f0       	breq	.+12     	; 0x1a58 <Receive_VCP_byte+0x4a>
    1a4c:	38 c0       	rjmp	.+112    	; 0x1abe <Receive_VCP_byte+0xb0>
    1a4e:	40 31       	cpi	r20, 0x10	; 16
    1a50:	31 f0       	breq	.+12     	; 0x1a5e <Receive_VCP_byte+0x50>
    1a52:	40 32       	cpi	r20, 0x20	; 32
    1a54:	a1 f5       	brne	.+104    	; 0x1abe <Receive_VCP_byte+0xb0>
    1a56:	0a c0       	rjmp	.+20     	; 0x1a6c <Receive_VCP_byte+0x5e>
	{
		case VCP_IDLE:										
			if (byte == FEND)
    1a58:	60 3c       	cpi	r22, 0xC0	; 192
    1a5a:	91 f5       	brne	.+100    	; 0x1ac0 <Receive_VCP_byte+0xb2>
    1a5c:	0d c0       	rjmp	.+26     	; 0x1a78 <Receive_VCP_byte+0x6a>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
    1a5e:	6c 30       	cpi	r22, 0x0C	; 12
    1a60:	18 f0       	brcs	.+6      	; 0x1a68 <Receive_VCP_byte+0x5a>
    1a62:	68 33       	cpi	r22, 0x38	; 56
    1a64:	09 f0       	breq	.+2      	; 0x1a68 <Receive_VCP_byte+0x5a>
    1a66:	6a c0       	rjmp	.+212    	; 0x1b3c <Receive_VCP_byte+0x12e>
				return VCP_ADDR_ERR;
			else
			{
				buff->address = byte;
    1a68:	68 83       	st	Y, r22
    1a6a:	26 c0       	rjmp	.+76     	; 0x1ab8 <Receive_VCP_byte+0xaa>
				buff->status = VCP_RECEIVING;
			}	
			break;
		case VCP_RECEIVING:
			if (byte == FEND)
    1a6c:	60 3c       	cpi	r22, 0xC0	; 192
    1a6e:	31 f4       	brne	.+12     	; 0x1a7c <Receive_VCP_byte+0x6e>
			{
				if (buff->index > 0)
    1a70:	89 2b       	or	r24, r25
    1a72:	11 f0       	breq	.+4      	; 0x1a78 <Receive_VCP_byte+0x6a>
					// Done
					buff->status = VCP_TERM;
    1a74:	81 e0       	ldi	r24, 0x01	; 1
    1a76:	21 c0       	rjmp	.+66     	; 0x1aba <Receive_VCP_byte+0xac>
				else
					// No data between FENDs - assume lost sync and start over
					buff->status = VCP_ADDRESS;
    1a78:	80 e1       	ldi	r24, 0x10	; 16
    1a7a:	1f c0       	rjmp	.+62     	; 0x1aba <Receive_VCP_byte+0xac>
			}
			else if (byte == FESC)
    1a7c:	6b 3d       	cpi	r22, 0xDB	; 219
    1a7e:	11 f4       	brne	.+4      	; 0x1a84 <Receive_VCP_byte+0x76>
				buff->status = VCP_ESC;
    1a80:	82 e0       	ldi	r24, 0x02	; 2
    1a82:	1b c0       	rjmp	.+54     	; 0x1aba <Receive_VCP_byte+0xac>
			else
			{
				buff->message[(buff->index)++] = byte;	
    1a84:	f9 01       	movw	r30, r18
    1a86:	e8 0f       	add	r30, r24
    1a88:	f9 1f       	adc	r31, r25
    1a8a:	60 83       	st	Z, r22
    1a8c:	01 96       	adiw	r24, 0x01	; 1
    1a8e:	98 87       	std	Y+8, r25	; 0x08
    1a90:	8f 83       	std	Y+7, r24	; 0x07
    1a92:	16 c0       	rjmp	.+44     	; 0x1ac0 <Receive_VCP_byte+0xb2>
			}						
			break;
		case VCP_ESC:
			if (byte == TFEND)
    1a94:	6c 3d       	cpi	r22, 0xDC	; 220
    1a96:	29 f4       	brne	.+10     	; 0x1aa2 <Receive_VCP_byte+0x94>
			{
				buff->message[(buff->index)++] = FEND;
    1a98:	f9 01       	movw	r30, r18
    1a9a:	e8 0f       	add	r30, r24
    1a9c:	f9 1f       	adc	r31, r25
    1a9e:	40 ec       	ldi	r20, 0xC0	; 192
    1aa0:	07 c0       	rjmp	.+14     	; 0x1ab0 <Receive_VCP_byte+0xa2>
				buff->status = VCP_RECEIVING;
			}
			else if (byte == TFESC)
    1aa2:	6d 3d       	cpi	r22, 0xDD	; 221
    1aa4:	09 f0       	breq	.+2      	; 0x1aa8 <Receive_VCP_byte+0x9a>
    1aa6:	4c c0       	rjmp	.+152    	; 0x1b40 <Receive_VCP_byte+0x132>
			{
				buff->message[(buff->index)++] = FESC;
    1aa8:	f9 01       	movw	r30, r18
    1aaa:	e8 0f       	add	r30, r24
    1aac:	f9 1f       	adc	r31, r25
    1aae:	4b ed       	ldi	r20, 0xDB	; 219
    1ab0:	40 83       	st	Z, r20
    1ab2:	01 96       	adiw	r24, 0x01	; 1
    1ab4:	98 87       	std	Y+8, r25	; 0x08
    1ab6:	8f 83       	std	Y+7, r24	; 0x07
				buff->status = VCP_RECEIVING;
    1ab8:	80 e2       	ldi	r24, 0x20	; 32
    1aba:	89 87       	std	Y+9, r24	; 0x09
    1abc:	01 c0       	rjmp	.+2      	; 0x1ac0 <Receive_VCP_byte+0xb2>
			}
			else
				return VCP_ESC_ERR;	
			break;
		default:
			buff->status = VCP_IDLE;
    1abe:	19 86       	std	Y+9, r1	; 0x09
			break; 
	}
	
	// End of frame
	if (buff->status == VCP_TERM)
    1ac0:	89 85       	ldd	r24, Y+9	; 0x09
    1ac2:	81 30       	cpi	r24, 0x01	; 1
    1ac4:	11 f0       	breq	.+4      	; 0x1aca <Receive_VCP_byte+0xbc>
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
    1ac6:	89 85       	ldd	r24, Y+9	; 0x09
    1ac8:	3c c0       	rjmp	.+120    	; 0x1b42 <Receive_VCP_byte+0x134>
	
	// End of frame
	if (buff->status == VCP_TERM)
	{
		// Message CRC is last 2 bytes 
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
    1aca:	89 81       	ldd	r24, Y+1	; 0x01
    1acc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ace:	4f 81       	ldd	r20, Y+7	; 0x07
    1ad0:	58 85       	ldd	r21, Y+8	; 0x08
    1ad2:	84 0f       	add	r24, r20
    1ad4:	95 1f       	adc	r25, r21
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	32 97       	sbiw	r30, 0x02	; 2
    1ada:	30 81       	ld	r19, Z
    1adc:	20 e0       	ldi	r18, 0x00	; 0
    1ade:	fc 01       	movw	r30, r24
    1ae0:	31 97       	sbiw	r30, 0x01	; 1
    1ae2:	80 81       	ld	r24, Z
    1ae4:	69 01       	movw	r12, r18
    1ae6:	c8 0e       	add	r12, r24
    1ae8:	d1 1c       	adc	r13, r1
		// Remove CRC bytes from the message
		buff->index -= 2;
    1aea:	42 50       	subi	r20, 0x02	; 2
    1aec:	51 09       	sbc	r21, r1
    1aee:	58 87       	std	Y+8, r21	; 0x08
    1af0:	4f 83       	std	Y+7, r20	; 0x07
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
    1af2:	7e 01       	movw	r14, r28
    1af4:	83 e0       	ldi	r24, 0x03	; 3
    1af6:	e8 0e       	add	r14, r24
    1af8:	f1 1c       	adc	r15, r1
    1afa:	b7 01       	movw	r22, r14
    1afc:	88 81       	ld	r24, Y
    1afe:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <append_crc16>
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    1b02:	00 e0       	ldi	r16, 0x00	; 0
    1b04:	10 e0       	ldi	r17, 0x00	; 0
    1b06:	0a c0       	rjmp	.+20     	; 0x1b1c <Receive_VCP_byte+0x10e>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
    1b08:	e9 81       	ldd	r30, Y+1	; 0x01
    1b0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b0c:	e0 0f       	add	r30, r16
    1b0e:	f1 1f       	adc	r31, r17
    1b10:	b7 01       	movw	r22, r14
    1b12:	80 81       	ld	r24, Z
    1b14:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <append_crc16>
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
		// Remove CRC bytes from the message
		buff->index -= 2;
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    1b18:	0f 5f       	subi	r16, 0xFF	; 255
    1b1a:	1f 4f       	sbci	r17, 0xFF	; 255
    1b1c:	8f 81       	ldd	r24, Y+7	; 0x07
    1b1e:	98 85       	ldd	r25, Y+8	; 0x08
    1b20:	08 17       	cp	r16, r24
    1b22:	19 07       	cpc	r17, r25
    1b24:	88 f3       	brcs	.-30     	; 0x1b08 <Receive_VCP_byte+0xfa>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
		}
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
    1b26:	8b 81       	ldd	r24, Y+3	; 0x03
    1b28:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2a:	8c 15       	cp	r24, r12
    1b2c:	9d 05       	cpc	r25, r13
    1b2e:	59 f2       	breq	.-106    	; 0x1ac6 <Receive_VCP_byte+0xb8>
			return VCP_CRC_ERR;
    1b30:	84 e0       	ldi	r24, 0x04	; 4
    1b32:	07 c0       	rjmp	.+14     	; 0x1b42 <Receive_VCP_byte+0x134>
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
		return VCP_NULL_ERR;
    1b34:	85 e0       	ldi	r24, 0x05	; 5
    1b36:	05 c0       	rjmp	.+10     	; 0x1b42 <Receive_VCP_byte+0x134>
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
		return VCP_OVR_ERR;
    1b38:	83 e0       	ldi	r24, 0x03	; 3
    1b3a:	03 c0       	rjmp	.+6      	; 0x1b42 <Receive_VCP_byte+0x134>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
				return VCP_ADDR_ERR;
    1b3c:	86 e0       	ldi	r24, 0x06	; 6
    1b3e:	01 c0       	rjmp	.+2      	; 0x1b42 <Receive_VCP_byte+0x134>
			{
				buff->message[(buff->index)++] = FESC;
				buff->status = VCP_RECEIVING;
			}
			else
				return VCP_ESC_ERR;	
    1b40:	87 e0       	ldi	r24, 0x07	; 7
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
}
    1b42:	df 91       	pop	r29
    1b44:	cf 91       	pop	r28
    1b46:	1f 91       	pop	r17
    1b48:	0f 91       	pop	r16
    1b4a:	ff 90       	pop	r15
    1b4c:	ef 90       	pop	r14
    1b4e:	df 90       	pop	r13
    1b50:	cf 90       	pop	r12
    1b52:	08 95       	ret

00001b54 <tx_put_byte.part.0>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    return;
  if( tel_packet_index[uart] < tel_packet_size[uart] )
    1b54:	28 2f       	mov	r18, r24
    1b56:	30 e0       	ldi	r19, 0x00	; 0
    1b58:	f9 01       	movw	r30, r18
    1b5a:	eb 59       	subi	r30, 0x9B	; 155
    1b5c:	f7 4f       	sbci	r31, 0xF7	; 247
    1b5e:	60 81       	ld	r22, Z
    1b60:	d9 01       	movw	r26, r18
    1b62:	aa 0f       	add	r26, r26
    1b64:	bb 1f       	adc	r27, r27
    1b66:	a7 5d       	subi	r26, 0xD7	; 215
    1b68:	bc 4f       	sbci	r27, 0xFC	; 252
    1b6a:	4d 91       	ld	r20, X+
    1b6c:	5c 91       	ld	r21, X
    1b6e:	70 e0       	ldi	r23, 0x00	; 0
    1b70:	64 17       	cp	r22, r20
    1b72:	75 07       	cpc	r23, r21
    1b74:	10 f5       	brcc	.+68     	; 0x1bba <tx_put_byte.part.0+0x66>
  {
      if ( uart == 0 )
    1b76:	81 11       	cpse	r24, r1
    1b78:	0e c0       	rjmp	.+28     	; 0x1b96 <tx_put_byte.part.0+0x42>
      UDR0 = tel_packet[uart][tel_packet_index[uart]++];
    1b7a:	80 81       	ld	r24, Z
    1b7c:	9f ef       	ldi	r25, 0xFF	; 255
    1b7e:	92 9f       	mul	r25, r18
    1b80:	d0 01       	movw	r26, r0
    1b82:	93 9f       	mul	r25, r19
    1b84:	b0 0d       	add	r27, r0
    1b86:	11 24       	eor	r1, r1
    1b88:	a8 0f       	add	r26, r24
    1b8a:	b1 1d       	adc	r27, r1
    1b8c:	a3 59       	subi	r26, 0x93	; 147
    1b8e:	b7 4f       	sbci	r27, 0xF7	; 247
    1b90:	9c 91       	ld	r25, X
    1b92:	9c b9       	out	0x0c, r25	; 12
    1b94:	10 c0       	rjmp	.+32     	; 0x1bb6 <tx_put_byte.part.0+0x62>
    else if ( uart == 1 )
    1b96:	81 30       	cpi	r24, 0x01	; 1
    1b98:	81 f4       	brne	.+32     	; 0x1bba <tx_put_byte.part.0+0x66>
      UDR1 = tel_packet[uart][tel_packet_index[uart]++];
    1b9a:	80 81       	ld	r24, Z
    1b9c:	9f ef       	ldi	r25, 0xFF	; 255
    1b9e:	92 9f       	mul	r25, r18
    1ba0:	d0 01       	movw	r26, r0
    1ba2:	93 9f       	mul	r25, r19
    1ba4:	b0 0d       	add	r27, r0
    1ba6:	11 24       	eor	r1, r1
    1ba8:	a8 0f       	add	r26, r24
    1baa:	b1 1d       	adc	r27, r1
    1bac:	a3 59       	subi	r26, 0x93	; 147
    1bae:	b7 4f       	sbci	r27, 0xF7	; 247
    1bb0:	9c 91       	ld	r25, X
    1bb2:	90 93 9c 00 	sts	0x009C, r25
    1bb6:	8f 5f       	subi	r24, 0xFF	; 255
    1bb8:	80 83       	st	Z, r24
    1bba:	08 95       	ret

00001bbc <__vector_15>:
#include "vcp_library.h"
#include "crclib.h"
#include "uart.h"

ISR(TIMER0_COMP_vect)
{
    1bbc:	1f 92       	push	r1
    1bbe:	0f 92       	push	r0
    1bc0:	0f b6       	in	r0, 0x3f	; 63
    1bc2:	0f 92       	push	r0
    1bc4:	11 24       	eor	r1, r1
    1bc6:	8f 93       	push	r24
  if ( timer0_counter[0] > 0 )
    1bc8:	80 91 96 0c 	lds	r24, 0x0C96
    1bcc:	88 23       	and	r24, r24
    1bce:	29 f0       	breq	.+10     	; 0x1bda <__vector_15+0x1e>
    --timer0_counter[0];
    1bd0:	80 91 96 0c 	lds	r24, 0x0C96
    1bd4:	81 50       	subi	r24, 0x01	; 1
    1bd6:	80 93 96 0c 	sts	0x0C96, r24
  if ( timer0_counter[1] > 0 )
    1bda:	80 91 97 0c 	lds	r24, 0x0C97
    1bde:	88 23       	and	r24, r24
    1be0:	29 f0       	breq	.+10     	; 0x1bec <__vector_15+0x30>
    --timer0_counter[1];
    1be2:	80 91 97 0c 	lds	r24, 0x0C97
    1be6:	81 50       	subi	r24, 0x01	; 1
    1be8:	80 93 97 0c 	sts	0x0C97, r24
	//if (cntr == 0)
	//	PORTC |= 0x01;
	//else
	//	PORTC &= 0xFE;
	//_delay_ms(500);
}
    1bec:	8f 91       	pop	r24
    1bee:	0f 90       	pop	r0
    1bf0:	0f be       	out	0x3f, r0	; 63
    1bf2:	0f 90       	pop	r0
    1bf4:	1f 90       	pop	r1
    1bf6:	18 95       	reti

00001bf8 <__vector_12>:

/* Timer 1(A) routine */
ISR(TIMER1_COMPA_vect)		//Handle Radio & Torquer 30 min delays here; handle 10 min CDH-IB no heartbeat restart
{
    1bf8:	1f 92       	push	r1
    1bfa:	0f 92       	push	r0
    1bfc:	0f b6       	in	r0, 0x3f	; 63
    1bfe:	0f 92       	push	r0
    1c00:	11 24       	eor	r1, r1
    1c02:	0b b6       	in	r0, 0x3b	; 59
    1c04:	0f 92       	push	r0
    1c06:	2f 93       	push	r18
    1c08:	3f 93       	push	r19
    1c0a:	4f 93       	push	r20
    1c0c:	5f 93       	push	r21
    1c0e:	6f 93       	push	r22
    1c10:	7f 93       	push	r23
    1c12:	8f 93       	push	r24
    1c14:	9f 93       	push	r25
    1c16:	af 93       	push	r26
    1c18:	bf 93       	push	r27
    1c1a:	cf 93       	push	r28
    1c1c:	ef 93       	push	r30
    1c1e:	ff 93       	push	r31
	SVIT_t *component;
	
	//Testing
	PORTF ^= 0xFF;
    1c20:	80 91 62 00 	lds	r24, 0x0062
    1c24:	80 95       	com	r24
    1c26:	80 93 62 00 	sts	0x0062, r24
		
	if (timer1_counter[0] <= 0	  &&     rad_torq_flag){	//provides 30 minute delay			
    1c2a:	80 91 be 0e 	lds	r24, 0x0EBE
    1c2e:	81 11       	cpse	r24, r1
    1c30:	31 c0       	rjmp	.+98     	; 0x1c94 <__vector_12+0x9c>
    1c32:	80 91 0d 03 	lds	r24, 0x030D
    1c36:	88 23       	and	r24, r24
    1c38:	69 f1       	breq	.+90     	; 0x1c94 <__vector_12+0x9c>
	//if ( receive_flag == 1){		//If message is received, reset timer1_counter[0] to CYCLE_COUNTER
	    timer1_counter[0] = CYCLE_COUNTER;
    1c3a:	84 e8       	ldi	r24, 0x84	; 132
    1c3c:	80 93 be 0e 	sts	0x0EBE, r24
		
		//CHECK: Should the ISR do this code or not?
		
		//Turn on radios
		component = &svit[RADIO_1];
		switch_on( component->switch_num );
    1c40:	80 91 c9 04 	lds	r24, 0x04C9
    1c44:	0e 94 28 0a 	call	0x1450	; 0x1450 <switch_on>
		component->switch_state = SW_ON;
    1c48:	c1 e0       	ldi	r28, 0x01	; 1
    1c4a:	c0 93 ca 04 	sts	0x04CA, r28
		component = &svit[RADIO_2];
		switch_on( component->switch_num );
    1c4e:	80 91 ed 04 	lds	r24, 0x04ED
    1c52:	0e 94 28 0a 	call	0x1450	; 0x1450 <switch_on>
		component->switch_state = SW_ON;
    1c56:	c0 93 ee 04 	sts	0x04EE, r28
		
		//Turn on torque coils			
		component = &svit[TORQUER_1];
		switch_on( component->switch_num );
    1c5a:	80 91 a1 05 	lds	r24, 0x05A1
    1c5e:	0e 94 28 0a 	call	0x1450	; 0x1450 <switch_on>
		component->switch_state = SW_ON;
    1c62:	c0 93 a2 05 	sts	0x05A2, r28
		component = &svit[TORQUER_2];
		switch_on( component->switch_num );
    1c66:	80 91 c5 05 	lds	r24, 0x05C5
    1c6a:	0e 94 28 0a 	call	0x1450	; 0x1450 <switch_on>
		component->switch_state = SW_ON;
    1c6e:	c0 93 c6 05 	sts	0x05C6, r28
		component = &svit[TORQUER_3];
		switch_on( component->switch_num );
    1c72:	80 91 e9 05 	lds	r24, 0x05E9
    1c76:	0e 94 28 0a 	call	0x1450	; 0x1450 <switch_on>
		component->switch_state = SW_ON;
    1c7a:	c0 93 ea 05 	sts	0x05EA, r28
		torquer_on(TORQUER_1);
    1c7e:	81 e1       	ldi	r24, 0x11	; 17
    1c80:	0e 94 0b 0a 	call	0x1416	; 0x1416 <torquer_on>
		torquer_on(TORQUER_2);
    1c84:	82 e1       	ldi	r24, 0x12	; 18
    1c86:	0e 94 0b 0a 	call	0x1416	; 0x1416 <torquer_on>
		torquer_on(TORQUER_3);
    1c8a:	83 e1       	ldi	r24, 0x13	; 19
    1c8c:	0e 94 0b 0a 	call	0x1416	; 0x1416 <torquer_on>
		
		//PORTC ^= 0x02;	//LED for STK testing
		//PORTC ^= 0x01;
		
		//Don't reexecute this code
		rad_torq_flag = 0;
    1c90:	10 92 0d 03 	sts	0x030D, r1
	}
	
	if (timer1_counter[1] <= 0   &&   !cdh_heartbeat_flag){		//If heartbeat timer 1 has expired AND we haven't already ordered a restart
    1c94:	80 91 bf 0e 	lds	r24, 0x0EBF
    1c98:	81 11       	cpse	r24, r1
    1c9a:	07 c0       	rjmp	.+14     	; 0x1caa <__vector_12+0xb2>
    1c9c:	80 91 24 03 	lds	r24, 0x0324
    1ca0:	81 11       	cpse	r24, r1
    1ca2:	03 c0       	rjmp	.+6      	; 0x1caa <__vector_12+0xb2>
		//Order full component restart
		cdh_heartbeat_flag = 1;
    1ca4:	81 e0       	ldi	r24, 0x01	; 1
    1ca6:	80 93 24 03 	sts	0x0324, r24
		
	}
	
	//else{
		PORTC ^= 0x01;		//LED for STK testing at PORTC0
    1caa:	85 b3       	in	r24, 0x15	; 21
    1cac:	91 e0       	ldi	r25, 0x01	; 1
    1cae:	89 27       	eor	r24, r25
    1cb0:	85 bb       	out	0x15, r24	; 21
    1cb2:	2f ef       	ldi	r18, 0xFF	; 255
    1cb4:	8f e7       	ldi	r24, 0x7F	; 127
    1cb6:	96 e1       	ldi	r25, 0x16	; 22
    1cb8:	21 50       	subi	r18, 0x01	; 1
    1cba:	80 40       	sbci	r24, 0x00	; 0
    1cbc:	90 40       	sbci	r25, 0x00	; 0
    1cbe:	e1 f7       	brne	.-8      	; 0x1cb8 <__vector_12+0xc0>
    1cc0:	00 c0       	rjmp	.+0      	; 0x1cc2 <__vector_12+0xca>
    1cc2:	00 00       	nop
		_delay_ms(500);
		--timer1_counter[0];
    1cc4:	80 91 be 0e 	lds	r24, 0x0EBE
    1cc8:	81 50       	subi	r24, 0x01	; 1
    1cca:	80 93 be 0e 	sts	0x0EBE, r24
		--timer1_counter[1];
    1cce:	80 91 bf 0e 	lds	r24, 0x0EBF
    1cd2:	81 50       	subi	r24, 0x01	; 1
    1cd4:	80 93 bf 0e 	sts	0x0EBF, r24
	//   volatile float current_sample[t]
	// ADC current sample --> current_sample[t]
	// ADC voltage sample --> voltage_sample[t]
	// t = t + 1;
	// if t = max, make sure we call calc_OCV(method)
}
    1cd8:	ff 91       	pop	r31
    1cda:	ef 91       	pop	r30
    1cdc:	cf 91       	pop	r28
    1cde:	bf 91       	pop	r27
    1ce0:	af 91       	pop	r26
    1ce2:	9f 91       	pop	r25
    1ce4:	8f 91       	pop	r24
    1ce6:	7f 91       	pop	r23
    1ce8:	6f 91       	pop	r22
    1cea:	5f 91       	pop	r21
    1cec:	4f 91       	pop	r20
    1cee:	3f 91       	pop	r19
    1cf0:	2f 91       	pop	r18
    1cf2:	0f 90       	pop	r0
    1cf4:	0b be       	out	0x3b, r0	; 59
    1cf6:	0f 90       	pop	r0
    1cf8:	0f be       	out	0x3f, r0	; 63
    1cfa:	0f 90       	pop	r0
    1cfc:	1f 90       	pop	r1
    1cfe:	18 95       	reti

00001d00 <__vector_32>:

ISR(USART1_TX_vect)
{
    1d00:	1f 92       	push	r1
    1d02:	0f 92       	push	r0
    1d04:	0f b6       	in	r0, 0x3f	; 63
    1d06:	0f 92       	push	r0
    1d08:	11 24       	eor	r1, r1
    1d0a:	0b b6       	in	r0, 0x3b	; 59
    1d0c:	0f 92       	push	r0
    1d0e:	2f 93       	push	r18
    1d10:	3f 93       	push	r19
    1d12:	4f 93       	push	r20
    1d14:	5f 93       	push	r21
    1d16:	6f 93       	push	r22
    1d18:	7f 93       	push	r23
    1d1a:	8f 93       	push	r24
    1d1c:	9f 93       	push	r25
    1d1e:	af 93       	push	r26
    1d20:	bf 93       	push	r27
    1d22:	ef 93       	push	r30
    1d24:	ff 93       	push	r31
    1d26:	81 e0       	ldi	r24, 0x01	; 1
    1d28:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <tx_put_byte.part.0>
  tx_put_byte( 1 );
}
    1d2c:	ff 91       	pop	r31
    1d2e:	ef 91       	pop	r30
    1d30:	bf 91       	pop	r27
    1d32:	af 91       	pop	r26
    1d34:	9f 91       	pop	r25
    1d36:	8f 91       	pop	r24
    1d38:	7f 91       	pop	r23
    1d3a:	6f 91       	pop	r22
    1d3c:	5f 91       	pop	r21
    1d3e:	4f 91       	pop	r20
    1d40:	3f 91       	pop	r19
    1d42:	2f 91       	pop	r18
    1d44:	0f 90       	pop	r0
    1d46:	0b be       	out	0x3b, r0	; 59
    1d48:	0f 90       	pop	r0
    1d4a:	0f be       	out	0x3f, r0	; 63
    1d4c:	0f 90       	pop	r0
    1d4e:	1f 90       	pop	r1
    1d50:	18 95       	reti

00001d52 <__vector_30>:

ISR(USART1_RX_vect)
{
    1d52:	1f 92       	push	r1
    1d54:	0f 92       	push	r0
    1d56:	0f b6       	in	r0, 0x3f	; 63
    1d58:	0f 92       	push	r0
    1d5a:	11 24       	eor	r1, r1
    1d5c:	0b b6       	in	r0, 0x3b	; 59
    1d5e:	0f 92       	push	r0
    1d60:	2f 93       	push	r18
    1d62:	3f 93       	push	r19
    1d64:	4f 93       	push	r20
    1d66:	5f 93       	push	r21
    1d68:	6f 93       	push	r22
    1d6a:	7f 93       	push	r23
    1d6c:	8f 93       	push	r24
    1d6e:	9f 93       	push	r25
    1d70:	af 93       	push	r26
    1d72:	bf 93       	push	r27
    1d74:	ef 93       	push	r30
    1d76:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[1], UDR1 ) == VCP_TERM )
    1d78:	60 91 9c 00 	lds	r22, 0x009C
    1d7c:	80 91 c8 0e 	lds	r24, 0x0EC8
    1d80:	90 91 c9 0e 	lds	r25, 0x0EC9
    1d84:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <Receive_VCP_byte>
    1d88:	81 30       	cpi	r24, 0x01	; 1
    1d8a:	29 f4       	brne	.+10     	; 0x1d96 <__vector_30+0x44>
  {
    rx_flag[1]++;
    1d8c:	80 91 cc 0e 	lds	r24, 0x0ECC
    1d90:	8f 5f       	subi	r24, 0xFF	; 255
    1d92:	80 93 cc 0e 	sts	0x0ECC, r24
  }
}
    1d96:	ff 91       	pop	r31
    1d98:	ef 91       	pop	r30
    1d9a:	bf 91       	pop	r27
    1d9c:	af 91       	pop	r26
    1d9e:	9f 91       	pop	r25
    1da0:	8f 91       	pop	r24
    1da2:	7f 91       	pop	r23
    1da4:	6f 91       	pop	r22
    1da6:	5f 91       	pop	r21
    1da8:	4f 91       	pop	r20
    1daa:	3f 91       	pop	r19
    1dac:	2f 91       	pop	r18
    1dae:	0f 90       	pop	r0
    1db0:	0b be       	out	0x3b, r0	; 59
    1db2:	0f 90       	pop	r0
    1db4:	0f be       	out	0x3f, r0	; 63
    1db6:	0f 90       	pop	r0
    1db8:	1f 90       	pop	r1
    1dba:	18 95       	reti

00001dbc <__vector_21>:

ISR ( ADC_vect )
{
    1dbc:	1f 92       	push	r1
    1dbe:	0f 92       	push	r0
    1dc0:	0f b6       	in	r0, 0x3f	; 63
    1dc2:	0f 92       	push	r0
    1dc4:	11 24       	eor	r1, r1
    1dc6:	5f 93       	push	r21
    1dc8:	6f 93       	push	r22
    1dca:	7f 93       	push	r23
    1dcc:	8f 93       	push	r24
    1dce:	9f 93       	push	r25
    1dd0:	af 93       	push	r26
    1dd2:	bf 93       	push	r27
  ADC_low = ADCL;	// Left adjusted; read 2 LSB then 8 MSB
    1dd4:	84 b1       	in	r24, 0x04	; 4
    1dd6:	80 93 c0 0e 	sts	0x0EC0, r24
  ADC_high = ADCH;
    1dda:	85 b1       	in	r24, 0x05	; 5
    1ddc:	80 93 86 0a 	sts	0x0A86, r24
  adc_flag = 1;
    1de0:	81 e0       	ldi	r24, 0x01	; 1
    1de2:	80 93 6c 0a 	sts	0x0A6C, r24
  coul_count_cnt = (coul_count_cnt + 1) % COUL_SAMPLES;
    1de6:	80 91 07 03 	lds	r24, 0x0307
    1dea:	90 91 08 03 	lds	r25, 0x0308
    1dee:	01 96       	adiw	r24, 0x01	; 1
    1df0:	64 e6       	ldi	r22, 0x64	; 100
    1df2:	70 e0       	ldi	r23, 0x00	; 0
    1df4:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <__udivmodhi4>
    1df8:	90 93 08 03 	sts	0x0308, r25
    1dfc:	80 93 07 03 	sts	0x0307, r24
}
    1e00:	bf 91       	pop	r27
    1e02:	af 91       	pop	r26
    1e04:	9f 91       	pop	r25
    1e06:	8f 91       	pop	r24
    1e08:	7f 91       	pop	r23
    1e0a:	6f 91       	pop	r22
    1e0c:	5f 91       	pop	r21
    1e0e:	0f 90       	pop	r0
    1e10:	0f be       	out	0x3f, r0	; 63
    1e12:	0f 90       	pop	r0
    1e14:	1f 90       	pop	r1
    1e16:	18 95       	reti

00001e18 <__vector_20>:

ISR( USART0_TX_vect )
{
    1e18:	1f 92       	push	r1
    1e1a:	0f 92       	push	r0
    1e1c:	0f b6       	in	r0, 0x3f	; 63
    1e1e:	0f 92       	push	r0
    1e20:	11 24       	eor	r1, r1
    1e22:	0b b6       	in	r0, 0x3b	; 59
    1e24:	0f 92       	push	r0
    1e26:	2f 93       	push	r18
    1e28:	3f 93       	push	r19
    1e2a:	4f 93       	push	r20
    1e2c:	5f 93       	push	r21
    1e2e:	6f 93       	push	r22
    1e30:	7f 93       	push	r23
    1e32:	8f 93       	push	r24
    1e34:	9f 93       	push	r25
    1e36:	af 93       	push	r26
    1e38:	bf 93       	push	r27
    1e3a:	ef 93       	push	r30
    1e3c:	ff 93       	push	r31
    1e3e:	80 e0       	ldi	r24, 0x00	; 0
    1e40:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <tx_put_byte.part.0>
  tx_put_byte( 0 );
}
    1e44:	ff 91       	pop	r31
    1e46:	ef 91       	pop	r30
    1e48:	bf 91       	pop	r27
    1e4a:	af 91       	pop	r26
    1e4c:	9f 91       	pop	r25
    1e4e:	8f 91       	pop	r24
    1e50:	7f 91       	pop	r23
    1e52:	6f 91       	pop	r22
    1e54:	5f 91       	pop	r21
    1e56:	4f 91       	pop	r20
    1e58:	3f 91       	pop	r19
    1e5a:	2f 91       	pop	r18
    1e5c:	0f 90       	pop	r0
    1e5e:	0b be       	out	0x3b, r0	; 59
    1e60:	0f 90       	pop	r0
    1e62:	0f be       	out	0x3f, r0	; 63
    1e64:	0f 90       	pop	r0
    1e66:	1f 90       	pop	r1
    1e68:	18 95       	reti

00001e6a <__vector_18>:

ISR( USART0_RX_vect )
{
    1e6a:	1f 92       	push	r1
    1e6c:	0f 92       	push	r0
    1e6e:	0f b6       	in	r0, 0x3f	; 63
    1e70:	0f 92       	push	r0
    1e72:	11 24       	eor	r1, r1
    1e74:	0b b6       	in	r0, 0x3b	; 59
    1e76:	0f 92       	push	r0
    1e78:	2f 93       	push	r18
    1e7a:	3f 93       	push	r19
    1e7c:	4f 93       	push	r20
    1e7e:	5f 93       	push	r21
    1e80:	6f 93       	push	r22
    1e82:	7f 93       	push	r23
    1e84:	8f 93       	push	r24
    1e86:	9f 93       	push	r25
    1e88:	af 93       	push	r26
    1e8a:	bf 93       	push	r27
    1e8c:	ef 93       	push	r30
    1e8e:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[0], UDR0 ) == VCP_TERM )
    1e90:	6c b1       	in	r22, 0x0c	; 12
    1e92:	80 91 c6 0e 	lds	r24, 0x0EC6
    1e96:	90 91 c7 0e 	lds	r25, 0x0EC7
    1e9a:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <Receive_VCP_byte>
    1e9e:	81 30       	cpi	r24, 0x01	; 1
    1ea0:	29 f4       	brne	.+10     	; 0x1eac <__vector_18+0x42>
  {
    rx_flag[0]++;
    1ea2:	80 91 cb 0e 	lds	r24, 0x0ECB
    1ea6:	8f 5f       	subi	r24, 0xFF	; 255
    1ea8:	80 93 cb 0e 	sts	0x0ECB, r24
  }
}
    1eac:	ff 91       	pop	r31
    1eae:	ef 91       	pop	r30
    1eb0:	bf 91       	pop	r27
    1eb2:	af 91       	pop	r26
    1eb4:	9f 91       	pop	r25
    1eb6:	8f 91       	pop	r24
    1eb8:	7f 91       	pop	r23
    1eba:	6f 91       	pop	r22
    1ebc:	5f 91       	pop	r21
    1ebe:	4f 91       	pop	r20
    1ec0:	3f 91       	pop	r19
    1ec2:	2f 91       	pop	r18
    1ec4:	0f 90       	pop	r0
    1ec6:	0b be       	out	0x3b, r0	; 59
    1ec8:	0f 90       	pop	r0
    1eca:	0f be       	out	0x3f, r0	; 63
    1ecc:	0f 90       	pop	r0
    1ece:	1f 90       	pop	r1
    1ed0:	18 95       	reti

00001ed2 <tx_put_byte>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    1ed2:	82 30       	cpi	r24, 0x02	; 2
    1ed4:	10 f4       	brcc	.+4      	; 0x1eda <tx_put_byte+0x8>
    1ed6:	0c 94 aa 0d 	jmp	0x1b54	; 0x1b54 <tx_put_byte.part.0>
    1eda:	08 95       	ret

00001edc <construct_telemetry_packet>:
  }
}


void construct_telemetry_packet( uint8_t* packet_payload )
{
    1edc:	2f 92       	push	r2
    1ede:	3f 92       	push	r3
    1ee0:	4f 92       	push	r4
    1ee2:	5f 92       	push	r5
    1ee4:	6f 92       	push	r6
    1ee6:	7f 92       	push	r7
    1ee8:	8f 92       	push	r8
    1eea:	9f 92       	push	r9
    1eec:	af 92       	push	r10
    1eee:	bf 92       	push	r11
    1ef0:	cf 92       	push	r12
    1ef2:	df 92       	push	r13
    1ef4:	ef 92       	push	r14
    1ef6:	ff 92       	push	r15
    1ef8:	0f 93       	push	r16
    1efa:	1f 93       	push	r17
    1efc:	cf 93       	push	r28
    1efe:	df 93       	push	r29
    1f00:	cd b7       	in	r28, 0x3d	; 61
    1f02:	de b7       	in	r29, 0x3e	; 62
    1f04:	28 97       	sbiw	r28, 0x08	; 8
    1f06:	0f b6       	in	r0, 0x3f	; 63
    1f08:	f8 94       	cli
    1f0a:	de bf       	out	0x3e, r29	; 62
    1f0c:	0f be       	out	0x3f, r0	; 63
    1f0e:	cd bf       	out	0x3d, r28	; 61
    1f10:	98 87       	std	Y+8, r25	; 0x08
    1f12:	8f 83       	std	Y+7, r24	; 0x07
  packet_payload[0] = VCP_POWER_TELEMETRY;
    1f14:	dc 01       	movw	r26, r24
    1f16:	1c 92       	st	X, r1
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
    1f18:	30 91 a6 04 	lds	r19, 0x04A6
    1f1c:	33 0f       	add	r19, r19
                  ( svit[RADIO_1].switch_state << 2 )    |
    1f1e:	80 91 ca 04 	lds	r24, 0x04CA
    1f22:	b4 e0       	ldi	r27, 0x04	; 4
    1f24:	8b 9f       	mul	r24, r27
    1f26:	c0 01       	movw	r24, r0
    1f28:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1f2a:	38 2b       	or	r19, r24
    1f2c:	80 91 82 04 	lds	r24, 0x0482
    1f30:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
    1f32:	80 91 ee 04 	lds	r24, 0x04EE
    1f36:	e8 e0       	ldi	r30, 0x08	; 8
    1f38:	8e 9f       	mul	r24, r30
    1f3a:	c0 01       	movw	r24, r0
    1f3c:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1f3e:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
    1f40:	80 91 5a 05 	lds	r24, 0x055A
    1f44:	f0 e1       	ldi	r31, 0x10	; 16
    1f46:	8f 9f       	mul	r24, r31
    1f48:	c0 01       	movw	r24, r0
    1f4a:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1f4c:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;
    1f4e:	80 91 7e 05 	lds	r24, 0x057E
    1f52:	20 e2       	ldi	r18, 0x20	; 32
    1f54:	82 9f       	mul	r24, r18
    1f56:	c0 01       	movw	r24, r0
    1f58:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1f5a:	38 2b       	or	r19, r24
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
    1f5c:	40 91 c6 05 	lds	r20, 0x05C6
    1f60:	44 0f       	add	r20, r20
                  ( svit[TORQUER_3].switch_state << 2 ) |
    1f62:	80 91 ea 05 	lds	r24, 0x05EA
    1f66:	54 e0       	ldi	r21, 0x04	; 4
    1f68:	85 9f       	mul	r24, r21
    1f6a:	c0 01       	movw	r24, r0
    1f6c:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1f6e:	48 2b       	or	r20, r24
    1f70:	80 91 a2 05 	lds	r24, 0x05A2
    1f74:	48 2b       	or	r20, r24
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );
    1f76:	e2 e1       	ldi	r30, 0x12	; 18
    1f78:	f5 e0       	ldi	r31, 0x05	; 5
    1f7a:	80 81       	ld	r24, Z
    1f7c:	a8 e0       	ldi	r26, 0x08	; 8
    1f7e:	8a 9f       	mul	r24, r26
    1f80:	c0 01       	movw	r24, r0
    1f82:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1f84:	48 2b       	or	r20, r24
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
    1f86:	20 91 62 03 	lds	r18, 0x0362
    1f8a:	22 0f       	add	r18, r18
                  ( svit[FC_5V].switch_state << 2 )        |
    1f8c:	80 91 86 03 	lds	r24, 0x0386
    1f90:	b4 e0       	ldi	r27, 0x04	; 4
    1f92:	8b 9f       	mul	r24, r27
    1f94:	c0 01       	movw	r24, r0
    1f96:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1f98:	28 2b       	or	r18, r24
    1f9a:	80 91 3e 03 	lds	r24, 0x033E
    1f9e:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
    1fa0:	80 91 ce 03 	lds	r24, 0x03CE
    1fa4:	58 e0       	ldi	r21, 0x08	; 8
    1fa6:	85 9f       	mul	r24, r21
    1fa8:	c0 01       	movw	r24, r0
    1faa:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1fac:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
    1fae:	80 91 f2 03 	lds	r24, 0x03F2
    1fb2:	a0 e1       	ldi	r26, 0x10	; 16
    1fb4:	8a 9f       	mul	r24, r26
    1fb6:	c0 01       	movw	r24, r0
    1fb8:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1fba:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
    1fbc:	80 91 16 04 	lds	r24, 0x0416
    1fc0:	b0 e2       	ldi	r27, 0x20	; 32
    1fc2:	8b 9f       	mul	r24, r27
    1fc4:	c0 01       	movw	r24, r0
    1fc6:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1fc8:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
    1fca:	80 91 3a 04 	lds	r24, 0x043A
    1fce:	50 e4       	ldi	r21, 0x40	; 64
    1fd0:	85 9f       	mul	r24, r21
    1fd2:	c0 01       	movw	r24, r0
    1fd4:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1fd6:	28 2b       	or	r18, r24
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;
    1fd8:	80 91 5e 04 	lds	r24, 0x045E
    1fdc:	a0 e8       	ldi	r26, 0x80	; 128
    1fde:	8a 9f       	mul	r24, r26
    1fe0:	c0 01       	movw	r24, r0
    1fe2:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1fe4:	28 2b       	or	r18, r24
  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );

  packet_payload[1] = on_off_state0;
    1fe6:	af 81       	ldd	r26, Y+7	; 0x07
    1fe8:	b8 85       	ldd	r27, Y+8	; 0x08
    1fea:	11 96       	adiw	r26, 0x01	; 1
    1fec:	2c 93       	st	X, r18
    1fee:	11 97       	sbiw	r26, 0x01	; 1
  packet_payload[2] = on_off_state1;
    1ff0:	12 96       	adiw	r26, 0x02	; 2
    1ff2:	3c 93       	st	X, r19
    1ff4:	12 97       	sbiw	r26, 0x02	; 2
  packet_payload[3] = on_off_state2;
    1ff6:	13 96       	adiw	r26, 0x03	; 3
    1ff8:	4c 93       	st	X, r20
    1ffa:	13 97       	sbiw	r26, 0x03	; 3
  packet_payload[4] = 0x99;
    1ffc:	89 e9       	ldi	r24, 0x99	; 153
    1ffe:	14 96       	adiw	r26, 0x04	; 4
    2000:	8c 93       	st	X, r24
    2002:	14 97       	sbiw	r26, 0x04	; 4
  packet_payload[5] = svit[MAESTRO].switch_state;
    2004:	80 81       	ld	r24, Z
    2006:	15 96       	adiw	r26, 0x05	; 5
    2008:	8c 93       	st	X, r24

  // voltage values (raw ADC output)
  packet_payload[6]  = SVIT_check_V_critical( svit[SPECTROMETER].name );
    200a:	2c e3       	ldi	r18, 0x3C	; 60
    200c:	62 2e       	mov	r6, r18
    200e:	23 e0       	ldi	r18, 0x03	; 3
    2010:	72 2e       	mov	r7, r18
    2012:	f3 01       	movw	r30, r6
    2014:	80 81       	ld	r24, Z
    2016:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    201a:	af 81       	ldd	r26, Y+7	; 0x07
    201c:	b8 85       	ldd	r27, Y+8	; 0x08
    201e:	16 96       	adiw	r26, 0x06	; 6
    2020:	8c 93       	st	X, r24
  packet_payload[7]  = SVIT_check_V_critical( svit[STAR_TRACKER].name );
    2022:	30 e6       	ldi	r19, 0x60	; 96
    2024:	83 2e       	mov	r8, r19
    2026:	33 e0       	ldi	r19, 0x03	; 3
    2028:	93 2e       	mov	r9, r19
    202a:	f4 01       	movw	r30, r8
    202c:	80 81       	ld	r24, Z
    202e:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2032:	af 81       	ldd	r26, Y+7	; 0x07
    2034:	b8 85       	ldd	r27, Y+8	; 0x08
    2036:	17 96       	adiw	r26, 0x07	; 7
    2038:	8c 93       	st	X, r24
  packet_payload[8]  = SVIT_check_V_critical( svit[FC_5V].name );
    203a:	44 e8       	ldi	r20, 0x84	; 132
    203c:	a4 2e       	mov	r10, r20
    203e:	43 e0       	ldi	r20, 0x03	; 3
    2040:	b4 2e       	mov	r11, r20
    2042:	f5 01       	movw	r30, r10
    2044:	80 81       	ld	r24, Z
    2046:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    204a:	af 81       	ldd	r26, Y+7	; 0x07
    204c:	b8 85       	ldd	r27, Y+8	; 0x08
    204e:	18 96       	adiw	r26, 0x08	; 8
    2050:	8c 93       	st	X, r24
  packet_payload[9]  = SVIT_check_V_critical( svit[FC_3_3V].name );
    2052:	58 ea       	ldi	r21, 0xA8	; 168
    2054:	c5 2e       	mov	r12, r21
    2056:	53 e0       	ldi	r21, 0x03	; 3
    2058:	d5 2e       	mov	r13, r21
    205a:	f6 01       	movw	r30, r12
    205c:	80 81       	ld	r24, Z
    205e:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2062:	af 81       	ldd	r26, Y+7	; 0x07
    2064:	b8 85       	ldd	r27, Y+8	; 0x08
    2066:	19 96       	adiw	r26, 0x09	; 9
    2068:	8c 93       	st	X, r24
  packet_payload[10] = SVIT_check_V_critical( svit[GPS_1].name );
    206a:	6c ec       	ldi	r22, 0xCC	; 204
    206c:	e6 2e       	mov	r14, r22
    206e:	63 e0       	ldi	r22, 0x03	; 3
    2070:	f6 2e       	mov	r15, r22
    2072:	f7 01       	movw	r30, r14
    2074:	80 81       	ld	r24, Z
    2076:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    207a:	af 81       	ldd	r26, Y+7	; 0x07
    207c:	b8 85       	ldd	r27, Y+8	; 0x08
    207e:	1a 96       	adiw	r26, 0x0a	; 10
    2080:	8c 93       	st	X, r24
  packet_payload[11] = SVIT_check_V_critical( svit[CDH_IB].name );
    2082:	04 e1       	ldi	r16, 0x14	; 20
    2084:	14 e0       	ldi	r17, 0x04	; 4
    2086:	f8 01       	movw	r30, r16
    2088:	80 81       	ld	r24, Z
    208a:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    208e:	af 81       	ldd	r26, Y+7	; 0x07
    2090:	b8 85       	ldd	r27, Y+8	; 0x08
    2092:	1b 96       	adiw	r26, 0x0b	; 11
    2094:	8c 93       	st	X, r24
  packet_payload[12] = SVIT_check_V_critical( svit[HEATER_1].name );
    2096:	e8 e3       	ldi	r30, 0x38	; 56
    2098:	f4 e0       	ldi	r31, 0x04	; 4
    209a:	80 81       	ld	r24, Z
    209c:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    20a0:	af 81       	ldd	r26, Y+7	; 0x07
    20a2:	b8 85       	ldd	r27, Y+8	; 0x08
    20a4:	1c 96       	adiw	r26, 0x0c	; 12
    20a6:	8c 93       	st	X, r24
  packet_payload[13] = SVIT_check_V_critical( svit[HEATER_2].name );
    20a8:	7c e5       	ldi	r23, 0x5C	; 92
    20aa:	47 2e       	mov	r4, r23
    20ac:	74 e0       	ldi	r23, 0x04	; 4
    20ae:	57 2e       	mov	r5, r23
    20b0:	f2 01       	movw	r30, r4
    20b2:	80 81       	ld	r24, Z
    20b4:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    20b8:	af 81       	ldd	r26, Y+7	; 0x07
    20ba:	b8 85       	ldd	r27, Y+8	; 0x08
    20bc:	1d 96       	adiw	r26, 0x0d	; 13
    20be:	8c 93       	st	X, r24
  packet_payload[14] = SVIT_check_V_critical( svit[CMG].name );
    20c0:	e0 e8       	ldi	r30, 0x80	; 128
    20c2:	2e 2e       	mov	r2, r30
    20c4:	e4 e0       	ldi	r30, 0x04	; 4
    20c6:	3e 2e       	mov	r3, r30
    20c8:	f1 01       	movw	r30, r2
    20ca:	80 81       	ld	r24, Z
    20cc:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    20d0:	af 81       	ldd	r26, Y+7	; 0x07
    20d2:	b8 85       	ldd	r27, Y+8	; 0x08
    20d4:	1e 96       	adiw	r26, 0x0e	; 14
    20d6:	8c 93       	st	X, r24
  packet_payload[15] = SVIT_check_V_critical( svit[SUN_SENSOR].name );
    20d8:	24 ea       	ldi	r18, 0xA4	; 164
    20da:	34 e0       	ldi	r19, 0x04	; 4
    20dc:	f9 01       	movw	r30, r18
    20de:	80 81       	ld	r24, Z
    20e0:	29 83       	std	Y+1, r18	; 0x01
    20e2:	3a 83       	std	Y+2, r19	; 0x02
    20e4:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    20e8:	af 81       	ldd	r26, Y+7	; 0x07
    20ea:	b8 85       	ldd	r27, Y+8	; 0x08
    20ec:	1f 96       	adiw	r26, 0x0f	; 15
    20ee:	8c 93       	st	X, r24
  packet_payload[16] = SVIT_check_V_critical( svit[RADIO_1].name );
    20f0:	48 ec       	ldi	r20, 0xC8	; 200
    20f2:	54 e0       	ldi	r21, 0x04	; 4
    20f4:	fa 01       	movw	r30, r20
    20f6:	80 81       	ld	r24, Z
    20f8:	4b 83       	std	Y+3, r20	; 0x03
    20fa:	5c 83       	std	Y+4, r21	; 0x04
    20fc:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2100:	af 81       	ldd	r26, Y+7	; 0x07
    2102:	b8 85       	ldd	r27, Y+8	; 0x08
    2104:	50 96       	adiw	r26, 0x10	; 16
    2106:	8c 93       	st	X, r24
  packet_payload[17] = SVIT_check_V_critical( svit[RADIO_2].name );
    2108:	6c ee       	ldi	r22, 0xEC	; 236
    210a:	74 e0       	ldi	r23, 0x04	; 4
    210c:	fb 01       	movw	r30, r22
    210e:	80 81       	ld	r24, Z
    2110:	6d 83       	std	Y+5, r22	; 0x05
    2112:	7e 83       	std	Y+6, r23	; 0x06
    2114:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2118:	af 81       	ldd	r26, Y+7	; 0x07
    211a:	b8 85       	ldd	r27, Y+8	; 0x08
    211c:	51 96       	adiw	r26, 0x11	; 17
    211e:	8c 93       	st	X, r24
  packet_payload[18] = SVIT_check_V_critical( svit[FOG_15V].name );
    2120:	e8 e5       	ldi	r30, 0x58	; 88
    2122:	f5 e0       	ldi	r31, 0x05	; 5
    2124:	80 81       	ld	r24, Z
    2126:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    212a:	af 81       	ldd	r26, Y+7	; 0x07
    212c:	b8 85       	ldd	r27, Y+8	; 0x08
    212e:	52 96       	adiw	r26, 0x12	; 18
    2130:	8c 93       	st	X, r24
  packet_payload[19] = SVIT_check_V_critical( svit[FOG_5V].name );
    2132:	ec e7       	ldi	r30, 0x7C	; 124
    2134:	f5 e0       	ldi	r31, 0x05	; 5
    2136:	80 81       	ld	r24, Z
    2138:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    213c:	af 81       	ldd	r26, Y+7	; 0x07
    213e:	b8 85       	ldd	r27, Y+8	; 0x08
    2140:	53 96       	adiw	r26, 0x13	; 19
    2142:	8c 93       	st	X, r24
  packet_payload[20] = SVIT_check_V_critical( svit[TORQUER_1].name );
    2144:	e0 ea       	ldi	r30, 0xA0	; 160
    2146:	f5 e0       	ldi	r31, 0x05	; 5
    2148:	80 81       	ld	r24, Z
    214a:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    214e:	af 81       	ldd	r26, Y+7	; 0x07
    2150:	b8 85       	ldd	r27, Y+8	; 0x08
    2152:	54 96       	adiw	r26, 0x14	; 20
    2154:	8c 93       	st	X, r24
  packet_payload[21] = SVIT_check_V_critical( svit[TORQUER_2].name );
    2156:	e4 ec       	ldi	r30, 0xC4	; 196
    2158:	f5 e0       	ldi	r31, 0x05	; 5
    215a:	80 81       	ld	r24, Z
    215c:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2160:	af 81       	ldd	r26, Y+7	; 0x07
    2162:	b8 85       	ldd	r27, Y+8	; 0x08
    2164:	55 96       	adiw	r26, 0x15	; 21
    2166:	8c 93       	st	X, r24
  packet_payload[22] = SVIT_check_V_critical( svit[TORQUER_3].name );
    2168:	e8 ee       	ldi	r30, 0xE8	; 232
    216a:	f5 e0       	ldi	r31, 0x05	; 5
    216c:	80 81       	ld	r24, Z
    216e:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2172:	af 81       	ldd	r26, Y+7	; 0x07
    2174:	b8 85       	ldd	r27, Y+8	; 0x08
    2176:	56 96       	adiw	r26, 0x16	; 22
    2178:	8c 93       	st	X, r24
  packet_payload[23] = SVIT_check_V_critical( svit[BATTERY_1].name );
    217a:	ec e0       	ldi	r30, 0x0C	; 12
    217c:	f6 e0       	ldi	r31, 0x06	; 6
    217e:	80 81       	ld	r24, Z
    2180:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2184:	af 81       	ldd	r26, Y+7	; 0x07
    2186:	b8 85       	ldd	r27, Y+8	; 0x08
    2188:	57 96       	adiw	r26, 0x17	; 23
    218a:	8c 93       	st	X, r24
  packet_payload[24] = SVIT_check_V_critical( svit[BATTERY_2].name );
    218c:	e0 e3       	ldi	r30, 0x30	; 48
    218e:	f6 e0       	ldi	r31, 0x06	; 6
    2190:	80 81       	ld	r24, Z
    2192:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2196:	af 81       	ldd	r26, Y+7	; 0x07
    2198:	b8 85       	ldd	r27, Y+8	; 0x08
    219a:	58 96       	adiw	r26, 0x18	; 24
    219c:	8c 93       	st	X, r24
  packet_payload[25] = SVIT_check_V_critical( svit[SOLAR_FULL].name );
    219e:	e4 e5       	ldi	r30, 0x54	; 84
    21a0:	f6 e0       	ldi	r31, 0x06	; 6
    21a2:	80 81       	ld	r24, Z
    21a4:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    21a8:	af 81       	ldd	r26, Y+7	; 0x07
    21aa:	b8 85       	ldd	r27, Y+8	; 0x08
    21ac:	59 96       	adiw	r26, 0x19	; 25
    21ae:	8c 93       	st	X, r24
  packet_payload[26] = SVIT_check_V_critical( svit[SOLAR_1].name );
    21b0:	e8 e7       	ldi	r30, 0x78	; 120
    21b2:	f6 e0       	ldi	r31, 0x06	; 6
    21b4:	80 81       	ld	r24, Z
    21b6:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    21ba:	af 81       	ldd	r26, Y+7	; 0x07
    21bc:	b8 85       	ldd	r27, Y+8	; 0x08
    21be:	5a 96       	adiw	r26, 0x1a	; 26
    21c0:	8c 93       	st	X, r24
  packet_payload[27] = SVIT_check_V_critical( svit[SOLAR_2].name );
    21c2:	ec e9       	ldi	r30, 0x9C	; 156
    21c4:	f6 e0       	ldi	r31, 0x06	; 6
    21c6:	80 81       	ld	r24, Z
    21c8:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    21cc:	af 81       	ldd	r26, Y+7	; 0x07
    21ce:	b8 85       	ldd	r27, Y+8	; 0x08
    21d0:	5b 96       	adiw	r26, 0x1b	; 27
    21d2:	8c 93       	st	X, r24
  packet_payload[28] = SVIT_check_V_critical( svit[SOLAR_3].name );
    21d4:	e0 ec       	ldi	r30, 0xC0	; 192
    21d6:	f6 e0       	ldi	r31, 0x06	; 6
    21d8:	80 81       	ld	r24, Z
    21da:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    21de:	af 81       	ldd	r26, Y+7	; 0x07
    21e0:	b8 85       	ldd	r27, Y+8	; 0x08
    21e2:	5c 96       	adiw	r26, 0x1c	; 28
    21e4:	8c 93       	st	X, r24
  packet_payload[29] = SVIT_check_V_critical( svit[SOLAR_4].name );
    21e6:	e4 ee       	ldi	r30, 0xE4	; 228
    21e8:	f6 e0       	ldi	r31, 0x06	; 6
    21ea:	80 81       	ld	r24, Z
    21ec:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    21f0:	af 81       	ldd	r26, Y+7	; 0x07
    21f2:	b8 85       	ldd	r27, Y+8	; 0x08
    21f4:	5d 96       	adiw	r26, 0x1d	; 29
    21f6:	8c 93       	st	X, r24
  packet_payload[30] = SVIT_check_V_critical( svit[SOLAR_5].name );
    21f8:	e8 e0       	ldi	r30, 0x08	; 8
    21fa:	f7 e0       	ldi	r31, 0x07	; 7
    21fc:	80 81       	ld	r24, Z
    21fe:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2202:	af 81       	ldd	r26, Y+7	; 0x07
    2204:	b8 85       	ldd	r27, Y+8	; 0x08
    2206:	5e 96       	adiw	r26, 0x1e	; 30
    2208:	8c 93       	st	X, r24
  packet_payload[31] = SVIT_check_V_critical( svit[SOLAR_6].name );
    220a:	ec e2       	ldi	r30, 0x2C	; 44
    220c:	f7 e0       	ldi	r31, 0x07	; 7
    220e:	80 81       	ld	r24, Z
    2210:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2214:	af 81       	ldd	r26, Y+7	; 0x07
    2216:	b8 85       	ldd	r27, Y+8	; 0x08
    2218:	5f 96       	adiw	r26, 0x1f	; 31
    221a:	8c 93       	st	X, r24
  packet_payload[32] = SVIT_check_V_critical( svit[SOLAR_7].name );
    221c:	e0 e5       	ldi	r30, 0x50	; 80
    221e:	f7 e0       	ldi	r31, 0x07	; 7
    2220:	80 81       	ld	r24, Z
    2222:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2226:	af 81       	ldd	r26, Y+7	; 0x07
    2228:	b8 85       	ldd	r27, Y+8	; 0x08
    222a:	90 96       	adiw	r26, 0x20	; 32
    222c:	8c 93       	st	X, r24
  packet_payload[33] = SVIT_check_V_critical( svit[SOLAR_8].name );
    222e:	e4 e7       	ldi	r30, 0x74	; 116
    2230:	f7 e0       	ldi	r31, 0x07	; 7
    2232:	80 81       	ld	r24, Z
    2234:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2238:	af 81       	ldd	r26, Y+7	; 0x07
    223a:	b8 85       	ldd	r27, Y+8	; 0x08
    223c:	91 96       	adiw	r26, 0x21	; 33
    223e:	8c 93       	st	X, r24
  packet_payload[34] = SVIT_check_V_critical( svit[SOLAR_9].name );
    2240:	e8 e9       	ldi	r30, 0x98	; 152
    2242:	f7 e0       	ldi	r31, 0x07	; 7
    2244:	80 81       	ld	r24, Z
    2246:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    224a:	af 81       	ldd	r26, Y+7	; 0x07
    224c:	b8 85       	ldd	r27, Y+8	; 0x08
    224e:	92 96       	adiw	r26, 0x22	; 34
    2250:	8c 93       	st	X, r24
  packet_payload[35] = SVIT_check_V_critical( svit[SOLAR_10].name );
    2252:	ec eb       	ldi	r30, 0xBC	; 188
    2254:	f7 e0       	ldi	r31, 0x07	; 7
    2256:	80 81       	ld	r24, Z
    2258:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    225c:	af 81       	ldd	r26, Y+7	; 0x07
    225e:	b8 85       	ldd	r27, Y+8	; 0x08
    2260:	93 96       	adiw	r26, 0x23	; 35
    2262:	8c 93       	st	X, r24
  packet_payload[36] = SVIT_check_V_critical( svit[SOLAR_11].name );
    2264:	e0 ee       	ldi	r30, 0xE0	; 224
    2266:	f7 e0       	ldi	r31, 0x07	; 7
    2268:	80 81       	ld	r24, Z
    226a:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    226e:	af 81       	ldd	r26, Y+7	; 0x07
    2270:	b8 85       	ldd	r27, Y+8	; 0x08
    2272:	94 96       	adiw	r26, 0x24	; 36
    2274:	8c 93       	st	X, r24
  packet_payload[37] = SVIT_check_V_critical( svit[SOLAR_12].name );
    2276:	e4 e0       	ldi	r30, 0x04	; 4
    2278:	f8 e0       	ldi	r31, 0x08	; 8
    227a:	80 81       	ld	r24, Z
    227c:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2280:	af 81       	ldd	r26, Y+7	; 0x07
    2282:	b8 85       	ldd	r27, Y+8	; 0x08
    2284:	95 96       	adiw	r26, 0x25	; 37
    2286:	8c 93       	st	X, r24
  packet_payload[38] = SVIT_check_V_critical( svit[POWER_BOARD].name );
    2288:	80 91 28 08 	lds	r24, 0x0828
    228c:	0e 94 cc 0a 	call	0x1598	; 0x1598 <SVIT_check_V_critical>
    2290:	ef 81       	ldd	r30, Y+7	; 0x07
    2292:	f8 85       	ldd	r31, Y+8	; 0x08
    2294:	86 a3       	std	Z+38, r24	; 0x26
  //uint8_t voltage_error1;
  //uint8_t voltage_error2;
  //uint8_t voltage_error3;
  //uint8_t voltage_error4;
 
  packet_payload[39] = 0;
    2296:	17 a2       	std	Z+39, r1	; 0x27
  packet_payload[40] = 0;
    2298:	10 a6       	std	Z+40, r1	; 0x28
  packet_payload[41] = 0;
    229a:	11 a6       	std	Z+41, r1	; 0x29
  packet_payload[42] = 0;
    229c:	12 a6       	std	Z+42, r1	; 0x2a
  packet_payload[43] = 0;
    229e:	13 a6       	std	Z+43, r1	; 0x2b

  // current values (raw ADC output)
  packet_payload[44] = SVIT_check_I_critical( svit[SPECTROMETER].name );
    22a0:	d3 01       	movw	r26, r6
    22a2:	8c 91       	ld	r24, X
    22a4:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    22a8:	ef 81       	ldd	r30, Y+7	; 0x07
    22aa:	f8 85       	ldd	r31, Y+8	; 0x08
    22ac:	84 a7       	std	Z+44, r24	; 0x2c
  packet_payload[45] = SVIT_check_I_critical( svit[STAR_TRACKER].name );
    22ae:	d4 01       	movw	r26, r8
    22b0:	8c 91       	ld	r24, X
    22b2:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    22b6:	ef 81       	ldd	r30, Y+7	; 0x07
    22b8:	f8 85       	ldd	r31, Y+8	; 0x08
    22ba:	85 a7       	std	Z+45, r24	; 0x2d
  packet_payload[46] = SVIT_check_I_critical( svit[FC_5V].name );
    22bc:	d5 01       	movw	r26, r10
    22be:	8c 91       	ld	r24, X
    22c0:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    22c4:	ef 81       	ldd	r30, Y+7	; 0x07
    22c6:	f8 85       	ldd	r31, Y+8	; 0x08
    22c8:	86 a7       	std	Z+46, r24	; 0x2e
  packet_payload[47] = SVIT_check_I_critical( svit[FC_3_3V].name );
    22ca:	d6 01       	movw	r26, r12
    22cc:	8c 91       	ld	r24, X
    22ce:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    22d2:	ef 81       	ldd	r30, Y+7	; 0x07
    22d4:	f8 85       	ldd	r31, Y+8	; 0x08
    22d6:	87 a7       	std	Z+47, r24	; 0x2f
  packet_payload[48] = SVIT_check_I_critical( svit[GPS_1].name );
    22d8:	d7 01       	movw	r26, r14
    22da:	8c 91       	ld	r24, X
    22dc:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    22e0:	ef 81       	ldd	r30, Y+7	; 0x07
    22e2:	f8 85       	ldd	r31, Y+8	; 0x08
    22e4:	80 ab       	std	Z+48, r24	; 0x30
  packet_payload[49] = SVIT_check_I_critical( svit[CDH_IB].name );
    22e6:	d8 01       	movw	r26, r16
    22e8:	8c 91       	ld	r24, X
    22ea:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    22ee:	ef 81       	ldd	r30, Y+7	; 0x07
    22f0:	f8 85       	ldd	r31, Y+8	; 0x08
    22f2:	81 ab       	std	Z+49, r24	; 0x31
  packet_payload[50] = SVIT_check_I_critical( svit[HEATER_1].name );
    22f4:	a8 e3       	ldi	r26, 0x38	; 56
    22f6:	b4 e0       	ldi	r27, 0x04	; 4
    22f8:	8c 91       	ld	r24, X
    22fa:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    22fe:	ef 81       	ldd	r30, Y+7	; 0x07
    2300:	f8 85       	ldd	r31, Y+8	; 0x08
    2302:	82 ab       	std	Z+50, r24	; 0x32
  packet_payload[51] = SVIT_check_I_critical( svit[HEATER_2].name );
    2304:	d2 01       	movw	r26, r4
    2306:	8c 91       	ld	r24, X
    2308:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    230c:	ef 81       	ldd	r30, Y+7	; 0x07
    230e:	f8 85       	ldd	r31, Y+8	; 0x08
    2310:	83 ab       	std	Z+51, r24	; 0x33
  packet_payload[52] = SVIT_check_I_critical( svit[CMG].name );
    2312:	d1 01       	movw	r26, r2
    2314:	8c 91       	ld	r24, X
    2316:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    231a:	ef 81       	ldd	r30, Y+7	; 0x07
    231c:	f8 85       	ldd	r31, Y+8	; 0x08
    231e:	84 ab       	std	Z+52, r24	; 0x34
  packet_payload[53] = SVIT_check_I_critical( svit[SUN_SENSOR].name );
    2320:	29 81       	ldd	r18, Y+1	; 0x01
    2322:	3a 81       	ldd	r19, Y+2	; 0x02
    2324:	d9 01       	movw	r26, r18
    2326:	8c 91       	ld	r24, X
    2328:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    232c:	ef 81       	ldd	r30, Y+7	; 0x07
    232e:	f8 85       	ldd	r31, Y+8	; 0x08
    2330:	85 ab       	std	Z+53, r24	; 0x35
  packet_payload[54] = SVIT_check_I_critical( svit[RADIO_1].name );
    2332:	4b 81       	ldd	r20, Y+3	; 0x03
    2334:	5c 81       	ldd	r21, Y+4	; 0x04
    2336:	da 01       	movw	r26, r20
    2338:	8c 91       	ld	r24, X
    233a:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    233e:	ef 81       	ldd	r30, Y+7	; 0x07
    2340:	f8 85       	ldd	r31, Y+8	; 0x08
    2342:	86 ab       	std	Z+54, r24	; 0x36
  packet_payload[55] = SVIT_check_I_critical( svit[RADIO_2].name );
    2344:	6d 81       	ldd	r22, Y+5	; 0x05
    2346:	7e 81       	ldd	r23, Y+6	; 0x06
    2348:	db 01       	movw	r26, r22
    234a:	8c 91       	ld	r24, X
    234c:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2350:	ef 81       	ldd	r30, Y+7	; 0x07
    2352:	f8 85       	ldd	r31, Y+8	; 0x08
    2354:	87 ab       	std	Z+55, r24	; 0x37
  packet_payload[56] = SVIT_check_I_critical( svit[FOG_15V].name );
    2356:	a8 e5       	ldi	r26, 0x58	; 88
    2358:	b5 e0       	ldi	r27, 0x05	; 5
    235a:	8c 91       	ld	r24, X
    235c:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2360:	ef 81       	ldd	r30, Y+7	; 0x07
    2362:	f8 85       	ldd	r31, Y+8	; 0x08
    2364:	80 af       	std	Z+56, r24	; 0x38
  packet_payload[57] = SVIT_check_I_critical( svit[FOG_5V].name );
    2366:	ac e7       	ldi	r26, 0x7C	; 124
    2368:	b5 e0       	ldi	r27, 0x05	; 5
    236a:	8c 91       	ld	r24, X
    236c:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2370:	ef 81       	ldd	r30, Y+7	; 0x07
    2372:	f8 85       	ldd	r31, Y+8	; 0x08
    2374:	81 af       	std	Z+57, r24	; 0x39
  packet_payload[58] = SVIT_check_I_critical( svit[TORQUER_1].name );
    2376:	a0 ea       	ldi	r26, 0xA0	; 160
    2378:	b5 e0       	ldi	r27, 0x05	; 5
    237a:	8c 91       	ld	r24, X
    237c:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2380:	ef 81       	ldd	r30, Y+7	; 0x07
    2382:	f8 85       	ldd	r31, Y+8	; 0x08
    2384:	82 af       	std	Z+58, r24	; 0x3a
  packet_payload[59] = SVIT_check_I_critical( svit[TORQUER_2].name );
    2386:	a4 ec       	ldi	r26, 0xC4	; 196
    2388:	b5 e0       	ldi	r27, 0x05	; 5
    238a:	8c 91       	ld	r24, X
    238c:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2390:	ef 81       	ldd	r30, Y+7	; 0x07
    2392:	f8 85       	ldd	r31, Y+8	; 0x08
    2394:	83 af       	std	Z+59, r24	; 0x3b
  packet_payload[60] = SVIT_check_I_critical( svit[TORQUER_3].name );
    2396:	a8 ee       	ldi	r26, 0xE8	; 232
    2398:	b5 e0       	ldi	r27, 0x05	; 5
    239a:	8c 91       	ld	r24, X
    239c:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    23a0:	ef 81       	ldd	r30, Y+7	; 0x07
    23a2:	f8 85       	ldd	r31, Y+8	; 0x08
    23a4:	84 af       	std	Z+60, r24	; 0x3c
  packet_payload[61] = SVIT_check_I_critical( svit[BATTERY_1].name );
    23a6:	ac e0       	ldi	r26, 0x0C	; 12
    23a8:	b6 e0       	ldi	r27, 0x06	; 6
    23aa:	8c 91       	ld	r24, X
    23ac:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    23b0:	ef 81       	ldd	r30, Y+7	; 0x07
    23b2:	f8 85       	ldd	r31, Y+8	; 0x08
    23b4:	85 af       	std	Z+61, r24	; 0x3d
  packet_payload[62] = SVIT_check_I_critical( svit[BATTERY_2].name );
    23b6:	a0 e3       	ldi	r26, 0x30	; 48
    23b8:	b6 e0       	ldi	r27, 0x06	; 6
    23ba:	8c 91       	ld	r24, X
    23bc:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    23c0:	ef 81       	ldd	r30, Y+7	; 0x07
    23c2:	f8 85       	ldd	r31, Y+8	; 0x08
    23c4:	86 af       	std	Z+62, r24	; 0x3e
  packet_payload[63] = SVIT_check_I_critical( svit[SOLAR_FULL].name );
    23c6:	a4 e5       	ldi	r26, 0x54	; 84
    23c8:	b6 e0       	ldi	r27, 0x06	; 6
    23ca:	8c 91       	ld	r24, X
    23cc:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    23d0:	ef 81       	ldd	r30, Y+7	; 0x07
    23d2:	f8 85       	ldd	r31, Y+8	; 0x08
    23d4:	87 af       	std	Z+63, r24	; 0x3f
  packet_payload[64] = SVIT_check_I_critical( svit[SOLAR_1].name );
    23d6:	a8 e7       	ldi	r26, 0x78	; 120
    23d8:	b6 e0       	ldi	r27, 0x06	; 6
    23da:	8c 91       	ld	r24, X
    23dc:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    23e0:	ef 81       	ldd	r30, Y+7	; 0x07
    23e2:	f8 85       	ldd	r31, Y+8	; 0x08
    23e4:	e0 5c       	subi	r30, 0xC0	; 192
    23e6:	ff 4f       	sbci	r31, 0xFF	; 255
    23e8:	80 83       	st	Z, r24
  packet_payload[65] = SVIT_check_I_critical( svit[SOLAR_2].name );
    23ea:	ec e9       	ldi	r30, 0x9C	; 156
    23ec:	f6 e0       	ldi	r31, 0x06	; 6
    23ee:	80 81       	ld	r24, Z
    23f0:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    23f4:	ef 81       	ldd	r30, Y+7	; 0x07
    23f6:	f8 85       	ldd	r31, Y+8	; 0x08
    23f8:	ef 5b       	subi	r30, 0xBF	; 191
    23fa:	ff 4f       	sbci	r31, 0xFF	; 255
    23fc:	80 83       	st	Z, r24
  packet_payload[66] = SVIT_check_I_critical( svit[SOLAR_3].name );
    23fe:	a0 ec       	ldi	r26, 0xC0	; 192
    2400:	b6 e0       	ldi	r27, 0x06	; 6
    2402:	8c 91       	ld	r24, X
    2404:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2408:	ef 81       	ldd	r30, Y+7	; 0x07
    240a:	f8 85       	ldd	r31, Y+8	; 0x08
    240c:	ee 5b       	subi	r30, 0xBE	; 190
    240e:	ff 4f       	sbci	r31, 0xFF	; 255
    2410:	80 83       	st	Z, r24
  packet_payload[67] = SVIT_check_I_critical( svit[SOLAR_4].name );
    2412:	e4 ee       	ldi	r30, 0xE4	; 228
    2414:	f6 e0       	ldi	r31, 0x06	; 6
    2416:	80 81       	ld	r24, Z
    2418:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    241c:	ef 81       	ldd	r30, Y+7	; 0x07
    241e:	f8 85       	ldd	r31, Y+8	; 0x08
    2420:	ed 5b       	subi	r30, 0xBD	; 189
    2422:	ff 4f       	sbci	r31, 0xFF	; 255
    2424:	80 83       	st	Z, r24
  packet_payload[68] = SVIT_check_I_critical( svit[SOLAR_5].name );
    2426:	a8 e0       	ldi	r26, 0x08	; 8
    2428:	b7 e0       	ldi	r27, 0x07	; 7
    242a:	8c 91       	ld	r24, X
    242c:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2430:	ef 81       	ldd	r30, Y+7	; 0x07
    2432:	f8 85       	ldd	r31, Y+8	; 0x08
    2434:	ec 5b       	subi	r30, 0xBC	; 188
    2436:	ff 4f       	sbci	r31, 0xFF	; 255
    2438:	80 83       	st	Z, r24
  packet_payload[69] = SVIT_check_I_critical( svit[SOLAR_6].name );
    243a:	ec e2       	ldi	r30, 0x2C	; 44
    243c:	f7 e0       	ldi	r31, 0x07	; 7
    243e:	80 81       	ld	r24, Z
    2440:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2444:	ef 81       	ldd	r30, Y+7	; 0x07
    2446:	f8 85       	ldd	r31, Y+8	; 0x08
    2448:	eb 5b       	subi	r30, 0xBB	; 187
    244a:	ff 4f       	sbci	r31, 0xFF	; 255
    244c:	80 83       	st	Z, r24
  packet_payload[70] = SVIT_check_I_critical( svit[SOLAR_7].name );
    244e:	a0 e5       	ldi	r26, 0x50	; 80
    2450:	b7 e0       	ldi	r27, 0x07	; 7
    2452:	8c 91       	ld	r24, X
    2454:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2458:	ef 81       	ldd	r30, Y+7	; 0x07
    245a:	f8 85       	ldd	r31, Y+8	; 0x08
    245c:	ea 5b       	subi	r30, 0xBA	; 186
    245e:	ff 4f       	sbci	r31, 0xFF	; 255
    2460:	80 83       	st	Z, r24
  packet_payload[71] = SVIT_check_I_critical( svit[SOLAR_8].name );
    2462:	e4 e7       	ldi	r30, 0x74	; 116
    2464:	f7 e0       	ldi	r31, 0x07	; 7
    2466:	80 81       	ld	r24, Z
    2468:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    246c:	ef 81       	ldd	r30, Y+7	; 0x07
    246e:	f8 85       	ldd	r31, Y+8	; 0x08
    2470:	e9 5b       	subi	r30, 0xB9	; 185
    2472:	ff 4f       	sbci	r31, 0xFF	; 255
    2474:	80 83       	st	Z, r24
  packet_payload[72] = SVIT_check_I_critical( svit[SOLAR_9].name );
    2476:	a8 e9       	ldi	r26, 0x98	; 152
    2478:	b7 e0       	ldi	r27, 0x07	; 7
    247a:	8c 91       	ld	r24, X
    247c:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2480:	ef 81       	ldd	r30, Y+7	; 0x07
    2482:	f8 85       	ldd	r31, Y+8	; 0x08
    2484:	e8 5b       	subi	r30, 0xB8	; 184
    2486:	ff 4f       	sbci	r31, 0xFF	; 255
    2488:	80 83       	st	Z, r24
  packet_payload[73] = SVIT_check_I_critical( svit[SOLAR_10].name );
    248a:	ec eb       	ldi	r30, 0xBC	; 188
    248c:	f7 e0       	ldi	r31, 0x07	; 7
    248e:	80 81       	ld	r24, Z
    2490:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    2494:	ef 81       	ldd	r30, Y+7	; 0x07
    2496:	f8 85       	ldd	r31, Y+8	; 0x08
    2498:	e7 5b       	subi	r30, 0xB7	; 183
    249a:	ff 4f       	sbci	r31, 0xFF	; 255
    249c:	80 83       	st	Z, r24
  packet_payload[74] = SVIT_check_I_critical( svit[SOLAR_11].name );
    249e:	a0 ee       	ldi	r26, 0xE0	; 224
    24a0:	b7 e0       	ldi	r27, 0x07	; 7
    24a2:	8c 91       	ld	r24, X
    24a4:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    24a8:	ef 81       	ldd	r30, Y+7	; 0x07
    24aa:	f8 85       	ldd	r31, Y+8	; 0x08
    24ac:	e6 5b       	subi	r30, 0xB6	; 182
    24ae:	ff 4f       	sbci	r31, 0xFF	; 255
    24b0:	80 83       	st	Z, r24
  packet_payload[75] = SVIT_check_I_critical( svit[SOLAR_12].name );
    24b2:	e4 e0       	ldi	r30, 0x04	; 4
    24b4:	f8 e0       	ldi	r31, 0x08	; 8
    24b6:	80 81       	ld	r24, Z
    24b8:	0e 94 bd 0a 	call	0x157a	; 0x157a <SVIT_check_I_critical>
    24bc:	ef 81       	ldd	r30, Y+7	; 0x07
    24be:	f8 85       	ldd	r31, Y+8	; 0x08
    24c0:	e5 5b       	subi	r30, 0xB5	; 181
    24c2:	ff 4f       	sbci	r31, 0xFF	; 255
    24c4:	80 83       	st	Z, r24
  packet_payload[76] = 0xFF;//SVIT_check_I_critical( svit[POWER_BOARD].name );
    24c6:	ef 81       	ldd	r30, Y+7	; 0x07
    24c8:	f8 85       	ldd	r31, Y+8	; 0x08
    24ca:	e4 5b       	subi	r30, 0xB4	; 180
    24cc:	ff 4f       	sbci	r31, 0xFF	; 255
    24ce:	8f ef       	ldi	r24, 0xFF	; 255
    24d0:	80 83       	st	Z, r24
  //uint8_t current_error1;
  //uint8_t current_error2;
  //uint8_t current_error3;
  //uint8_t current_error4;

  packet_payload[77] = batt1_voltage;//V_ack_change();
    24d2:	ef 81       	ldd	r30, Y+7	; 0x07
    24d4:	f8 85       	ldd	r31, Y+8	; 0x08
    24d6:	e3 5b       	subi	r30, 0xB3	; 179
    24d8:	ff 4f       	sbci	r31, 0xFF	; 255
    24da:	90 91 90 0a 	lds	r25, 0x0A90
    24de:	90 83       	st	Z, r25
  packet_payload[78] = soc;//soc;// I_ack_change();
    24e0:	ef 81       	ldd	r30, Y+7	; 0x07
    24e2:	f8 85       	ldd	r31, Y+8	; 0x08
    24e4:	e2 5b       	subi	r30, 0xB2	; 178
    24e6:	ff 4f       	sbci	r31, 0xFF	; 255
    24e8:	90 91 cf 10 	lds	r25, 0x10CF
    24ec:	90 83       	st	Z, r25
  packet_payload[79] = 0x00;//low >> 6;//safe_mode;
    24ee:	ef 81       	ldd	r30, Y+7	; 0x07
    24f0:	f8 85       	ldd	r31, Y+8	; 0x08
    24f2:	e1 5b       	subi	r30, 0xB1	; 177
    24f4:	ff 4f       	sbci	r31, 0xFF	; 255
    24f6:	10 82       	st	Z, r1
  packet_payload[80] = 0x00;//charging;
    24f8:	ef 81       	ldd	r30, Y+7	; 0x07
    24fa:	f8 85       	ldd	r31, Y+8	; 0x08
    24fc:	e0 5b       	subi	r30, 0xB0	; 176
    24fe:	ff 4f       	sbci	r31, 0xFF	; 255
    2500:	10 82       	st	Z, r1
  packet_payload[81] = 0x00;//chargeforward;
    2502:	ef 81       	ldd	r30, Y+7	; 0x07
    2504:	f8 85       	ldd	r31, Y+8	; 0x08
    2506:	ef 5a       	subi	r30, 0xAF	; 175
    2508:	ff 4f       	sbci	r31, 0xFF	; 255
    250a:	10 82       	st	Z, r1

  // temperature values (raw ADC output)
  packet_payload[82] = debug;//average_samples( svit[STAR_TRACKER].T_samples );
    250c:	ef 81       	ldd	r30, Y+7	; 0x07
    250e:	f8 85       	ldd	r31, Y+8	; 0x08
    2510:	ee 5a       	subi	r30, 0xAE	; 174
    2512:	ff 4f       	sbci	r31, 0xFF	; 255
    2514:	90 91 5b 08 	lds	r25, 0x085B
    2518:	90 83       	st	Z, r25
  packet_payload[83] = 0xFF;//average_samples( svit[BATTERY_1].T_samples );
    251a:	ef 81       	ldd	r30, Y+7	; 0x07
    251c:	f8 85       	ldd	r31, Y+8	; 0x08
    251e:	ed 5a       	subi	r30, 0xAD	; 173
    2520:	ff 4f       	sbci	r31, 0xFF	; 255
    2522:	80 83       	st	Z, r24
  packet_payload[84] = average_samples( svit[BATTERY_2].T_samples );
    2524:	88 e4       	ldi	r24, 0x48	; 72
    2526:	96 e0       	ldi	r25, 0x06	; 6
    2528:	0e 94 ae 0a 	call	0x155c	; 0x155c <average_samples>
    252c:	ef 81       	ldd	r30, Y+7	; 0x07
    252e:	f8 85       	ldd	r31, Y+8	; 0x08
    2530:	ec 5a       	subi	r30, 0xAC	; 172
    2532:	ff 4f       	sbci	r31, 0xFF	; 255
    2534:	80 83       	st	Z, r24
  packet_payload[85] = average_samples( svit[SOLAR_1].T_samples );
    2536:	80 e9       	ldi	r24, 0x90	; 144
    2538:	96 e0       	ldi	r25, 0x06	; 6
    253a:	0e 94 ae 0a 	call	0x155c	; 0x155c <average_samples>
    253e:	ef 81       	ldd	r30, Y+7	; 0x07
    2540:	f8 85       	ldd	r31, Y+8	; 0x08
    2542:	eb 5a       	subi	r30, 0xAB	; 171
    2544:	ff 4f       	sbci	r31, 0xFF	; 255
    2546:	80 83       	st	Z, r24
  packet_payload[86] = average_samples( svit[SOLAR_2].T_samples );
    2548:	84 eb       	ldi	r24, 0xB4	; 180
    254a:	96 e0       	ldi	r25, 0x06	; 6
    254c:	0e 94 ae 0a 	call	0x155c	; 0x155c <average_samples>
    2550:	ef 81       	ldd	r30, Y+7	; 0x07
    2552:	f8 85       	ldd	r31, Y+8	; 0x08
    2554:	ea 5a       	subi	r30, 0xAA	; 170
    2556:	ff 4f       	sbci	r31, 0xFF	; 255
    2558:	80 83       	st	Z, r24
  packet_payload[87] = average_samples( svit[SOLAR_3].T_samples );
    255a:	88 ed       	ldi	r24, 0xD8	; 216
    255c:	96 e0       	ldi	r25, 0x06	; 6
    255e:	0e 94 ae 0a 	call	0x155c	; 0x155c <average_samples>
    2562:	ef 81       	ldd	r30, Y+7	; 0x07
    2564:	f8 85       	ldd	r31, Y+8	; 0x08
    2566:	e9 5a       	subi	r30, 0xA9	; 169
    2568:	ff 4f       	sbci	r31, 0xFF	; 255
    256a:	80 83       	st	Z, r24
  packet_payload[88] = average_samples( svit[SOLAR_4].T_samples );
    256c:	8c ef       	ldi	r24, 0xFC	; 252
    256e:	96 e0       	ldi	r25, 0x06	; 6
    2570:	0e 94 ae 0a 	call	0x155c	; 0x155c <average_samples>
    2574:	ef 81       	ldd	r30, Y+7	; 0x07
    2576:	f8 85       	ldd	r31, Y+8	; 0x08
    2578:	e8 5a       	subi	r30, 0xA8	; 168
    257a:	ff 4f       	sbci	r31, 0xFF	; 255
    257c:	80 83       	st	Z, r24
  packet_payload[89] = average_samples( svit[SOLAR_5].T_samples );
    257e:	80 e2       	ldi	r24, 0x20	; 32
    2580:	97 e0       	ldi	r25, 0x07	; 7
    2582:	0e 94 ae 0a 	call	0x155c	; 0x155c <average_samples>
    2586:	ef 81       	ldd	r30, Y+7	; 0x07
    2588:	f8 85       	ldd	r31, Y+8	; 0x08
    258a:	e7 5a       	subi	r30, 0xA7	; 167
    258c:	ff 4f       	sbci	r31, 0xFF	; 255
    258e:	80 83       	st	Z, r24
  packet_payload[90] = average_samples( svit[SOLAR_9].T_samples );
    2590:	80 eb       	ldi	r24, 0xB0	; 176
    2592:	97 e0       	ldi	r25, 0x07	; 7
    2594:	0e 94 ae 0a 	call	0x155c	; 0x155c <average_samples>
    2598:	ef 81       	ldd	r30, Y+7	; 0x07
    259a:	f8 85       	ldd	r31, Y+8	; 0x08
    259c:	e6 5a       	subi	r30, 0xA6	; 166
    259e:	ff 4f       	sbci	r31, 0xFF	; 255
    25a0:	80 83       	st	Z, r24
  packet_payload[91] = average_samples( svit[POWER_BOARD].T_samples );
    25a2:	80 e4       	ldi	r24, 0x40	; 64
    25a4:	98 e0       	ldi	r25, 0x08	; 8
    25a6:	0e 94 ae 0a 	call	0x155c	; 0x155c <average_samples>
    25aa:	ef 81       	ldd	r30, Y+7	; 0x07
    25ac:	f8 85       	ldd	r31, Y+8	; 0x08
    25ae:	e5 5a       	subi	r30, 0xA5	; 165
    25b0:	ff 4f       	sbci	r31, 0xFF	; 255
    25b2:	80 83       	st	Z, r24

uint8_t V_ack_change( void )
{
  uint8_t temp;

  temp = V_upper_val_change;
    25b4:	80 91 9d 0c 	lds	r24, 0x0C9D
  V_upper_val_change = 0;
    25b8:	10 92 9d 0c 	sts	0x0C9D, r1
  //uint8_t temperature_error1;
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
    25bc:	ef 81       	ldd	r30, Y+7	; 0x07
    25be:	f8 85       	ldd	r31, Y+8	; 0x08
    25c0:	e4 5a       	subi	r30, 0xA4	; 164
    25c2:	ff 4f       	sbci	r31, 0xFF	; 255
    25c4:	80 83       	st	Z, r24

uint8_t I_ack_change( void )
{
  uint8_t temp;

  temp = I_upper_val_change;
    25c6:	80 91 98 0c 	lds	r24, 0x0C98
  I_upper_val_change = 0;
    25ca:	10 92 98 0c 	sts	0x0C98, r1
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
  packet_payload[93] = I_ack_change();
    25ce:	ef 81       	ldd	r30, Y+7	; 0x07
    25d0:	f8 85       	ldd	r31, Y+8	; 0x08
    25d2:	e3 5a       	subi	r30, 0xA3	; 163
    25d4:	ff 4f       	sbci	r31, 0xFF	; 255
    25d6:	80 83       	st	Z, r24
}
    25d8:	28 96       	adiw	r28, 0x08	; 8
    25da:	0f b6       	in	r0, 0x3f	; 63
    25dc:	f8 94       	cli
    25de:	de bf       	out	0x3e, r29	; 62
    25e0:	0f be       	out	0x3f, r0	; 63
    25e2:	cd bf       	out	0x3d, r28	; 61
    25e4:	df 91       	pop	r29
    25e6:	cf 91       	pop	r28
    25e8:	1f 91       	pop	r17
    25ea:	0f 91       	pop	r16
    25ec:	ff 90       	pop	r15
    25ee:	ef 90       	pop	r14
    25f0:	df 90       	pop	r13
    25f2:	cf 90       	pop	r12
    25f4:	bf 90       	pop	r11
    25f6:	af 90       	pop	r10
    25f8:	9f 90       	pop	r9
    25fa:	8f 90       	pop	r8
    25fc:	7f 90       	pop	r7
    25fe:	6f 90       	pop	r6
    2600:	5f 90       	pop	r5
    2602:	4f 90       	pop	r4
    2604:	3f 90       	pop	r3
    2606:	2f 90       	pop	r2
    2608:	08 95       	ret

0000260a <transmit_packet>:

void transmit_packet( uint8_t uart, uint8_t packet_type, uint8_t ack_command )
{
    260a:	6f 92       	push	r6
    260c:	7f 92       	push	r7
    260e:	8f 92       	push	r8
    2610:	9f 92       	push	r9
    2612:	bf 92       	push	r11
    2614:	cf 92       	push	r12
    2616:	df 92       	push	r13
    2618:	ef 92       	push	r14
    261a:	ff 92       	push	r15
    261c:	0f 93       	push	r16
    261e:	1f 93       	push	r17
    2620:	cf 93       	push	r28
    2622:	df 93       	push	r29
    2624:	b8 2e       	mov	r11, r24
  uint8_t VCP_tx_status;

  switch( packet_type )
    2626:	61 30       	cpi	r22, 0x01	; 1
    2628:	b9 f0       	breq	.+46     	; 0x2658 <transmit_packet+0x4e>
    262a:	20 f0       	brcs	.+8      	; 0x2634 <transmit_packet+0x2a>
    262c:	62 30       	cpi	r22, 0x02	; 2
    262e:	09 f0       	breq	.+2      	; 0x2632 <transmit_packet+0x28>
    2630:	8b c0       	rjmp	.+278    	; 0x2748 <transmit_packet+0x13e>
    2632:	22 c0       	rjmp	.+68     	; 0x2678 <transmit_packet+0x6e>
  {
    case VCP_POWER_TELEMETRY:
      construct_telemetry_packet( tel_packet_payload[uart] );
    2634:	c8 2f       	mov	r28, r24
    2636:	d0 e0       	ldi	r29, 0x00	; 0
    2638:	2f ef       	ldi	r18, 0xFF	; 255
    263a:	82 9f       	mul	r24, r18
    263c:	c0 01       	movw	r24, r0
    263e:	11 24       	eor	r1, r1
    2640:	8f 52       	subi	r24, 0x2F	; 47
    2642:	91 4f       	sbci	r25, 0xF1	; 241
    2644:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <construct_telemetry_packet>
      tel_packet_payload_size[uart] = 96;
    2648:	fe 01       	movw	r30, r28
    264a:	ee 0f       	add	r30, r30
    264c:	ff 1f       	adc	r31, r31
    264e:	e3 5a       	subi	r30, 0xA3	; 163
    2650:	f7 4f       	sbci	r31, 0xF7	; 247
    2652:	80 e6       	ldi	r24, 0x60	; 96
    2654:	90 e0       	ldi	r25, 0x00	; 0
    2656:	21 c0       	rjmp	.+66     	; 0x269a <transmit_packet+0x90>
      break;
    case VCP_INVALID_COMMAND:
      tel_packet_payload[uart][0] = VCP_INVALID_COMMAND;
    2658:	e8 2f       	mov	r30, r24
    265a:	f0 e0       	ldi	r31, 0x00	; 0
    265c:	8f ef       	ldi	r24, 0xFF	; 255
    265e:	b8 9e       	mul	r11, r24
    2660:	d0 01       	movw	r26, r0
    2662:	11 24       	eor	r1, r1
    2664:	af 52       	subi	r26, 0x2F	; 47
    2666:	b1 4f       	sbci	r27, 0xF1	; 241
    2668:	6c 93       	st	X, r22
      tel_packet_payload_size[uart] = 1;
    266a:	ee 0f       	add	r30, r30
    266c:	ff 1f       	adc	r31, r31
    266e:	e3 5a       	subi	r30, 0xA3	; 163
    2670:	f7 4f       	sbci	r31, 0xF7	; 247
    2672:	81 e0       	ldi	r24, 0x01	; 1
    2674:	90 e0       	ldi	r25, 0x00	; 0
    2676:	11 c0       	rjmp	.+34     	; 0x269a <transmit_packet+0x90>
      break;
    case VCP_ACK:
      tel_packet_payload[uart][0] = VCP_ACK;
    2678:	e8 2f       	mov	r30, r24
    267a:	f0 e0       	ldi	r31, 0x00	; 0
    267c:	2f ef       	ldi	r18, 0xFF	; 255
    267e:	82 9f       	mul	r24, r18
    2680:	d0 01       	movw	r26, r0
    2682:	11 24       	eor	r1, r1
    2684:	af 52       	subi	r26, 0x2F	; 47
    2686:	b1 4f       	sbci	r27, 0xF1	; 241
    2688:	6c 93       	st	X, r22
      tel_packet_payload[uart][1] = ack_command;
    268a:	11 96       	adiw	r26, 0x01	; 1
    268c:	4c 93       	st	X, r20
      tel_packet_payload_size[uart] = 2;
    268e:	ee 0f       	add	r30, r30
    2690:	ff 1f       	adc	r31, r31
    2692:	e3 5a       	subi	r30, 0xA3	; 163
    2694:	f7 4f       	sbci	r31, 0xF7	; 247
    2696:	82 e0       	ldi	r24, 0x02	; 2
    2698:	90 e0       	ldi	r25, 0x00	; 0
    269a:	91 83       	std	Z+1, r25	; 0x01
    269c:	80 83       	st	Z, r24
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    269e:	8b 2c       	mov	r8, r11
    26a0:	91 2c       	mov	r9, r1
    26a2:	8f ef       	ldi	r24, 0xFF	; 255
    26a4:	b8 9e       	mul	r11, r24
    26a6:	70 01       	movw	r14, r0
    26a8:	11 24       	eor	r1, r1
    26aa:	e7 01       	movw	r28, r14
    26ac:	c8 56       	subi	r28, 0x68	; 104
    26ae:	d5 4f       	sbci	r29, 0xF5	; 245
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
    26b0:	64 01       	movw	r12, r8
    26b2:	cc 0c       	add	r12, r12
    26b4:	dd 1c       	adc	r13, r13
    26b6:	f6 01       	movw	r30, r12
    26b8:	e3 5a       	subi	r30, 0xA3	; 163
    26ba:	f7 4f       	sbci	r31, 0xF7	; 247
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    26bc:	00 81       	ld	r16, Z
    26be:	11 81       	ldd	r17, Z+1	; 0x01
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
    26c0:	97 01       	movw	r18, r14
    26c2:	2f 52       	subi	r18, 0x2F	; 47
    26c4:	31 4f       	sbci	r19, 0xF1	; 241
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    26c6:	a2 ea       	ldi	r26, 0xA2	; 162
    26c8:	6a 2e       	mov	r6, r26
    26ca:	ae e0       	ldi	r26, 0x0E	; 14
    26cc:	7a 2e       	mov	r7, r26
    26ce:	6c 0c       	add	r6, r12
    26d0:	7d 1c       	adc	r7, r13
    26d2:	41 e0       	ldi	r20, 0x01	; 1
    26d4:	b3 01       	movw	r22, r6
    26d6:	ce 01       	movw	r24, r28
    26d8:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <Create_VCP_frame>
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
                  );

  // VCP frame creation was successful
  if ( VCP_tx_status == VCP_TERM )
    26dc:	81 30       	cpi	r24, 0x01	; 1
    26de:	a1 f5       	brne	.+104    	; 0x2748 <transmit_packet+0x13e>
  {
    tel_packet_size[uart] = dest_size[uart];
    26e0:	f3 01       	movw	r30, r6
    26e2:	80 81       	ld	r24, Z
    26e4:	91 81       	ldd	r25, Z+1	; 0x01
    26e6:	f6 01       	movw	r30, r12
    26e8:	e7 5d       	subi	r30, 0xD7	; 215
    26ea:	fc 4f       	sbci	r31, 0xFC	; 252
    26ec:	91 83       	std	Z+1, r25	; 0x01
    26ee:	80 83       	st	Z, r24
    memcpy( tel_packet[uart], dest_data[uart], tel_packet_size[uart] );
    26f0:	80 81       	ld	r24, Z
    26f2:	91 81       	ldd	r25, Z+1	; 0x01
    26f4:	97 01       	movw	r18, r14
    26f6:	23 59       	subi	r18, 0x93	; 147
    26f8:	37 4f       	sbci	r19, 0xF7	; 247
    26fa:	ac 01       	movw	r20, r24
    26fc:	be 01       	movw	r22, r28
    26fe:	c9 01       	movw	r24, r18
    2700:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <memcpy>
    tel_packet_index[uart] = 0;
    2704:	f4 01       	movw	r30, r8
    2706:	eb 59       	subi	r30, 0x9B	; 155
    2708:	f7 4f       	sbci	r31, 0xF7	; 247
    270a:	10 82       	st	Z, r1
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
    270c:	f1 e0       	ldi	r31, 0x01	; 1
    270e:	bf 12       	cpse	r11, r31
    2710:	06 c0       	rjmp	.+12     	; 0x271e <transmit_packet+0x114>
    2712:	80 91 9b 00 	lds	r24, 0x009B
    2716:	88 23       	and	r24, r24
    2718:	b9 f0       	breq	.+46     	; 0x2748 <transmit_packet+0x13e>
      tx_put_byte( uart );
    271a:	81 e0       	ldi	r24, 0x01	; 1
    271c:	06 c0       	rjmp	.+12     	; 0x272a <transmit_packet+0x120>
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
    271e:	b1 10       	cpse	r11, r1
    2720:	13 c0       	rjmp	.+38     	; 0x2748 <transmit_packet+0x13e>
    2722:	8b b1       	in	r24, 0x0b	; 11
    2724:	88 23       	and	r24, r24
    2726:	81 f0       	breq	.+32     	; 0x2748 <transmit_packet+0x13e>
      tx_put_byte( uart );
    2728:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    272a:	df 91       	pop	r29
    272c:	cf 91       	pop	r28
    272e:	1f 91       	pop	r17
    2730:	0f 91       	pop	r16
    2732:	ff 90       	pop	r15
    2734:	ef 90       	pop	r14
    2736:	df 90       	pop	r13
    2738:	cf 90       	pop	r12
    273a:	bf 90       	pop	r11
    273c:	9f 90       	pop	r9
    273e:	8f 90       	pop	r8
    2740:	7f 90       	pop	r7
    2742:	6f 90       	pop	r6
    tel_packet_index[uart] = 0;
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    2744:	0c 94 69 0f 	jmp	0x1ed2	; 0x1ed2 <tx_put_byte>
  }
}
    2748:	df 91       	pop	r29
    274a:	cf 91       	pop	r28
    274c:	1f 91       	pop	r17
    274e:	0f 91       	pop	r16
    2750:	ff 90       	pop	r15
    2752:	ef 90       	pop	r14
    2754:	df 90       	pop	r13
    2756:	cf 90       	pop	r12
    2758:	bf 90       	pop	r11
    275a:	9f 90       	pop	r9
    275c:	8f 90       	pop	r8
    275e:	7f 90       	pop	r7
    2760:	6f 90       	pop	r6
    2762:	08 95       	ret

00002764 <__subsf3>:
    2764:	50 58       	subi	r21, 0x80	; 128

00002766 <__addsf3>:
    2766:	bb 27       	eor	r27, r27
    2768:	aa 27       	eor	r26, r26
    276a:	0e d0       	rcall	.+28     	; 0x2788 <__addsf3x>
    276c:	70 c1       	rjmp	.+736    	; 0x2a4e <__fp_round>
    276e:	61 d1       	rcall	.+706    	; 0x2a32 <__fp_pscA>
    2770:	30 f0       	brcs	.+12     	; 0x277e <__addsf3+0x18>
    2772:	66 d1       	rcall	.+716    	; 0x2a40 <__fp_pscB>
    2774:	20 f0       	brcs	.+8      	; 0x277e <__addsf3+0x18>
    2776:	31 f4       	brne	.+12     	; 0x2784 <__addsf3+0x1e>
    2778:	9f 3f       	cpi	r25, 0xFF	; 255
    277a:	11 f4       	brne	.+4      	; 0x2780 <__addsf3+0x1a>
    277c:	1e f4       	brtc	.+6      	; 0x2784 <__addsf3+0x1e>
    277e:	56 c1       	rjmp	.+684    	; 0x2a2c <__fp_nan>
    2780:	0e f4       	brtc	.+2      	; 0x2784 <__addsf3+0x1e>
    2782:	e0 95       	com	r30
    2784:	e7 fb       	bst	r30, 7
    2786:	4c c1       	rjmp	.+664    	; 0x2a20 <__fp_inf>

00002788 <__addsf3x>:
    2788:	e9 2f       	mov	r30, r25
    278a:	72 d1       	rcall	.+740    	; 0x2a70 <__fp_split3>
    278c:	80 f3       	brcs	.-32     	; 0x276e <__addsf3+0x8>
    278e:	ba 17       	cp	r27, r26
    2790:	62 07       	cpc	r22, r18
    2792:	73 07       	cpc	r23, r19
    2794:	84 07       	cpc	r24, r20
    2796:	95 07       	cpc	r25, r21
    2798:	18 f0       	brcs	.+6      	; 0x27a0 <__addsf3x+0x18>
    279a:	71 f4       	brne	.+28     	; 0x27b8 <__addsf3x+0x30>
    279c:	9e f5       	brtc	.+102    	; 0x2804 <__addsf3x+0x7c>
    279e:	8a c1       	rjmp	.+788    	; 0x2ab4 <__fp_zero>
    27a0:	0e f4       	brtc	.+2      	; 0x27a4 <__addsf3x+0x1c>
    27a2:	e0 95       	com	r30
    27a4:	0b 2e       	mov	r0, r27
    27a6:	ba 2f       	mov	r27, r26
    27a8:	a0 2d       	mov	r26, r0
    27aa:	0b 01       	movw	r0, r22
    27ac:	b9 01       	movw	r22, r18
    27ae:	90 01       	movw	r18, r0
    27b0:	0c 01       	movw	r0, r24
    27b2:	ca 01       	movw	r24, r20
    27b4:	a0 01       	movw	r20, r0
    27b6:	11 24       	eor	r1, r1
    27b8:	ff 27       	eor	r31, r31
    27ba:	59 1b       	sub	r21, r25
    27bc:	99 f0       	breq	.+38     	; 0x27e4 <__addsf3x+0x5c>
    27be:	59 3f       	cpi	r21, 0xF9	; 249
    27c0:	50 f4       	brcc	.+20     	; 0x27d6 <__addsf3x+0x4e>
    27c2:	50 3e       	cpi	r21, 0xE0	; 224
    27c4:	68 f1       	brcs	.+90     	; 0x2820 <__addsf3x+0x98>
    27c6:	1a 16       	cp	r1, r26
    27c8:	f0 40       	sbci	r31, 0x00	; 0
    27ca:	a2 2f       	mov	r26, r18
    27cc:	23 2f       	mov	r18, r19
    27ce:	34 2f       	mov	r19, r20
    27d0:	44 27       	eor	r20, r20
    27d2:	58 5f       	subi	r21, 0xF8	; 248
    27d4:	f3 cf       	rjmp	.-26     	; 0x27bc <__addsf3x+0x34>
    27d6:	46 95       	lsr	r20
    27d8:	37 95       	ror	r19
    27da:	27 95       	ror	r18
    27dc:	a7 95       	ror	r26
    27de:	f0 40       	sbci	r31, 0x00	; 0
    27e0:	53 95       	inc	r21
    27e2:	c9 f7       	brne	.-14     	; 0x27d6 <__addsf3x+0x4e>
    27e4:	7e f4       	brtc	.+30     	; 0x2804 <__addsf3x+0x7c>
    27e6:	1f 16       	cp	r1, r31
    27e8:	ba 0b       	sbc	r27, r26
    27ea:	62 0b       	sbc	r22, r18
    27ec:	73 0b       	sbc	r23, r19
    27ee:	84 0b       	sbc	r24, r20
    27f0:	ba f0       	brmi	.+46     	; 0x2820 <__addsf3x+0x98>
    27f2:	91 50       	subi	r25, 0x01	; 1
    27f4:	a1 f0       	breq	.+40     	; 0x281e <__addsf3x+0x96>
    27f6:	ff 0f       	add	r31, r31
    27f8:	bb 1f       	adc	r27, r27
    27fa:	66 1f       	adc	r22, r22
    27fc:	77 1f       	adc	r23, r23
    27fe:	88 1f       	adc	r24, r24
    2800:	c2 f7       	brpl	.-16     	; 0x27f2 <__addsf3x+0x6a>
    2802:	0e c0       	rjmp	.+28     	; 0x2820 <__addsf3x+0x98>
    2804:	ba 0f       	add	r27, r26
    2806:	62 1f       	adc	r22, r18
    2808:	73 1f       	adc	r23, r19
    280a:	84 1f       	adc	r24, r20
    280c:	48 f4       	brcc	.+18     	; 0x2820 <__addsf3x+0x98>
    280e:	87 95       	ror	r24
    2810:	77 95       	ror	r23
    2812:	67 95       	ror	r22
    2814:	b7 95       	ror	r27
    2816:	f7 95       	ror	r31
    2818:	9e 3f       	cpi	r25, 0xFE	; 254
    281a:	08 f0       	brcs	.+2      	; 0x281e <__addsf3x+0x96>
    281c:	b3 cf       	rjmp	.-154    	; 0x2784 <__addsf3+0x1e>
    281e:	93 95       	inc	r25
    2820:	88 0f       	add	r24, r24
    2822:	08 f0       	brcs	.+2      	; 0x2826 <__addsf3x+0x9e>
    2824:	99 27       	eor	r25, r25
    2826:	ee 0f       	add	r30, r30
    2828:	97 95       	ror	r25
    282a:	87 95       	ror	r24
    282c:	08 95       	ret

0000282e <__cmpsf2>:
    282e:	d4 d0       	rcall	.+424    	; 0x29d8 <__fp_cmp>
    2830:	08 f4       	brcc	.+2      	; 0x2834 <__cmpsf2+0x6>
    2832:	81 e0       	ldi	r24, 0x01	; 1
    2834:	08 95       	ret

00002836 <__divsf3>:
    2836:	0c d0       	rcall	.+24     	; 0x2850 <__divsf3x>
    2838:	0a c1       	rjmp	.+532    	; 0x2a4e <__fp_round>
    283a:	02 d1       	rcall	.+516    	; 0x2a40 <__fp_pscB>
    283c:	40 f0       	brcs	.+16     	; 0x284e <__divsf3+0x18>
    283e:	f9 d0       	rcall	.+498    	; 0x2a32 <__fp_pscA>
    2840:	30 f0       	brcs	.+12     	; 0x284e <__divsf3+0x18>
    2842:	21 f4       	brne	.+8      	; 0x284c <__divsf3+0x16>
    2844:	5f 3f       	cpi	r21, 0xFF	; 255
    2846:	19 f0       	breq	.+6      	; 0x284e <__divsf3+0x18>
    2848:	eb c0       	rjmp	.+470    	; 0x2a20 <__fp_inf>
    284a:	51 11       	cpse	r21, r1
    284c:	34 c1       	rjmp	.+616    	; 0x2ab6 <__fp_szero>
    284e:	ee c0       	rjmp	.+476    	; 0x2a2c <__fp_nan>

00002850 <__divsf3x>:
    2850:	0f d1       	rcall	.+542    	; 0x2a70 <__fp_split3>
    2852:	98 f3       	brcs	.-26     	; 0x283a <__divsf3+0x4>

00002854 <__divsf3_pse>:
    2854:	99 23       	and	r25, r25
    2856:	c9 f3       	breq	.-14     	; 0x284a <__divsf3+0x14>
    2858:	55 23       	and	r21, r21
    285a:	b1 f3       	breq	.-20     	; 0x2848 <__divsf3+0x12>
    285c:	95 1b       	sub	r25, r21
    285e:	55 0b       	sbc	r21, r21
    2860:	bb 27       	eor	r27, r27
    2862:	aa 27       	eor	r26, r26
    2864:	62 17       	cp	r22, r18
    2866:	73 07       	cpc	r23, r19
    2868:	84 07       	cpc	r24, r20
    286a:	38 f0       	brcs	.+14     	; 0x287a <__divsf3_pse+0x26>
    286c:	9f 5f       	subi	r25, 0xFF	; 255
    286e:	5f 4f       	sbci	r21, 0xFF	; 255
    2870:	22 0f       	add	r18, r18
    2872:	33 1f       	adc	r19, r19
    2874:	44 1f       	adc	r20, r20
    2876:	aa 1f       	adc	r26, r26
    2878:	a9 f3       	breq	.-22     	; 0x2864 <__divsf3_pse+0x10>
    287a:	33 d0       	rcall	.+102    	; 0x28e2 <__divsf3_pse+0x8e>
    287c:	0e 2e       	mov	r0, r30
    287e:	3a f0       	brmi	.+14     	; 0x288e <__divsf3_pse+0x3a>
    2880:	e0 e8       	ldi	r30, 0x80	; 128
    2882:	30 d0       	rcall	.+96     	; 0x28e4 <__divsf3_pse+0x90>
    2884:	91 50       	subi	r25, 0x01	; 1
    2886:	50 40       	sbci	r21, 0x00	; 0
    2888:	e6 95       	lsr	r30
    288a:	00 1c       	adc	r0, r0
    288c:	ca f7       	brpl	.-14     	; 0x2880 <__divsf3_pse+0x2c>
    288e:	29 d0       	rcall	.+82     	; 0x28e2 <__divsf3_pse+0x8e>
    2890:	fe 2f       	mov	r31, r30
    2892:	27 d0       	rcall	.+78     	; 0x28e2 <__divsf3_pse+0x8e>
    2894:	66 0f       	add	r22, r22
    2896:	77 1f       	adc	r23, r23
    2898:	88 1f       	adc	r24, r24
    289a:	bb 1f       	adc	r27, r27
    289c:	26 17       	cp	r18, r22
    289e:	37 07       	cpc	r19, r23
    28a0:	48 07       	cpc	r20, r24
    28a2:	ab 07       	cpc	r26, r27
    28a4:	b0 e8       	ldi	r27, 0x80	; 128
    28a6:	09 f0       	breq	.+2      	; 0x28aa <__divsf3_pse+0x56>
    28a8:	bb 0b       	sbc	r27, r27
    28aa:	80 2d       	mov	r24, r0
    28ac:	bf 01       	movw	r22, r30
    28ae:	ff 27       	eor	r31, r31
    28b0:	93 58       	subi	r25, 0x83	; 131
    28b2:	5f 4f       	sbci	r21, 0xFF	; 255
    28b4:	2a f0       	brmi	.+10     	; 0x28c0 <__divsf3_pse+0x6c>
    28b6:	9e 3f       	cpi	r25, 0xFE	; 254
    28b8:	51 05       	cpc	r21, r1
    28ba:	68 f0       	brcs	.+26     	; 0x28d6 <__divsf3_pse+0x82>
    28bc:	b1 c0       	rjmp	.+354    	; 0x2a20 <__fp_inf>
    28be:	fb c0       	rjmp	.+502    	; 0x2ab6 <__fp_szero>
    28c0:	5f 3f       	cpi	r21, 0xFF	; 255
    28c2:	ec f3       	brlt	.-6      	; 0x28be <__divsf3_pse+0x6a>
    28c4:	98 3e       	cpi	r25, 0xE8	; 232
    28c6:	dc f3       	brlt	.-10     	; 0x28be <__divsf3_pse+0x6a>
    28c8:	86 95       	lsr	r24
    28ca:	77 95       	ror	r23
    28cc:	67 95       	ror	r22
    28ce:	b7 95       	ror	r27
    28d0:	f7 95       	ror	r31
    28d2:	9f 5f       	subi	r25, 0xFF	; 255
    28d4:	c9 f7       	brne	.-14     	; 0x28c8 <__divsf3_pse+0x74>
    28d6:	88 0f       	add	r24, r24
    28d8:	91 1d       	adc	r25, r1
    28da:	96 95       	lsr	r25
    28dc:	87 95       	ror	r24
    28de:	97 f9       	bld	r25, 7
    28e0:	08 95       	ret
    28e2:	e1 e0       	ldi	r30, 0x01	; 1
    28e4:	66 0f       	add	r22, r22
    28e6:	77 1f       	adc	r23, r23
    28e8:	88 1f       	adc	r24, r24
    28ea:	bb 1f       	adc	r27, r27
    28ec:	62 17       	cp	r22, r18
    28ee:	73 07       	cpc	r23, r19
    28f0:	84 07       	cpc	r24, r20
    28f2:	ba 07       	cpc	r27, r26
    28f4:	20 f0       	brcs	.+8      	; 0x28fe <__divsf3_pse+0xaa>
    28f6:	62 1b       	sub	r22, r18
    28f8:	73 0b       	sbc	r23, r19
    28fa:	84 0b       	sbc	r24, r20
    28fc:	ba 0b       	sbc	r27, r26
    28fe:	ee 1f       	adc	r30, r30
    2900:	88 f7       	brcc	.-30     	; 0x28e4 <__divsf3_pse+0x90>
    2902:	e0 95       	com	r30
    2904:	08 95       	ret

00002906 <__fixunssfsi>:
    2906:	bc d0       	rcall	.+376    	; 0x2a80 <__fp_splitA>
    2908:	88 f0       	brcs	.+34     	; 0x292c <__fixunssfsi+0x26>
    290a:	9f 57       	subi	r25, 0x7F	; 127
    290c:	90 f0       	brcs	.+36     	; 0x2932 <__fixunssfsi+0x2c>
    290e:	b9 2f       	mov	r27, r25
    2910:	99 27       	eor	r25, r25
    2912:	b7 51       	subi	r27, 0x17	; 23
    2914:	a0 f0       	brcs	.+40     	; 0x293e <__fixunssfsi+0x38>
    2916:	d1 f0       	breq	.+52     	; 0x294c <__fixunssfsi+0x46>
    2918:	66 0f       	add	r22, r22
    291a:	77 1f       	adc	r23, r23
    291c:	88 1f       	adc	r24, r24
    291e:	99 1f       	adc	r25, r25
    2920:	1a f0       	brmi	.+6      	; 0x2928 <__fixunssfsi+0x22>
    2922:	ba 95       	dec	r27
    2924:	c9 f7       	brne	.-14     	; 0x2918 <__fixunssfsi+0x12>
    2926:	12 c0       	rjmp	.+36     	; 0x294c <__fixunssfsi+0x46>
    2928:	b1 30       	cpi	r27, 0x01	; 1
    292a:	81 f0       	breq	.+32     	; 0x294c <__fixunssfsi+0x46>
    292c:	c3 d0       	rcall	.+390    	; 0x2ab4 <__fp_zero>
    292e:	b1 e0       	ldi	r27, 0x01	; 1
    2930:	08 95       	ret
    2932:	c0 c0       	rjmp	.+384    	; 0x2ab4 <__fp_zero>
    2934:	67 2f       	mov	r22, r23
    2936:	78 2f       	mov	r23, r24
    2938:	88 27       	eor	r24, r24
    293a:	b8 5f       	subi	r27, 0xF8	; 248
    293c:	39 f0       	breq	.+14     	; 0x294c <__fixunssfsi+0x46>
    293e:	b9 3f       	cpi	r27, 0xF9	; 249
    2940:	cc f3       	brlt	.-14     	; 0x2934 <__fixunssfsi+0x2e>
    2942:	86 95       	lsr	r24
    2944:	77 95       	ror	r23
    2946:	67 95       	ror	r22
    2948:	b3 95       	inc	r27
    294a:	d9 f7       	brne	.-10     	; 0x2942 <__fixunssfsi+0x3c>
    294c:	3e f4       	brtc	.+14     	; 0x295c <__fixunssfsi+0x56>
    294e:	90 95       	com	r25
    2950:	80 95       	com	r24
    2952:	70 95       	com	r23
    2954:	61 95       	neg	r22
    2956:	7f 4f       	sbci	r23, 0xFF	; 255
    2958:	8f 4f       	sbci	r24, 0xFF	; 255
    295a:	9f 4f       	sbci	r25, 0xFF	; 255
    295c:	08 95       	ret

0000295e <__floatunsisf>:
    295e:	e8 94       	clt
    2960:	09 c0       	rjmp	.+18     	; 0x2974 <__floatsisf+0x12>

00002962 <__floatsisf>:
    2962:	97 fb       	bst	r25, 7
    2964:	3e f4       	brtc	.+14     	; 0x2974 <__floatsisf+0x12>
    2966:	90 95       	com	r25
    2968:	80 95       	com	r24
    296a:	70 95       	com	r23
    296c:	61 95       	neg	r22
    296e:	7f 4f       	sbci	r23, 0xFF	; 255
    2970:	8f 4f       	sbci	r24, 0xFF	; 255
    2972:	9f 4f       	sbci	r25, 0xFF	; 255
    2974:	99 23       	and	r25, r25
    2976:	a9 f0       	breq	.+42     	; 0x29a2 <__floatsisf+0x40>
    2978:	f9 2f       	mov	r31, r25
    297a:	96 e9       	ldi	r25, 0x96	; 150
    297c:	bb 27       	eor	r27, r27
    297e:	93 95       	inc	r25
    2980:	f6 95       	lsr	r31
    2982:	87 95       	ror	r24
    2984:	77 95       	ror	r23
    2986:	67 95       	ror	r22
    2988:	b7 95       	ror	r27
    298a:	f1 11       	cpse	r31, r1
    298c:	f8 cf       	rjmp	.-16     	; 0x297e <__floatsisf+0x1c>
    298e:	fa f4       	brpl	.+62     	; 0x29ce <__floatsisf+0x6c>
    2990:	bb 0f       	add	r27, r27
    2992:	11 f4       	brne	.+4      	; 0x2998 <__floatsisf+0x36>
    2994:	60 ff       	sbrs	r22, 0
    2996:	1b c0       	rjmp	.+54     	; 0x29ce <__floatsisf+0x6c>
    2998:	6f 5f       	subi	r22, 0xFF	; 255
    299a:	7f 4f       	sbci	r23, 0xFF	; 255
    299c:	8f 4f       	sbci	r24, 0xFF	; 255
    299e:	9f 4f       	sbci	r25, 0xFF	; 255
    29a0:	16 c0       	rjmp	.+44     	; 0x29ce <__floatsisf+0x6c>
    29a2:	88 23       	and	r24, r24
    29a4:	11 f0       	breq	.+4      	; 0x29aa <__floatsisf+0x48>
    29a6:	96 e9       	ldi	r25, 0x96	; 150
    29a8:	11 c0       	rjmp	.+34     	; 0x29cc <__floatsisf+0x6a>
    29aa:	77 23       	and	r23, r23
    29ac:	21 f0       	breq	.+8      	; 0x29b6 <__floatsisf+0x54>
    29ae:	9e e8       	ldi	r25, 0x8E	; 142
    29b0:	87 2f       	mov	r24, r23
    29b2:	76 2f       	mov	r23, r22
    29b4:	05 c0       	rjmp	.+10     	; 0x29c0 <__floatsisf+0x5e>
    29b6:	66 23       	and	r22, r22
    29b8:	71 f0       	breq	.+28     	; 0x29d6 <__floatsisf+0x74>
    29ba:	96 e8       	ldi	r25, 0x86	; 134
    29bc:	86 2f       	mov	r24, r22
    29be:	70 e0       	ldi	r23, 0x00	; 0
    29c0:	60 e0       	ldi	r22, 0x00	; 0
    29c2:	2a f0       	brmi	.+10     	; 0x29ce <__floatsisf+0x6c>
    29c4:	9a 95       	dec	r25
    29c6:	66 0f       	add	r22, r22
    29c8:	77 1f       	adc	r23, r23
    29ca:	88 1f       	adc	r24, r24
    29cc:	da f7       	brpl	.-10     	; 0x29c4 <__floatsisf+0x62>
    29ce:	88 0f       	add	r24, r24
    29d0:	96 95       	lsr	r25
    29d2:	87 95       	ror	r24
    29d4:	97 f9       	bld	r25, 7
    29d6:	08 95       	ret

000029d8 <__fp_cmp>:
    29d8:	99 0f       	add	r25, r25
    29da:	00 08       	sbc	r0, r0
    29dc:	55 0f       	add	r21, r21
    29de:	aa 0b       	sbc	r26, r26
    29e0:	e0 e8       	ldi	r30, 0x80	; 128
    29e2:	fe ef       	ldi	r31, 0xFE	; 254
    29e4:	16 16       	cp	r1, r22
    29e6:	17 06       	cpc	r1, r23
    29e8:	e8 07       	cpc	r30, r24
    29ea:	f9 07       	cpc	r31, r25
    29ec:	c0 f0       	brcs	.+48     	; 0x2a1e <__fp_cmp+0x46>
    29ee:	12 16       	cp	r1, r18
    29f0:	13 06       	cpc	r1, r19
    29f2:	e4 07       	cpc	r30, r20
    29f4:	f5 07       	cpc	r31, r21
    29f6:	98 f0       	brcs	.+38     	; 0x2a1e <__fp_cmp+0x46>
    29f8:	62 1b       	sub	r22, r18
    29fa:	73 0b       	sbc	r23, r19
    29fc:	84 0b       	sbc	r24, r20
    29fe:	95 0b       	sbc	r25, r21
    2a00:	39 f4       	brne	.+14     	; 0x2a10 <__fp_cmp+0x38>
    2a02:	0a 26       	eor	r0, r26
    2a04:	61 f0       	breq	.+24     	; 0x2a1e <__fp_cmp+0x46>
    2a06:	23 2b       	or	r18, r19
    2a08:	24 2b       	or	r18, r20
    2a0a:	25 2b       	or	r18, r21
    2a0c:	21 f4       	brne	.+8      	; 0x2a16 <__fp_cmp+0x3e>
    2a0e:	08 95       	ret
    2a10:	0a 26       	eor	r0, r26
    2a12:	09 f4       	brne	.+2      	; 0x2a16 <__fp_cmp+0x3e>
    2a14:	a1 40       	sbci	r26, 0x01	; 1
    2a16:	a6 95       	lsr	r26
    2a18:	8f ef       	ldi	r24, 0xFF	; 255
    2a1a:	81 1d       	adc	r24, r1
    2a1c:	81 1d       	adc	r24, r1
    2a1e:	08 95       	ret

00002a20 <__fp_inf>:
    2a20:	97 f9       	bld	r25, 7
    2a22:	9f 67       	ori	r25, 0x7F	; 127
    2a24:	80 e8       	ldi	r24, 0x80	; 128
    2a26:	70 e0       	ldi	r23, 0x00	; 0
    2a28:	60 e0       	ldi	r22, 0x00	; 0
    2a2a:	08 95       	ret

00002a2c <__fp_nan>:
    2a2c:	9f ef       	ldi	r25, 0xFF	; 255
    2a2e:	80 ec       	ldi	r24, 0xC0	; 192
    2a30:	08 95       	ret

00002a32 <__fp_pscA>:
    2a32:	00 24       	eor	r0, r0
    2a34:	0a 94       	dec	r0
    2a36:	16 16       	cp	r1, r22
    2a38:	17 06       	cpc	r1, r23
    2a3a:	18 06       	cpc	r1, r24
    2a3c:	09 06       	cpc	r0, r25
    2a3e:	08 95       	ret

00002a40 <__fp_pscB>:
    2a40:	00 24       	eor	r0, r0
    2a42:	0a 94       	dec	r0
    2a44:	12 16       	cp	r1, r18
    2a46:	13 06       	cpc	r1, r19
    2a48:	14 06       	cpc	r1, r20
    2a4a:	05 06       	cpc	r0, r21
    2a4c:	08 95       	ret

00002a4e <__fp_round>:
    2a4e:	09 2e       	mov	r0, r25
    2a50:	03 94       	inc	r0
    2a52:	00 0c       	add	r0, r0
    2a54:	11 f4       	brne	.+4      	; 0x2a5a <__fp_round+0xc>
    2a56:	88 23       	and	r24, r24
    2a58:	52 f0       	brmi	.+20     	; 0x2a6e <__fp_round+0x20>
    2a5a:	bb 0f       	add	r27, r27
    2a5c:	40 f4       	brcc	.+16     	; 0x2a6e <__fp_round+0x20>
    2a5e:	bf 2b       	or	r27, r31
    2a60:	11 f4       	brne	.+4      	; 0x2a66 <__fp_round+0x18>
    2a62:	60 ff       	sbrs	r22, 0
    2a64:	04 c0       	rjmp	.+8      	; 0x2a6e <__fp_round+0x20>
    2a66:	6f 5f       	subi	r22, 0xFF	; 255
    2a68:	7f 4f       	sbci	r23, 0xFF	; 255
    2a6a:	8f 4f       	sbci	r24, 0xFF	; 255
    2a6c:	9f 4f       	sbci	r25, 0xFF	; 255
    2a6e:	08 95       	ret

00002a70 <__fp_split3>:
    2a70:	57 fd       	sbrc	r21, 7
    2a72:	90 58       	subi	r25, 0x80	; 128
    2a74:	44 0f       	add	r20, r20
    2a76:	55 1f       	adc	r21, r21
    2a78:	59 f0       	breq	.+22     	; 0x2a90 <__fp_splitA+0x10>
    2a7a:	5f 3f       	cpi	r21, 0xFF	; 255
    2a7c:	71 f0       	breq	.+28     	; 0x2a9a <__fp_splitA+0x1a>
    2a7e:	47 95       	ror	r20

00002a80 <__fp_splitA>:
    2a80:	88 0f       	add	r24, r24
    2a82:	97 fb       	bst	r25, 7
    2a84:	99 1f       	adc	r25, r25
    2a86:	61 f0       	breq	.+24     	; 0x2aa0 <__fp_splitA+0x20>
    2a88:	9f 3f       	cpi	r25, 0xFF	; 255
    2a8a:	79 f0       	breq	.+30     	; 0x2aaa <__fp_splitA+0x2a>
    2a8c:	87 95       	ror	r24
    2a8e:	08 95       	ret
    2a90:	12 16       	cp	r1, r18
    2a92:	13 06       	cpc	r1, r19
    2a94:	14 06       	cpc	r1, r20
    2a96:	55 1f       	adc	r21, r21
    2a98:	f2 cf       	rjmp	.-28     	; 0x2a7e <__fp_split3+0xe>
    2a9a:	46 95       	lsr	r20
    2a9c:	f1 df       	rcall	.-30     	; 0x2a80 <__fp_splitA>
    2a9e:	08 c0       	rjmp	.+16     	; 0x2ab0 <__fp_splitA+0x30>
    2aa0:	16 16       	cp	r1, r22
    2aa2:	17 06       	cpc	r1, r23
    2aa4:	18 06       	cpc	r1, r24
    2aa6:	99 1f       	adc	r25, r25
    2aa8:	f1 cf       	rjmp	.-30     	; 0x2a8c <__fp_splitA+0xc>
    2aaa:	86 95       	lsr	r24
    2aac:	71 05       	cpc	r23, r1
    2aae:	61 05       	cpc	r22, r1
    2ab0:	08 94       	sec
    2ab2:	08 95       	ret

00002ab4 <__fp_zero>:
    2ab4:	e8 94       	clt

00002ab6 <__fp_szero>:
    2ab6:	bb 27       	eor	r27, r27
    2ab8:	66 27       	eor	r22, r22
    2aba:	77 27       	eor	r23, r23
    2abc:	cb 01       	movw	r24, r22
    2abe:	97 f9       	bld	r25, 7
    2ac0:	08 95       	ret

00002ac2 <__gesf2>:
    2ac2:	8a df       	rcall	.-236    	; 0x29d8 <__fp_cmp>
    2ac4:	08 f4       	brcc	.+2      	; 0x2ac8 <__gesf2+0x6>
    2ac6:	8f ef       	ldi	r24, 0xFF	; 255
    2ac8:	08 95       	ret

00002aca <__mulsf3>:
    2aca:	0b d0       	rcall	.+22     	; 0x2ae2 <__mulsf3x>
    2acc:	c0 cf       	rjmp	.-128    	; 0x2a4e <__fp_round>
    2ace:	b1 df       	rcall	.-158    	; 0x2a32 <__fp_pscA>
    2ad0:	28 f0       	brcs	.+10     	; 0x2adc <__mulsf3+0x12>
    2ad2:	b6 df       	rcall	.-148    	; 0x2a40 <__fp_pscB>
    2ad4:	18 f0       	brcs	.+6      	; 0x2adc <__mulsf3+0x12>
    2ad6:	95 23       	and	r25, r21
    2ad8:	09 f0       	breq	.+2      	; 0x2adc <__mulsf3+0x12>
    2ada:	a2 cf       	rjmp	.-188    	; 0x2a20 <__fp_inf>
    2adc:	a7 cf       	rjmp	.-178    	; 0x2a2c <__fp_nan>
    2ade:	11 24       	eor	r1, r1
    2ae0:	ea cf       	rjmp	.-44     	; 0x2ab6 <__fp_szero>

00002ae2 <__mulsf3x>:
    2ae2:	c6 df       	rcall	.-116    	; 0x2a70 <__fp_split3>
    2ae4:	a0 f3       	brcs	.-24     	; 0x2ace <__mulsf3+0x4>

00002ae6 <__mulsf3_pse>:
    2ae6:	95 9f       	mul	r25, r21
    2ae8:	d1 f3       	breq	.-12     	; 0x2ade <__mulsf3+0x14>
    2aea:	95 0f       	add	r25, r21
    2aec:	50 e0       	ldi	r21, 0x00	; 0
    2aee:	55 1f       	adc	r21, r21
    2af0:	62 9f       	mul	r22, r18
    2af2:	f0 01       	movw	r30, r0
    2af4:	72 9f       	mul	r23, r18
    2af6:	bb 27       	eor	r27, r27
    2af8:	f0 0d       	add	r31, r0
    2afa:	b1 1d       	adc	r27, r1
    2afc:	63 9f       	mul	r22, r19
    2afe:	aa 27       	eor	r26, r26
    2b00:	f0 0d       	add	r31, r0
    2b02:	b1 1d       	adc	r27, r1
    2b04:	aa 1f       	adc	r26, r26
    2b06:	64 9f       	mul	r22, r20
    2b08:	66 27       	eor	r22, r22
    2b0a:	b0 0d       	add	r27, r0
    2b0c:	a1 1d       	adc	r26, r1
    2b0e:	66 1f       	adc	r22, r22
    2b10:	82 9f       	mul	r24, r18
    2b12:	22 27       	eor	r18, r18
    2b14:	b0 0d       	add	r27, r0
    2b16:	a1 1d       	adc	r26, r1
    2b18:	62 1f       	adc	r22, r18
    2b1a:	73 9f       	mul	r23, r19
    2b1c:	b0 0d       	add	r27, r0
    2b1e:	a1 1d       	adc	r26, r1
    2b20:	62 1f       	adc	r22, r18
    2b22:	83 9f       	mul	r24, r19
    2b24:	a0 0d       	add	r26, r0
    2b26:	61 1d       	adc	r22, r1
    2b28:	22 1f       	adc	r18, r18
    2b2a:	74 9f       	mul	r23, r20
    2b2c:	33 27       	eor	r19, r19
    2b2e:	a0 0d       	add	r26, r0
    2b30:	61 1d       	adc	r22, r1
    2b32:	23 1f       	adc	r18, r19
    2b34:	84 9f       	mul	r24, r20
    2b36:	60 0d       	add	r22, r0
    2b38:	21 1d       	adc	r18, r1
    2b3a:	82 2f       	mov	r24, r18
    2b3c:	76 2f       	mov	r23, r22
    2b3e:	6a 2f       	mov	r22, r26
    2b40:	11 24       	eor	r1, r1
    2b42:	9f 57       	subi	r25, 0x7F	; 127
    2b44:	50 40       	sbci	r21, 0x00	; 0
    2b46:	8a f0       	brmi	.+34     	; 0x2b6a <__mulsf3_pse+0x84>
    2b48:	e1 f0       	breq	.+56     	; 0x2b82 <__mulsf3_pse+0x9c>
    2b4a:	88 23       	and	r24, r24
    2b4c:	4a f0       	brmi	.+18     	; 0x2b60 <__mulsf3_pse+0x7a>
    2b4e:	ee 0f       	add	r30, r30
    2b50:	ff 1f       	adc	r31, r31
    2b52:	bb 1f       	adc	r27, r27
    2b54:	66 1f       	adc	r22, r22
    2b56:	77 1f       	adc	r23, r23
    2b58:	88 1f       	adc	r24, r24
    2b5a:	91 50       	subi	r25, 0x01	; 1
    2b5c:	50 40       	sbci	r21, 0x00	; 0
    2b5e:	a9 f7       	brne	.-22     	; 0x2b4a <__mulsf3_pse+0x64>
    2b60:	9e 3f       	cpi	r25, 0xFE	; 254
    2b62:	51 05       	cpc	r21, r1
    2b64:	70 f0       	brcs	.+28     	; 0x2b82 <__mulsf3_pse+0x9c>
    2b66:	5c cf       	rjmp	.-328    	; 0x2a20 <__fp_inf>
    2b68:	a6 cf       	rjmp	.-180    	; 0x2ab6 <__fp_szero>
    2b6a:	5f 3f       	cpi	r21, 0xFF	; 255
    2b6c:	ec f3       	brlt	.-6      	; 0x2b68 <__mulsf3_pse+0x82>
    2b6e:	98 3e       	cpi	r25, 0xE8	; 232
    2b70:	dc f3       	brlt	.-10     	; 0x2b68 <__mulsf3_pse+0x82>
    2b72:	86 95       	lsr	r24
    2b74:	77 95       	ror	r23
    2b76:	67 95       	ror	r22
    2b78:	b7 95       	ror	r27
    2b7a:	f7 95       	ror	r31
    2b7c:	e7 95       	ror	r30
    2b7e:	9f 5f       	subi	r25, 0xFF	; 255
    2b80:	c1 f7       	brne	.-16     	; 0x2b72 <__mulsf3_pse+0x8c>
    2b82:	fe 2b       	or	r31, r30
    2b84:	88 0f       	add	r24, r24
    2b86:	91 1d       	adc	r25, r1
    2b88:	96 95       	lsr	r25
    2b8a:	87 95       	ror	r24
    2b8c:	97 f9       	bld	r25, 7
    2b8e:	08 95       	ret

00002b90 <__udivmodhi4>:
    2b90:	aa 1b       	sub	r26, r26
    2b92:	bb 1b       	sub	r27, r27
    2b94:	51 e1       	ldi	r21, 0x11	; 17
    2b96:	07 c0       	rjmp	.+14     	; 0x2ba6 <__udivmodhi4_ep>

00002b98 <__udivmodhi4_loop>:
    2b98:	aa 1f       	adc	r26, r26
    2b9a:	bb 1f       	adc	r27, r27
    2b9c:	a6 17       	cp	r26, r22
    2b9e:	b7 07       	cpc	r27, r23
    2ba0:	10 f0       	brcs	.+4      	; 0x2ba6 <__udivmodhi4_ep>
    2ba2:	a6 1b       	sub	r26, r22
    2ba4:	b7 0b       	sbc	r27, r23

00002ba6 <__udivmodhi4_ep>:
    2ba6:	88 1f       	adc	r24, r24
    2ba8:	99 1f       	adc	r25, r25
    2baa:	5a 95       	dec	r21
    2bac:	a9 f7       	brne	.-22     	; 0x2b98 <__udivmodhi4_loop>
    2bae:	80 95       	com	r24
    2bb0:	90 95       	com	r25
    2bb2:	bc 01       	movw	r22, r24
    2bb4:	cd 01       	movw	r24, r26
    2bb6:	08 95       	ret

00002bb8 <__divmodhi4>:
    2bb8:	97 fb       	bst	r25, 7
    2bba:	07 2e       	mov	r0, r23
    2bbc:	16 f4       	brtc	.+4      	; 0x2bc2 <__divmodhi4+0xa>
    2bbe:	00 94       	com	r0
    2bc0:	07 d0       	rcall	.+14     	; 0x2bd0 <__divmodhi4_neg1>
    2bc2:	77 fd       	sbrc	r23, 7
    2bc4:	09 d0       	rcall	.+18     	; 0x2bd8 <__divmodhi4_neg2>
    2bc6:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <__udivmodhi4>
    2bca:	07 fc       	sbrc	r0, 7
    2bcc:	05 d0       	rcall	.+10     	; 0x2bd8 <__divmodhi4_neg2>
    2bce:	3e f4       	brtc	.+14     	; 0x2bde <__divmodhi4_exit>

00002bd0 <__divmodhi4_neg1>:
    2bd0:	90 95       	com	r25
    2bd2:	81 95       	neg	r24
    2bd4:	9f 4f       	sbci	r25, 0xFF	; 255
    2bd6:	08 95       	ret

00002bd8 <__divmodhi4_neg2>:
    2bd8:	70 95       	com	r23
    2bda:	61 95       	neg	r22
    2bdc:	7f 4f       	sbci	r23, 0xFF	; 255

00002bde <__divmodhi4_exit>:
    2bde:	08 95       	ret

00002be0 <malloc>:
    2be0:	0f 93       	push	r16
    2be2:	1f 93       	push	r17
    2be4:	cf 93       	push	r28
    2be6:	df 93       	push	r29
    2be8:	82 30       	cpi	r24, 0x02	; 2
    2bea:	91 05       	cpc	r25, r1
    2bec:	10 f4       	brcc	.+4      	; 0x2bf2 <malloc+0x12>
    2bee:	82 e0       	ldi	r24, 0x02	; 2
    2bf0:	90 e0       	ldi	r25, 0x00	; 0
    2bf2:	e0 91 d2 10 	lds	r30, 0x10D2
    2bf6:	f0 91 d3 10 	lds	r31, 0x10D3
    2bfa:	20 e0       	ldi	r18, 0x00	; 0
    2bfc:	30 e0       	ldi	r19, 0x00	; 0
    2bfe:	c0 e0       	ldi	r28, 0x00	; 0
    2c00:	d0 e0       	ldi	r29, 0x00	; 0
    2c02:	23 c0       	rjmp	.+70     	; 0x2c4a <malloc+0x6a>
    2c04:	40 81       	ld	r20, Z
    2c06:	51 81       	ldd	r21, Z+1	; 0x01
    2c08:	48 17       	cp	r20, r24
    2c0a:	59 07       	cpc	r21, r25
    2c0c:	a8 f0       	brcs	.+42     	; 0x2c38 <malloc+0x58>
    2c0e:	48 17       	cp	r20, r24
    2c10:	59 07       	cpc	r21, r25
    2c12:	61 f4       	brne	.+24     	; 0x2c2c <malloc+0x4c>
    2c14:	82 81       	ldd	r24, Z+2	; 0x02
    2c16:	93 81       	ldd	r25, Z+3	; 0x03
    2c18:	20 97       	sbiw	r28, 0x00	; 0
    2c1a:	19 f0       	breq	.+6      	; 0x2c22 <malloc+0x42>
    2c1c:	9b 83       	std	Y+3, r25	; 0x03
    2c1e:	8a 83       	std	Y+2, r24	; 0x02
    2c20:	2e c0       	rjmp	.+92     	; 0x2c7e <malloc+0x9e>
    2c22:	90 93 d3 10 	sts	0x10D3, r25
    2c26:	80 93 d2 10 	sts	0x10D2, r24
    2c2a:	29 c0       	rjmp	.+82     	; 0x2c7e <malloc+0x9e>
    2c2c:	21 15       	cp	r18, r1
    2c2e:	31 05       	cpc	r19, r1
    2c30:	29 f0       	breq	.+10     	; 0x2c3c <malloc+0x5c>
    2c32:	42 17       	cp	r20, r18
    2c34:	53 07       	cpc	r21, r19
    2c36:	10 f0       	brcs	.+4      	; 0x2c3c <malloc+0x5c>
    2c38:	a9 01       	movw	r20, r18
    2c3a:	02 c0       	rjmp	.+4      	; 0x2c40 <malloc+0x60>
    2c3c:	be 01       	movw	r22, r28
    2c3e:	df 01       	movw	r26, r30
    2c40:	02 81       	ldd	r16, Z+2	; 0x02
    2c42:	13 81       	ldd	r17, Z+3	; 0x03
    2c44:	ef 01       	movw	r28, r30
    2c46:	9a 01       	movw	r18, r20
    2c48:	f8 01       	movw	r30, r16
    2c4a:	30 97       	sbiw	r30, 0x00	; 0
    2c4c:	d9 f6       	brne	.-74     	; 0x2c04 <malloc+0x24>
    2c4e:	21 15       	cp	r18, r1
    2c50:	31 05       	cpc	r19, r1
    2c52:	09 f1       	breq	.+66     	; 0x2c96 <malloc+0xb6>
    2c54:	28 1b       	sub	r18, r24
    2c56:	39 0b       	sbc	r19, r25
    2c58:	24 30       	cpi	r18, 0x04	; 4
    2c5a:	31 05       	cpc	r19, r1
    2c5c:	90 f4       	brcc	.+36     	; 0x2c82 <malloc+0xa2>
    2c5e:	12 96       	adiw	r26, 0x02	; 2
    2c60:	8d 91       	ld	r24, X+
    2c62:	9c 91       	ld	r25, X
    2c64:	13 97       	sbiw	r26, 0x03	; 3
    2c66:	61 15       	cp	r22, r1
    2c68:	71 05       	cpc	r23, r1
    2c6a:	21 f0       	breq	.+8      	; 0x2c74 <malloc+0x94>
    2c6c:	fb 01       	movw	r30, r22
    2c6e:	93 83       	std	Z+3, r25	; 0x03
    2c70:	82 83       	std	Z+2, r24	; 0x02
    2c72:	04 c0       	rjmp	.+8      	; 0x2c7c <malloc+0x9c>
    2c74:	90 93 d3 10 	sts	0x10D3, r25
    2c78:	80 93 d2 10 	sts	0x10D2, r24
    2c7c:	fd 01       	movw	r30, r26
    2c7e:	32 96       	adiw	r30, 0x02	; 2
    2c80:	44 c0       	rjmp	.+136    	; 0x2d0a <malloc+0x12a>
    2c82:	fd 01       	movw	r30, r26
    2c84:	e2 0f       	add	r30, r18
    2c86:	f3 1f       	adc	r31, r19
    2c88:	81 93       	st	Z+, r24
    2c8a:	91 93       	st	Z+, r25
    2c8c:	22 50       	subi	r18, 0x02	; 2
    2c8e:	31 09       	sbc	r19, r1
    2c90:	2d 93       	st	X+, r18
    2c92:	3c 93       	st	X, r19
    2c94:	3a c0       	rjmp	.+116    	; 0x2d0a <malloc+0x12a>
    2c96:	20 91 d0 10 	lds	r18, 0x10D0
    2c9a:	30 91 d1 10 	lds	r19, 0x10D1
    2c9e:	23 2b       	or	r18, r19
    2ca0:	41 f4       	brne	.+16     	; 0x2cb2 <malloc+0xd2>
    2ca2:	20 91 02 01 	lds	r18, 0x0102
    2ca6:	30 91 03 01 	lds	r19, 0x0103
    2caa:	30 93 d1 10 	sts	0x10D1, r19
    2cae:	20 93 d0 10 	sts	0x10D0, r18
    2cb2:	20 91 00 01 	lds	r18, 0x0100
    2cb6:	30 91 01 01 	lds	r19, 0x0101
    2cba:	21 15       	cp	r18, r1
    2cbc:	31 05       	cpc	r19, r1
    2cbe:	41 f4       	brne	.+16     	; 0x2cd0 <malloc+0xf0>
    2cc0:	2d b7       	in	r18, 0x3d	; 61
    2cc2:	3e b7       	in	r19, 0x3e	; 62
    2cc4:	40 91 04 01 	lds	r20, 0x0104
    2cc8:	50 91 05 01 	lds	r21, 0x0105
    2ccc:	24 1b       	sub	r18, r20
    2cce:	35 0b       	sbc	r19, r21
    2cd0:	e0 91 d0 10 	lds	r30, 0x10D0
    2cd4:	f0 91 d1 10 	lds	r31, 0x10D1
    2cd8:	e2 17       	cp	r30, r18
    2cda:	f3 07       	cpc	r31, r19
    2cdc:	a0 f4       	brcc	.+40     	; 0x2d06 <malloc+0x126>
    2cde:	2e 1b       	sub	r18, r30
    2ce0:	3f 0b       	sbc	r19, r31
    2ce2:	28 17       	cp	r18, r24
    2ce4:	39 07       	cpc	r19, r25
    2ce6:	78 f0       	brcs	.+30     	; 0x2d06 <malloc+0x126>
    2ce8:	ac 01       	movw	r20, r24
    2cea:	4e 5f       	subi	r20, 0xFE	; 254
    2cec:	5f 4f       	sbci	r21, 0xFF	; 255
    2cee:	24 17       	cp	r18, r20
    2cf0:	35 07       	cpc	r19, r21
    2cf2:	48 f0       	brcs	.+18     	; 0x2d06 <malloc+0x126>
    2cf4:	4e 0f       	add	r20, r30
    2cf6:	5f 1f       	adc	r21, r31
    2cf8:	50 93 d1 10 	sts	0x10D1, r21
    2cfc:	40 93 d0 10 	sts	0x10D0, r20
    2d00:	81 93       	st	Z+, r24
    2d02:	91 93       	st	Z+, r25
    2d04:	02 c0       	rjmp	.+4      	; 0x2d0a <malloc+0x12a>
    2d06:	e0 e0       	ldi	r30, 0x00	; 0
    2d08:	f0 e0       	ldi	r31, 0x00	; 0
    2d0a:	cf 01       	movw	r24, r30
    2d0c:	df 91       	pop	r29
    2d0e:	cf 91       	pop	r28
    2d10:	1f 91       	pop	r17
    2d12:	0f 91       	pop	r16
    2d14:	08 95       	ret

00002d16 <free>:
    2d16:	ef 92       	push	r14
    2d18:	ff 92       	push	r15
    2d1a:	0f 93       	push	r16
    2d1c:	1f 93       	push	r17
    2d1e:	cf 93       	push	r28
    2d20:	df 93       	push	r29
    2d22:	00 97       	sbiw	r24, 0x00	; 0
    2d24:	09 f4       	brne	.+2      	; 0x2d28 <free+0x12>
    2d26:	8f c0       	rjmp	.+286    	; 0x2e46 <free+0x130>
    2d28:	dc 01       	movw	r26, r24
    2d2a:	12 97       	sbiw	r26, 0x02	; 2
    2d2c:	13 96       	adiw	r26, 0x03	; 3
    2d2e:	1c 92       	st	X, r1
    2d30:	1e 92       	st	-X, r1
    2d32:	12 97       	sbiw	r26, 0x02	; 2
    2d34:	e0 90 d2 10 	lds	r14, 0x10D2
    2d38:	f0 90 d3 10 	lds	r15, 0x10D3
    2d3c:	e1 14       	cp	r14, r1
    2d3e:	f1 04       	cpc	r15, r1
    2d40:	89 f4       	brne	.+34     	; 0x2d64 <free+0x4e>
    2d42:	2d 91       	ld	r18, X+
    2d44:	3c 91       	ld	r19, X
    2d46:	11 97       	sbiw	r26, 0x01	; 1
    2d48:	28 0f       	add	r18, r24
    2d4a:	39 1f       	adc	r19, r25
    2d4c:	80 91 d0 10 	lds	r24, 0x10D0
    2d50:	90 91 d1 10 	lds	r25, 0x10D1
    2d54:	82 17       	cp	r24, r18
    2d56:	93 07       	cpc	r25, r19
    2d58:	89 f5       	brne	.+98     	; 0x2dbc <free+0xa6>
    2d5a:	b0 93 d1 10 	sts	0x10D1, r27
    2d5e:	a0 93 d0 10 	sts	0x10D0, r26
    2d62:	71 c0       	rjmp	.+226    	; 0x2e46 <free+0x130>
    2d64:	e7 01       	movw	r28, r14
    2d66:	20 e0       	ldi	r18, 0x00	; 0
    2d68:	30 e0       	ldi	r19, 0x00	; 0
    2d6a:	01 c0       	rjmp	.+2      	; 0x2d6e <free+0x58>
    2d6c:	ea 01       	movw	r28, r20
    2d6e:	ca 17       	cp	r28, r26
    2d70:	db 07       	cpc	r29, r27
    2d72:	38 f4       	brcc	.+14     	; 0x2d82 <free+0x6c>
    2d74:	4a 81       	ldd	r20, Y+2	; 0x02
    2d76:	5b 81       	ldd	r21, Y+3	; 0x03
    2d78:	9e 01       	movw	r18, r28
    2d7a:	41 15       	cp	r20, r1
    2d7c:	51 05       	cpc	r21, r1
    2d7e:	b1 f7       	brne	.-20     	; 0x2d6c <free+0x56>
    2d80:	22 c0       	rjmp	.+68     	; 0x2dc6 <free+0xb0>
    2d82:	bc 01       	movw	r22, r24
    2d84:	62 50       	subi	r22, 0x02	; 2
    2d86:	71 09       	sbc	r23, r1
    2d88:	fb 01       	movw	r30, r22
    2d8a:	d3 83       	std	Z+3, r29	; 0x03
    2d8c:	c2 83       	std	Z+2, r28	; 0x02
    2d8e:	00 81       	ld	r16, Z
    2d90:	11 81       	ldd	r17, Z+1	; 0x01
    2d92:	ac 01       	movw	r20, r24
    2d94:	40 0f       	add	r20, r16
    2d96:	51 1f       	adc	r21, r17
    2d98:	4c 17       	cp	r20, r28
    2d9a:	5d 07       	cpc	r21, r29
    2d9c:	61 f4       	brne	.+24     	; 0x2db6 <free+0xa0>
    2d9e:	48 81       	ld	r20, Y
    2da0:	59 81       	ldd	r21, Y+1	; 0x01
    2da2:	40 0f       	add	r20, r16
    2da4:	51 1f       	adc	r21, r17
    2da6:	4e 5f       	subi	r20, 0xFE	; 254
    2da8:	5f 4f       	sbci	r21, 0xFF	; 255
    2daa:	51 83       	std	Z+1, r21	; 0x01
    2dac:	40 83       	st	Z, r20
    2dae:	4a 81       	ldd	r20, Y+2	; 0x02
    2db0:	5b 81       	ldd	r21, Y+3	; 0x03
    2db2:	53 83       	std	Z+3, r21	; 0x03
    2db4:	42 83       	std	Z+2, r20	; 0x02
    2db6:	21 15       	cp	r18, r1
    2db8:	31 05       	cpc	r19, r1
    2dba:	29 f4       	brne	.+10     	; 0x2dc6 <free+0xb0>
    2dbc:	b0 93 d3 10 	sts	0x10D3, r27
    2dc0:	a0 93 d2 10 	sts	0x10D2, r26
    2dc4:	40 c0       	rjmp	.+128    	; 0x2e46 <free+0x130>
    2dc6:	f9 01       	movw	r30, r18
    2dc8:	b3 83       	std	Z+3, r27	; 0x03
    2dca:	a2 83       	std	Z+2, r26	; 0x02
    2dcc:	e9 01       	movw	r28, r18
    2dce:	69 91       	ld	r22, Y+
    2dd0:	79 91       	ld	r23, Y+
    2dd2:	c6 0f       	add	r28, r22
    2dd4:	d7 1f       	adc	r29, r23
    2dd6:	ac 17       	cp	r26, r28
    2dd8:	bd 07       	cpc	r27, r29
    2dda:	79 f4       	brne	.+30     	; 0x2dfa <free+0xe4>
    2ddc:	dc 01       	movw	r26, r24
    2dde:	5e 91       	ld	r21, -X
    2de0:	4e 91       	ld	r20, -X
    2de2:	46 0f       	add	r20, r22
    2de4:	57 1f       	adc	r21, r23
    2de6:	4e 5f       	subi	r20, 0xFE	; 254
    2de8:	5f 4f       	sbci	r21, 0xFF	; 255
    2dea:	51 83       	std	Z+1, r21	; 0x01
    2dec:	40 83       	st	Z, r20
    2dee:	12 96       	adiw	r26, 0x02	; 2
    2df0:	8d 91       	ld	r24, X+
    2df2:	9c 91       	ld	r25, X
    2df4:	13 97       	sbiw	r26, 0x03	; 3
    2df6:	93 83       	std	Z+3, r25	; 0x03
    2df8:	82 83       	std	Z+2, r24	; 0x02
    2dfa:	a0 e0       	ldi	r26, 0x00	; 0
    2dfc:	b0 e0       	ldi	r27, 0x00	; 0
    2dfe:	02 c0       	rjmp	.+4      	; 0x2e04 <free+0xee>
    2e00:	d7 01       	movw	r26, r14
    2e02:	7c 01       	movw	r14, r24
    2e04:	f7 01       	movw	r30, r14
    2e06:	82 81       	ldd	r24, Z+2	; 0x02
    2e08:	93 81       	ldd	r25, Z+3	; 0x03
    2e0a:	00 97       	sbiw	r24, 0x00	; 0
    2e0c:	c9 f7       	brne	.-14     	; 0x2e00 <free+0xea>
    2e0e:	c7 01       	movw	r24, r14
    2e10:	02 96       	adiw	r24, 0x02	; 2
    2e12:	20 81       	ld	r18, Z
    2e14:	31 81       	ldd	r19, Z+1	; 0x01
    2e16:	82 0f       	add	r24, r18
    2e18:	93 1f       	adc	r25, r19
    2e1a:	20 91 d0 10 	lds	r18, 0x10D0
    2e1e:	30 91 d1 10 	lds	r19, 0x10D1
    2e22:	28 17       	cp	r18, r24
    2e24:	39 07       	cpc	r19, r25
    2e26:	79 f4       	brne	.+30     	; 0x2e46 <free+0x130>
    2e28:	10 97       	sbiw	r26, 0x00	; 0
    2e2a:	29 f4       	brne	.+10     	; 0x2e36 <free+0x120>
    2e2c:	10 92 d3 10 	sts	0x10D3, r1
    2e30:	10 92 d2 10 	sts	0x10D2, r1
    2e34:	04 c0       	rjmp	.+8      	; 0x2e3e <free+0x128>
    2e36:	13 96       	adiw	r26, 0x03	; 3
    2e38:	1c 92       	st	X, r1
    2e3a:	1e 92       	st	-X, r1
    2e3c:	12 97       	sbiw	r26, 0x02	; 2
    2e3e:	f0 92 d1 10 	sts	0x10D1, r15
    2e42:	e0 92 d0 10 	sts	0x10D0, r14
    2e46:	df 91       	pop	r29
    2e48:	cf 91       	pop	r28
    2e4a:	1f 91       	pop	r17
    2e4c:	0f 91       	pop	r16
    2e4e:	ff 90       	pop	r15
    2e50:	ef 90       	pop	r14
    2e52:	08 95       	ret

00002e54 <memcpy>:
    2e54:	fb 01       	movw	r30, r22
    2e56:	dc 01       	movw	r26, r24
    2e58:	02 c0       	rjmp	.+4      	; 0x2e5e <memcpy+0xa>
    2e5a:	01 90       	ld	r0, Z+
    2e5c:	0d 92       	st	X+, r0
    2e5e:	41 50       	subi	r20, 0x01	; 1
    2e60:	50 40       	sbci	r21, 0x00	; 0
    2e62:	d8 f7       	brcc	.-10     	; 0x2e5a <memcpy+0x6>
    2e64:	08 95       	ret

00002e66 <_exit>:
    2e66:	f8 94       	cli

00002e68 <__stop_program>:
    2e68:	ff cf       	rjmp	.-2      	; 0x2e68 <__stop_program>
