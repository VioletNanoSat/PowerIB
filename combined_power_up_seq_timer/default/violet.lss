
violet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000206  00800100  00003988  00003a1c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003988  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c5c  00800306  00800306  00003c22  2**0
                  ALLOC
  3 .debug_aranges 00000200  00000000  00000000  00003c22  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00001253  00000000  00000000  00003e22  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003bb4  00000000  00000000  00005075  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000a70  00000000  00000000  00008c29  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000031f8  00000000  00000000  00009699  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000320  00000000  00000000  0000c894  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000008b1  00000000  00000000  0000cbb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000c9f  00000000  00000000  0000d465  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001c8  00000000  00000000  0000e104  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
  svit[svit_index].I_sample_index = 0;
  svit[svit_index].I_critical_value = 0;
  svit[svit_index].T_mux_num = T_mux_num;
  svit[svit_index].T_mux_sel = T_mux_sel;
  svit[svit_index].T_sample_index = 0;
}
       0:	0c 94 96 00 	jmp	0x12c	; 0x12c <__ctors_end>
/*
 * Send character c down the UART Tx, wait until tx holding register
 * is empty.
 */
int uart_putchar(char c, FILE *stream)
{
       4:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>

	for (index = 0; index < size; index++)
		crc = (crc >> 8) ^ ccitt_crc16[(crc ^ message[index]) & 0xff];

	return crc;
}
       8:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      tx_put_byte( uart );
  }
}

uint8_t V_ack_change( void )
{
       c:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      10:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      14:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      18:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      1c:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      20:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      24:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      28:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      2c:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      30:	0c 94 f6 16 	jmp	0x2dec	; 0x2dec <__vector_12>
      34:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      38:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      3c:	0c 94 c6 12 	jmp	0x258c	; 0x258c <__vector_15>
      40:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      44:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      48:	0c 94 8d 16 	jmp	0x2d1a	; 0x2d1a <__vector_18>
      4c:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      50:	0c 94 36 13 	jmp	0x266c	; 0x266c <__vector_20>
      54:	0c 94 e4 12 	jmp	0x25c8	; 0x25c8 <__vector_21>
      58:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      5c:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      60:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      64:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      68:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      6c:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      70:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      74:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      78:	0c 94 c1 16 	jmp	0x2d82	; 0x2d82 <__vector_30>
      7c:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      80:	0c 94 5f 13 	jmp	0x26be	; 0x26be <__vector_32>
      84:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      88:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__bad_interrupt>
      8c:	05 a8       	ldd	r0, Z+53	; 0x35
      8e:	4c cd       	rjmp	.-1384   	; 0xfffffb28 <__eeprom_end+0xff7efb28>
      90:	b2 d4       	rcall	.+2404   	; 0x9f6 <initialize_svit+0x888>
      92:	4e b9       	out	0x0e, r20	; 14
      94:	38 36       	cpi	r19, 0x68	; 104
      96:	a9 02       	muls	r26, r25
      98:	0c 50       	subi	r16, 0x0C	; 12
      9a:	b9 91       	ld	r27, Y+
      9c:	86 88       	ldd	r8, Z+22	; 0x16
      9e:	08 3c       	cpi	r16, 0xC8	; 200
      a0:	a6 aa       	std	Z+54, r10	; 0x36
      a2:	aa 2a       	or	r10, r26
      a4:	be 00       	.word	0x00be	; ????
      a6:	00 00       	nop
      a8:	80 3f       	cpi	r24, 0xF0	; 240
      aa:	07 63       	ori	r16, 0x37	; 55
      ac:	42 36       	cpi	r20, 0x62	; 98
      ae:	b7 9b       	sbis	0x16, 7	; 22
      b0:	d8 a7       	std	Y+40, r29	; 0x28
      b2:	1a 39       	cpi	r17, 0x9A	; 154
      b4:	68 56       	subi	r22, 0x68	; 104
      b6:	18 ae       	std	Y+56, r1	; 0x38
      b8:	ba ab       	std	Y+50, r27	; 0x32
      ba:	55 8c       	ldd	r5, Z+29	; 0x1d
      bc:	1d 3c       	cpi	r17, 0xCD	; 205
      be:	b7 cc       	rjmp	.-1682   	; 0xfffffa2e <__eeprom_end+0xff7efa2e>
      c0:	57 63       	ori	r21, 0x37	; 55
      c2:	bd 6d       	ori	r27, 0xDD	; 221
      c4:	ed fd       	.word	0xfded	; ????
      c6:	75 3e       	cpi	r23, 0xE5	; 229
      c8:	f6 17       	cp	r31, r22
      ca:	72 31       	cpi	r23, 0x12	; 18
      cc:	bf 00       	.word	0x00bf	; ????
      ce:	00 00       	nop
      d0:	80 3f       	cpi	r24, 0xF0	; 240
      d2:	08 00       	.word	0x0008	; ????
      d4:	00 00       	nop
      d6:	be 92       	st	-X, r11
      d8:	24 49       	sbci	r18, 0x94	; 148
      da:	12 3e       	cpi	r17, 0xE2	; 226
      dc:	ab aa       	std	Y+51, r10	; 0x33
      de:	aa 2a       	or	r10, r26
      e0:	be cd       	rjmp	.-1156   	; 0xfffffc5e <__eeprom_end+0xff7efc5e>
      e2:	cc cc       	rjmp	.-1640   	; 0xfffffa7c <__eeprom_end+0xff7efa7c>
      e4:	4c 3e       	cpi	r20, 0xEC	; 236
      e6:	00 00       	nop
      e8:	00 80       	ld	r0, Z
      ea:	be ab       	std	Y+54, r27	; 0x36
      ec:	aa aa       	std	Y+50, r10	; 0x32
      ee:	aa 3e       	cpi	r26, 0xEA	; 234
      f0:	00 00       	nop
      f2:	00 00       	nop
      f4:	bf 00       	.word	0x00bf	; ????
      f6:	00 00       	nop
      f8:	80 3f       	cpi	r24, 0xF0	; 240
      fa:	00 00       	nop
      fc:	00 00       	nop
      fe:	00 08       	sbc	r0, r0
     100:	41 78       	andi	r20, 0x81	; 129
     102:	d3 bb       	out	0x13, r29	; 19
     104:	43 87       	std	Z+11, r20	; 0x0b
     106:	d1 13       	cpse	r29, r17
     108:	3d 19       	sub	r19, r13
     10a:	0e 3c       	cpi	r16, 0xCE	; 206
     10c:	c3 bd       	out	0x23, r28	; 35
     10e:	42 82       	std	Z+2, r4	; 0x02
     110:	ad 2b       	or	r26, r29
     112:	3e 68       	ori	r19, 0x8E	; 142
     114:	ec 82       	std	Y+4, r14	; 0x04
     116:	76 be       	out	0x36, r7	; 54
     118:	d9 8f       	std	Y+25, r29	; 0x19
     11a:	e1 a9       	ldd	r30, Z+49	; 0x31
     11c:	3e 4c       	sbci	r19, 0xCE	; 206
     11e:	80 ef       	ldi	r24, 0xF0	; 240
     120:	ff be       	out	0x3f, r15	; 63
     122:	01 c4       	rjmp	.+2050   	; 0x926 <initialize_svit+0x7b8>
     124:	ff 7f       	andi	r31, 0xFF	; 255
     126:	3f 00       	.word	0x003f	; ????
     128:	00 00       	nop
	...

0000012c <__ctors_end>:
     12c:	11 24       	eor	r1, r1
     12e:	1f be       	out	0x3f, r1	; 63
     130:	cf ef       	ldi	r28, 0xFF	; 255
     132:	d0 e1       	ldi	r29, 0x10	; 16
     134:	de bf       	out	0x3e, r29	; 62
     136:	cd bf       	out	0x3d, r28	; 61

00000138 <__do_copy_data>:
     138:	13 e0       	ldi	r17, 0x03	; 3
     13a:	a0 e0       	ldi	r26, 0x00	; 0
     13c:	b1 e0       	ldi	r27, 0x01	; 1
     13e:	e8 e8       	ldi	r30, 0x88	; 136
     140:	f9 e3       	ldi	r31, 0x39	; 57
     142:	00 e0       	ldi	r16, 0x00	; 0
     144:	0b bf       	out	0x3b, r16	; 59
     146:	02 c0       	rjmp	.+4      	; 0x14c <__do_copy_data+0x14>
     148:	07 90       	elpm	r0, Z+
     14a:	0d 92       	st	X+, r0
     14c:	a6 30       	cpi	r26, 0x06	; 6
     14e:	b1 07       	cpc	r27, r17
     150:	d9 f7       	brne	.-10     	; 0x148 <__do_copy_data+0x10>

00000152 <__do_clear_bss>:
     152:	1f e0       	ldi	r17, 0x0F	; 15
     154:	a6 e0       	ldi	r26, 0x06	; 6
     156:	b3 e0       	ldi	r27, 0x03	; 3
     158:	01 c0       	rjmp	.+2      	; 0x15c <.do_clear_bss_start>

0000015a <.do_clear_bss_loop>:
     15a:	1d 92       	st	X+, r1

0000015c <.do_clear_bss_start>:
     15c:	a2 36       	cpi	r26, 0x62	; 98
     15e:	b1 07       	cpc	r27, r17
     160:	e1 f7       	brne	.-8      	; 0x15a <.do_clear_bss_loop>
     162:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <main>
     166:	0c 94 c2 1c 	jmp	0x3984	; 0x3984 <_exit>

0000016a <__bad_interrupt>:
     16a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000016e <initialize_svit>:

void initialize_svit( void )
{ 
     16e:	3f 92       	push	r3
     170:	4f 92       	push	r4
     172:	5f 92       	push	r5
     174:	6f 92       	push	r6
     176:	7f 92       	push	r7
     178:	8f 92       	push	r8
     17a:	9f 92       	push	r9
     17c:	af 92       	push	r10
     17e:	bf 92       	push	r11
     180:	cf 92       	push	r12
     182:	df 92       	push	r13
     184:	ef 92       	push	r14
     186:	ff 92       	push	r15
     188:	0f 93       	push	r16
     18a:	1f 93       	push	r17
  // ADC
  // Vref = AVCC = 5 V
  // ADC clock = 16 MHz / 128 = 125 kHz

  // set Vref to AVCC, left-adjust result into ADCH
  ADMUX = ( 1 << ADLAR ) | ( 1 << REFS0 );
     18c:	80 e6       	ldi	r24, 0x60	; 96
     18e:	87 b9       	out	0x07, r24	; 7

  // enable ADC and set ADC division factor to 128
  ADCSRA = ( 1 << ADEN ) | ( 1 << ADIE ) | ( 1 << ADPS2 ) | ( 1 << ADPS1 ) | ( 1 << ADPS0 );
     190:	8f e8       	ldi	r24, 0x8F	; 143
     192:	86 b9       	out	0x06, r24	; 6
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     194:	e5 e3       	ldi	r30, 0x35	; 53
     196:	f3 e0       	ldi	r31, 0x03	; 3
     198:	10 92 35 03 	sts	0x0335, r1
  svit[svit_index].switch_num = switch_num;
     19c:	97 e0       	ldi	r25, 0x07	; 7
     19e:	c9 2e       	mov	r12, r25
     1a0:	c0 92 36 03 	sts	0x0336, r12
  svit[svit_index].switch_state = switch_state;
     1a4:	91 e0       	ldi	r25, 0x01	; 1
     1a6:	90 93 37 03 	sts	0x0337, r25
  svit[svit_index].force_on = 0;
     1aa:	10 92 38 03 	sts	0x0338, r1

  svit[svit_index].V_mux_num = V_mux_num;
     1ae:	10 92 39 03 	sts	0x0339, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     1b2:	8b e0       	ldi	r24, 0x0B	; 11
     1b4:	88 2e       	mov	r8, r24
     1b6:	80 92 3a 03 	sts	0x033A, r8
  svit[svit_index].V_upper_limit = V_upper_limit;
     1ba:	21 ee       	ldi	r18, 0xE1	; 225
     1bc:	20 93 3b 03 	sts	0x033B, r18
  svit[svit_index].V_sample_index = 0;
     1c0:	10 92 3f 03 	sts	0x033F, r1
  svit[svit_index].V_critical_value = 0;
     1c4:	10 92 40 03 	sts	0x0340, r1

  svit[svit_index].I_mux_num = I_mux_num;
     1c8:	10 92 41 03 	sts	0x0341, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     1cc:	16 e0       	ldi	r17, 0x06	; 6
     1ce:	10 93 42 03 	sts	0x0342, r17
  svit[svit_index].I_upper_limit = I_upper_limit;
     1d2:	20 93 43 03 	sts	0x0343, r18
  svit[svit_index].I_sample_index = 0;
     1d6:	10 92 47 03 	sts	0x0347, r1
  svit[svit_index].I_critical_value = 0;
     1da:	10 92 48 03 	sts	0x0348, r1
  svit[svit_index].T_mux_num = T_mux_num;
     1de:	43 e0       	ldi	r20, 0x03	; 3
     1e0:	40 93 49 03 	sts	0x0349, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     1e4:	10 92 4a 03 	sts	0x034A, r1
  svit[svit_index].T_sample_index = 0;
     1e8:	10 92 4e 03 	sts	0x034E, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     1ec:	90 93 4f 03 	sts	0x034F, r25
  svit[svit_index].switch_num = switch_num;
     1f0:	a8 e0       	ldi	r26, 0x08	; 8
     1f2:	a0 93 50 03 	sts	0x0350, r26
  svit[svit_index].switch_state = switch_state;
     1f6:	90 93 51 03 	sts	0x0351, r25
  svit[svit_index].force_on = 0;
     1fa:	10 92 52 03 	sts	0x0352, r1

  svit[svit_index].V_mux_num = V_mux_num;
     1fe:	10 92 53 03 	sts	0x0353, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     202:	07 e1       	ldi	r16, 0x17	; 23
     204:	60 2e       	mov	r6, r16
     206:	60 92 54 03 	sts	0x0354, r6
  svit[svit_index].V_upper_limit = V_upper_limit;
     20a:	20 93 55 03 	sts	0x0355, r18
  svit[svit_index].V_sample_index = 0;
     20e:	10 92 59 03 	sts	0x0359, r1
  svit[svit_index].V_critical_value = 0;
     212:	10 92 5a 03 	sts	0x035A, r1

  svit[svit_index].I_mux_num = I_mux_num;
     216:	10 92 5b 03 	sts	0x035B, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     21a:	c0 92 5c 03 	sts	0x035C, r12
  svit[svit_index].I_upper_limit = I_upper_limit;
     21e:	20 93 5d 03 	sts	0x035D, r18
  svit[svit_index].I_sample_index = 0;
     222:	10 92 61 03 	sts	0x0361, r1
  svit[svit_index].I_critical_value = 0;
     226:	10 92 62 03 	sts	0x0362, r1
  svit[svit_index].T_mux_num = T_mux_num;
     22a:	90 93 63 03 	sts	0x0363, r25
  svit[svit_index].T_mux_sel = T_mux_sel;
     22e:	c0 92 64 03 	sts	0x0364, r12
  svit[svit_index].T_sample_index = 0;
     232:	10 92 68 03 	sts	0x0368, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     236:	62 e0       	ldi	r22, 0x02	; 2
     238:	60 93 69 03 	sts	0x0369, r22
  svit[svit_index].switch_num = switch_num;
     23c:	90 93 6a 03 	sts	0x036A, r25
  svit[svit_index].switch_state = switch_state;
     240:	90 93 6b 03 	sts	0x036B, r25
  svit[svit_index].force_on = 0;
     244:	10 92 6c 03 	sts	0x036C, r1

  svit[svit_index].V_mux_num = V_mux_num;
     248:	90 93 6d 03 	sts	0x036D, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     24c:	b3 e1       	ldi	r27, 0x13	; 19
     24e:	7b 2e       	mov	r7, r27
     250:	70 92 6e 03 	sts	0x036E, r7
  svit[svit_index].V_upper_limit = V_upper_limit;
     254:	20 93 6f 03 	sts	0x036F, r18
  svit[svit_index].V_sample_index = 0;
     258:	16 ae       	std	Z+62, r1	; 0x3e
  svit[svit_index].V_critical_value = 0;
     25a:	17 ae       	std	Z+63, r1	; 0x3f

  svit[svit_index].I_mux_num = I_mux_num;
     25c:	90 93 75 03 	sts	0x0375, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     260:	10 92 76 03 	sts	0x0376, r1
  svit[svit_index].I_upper_limit = I_upper_limit;
     264:	20 93 77 03 	sts	0x0377, r18
  svit[svit_index].I_sample_index = 0;
     268:	10 92 7b 03 	sts	0x037B, r1
  svit[svit_index].I_critical_value = 0;
     26c:	10 92 7c 03 	sts	0x037C, r1
  svit[svit_index].T_mux_num = T_mux_num;
     270:	40 93 7d 03 	sts	0x037D, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     274:	10 92 7e 03 	sts	0x037E, r1
  svit[svit_index].T_sample_index = 0;
     278:	10 92 82 03 	sts	0x0382, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     27c:	40 93 83 03 	sts	0x0383, r20
  svit[svit_index].switch_num = switch_num;
     280:	90 93 84 03 	sts	0x0384, r25
  svit[svit_index].switch_state = switch_state;
     284:	90 93 85 03 	sts	0x0385, r25
  svit[svit_index].force_on = 0;
     288:	10 92 86 03 	sts	0x0386, r1

  svit[svit_index].V_mux_num = V_mux_num;
     28c:	60 93 87 03 	sts	0x0387, r22
  svit[svit_index].V_mux_sel = V_mux_sel;
     290:	fd e0       	ldi	r31, 0x0D	; 13
     292:	f0 93 88 03 	sts	0x0388, r31
  svit[svit_index].V_upper_limit = V_upper_limit;
     296:	20 93 89 03 	sts	0x0389, r18
  svit[svit_index].V_sample_index = 0;
     29a:	10 92 8d 03 	sts	0x038D, r1
  svit[svit_index].V_critical_value = 0;
     29e:	10 92 8e 03 	sts	0x038E, r1

  svit[svit_index].I_mux_num = I_mux_num;
     2a2:	60 93 8f 03 	sts	0x038F, r22
  svit[svit_index].I_mux_sel = I_mux_sel;
     2a6:	5e e0       	ldi	r21, 0x0E	; 14
     2a8:	50 93 90 03 	sts	0x0390, r21
  svit[svit_index].I_upper_limit = I_upper_limit;
     2ac:	20 93 91 03 	sts	0x0391, r18
  svit[svit_index].I_sample_index = 0;
     2b0:	10 92 95 03 	sts	0x0395, r1
  svit[svit_index].I_critical_value = 0;
     2b4:	10 92 96 03 	sts	0x0396, r1
  svit[svit_index].T_mux_num = T_mux_num;
     2b8:	40 93 97 03 	sts	0x0397, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     2bc:	10 92 98 03 	sts	0x0398, r1
  svit[svit_index].T_sample_index = 0;
     2c0:	10 92 9c 03 	sts	0x039C, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     2c4:	74 e0       	ldi	r23, 0x04	; 4
     2c6:	b7 2e       	mov	r11, r23
     2c8:	b0 92 9d 03 	sts	0x039D, r11
  svit[svit_index].switch_num = switch_num;
     2cc:	60 93 9e 03 	sts	0x039E, r22
  svit[svit_index].switch_state = switch_state;
     2d0:	90 93 9f 03 	sts	0x039F, r25
  svit[svit_index].force_on = 0;
     2d4:	10 92 a0 03 	sts	0x03A0, r1

  svit[svit_index].V_mux_num = V_mux_num;
     2d8:	90 93 a1 03 	sts	0x03A1, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     2dc:	35 e1       	ldi	r19, 0x15	; 21
     2de:	93 2e       	mov	r9, r19
     2e0:	90 92 a2 03 	sts	0x03A2, r9
  svit[svit_index].V_upper_limit = V_upper_limit;
     2e4:	20 93 a3 03 	sts	0x03A3, r18
  svit[svit_index].V_sample_index = 0;
     2e8:	10 92 a7 03 	sts	0x03A7, r1
  svit[svit_index].V_critical_value = 0;
     2ec:	10 92 a8 03 	sts	0x03A8, r1

  svit[svit_index].I_mux_num = I_mux_num;
     2f0:	90 93 a9 03 	sts	0x03A9, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     2f4:	90 93 aa 03 	sts	0x03AA, r25
  svit[svit_index].I_upper_limit = I_upper_limit;
     2f8:	20 93 ab 03 	sts	0x03AB, r18
  svit[svit_index].I_sample_index = 0;
     2fc:	10 92 af 03 	sts	0x03AF, r1
  svit[svit_index].I_critical_value = 0;
     300:	10 92 b0 03 	sts	0x03B0, r1
  svit[svit_index].T_mux_num = T_mux_num;
     304:	40 93 b1 03 	sts	0x03B1, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     308:	10 92 b2 03 	sts	0x03B2, r1
  svit[svit_index].T_sample_index = 0;
     30c:	10 92 b6 03 	sts	0x03B6, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     310:	05 e0       	ldi	r16, 0x05	; 5
     312:	00 93 b7 03 	sts	0x03B7, r16
  svit[svit_index].switch_num = switch_num;
     316:	40 93 b8 03 	sts	0x03B8, r20
  svit[svit_index].switch_state = switch_state;
     31a:	90 93 b9 03 	sts	0x03B9, r25
  svit[svit_index].force_on = 0;
     31e:	10 92 ba 03 	sts	0x03BA, r1

  svit[svit_index].V_mux_num = V_mux_num;
     322:	90 93 bb 03 	sts	0x03BB, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     326:	8a e1       	ldi	r24, 0x1A	; 26
     328:	38 2e       	mov	r3, r24
     32a:	30 92 bc 03 	sts	0x03BC, r3
  svit[svit_index].V_upper_limit = V_upper_limit;
     32e:	20 93 bd 03 	sts	0x03BD, r18
  svit[svit_index].V_sample_index = 0;
     332:	10 92 c1 03 	sts	0x03C1, r1
  svit[svit_index].V_critical_value = 0;
     336:	10 92 c2 03 	sts	0x03C2, r1

  svit[svit_index].I_mux_num = I_mux_num;
     33a:	90 93 c3 03 	sts	0x03C3, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     33e:	60 93 c4 03 	sts	0x03C4, r22
  svit[svit_index].I_upper_limit = I_upper_limit;
     342:	20 93 c5 03 	sts	0x03C5, r18
  svit[svit_index].I_sample_index = 0;
     346:	10 92 c9 03 	sts	0x03C9, r1
  svit[svit_index].I_critical_value = 0;
     34a:	10 92 ca 03 	sts	0x03CA, r1
  svit[svit_index].T_mux_num = T_mux_num;
     34e:	40 93 cb 03 	sts	0x03CB, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     352:	10 92 cc 03 	sts	0x03CC, r1
  svit[svit_index].T_sample_index = 0;
     356:	10 92 d0 03 	sts	0x03D0, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     35a:	10 93 d1 03 	sts	0x03D1, r17
  svit[svit_index].switch_num = switch_num;
     35e:	b0 92 d2 03 	sts	0x03D2, r11
  svit[svit_index].switch_state = switch_state;
     362:	90 93 d3 03 	sts	0x03D3, r25
  svit[svit_index].force_on = 0;
     366:	10 92 d4 03 	sts	0x03D4, r1

  svit[svit_index].V_mux_num = V_mux_num;
     36a:	90 93 d5 03 	sts	0x03D5, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     36e:	8d e1       	ldi	r24, 0x1D	; 29
     370:	80 93 d6 03 	sts	0x03D6, r24
  svit[svit_index].V_upper_limit = V_upper_limit;
     374:	20 93 d7 03 	sts	0x03D7, r18
  svit[svit_index].V_sample_index = 0;
     378:	10 92 db 03 	sts	0x03DB, r1
  svit[svit_index].V_critical_value = 0;
     37c:	10 92 dc 03 	sts	0x03DC, r1

  svit[svit_index].I_mux_num = I_mux_num;
     380:	90 93 dd 03 	sts	0x03DD, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     384:	40 93 de 03 	sts	0x03DE, r20
  svit[svit_index].I_upper_limit = I_upper_limit;
     388:	20 93 df 03 	sts	0x03DF, r18
  svit[svit_index].I_sample_index = 0;
     38c:	10 92 e3 03 	sts	0x03E3, r1
  svit[svit_index].I_critical_value = 0;
     390:	10 92 e4 03 	sts	0x03E4, r1
  svit[svit_index].T_mux_num = T_mux_num;
     394:	40 93 e5 03 	sts	0x03E5, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     398:	10 92 e6 03 	sts	0x03E6, r1
  svit[svit_index].T_sample_index = 0;
     39c:	10 92 ea 03 	sts	0x03EA, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     3a0:	c0 92 eb 03 	sts	0x03EB, r12
  svit[svit_index].switch_num = switch_num;
     3a4:	00 93 ec 03 	sts	0x03EC, r16
  svit[svit_index].switch_state = switch_state;
     3a8:	90 93 ed 03 	sts	0x03ED, r25
  svit[svit_index].force_on = 0;
     3ac:	10 92 ee 03 	sts	0x03EE, r1

  svit[svit_index].V_mux_num = V_mux_num;
     3b0:	90 93 ef 03 	sts	0x03EF, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     3b4:	50 93 f0 03 	sts	0x03F0, r21
  svit[svit_index].V_upper_limit = V_upper_limit;
     3b8:	20 93 f1 03 	sts	0x03F1, r18
  svit[svit_index].V_sample_index = 0;
     3bc:	10 92 f5 03 	sts	0x03F5, r1
  svit[svit_index].V_critical_value = 0;
     3c0:	10 92 f6 03 	sts	0x03F6, r1

  svit[svit_index].I_mux_num = I_mux_num;
     3c4:	90 93 f7 03 	sts	0x03F7, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     3c8:	8f e1       	ldi	r24, 0x1F	; 31
     3ca:	80 93 f8 03 	sts	0x03F8, r24
  svit[svit_index].I_upper_limit = I_upper_limit;
     3ce:	20 93 f9 03 	sts	0x03F9, r18
  svit[svit_index].I_sample_index = 0;
     3d2:	10 92 fd 03 	sts	0x03FD, r1
  svit[svit_index].I_critical_value = 0;
     3d6:	10 92 fe 03 	sts	0x03FE, r1
  svit[svit_index].T_mux_num = T_mux_num;
     3da:	40 93 ff 03 	sts	0x03FF, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     3de:	10 92 00 04 	sts	0x0400, r1
  svit[svit_index].T_sample_index = 0;
     3e2:	10 92 04 04 	sts	0x0404, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     3e6:	a0 93 05 04 	sts	0x0405, r26
  svit[svit_index].switch_num = switch_num;
     3ea:	10 93 06 04 	sts	0x0406, r17
  svit[svit_index].switch_state = switch_state;
     3ee:	90 93 07 04 	sts	0x0407, r25
  svit[svit_index].force_on = 0;
     3f2:	10 92 08 04 	sts	0x0408, r1

  svit[svit_index].V_mux_num = V_mux_num;
     3f6:	90 93 09 04 	sts	0x0409, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     3fa:	bb e1       	ldi	r27, 0x1B	; 27
     3fc:	4b 2e       	mov	r4, r27
     3fe:	40 92 0a 04 	sts	0x040A, r4
  svit[svit_index].V_upper_limit = V_upper_limit;
     402:	20 93 0b 04 	sts	0x040B, r18
  svit[svit_index].V_sample_index = 0;
     406:	10 92 0f 04 	sts	0x040F, r1
  svit[svit_index].V_critical_value = 0;
     40a:	10 92 10 04 	sts	0x0410, r1

  svit[svit_index].I_mux_num = I_mux_num;
     40e:	90 93 11 04 	sts	0x0411, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     412:	b0 92 12 04 	sts	0x0412, r11
  svit[svit_index].I_upper_limit = I_upper_limit;
     416:	20 93 13 04 	sts	0x0413, r18
  svit[svit_index].I_sample_index = 0;
     41a:	10 92 17 04 	sts	0x0417, r1
  svit[svit_index].I_critical_value = 0;
     41e:	10 92 18 04 	sts	0x0418, r1
  svit[svit_index].T_mux_num = T_mux_num;
     422:	40 93 19 04 	sts	0x0419, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     426:	10 92 1a 04 	sts	0x041A, r1
  svit[svit_index].T_sample_index = 0;
     42a:	10 92 1e 04 	sts	0x041E, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     42e:	e9 e0       	ldi	r30, 0x09	; 9
     430:	ee 2e       	mov	r14, r30
     432:	e0 92 1f 04 	sts	0x041F, r14
  svit[svit_index].switch_num = switch_num;
     436:	e0 92 20 04 	sts	0x0420, r14
  svit[svit_index].switch_state = switch_state;
     43a:	90 93 21 04 	sts	0x0421, r25
  svit[svit_index].force_on = 0;
     43e:	10 92 22 04 	sts	0x0422, r1

  svit[svit_index].V_mux_num = V_mux_num;
     442:	90 93 23 04 	sts	0x0423, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     446:	bf e0       	ldi	r27, 0x0F	; 15
     448:	b0 93 24 04 	sts	0x0424, r27
  svit[svit_index].V_upper_limit = V_upper_limit;
     44c:	20 93 25 04 	sts	0x0425, r18
  svit[svit_index].V_sample_index = 0;
     450:	10 92 29 04 	sts	0x0429, r1
  svit[svit_index].V_critical_value = 0;
     454:	10 92 2a 04 	sts	0x042A, r1

  svit[svit_index].I_mux_num = I_mux_num;
     458:	90 93 2b 04 	sts	0x042B, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     45c:	a0 93 2c 04 	sts	0x042C, r26
  svit[svit_index].I_upper_limit = I_upper_limit;
     460:	20 93 2d 04 	sts	0x042D, r18
  svit[svit_index].I_sample_index = 0;
     464:	10 92 31 04 	sts	0x0431, r1
  svit[svit_index].I_critical_value = 0;
     468:	10 92 32 04 	sts	0x0432, r1
  svit[svit_index].T_mux_num = T_mux_num;
     46c:	40 93 33 04 	sts	0x0433, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     470:	10 92 34 04 	sts	0x0434, r1
  svit[svit_index].T_sample_index = 0;
     474:	10 92 38 04 	sts	0x0438, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     478:	7a e0       	ldi	r23, 0x0A	; 10
     47a:	d7 2e       	mov	r13, r23
     47c:	d0 92 39 04 	sts	0x0439, r13
  svit[svit_index].switch_num = switch_num;
     480:	d0 92 3a 04 	sts	0x043A, r13
  svit[svit_index].switch_state = switch_state;
     484:	90 93 3b 04 	sts	0x043B, r25
  svit[svit_index].force_on = 0;
     488:	10 92 3c 04 	sts	0x043C, r1

  svit[svit_index].V_mux_num = V_mux_num;
     48c:	90 93 3d 04 	sts	0x043D, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     490:	39 e1       	ldi	r19, 0x19	; 25
     492:	53 2e       	mov	r5, r19
     494:	50 92 3e 04 	sts	0x043E, r5
  svit[svit_index].V_upper_limit = V_upper_limit;
     498:	20 93 3f 04 	sts	0x043F, r18
  svit[svit_index].V_sample_index = 0;
     49c:	10 92 43 04 	sts	0x0443, r1
  svit[svit_index].V_critical_value = 0;
     4a0:	10 92 44 04 	sts	0x0444, r1

  svit[svit_index].I_mux_num = I_mux_num;
     4a4:	90 93 45 04 	sts	0x0445, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     4a8:	e0 92 46 04 	sts	0x0446, r14
  svit[svit_index].I_upper_limit = I_upper_limit;
     4ac:	20 93 47 04 	sts	0x0447, r18
  svit[svit_index].I_sample_index = 0;
     4b0:	10 92 4b 04 	sts	0x044B, r1
  svit[svit_index].I_critical_value = 0;
     4b4:	10 92 4c 04 	sts	0x044C, r1
  svit[svit_index].T_mux_num = T_mux_num;
     4b8:	40 93 4d 04 	sts	0x044D, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     4bc:	10 92 4e 04 	sts	0x044E, r1
  svit[svit_index].T_sample_index = 0;
     4c0:	10 92 52 04 	sts	0x0452, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     4c4:	80 92 53 04 	sts	0x0453, r8
  svit[svit_index].switch_num = switch_num;
     4c8:	80 92 54 04 	sts	0x0454, r8
  svit[svit_index].switch_state = switch_state;
     4cc:	10 92 55 04 	sts	0x0455, r1
  svit[svit_index].force_on = 0;
     4d0:	10 92 56 04 	sts	0x0456, r1

  svit[svit_index].V_mux_num = V_mux_num;
     4d4:	90 93 57 04 	sts	0x0457, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     4d8:	88 e1       	ldi	r24, 0x18	; 24
     4da:	a8 2e       	mov	r10, r24
     4dc:	a0 92 58 04 	sts	0x0458, r10
  svit[svit_index].V_upper_limit = V_upper_limit;
     4e0:	20 93 59 04 	sts	0x0459, r18
  svit[svit_index].V_sample_index = 0;
     4e4:	10 92 5d 04 	sts	0x045D, r1
  svit[svit_index].V_critical_value = 0;
     4e8:	10 92 5e 04 	sts	0x045E, r1

  svit[svit_index].I_mux_num = I_mux_num;
     4ec:	90 93 5f 04 	sts	0x045F, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     4f0:	d0 92 60 04 	sts	0x0460, r13
  svit[svit_index].I_upper_limit = I_upper_limit;
     4f4:	20 93 61 04 	sts	0x0461, r18
  svit[svit_index].I_sample_index = 0;
     4f8:	10 92 65 04 	sts	0x0465, r1
  svit[svit_index].I_critical_value = 0;
     4fc:	10 92 66 04 	sts	0x0466, r1
  svit[svit_index].T_mux_num = T_mux_num;
     500:	40 93 67 04 	sts	0x0467, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     504:	10 92 68 04 	sts	0x0468, r1
  svit[svit_index].T_sample_index = 0;
     508:	10 92 6c 04 	sts	0x046C, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     50c:	8c e0       	ldi	r24, 0x0C	; 12
     50e:	80 93 6d 04 	sts	0x046D, r24
  svit[svit_index].switch_num = switch_num;
     512:	80 93 6e 04 	sts	0x046E, r24
  svit[svit_index].switch_state = switch_state;
     516:	10 92 6f 04 	sts	0x046F, r1
  svit[svit_index].force_on = 0;
     51a:	10 92 70 04 	sts	0x0470, r1

  svit[svit_index].V_mux_num = V_mux_num;
     51e:	90 93 71 04 	sts	0x0471, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     522:	71 e1       	ldi	r23, 0x11	; 17
     524:	70 93 72 04 	sts	0x0472, r23
  svit[svit_index].V_upper_limit = V_upper_limit;
     528:	20 93 73 04 	sts	0x0473, r18
  svit[svit_index].V_sample_index = 0;
     52c:	10 92 77 04 	sts	0x0477, r1
  svit[svit_index].V_critical_value = 0;
     530:	10 92 78 04 	sts	0x0478, r1

  svit[svit_index].I_mux_num = I_mux_num;
     534:	90 93 79 04 	sts	0x0479, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     538:	30 e1       	ldi	r19, 0x10	; 16
     53a:	30 93 7a 04 	sts	0x047A, r19
  svit[svit_index].I_upper_limit = I_upper_limit;
     53e:	20 93 7b 04 	sts	0x047B, r18
  svit[svit_index].I_sample_index = 0;
     542:	10 92 7f 04 	sts	0x047F, r1
  svit[svit_index].I_critical_value = 0;
     546:	10 92 80 04 	sts	0x0480, r1
  svit[svit_index].T_mux_num = T_mux_num;
     54a:	40 93 81 04 	sts	0x0481, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     54e:	10 92 82 04 	sts	0x0482, r1
  svit[svit_index].T_sample_index = 0;
     552:	10 92 86 04 	sts	0x0486, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     556:	f0 93 87 04 	sts	0x0487, r31
  svit[svit_index].switch_num = switch_num;
     55a:	f0 93 88 04 	sts	0x0488, r31
  svit[svit_index].switch_state = switch_state;
     55e:	90 93 89 04 	sts	0x0489, r25
  svit[svit_index].force_on = 0;
     562:	10 92 8a 04 	sts	0x048A, r1

  svit[svit_index].V_mux_num = V_mux_num;
     566:	90 93 8b 04 	sts	0x048B, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     56a:	e6 e1       	ldi	r30, 0x16	; 22
     56c:	fe 2e       	mov	r15, r30
     56e:	f0 92 8c 04 	sts	0x048C, r15
  svit[svit_index].V_upper_limit = V_upper_limit;
     572:	20 93 8d 04 	sts	0x048D, r18
  svit[svit_index].V_sample_index = 0;
     576:	10 92 91 04 	sts	0x0491, r1
  svit[svit_index].V_critical_value = 0;
     57a:	10 92 92 04 	sts	0x0492, r1

  svit[svit_index].I_mux_num = I_mux_num;
     57e:	90 93 93 04 	sts	0x0493, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     582:	80 93 94 04 	sts	0x0494, r24
  svit[svit_index].I_upper_limit = I_upper_limit;
     586:	20 93 95 04 	sts	0x0495, r18
  svit[svit_index].I_sample_index = 0;
     58a:	10 92 99 04 	sts	0x0499, r1
  svit[svit_index].I_critical_value = 0;
     58e:	10 92 9a 04 	sts	0x049A, r1
  svit[svit_index].T_mux_num = T_mux_num;
     592:	60 93 9b 04 	sts	0x049B, r22
  svit[svit_index].T_mux_sel = T_mux_sel;
     596:	a0 93 9c 04 	sts	0x049C, r26
  svit[svit_index].T_sample_index = 0;
     59a:	10 92 a0 04 	sts	0x04A0, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     59e:	50 93 a1 04 	sts	0x04A1, r21
  svit[svit_index].switch_num = switch_num;
     5a2:	50 93 a2 04 	sts	0x04A2, r21
  svit[svit_index].switch_state = switch_state;
     5a6:	90 93 a3 04 	sts	0x04A3, r25
  svit[svit_index].force_on = 0;
     5aa:	10 92 a4 04 	sts	0x04A4, r1

  svit[svit_index].V_mux_num = V_mux_num;
     5ae:	10 92 a5 04 	sts	0x04A5, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     5b2:	b0 92 a6 04 	sts	0x04A6, r11
  svit[svit_index].V_upper_limit = V_upper_limit;
     5b6:	20 93 a7 04 	sts	0x04A7, r18
  svit[svit_index].V_sample_index = 0;
     5ba:	10 92 ab 04 	sts	0x04AB, r1
  svit[svit_index].V_critical_value = 0;
     5be:	10 92 ac 04 	sts	0x04AC, r1

  svit[svit_index].I_mux_num = I_mux_num;
     5c2:	10 92 ad 04 	sts	0x04AD, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     5c6:	10 93 ae 04 	sts	0x04AE, r17
  svit[svit_index].I_upper_limit = I_upper_limit;
     5ca:	20 93 af 04 	sts	0x04AF, r18
  svit[svit_index].I_sample_index = 0;
     5ce:	10 92 b3 04 	sts	0x04B3, r1
  svit[svit_index].I_critical_value = 0;
     5d2:	10 92 b4 04 	sts	0x04B4, r1
  svit[svit_index].T_mux_num = T_mux_num;
     5d6:	40 93 b5 04 	sts	0x04B5, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     5da:	10 92 b6 04 	sts	0x04B6, r1
  svit[svit_index].T_sample_index = 0;
     5de:	10 92 ba 04 	sts	0x04BA, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     5e2:	b0 93 bb 04 	sts	0x04BB, r27
  svit[svit_index].switch_num = switch_num;
     5e6:	30 93 bc 04 	sts	0x04BC, r19
  svit[svit_index].switch_state = switch_state;
     5ea:	90 93 bd 04 	sts	0x04BD, r25
  svit[svit_index].force_on = 0;
     5ee:	10 92 be 04 	sts	0x04BE, r1

  svit[svit_index].V_mux_num = V_mux_num;
     5f2:	60 93 bf 04 	sts	0x04BF, r22
  svit[svit_index].V_mux_sel = V_mux_sel;
     5f6:	90 92 c0 04 	sts	0x04C0, r9
  svit[svit_index].V_upper_limit = V_upper_limit;
     5fa:	20 93 c1 04 	sts	0x04C1, r18
  svit[svit_index].V_sample_index = 0;
     5fe:	10 92 c5 04 	sts	0x04C5, r1
  svit[svit_index].V_critical_value = 0;
     602:	10 92 c6 04 	sts	0x04C6, r1

  svit[svit_index].I_mux_num = I_mux_num;
     606:	40 93 c7 04 	sts	0x04C7, r20
  svit[svit_index].I_mux_sel = I_mux_sel;
     60a:	10 92 c8 04 	sts	0x04C8, r1
  svit[svit_index].I_upper_limit = I_upper_limit;
     60e:	20 93 c9 04 	sts	0x04C9, r18
  svit[svit_index].I_sample_index = 0;
     612:	10 92 cd 04 	sts	0x04CD, r1
  svit[svit_index].I_critical_value = 0;
     616:	10 92 ce 04 	sts	0x04CE, r1
  svit[svit_index].T_mux_num = T_mux_num;
     61a:	40 93 cf 04 	sts	0x04CF, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     61e:	10 92 d0 04 	sts	0x04D0, r1
  svit[svit_index].T_sample_index = 0;
     622:	10 92 d4 04 	sts	0x04D4, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     626:	30 93 d5 04 	sts	0x04D5, r19
  svit[svit_index].switch_num = switch_num;
     62a:	b0 93 d6 04 	sts	0x04D6, r27
  svit[svit_index].switch_state = switch_state;
     62e:	90 93 d7 04 	sts	0x04D7, r25
  svit[svit_index].force_on = 0;
     632:	10 92 d8 04 	sts	0x04D8, r1

  svit[svit_index].V_mux_num = V_mux_num;
     636:	90 93 d9 04 	sts	0x04D9, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     63a:	e2 e1       	ldi	r30, 0x12	; 18
     63c:	e0 93 da 04 	sts	0x04DA, r30
  svit[svit_index].V_upper_limit = V_upper_limit;
     640:	20 93 db 04 	sts	0x04DB, r18
  svit[svit_index].V_sample_index = 0;
     644:	10 92 df 04 	sts	0x04DF, r1
  svit[svit_index].V_critical_value = 0;
     648:	10 92 e0 04 	sts	0x04E0, r1

  svit[svit_index].I_mux_num = I_mux_num;
     64c:	90 93 e1 04 	sts	0x04E1, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     650:	f0 93 e2 04 	sts	0x04E2, r31
  svit[svit_index].I_upper_limit = I_upper_limit;
     654:	20 93 e3 04 	sts	0x04E3, r18
  svit[svit_index].I_sample_index = 0;
     658:	10 92 e7 04 	sts	0x04E7, r1
  svit[svit_index].I_critical_value = 0;
     65c:	10 92 e8 04 	sts	0x04E8, r1
  svit[svit_index].T_mux_num = T_mux_num;
     660:	40 93 e9 04 	sts	0x04E9, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     664:	10 92 ea 04 	sts	0x04EA, r1
  svit[svit_index].T_sample_index = 0;
     668:	10 92 ee 04 	sts	0x04EE, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     66c:	70 93 ef 04 	sts	0x04EF, r23
  svit[svit_index].switch_num = switch_num;
     670:	5f ef       	ldi	r21, 0xFF	; 255
     672:	50 93 f0 04 	sts	0x04F0, r21
  svit[svit_index].switch_state = switch_state;
     676:	10 92 f1 04 	sts	0x04F1, r1
  svit[svit_index].force_on = 0;
     67a:	10 92 f2 04 	sts	0x04F2, r1

  svit[svit_index].V_mux_num = V_mux_num;
     67e:	90 93 f3 04 	sts	0x04F3, r25
  svit[svit_index].V_mux_sel = V_mux_sel;
     682:	8c e1       	ldi	r24, 0x1C	; 28
     684:	80 93 f4 04 	sts	0x04F4, r24
  svit[svit_index].V_upper_limit = V_upper_limit;
     688:	20 93 f5 04 	sts	0x04F5, r18
  svit[svit_index].V_sample_index = 0;
     68c:	10 92 f9 04 	sts	0x04F9, r1
  svit[svit_index].V_critical_value = 0;
     690:	10 92 fa 04 	sts	0x04FA, r1

  svit[svit_index].I_mux_num = I_mux_num;
     694:	90 93 fb 04 	sts	0x04FB, r25
  svit[svit_index].I_mux_sel = I_mux_sel;
     698:	00 93 fc 04 	sts	0x04FC, r16
  svit[svit_index].I_upper_limit = I_upper_limit;
     69c:	20 93 fd 04 	sts	0x04FD, r18
  svit[svit_index].I_sample_index = 0;
     6a0:	10 92 01 05 	sts	0x0501, r1
  svit[svit_index].I_critical_value = 0;
     6a4:	10 92 02 05 	sts	0x0502, r1
  svit[svit_index].T_mux_num = T_mux_num;
     6a8:	40 93 03 05 	sts	0x0503, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     6ac:	10 92 04 05 	sts	0x0504, r1
  svit[svit_index].T_sample_index = 0;
     6b0:	10 92 08 05 	sts	0x0508, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     6b4:	e0 93 09 05 	sts	0x0509, r30
  svit[svit_index].switch_num = switch_num;
     6b8:	50 93 0a 05 	sts	0x050A, r21
  svit[svit_index].switch_state = switch_state;
     6bc:	10 92 0b 05 	sts	0x050B, r1
  svit[svit_index].force_on = 0;
     6c0:	10 92 0c 05 	sts	0x050C, r1

  svit[svit_index].V_mux_num = V_mux_num;
     6c4:	60 93 0d 05 	sts	0x050D, r22
  svit[svit_index].V_mux_sel = V_mux_sel;
     6c8:	b0 93 0e 05 	sts	0x050E, r27
  svit[svit_index].V_upper_limit = V_upper_limit;
     6cc:	20 93 0f 05 	sts	0x050F, r18
  svit[svit_index].V_sample_index = 0;
     6d0:	10 92 13 05 	sts	0x0513, r1
  svit[svit_index].V_critical_value = 0;
     6d4:	10 92 14 05 	sts	0x0514, r1

  svit[svit_index].I_mux_num = I_mux_num;
     6d8:	60 93 15 05 	sts	0x0515, r22
  svit[svit_index].I_mux_sel = I_mux_sel;
     6dc:	30 93 16 05 	sts	0x0516, r19
  svit[svit_index].I_upper_limit = I_upper_limit;
     6e0:	20 93 17 05 	sts	0x0517, r18
  svit[svit_index].I_sample_index = 0;
     6e4:	10 92 1b 05 	sts	0x051B, r1
  svit[svit_index].I_critical_value = 0;
     6e8:	10 92 1c 05 	sts	0x051C, r1
  svit[svit_index].T_mux_num = T_mux_num;
     6ec:	40 93 1d 05 	sts	0x051D, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     6f0:	10 92 1e 05 	sts	0x051E, r1
  svit[svit_index].T_sample_index = 0;
     6f4:	10 92 22 05 	sts	0x0522, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     6f8:	70 92 23 05 	sts	0x0523, r7
  svit[svit_index].switch_num = switch_num;
     6fc:	50 93 24 05 	sts	0x0524, r21
  svit[svit_index].switch_state = switch_state;
     700:	10 92 25 05 	sts	0x0525, r1
  svit[svit_index].force_on = 0;
     704:	10 92 26 05 	sts	0x0526, r1

  svit[svit_index].V_mux_num = V_mux_num;
     708:	60 93 27 05 	sts	0x0527, r22
  svit[svit_index].V_mux_sel = V_mux_sel;
     70c:	70 93 28 05 	sts	0x0528, r23
  svit[svit_index].V_upper_limit = V_upper_limit;
     710:	20 93 29 05 	sts	0x0529, r18
  svit[svit_index].V_sample_index = 0;
     714:	10 92 2d 05 	sts	0x052D, r1
  svit[svit_index].V_critical_value = 0;
     718:	10 92 2e 05 	sts	0x052E, r1

  svit[svit_index].I_mux_num = I_mux_num;
     71c:	60 93 2f 05 	sts	0x052F, r22
  svit[svit_index].I_mux_sel = I_mux_sel;
     720:	e0 93 30 05 	sts	0x0530, r30
  svit[svit_index].I_upper_limit = I_upper_limit;
     724:	20 93 31 05 	sts	0x0531, r18
  svit[svit_index].I_sample_index = 0;
     728:	10 92 35 05 	sts	0x0535, r1
  svit[svit_index].I_critical_value = 0;
     72c:	10 92 36 05 	sts	0x0536, r1
  svit[svit_index].T_mux_num = T_mux_num;
     730:	40 93 37 05 	sts	0x0537, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     734:	10 92 38 05 	sts	0x0538, r1
  svit[svit_index].T_sample_index = 0;
     738:	10 92 3c 05 	sts	0x053C, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     73c:	74 e1       	ldi	r23, 0x14	; 20
     73e:	70 93 3d 05 	sts	0x053D, r23
  svit[svit_index].switch_num = switch_num;
     742:	50 93 3e 05 	sts	0x053E, r21
  svit[svit_index].switch_state = switch_state;
     746:	90 93 3f 05 	sts	0x053F, r25
  svit[svit_index].force_on = 0;
     74a:	10 92 40 05 	sts	0x0540, r1

  svit[svit_index].V_mux_num = V_mux_num;
     74e:	10 92 41 05 	sts	0x0541, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     752:	90 93 42 05 	sts	0x0542, r25
  svit[svit_index].V_upper_limit = V_upper_limit;
     756:	20 93 43 05 	sts	0x0543, r18
  svit[svit_index].V_sample_index = 0;
     75a:	10 92 47 05 	sts	0x0547, r1
  svit[svit_index].V_critical_value = 0;
     75e:	10 92 48 05 	sts	0x0548, r1

  svit[svit_index].I_mux_num = I_mux_num;
     762:	10 92 49 05 	sts	0x0549, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     766:	60 93 4a 05 	sts	0x054A, r22
  svit[svit_index].I_upper_limit = I_upper_limit;
     76a:	20 93 4b 05 	sts	0x054B, r18
  svit[svit_index].I_sample_index = 0;
     76e:	10 92 4f 05 	sts	0x054F, r1
  svit[svit_index].I_critical_value = 0;
     772:	10 92 50 05 	sts	0x0550, r1
  svit[svit_index].T_mux_num = T_mux_num;
     776:	60 93 51 05 	sts	0x0551, r22
  svit[svit_index].T_mux_sel = T_mux_sel;
     77a:	e0 92 52 05 	sts	0x0552, r14
  svit[svit_index].T_sample_index = 0;
     77e:	10 92 56 05 	sts	0x0556, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     782:	90 92 57 05 	sts	0x0557, r9
  svit[svit_index].switch_num = switch_num;
     786:	50 93 58 05 	sts	0x0558, r21
  svit[svit_index].switch_state = switch_state;
     78a:	90 93 59 05 	sts	0x0559, r25
  svit[svit_index].force_on = 0;
     78e:	10 92 5a 05 	sts	0x055A, r1

  svit[svit_index].V_mux_num = V_mux_num;
     792:	60 93 5b 05 	sts	0x055B, r22
  svit[svit_index].V_mux_sel = V_mux_sel;
     796:	70 93 5c 05 	sts	0x055C, r23
  svit[svit_index].V_upper_limit = V_upper_limit;
     79a:	20 93 5d 05 	sts	0x055D, r18
  svit[svit_index].V_sample_index = 0;
     79e:	10 92 61 05 	sts	0x0561, r1
  svit[svit_index].V_critical_value = 0;
     7a2:	10 92 62 05 	sts	0x0562, r1

  svit[svit_index].I_mux_num = I_mux_num;
     7a6:	60 93 63 05 	sts	0x0563, r22
  svit[svit_index].I_mux_sel = I_mux_sel;
     7aa:	8e e1       	ldi	r24, 0x1E	; 30
     7ac:	80 93 64 05 	sts	0x0564, r24
  svit[svit_index].I_upper_limit = I_upper_limit;
     7b0:	20 93 65 05 	sts	0x0565, r18
  svit[svit_index].I_sample_index = 0;
     7b4:	10 92 69 05 	sts	0x0569, r1
  svit[svit_index].I_critical_value = 0;
     7b8:	10 92 6a 05 	sts	0x056A, r1
  svit[svit_index].T_mux_num = T_mux_num;
     7bc:	60 93 6b 05 	sts	0x056B, r22
  svit[svit_index].T_mux_sel = T_mux_sel;
     7c0:	80 92 6c 05 	sts	0x056C, r8
  svit[svit_index].T_sample_index = 0;
     7c4:	10 92 70 05 	sts	0x0570, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     7c8:	f0 92 71 05 	sts	0x0571, r15
  svit[svit_index].switch_num = switch_num;
     7cc:	50 93 72 05 	sts	0x0572, r21
  svit[svit_index].switch_state = switch_state;
     7d0:	90 93 73 05 	sts	0x0573, r25
  svit[svit_index].force_on = 0;
     7d4:	10 92 74 05 	sts	0x0574, r1

  svit[svit_index].V_mux_num = V_mux_num;
     7d8:	10 92 75 05 	sts	0x0575, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     7dc:	c0 92 76 05 	sts	0x0576, r12
  svit[svit_index].V_upper_limit = V_upper_limit;
     7e0:	20 93 77 05 	sts	0x0577, r18
  svit[svit_index].V_sample_index = 0;
     7e4:	10 92 7b 05 	sts	0x057B, r1
  svit[svit_index].V_critical_value = 0;
     7e8:	10 92 7c 05 	sts	0x057C, r1

  svit[svit_index].I_mux_num = I_mux_num;
     7ec:	10 92 7d 05 	sts	0x057D, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     7f0:	40 93 7e 05 	sts	0x057E, r20
  svit[svit_index].I_upper_limit = I_upper_limit;
     7f4:	20 93 7f 05 	sts	0x057F, r18
  svit[svit_index].I_sample_index = 0;
     7f8:	10 92 83 05 	sts	0x0583, r1
  svit[svit_index].I_critical_value = 0;
     7fc:	10 92 84 05 	sts	0x0584, r1
  svit[svit_index].T_mux_num = T_mux_num;
     800:	40 93 85 05 	sts	0x0585, r20
  svit[svit_index].T_mux_sel = T_mux_sel;
     804:	10 92 86 05 	sts	0x0586, r1
  svit[svit_index].T_sample_index = 0;
     808:	10 92 8a 05 	sts	0x058A, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     80c:	60 92 8b 05 	sts	0x058B, r6
  svit[svit_index].switch_num = switch_num;
     810:	0f ef       	ldi	r16, 0xFF	; 255
     812:	50 93 8c 05 	sts	0x058C, r21
  svit[svit_index].switch_state = switch_state;
     816:	11 e0       	ldi	r17, 0x01	; 1
     818:	90 93 8d 05 	sts	0x058D, r25
  svit[svit_index].force_on = 0;
     81c:	10 92 8e 05 	sts	0x058E, r1

  svit[svit_index].V_mux_num = V_mux_num;
     820:	10 92 8f 05 	sts	0x058F, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     824:	e0 93 90 05 	sts	0x0590, r30
  svit[svit_index].V_upper_limit = V_upper_limit;
     828:	31 ee       	ldi	r19, 0xE1	; 225
     82a:	20 93 91 05 	sts	0x0591, r18
  svit[svit_index].V_sample_index = 0;
     82e:	10 92 95 05 	sts	0x0595, r1
  svit[svit_index].V_critical_value = 0;
     832:	10 92 96 05 	sts	0x0596, r1

  svit[svit_index].I_mux_num = I_mux_num;
     836:	10 92 97 05 	sts	0x0597, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     83a:	70 93 98 05 	sts	0x0598, r23
  svit[svit_index].I_upper_limit = I_upper_limit;
     83e:	20 93 99 05 	sts	0x0599, r18
  svit[svit_index].I_sample_index = 0;
     842:	10 92 9d 05 	sts	0x059D, r1
  svit[svit_index].I_critical_value = 0;
     846:	10 92 9e 05 	sts	0x059E, r1
  svit[svit_index].T_mux_num = T_mux_num;
     84a:	72 e0       	ldi	r23, 0x02	; 2
     84c:	c7 2e       	mov	r12, r23
     84e:	60 93 9f 05 	sts	0x059F, r22
  svit[svit_index].T_mux_sel = T_mux_sel;
     852:	10 92 a0 05 	sts	0x05A0, r1
  svit[svit_index].T_sample_index = 0;
     856:	10 92 a4 05 	sts	0x05A4, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     85a:	a0 92 a5 05 	sts	0x05A5, r10
  svit[svit_index].switch_num = switch_num;
     85e:	50 93 a6 05 	sts	0x05A6, r21
  svit[svit_index].switch_state = switch_state;
     862:	90 93 a7 05 	sts	0x05A7, r25
  svit[svit_index].force_on = 0;
     866:	10 92 a8 05 	sts	0x05A8, r1

  svit[svit_index].V_mux_num = V_mux_num;
     86a:	10 92 a9 05 	sts	0x05A9, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     86e:	70 92 aa 05 	sts	0x05AA, r7
  svit[svit_index].V_upper_limit = V_upper_limit;
     872:	20 93 ab 05 	sts	0x05AB, r18
  svit[svit_index].V_sample_index = 0;
     876:	10 92 af 05 	sts	0x05AF, r1
  svit[svit_index].V_critical_value = 0;
     87a:	10 92 b0 05 	sts	0x05B0, r1

  svit[svit_index].I_mux_num = I_mux_num;
     87e:	10 92 b1 05 	sts	0x05B1, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     882:	90 92 b2 05 	sts	0x05B2, r9
  svit[svit_index].I_upper_limit = I_upper_limit;
     886:	20 93 b3 05 	sts	0x05B3, r18
  svit[svit_index].I_sample_index = 0;
     88a:	10 92 b7 05 	sts	0x05B7, r1
  svit[svit_index].I_critical_value = 0;
     88e:	10 92 b8 05 	sts	0x05B8, r1
  svit[svit_index].T_mux_num = T_mux_num;
     892:	60 93 b9 05 	sts	0x05B9, r22
  svit[svit_index].T_mux_sel = T_mux_sel;
     896:	90 93 ba 05 	sts	0x05BA, r25
  svit[svit_index].T_sample_index = 0;
     89a:	10 92 be 05 	sts	0x05BE, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     89e:	50 92 bf 05 	sts	0x05BF, r5
  svit[svit_index].switch_num = switch_num;
     8a2:	50 93 c0 05 	sts	0x05C0, r21
  svit[svit_index].switch_state = switch_state;
     8a6:	90 93 c1 05 	sts	0x05C1, r25
  svit[svit_index].force_on = 0;
     8aa:	10 92 c2 05 	sts	0x05C2, r1

  svit[svit_index].V_mux_num = V_mux_num;
     8ae:	10 92 c3 05 	sts	0x05C3, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     8b2:	d0 92 c4 05 	sts	0x05C4, r13
  svit[svit_index].V_upper_limit = V_upper_limit;
     8b6:	20 93 c5 05 	sts	0x05C5, r18
  svit[svit_index].V_sample_index = 0;
     8ba:	10 92 c9 05 	sts	0x05C9, r1
  svit[svit_index].V_critical_value = 0;
     8be:	10 92 ca 05 	sts	0x05CA, r1

  svit[svit_index].I_mux_num = I_mux_num;
     8c2:	10 92 cb 05 	sts	0x05CB, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     8c6:	f0 92 cc 05 	sts	0x05CC, r15
  svit[svit_index].I_upper_limit = I_upper_limit;
     8ca:	20 93 cd 05 	sts	0x05CD, r18
  svit[svit_index].I_sample_index = 0;
     8ce:	10 92 d1 05 	sts	0x05D1, r1
  svit[svit_index].I_critical_value = 0;
     8d2:	10 92 d2 05 	sts	0x05D2, r1
  svit[svit_index].T_mux_num = T_mux_num;
     8d6:	60 93 d3 05 	sts	0x05D3, r22
  svit[svit_index].T_mux_sel = T_mux_sel;
     8da:	60 93 d4 05 	sts	0x05D4, r22
  svit[svit_index].T_sample_index = 0;
     8de:	10 92 d8 05 	sts	0x05D8, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     8e2:	30 92 d9 05 	sts	0x05D9, r3
  svit[svit_index].switch_num = switch_num;
     8e6:	50 93 da 05 	sts	0x05DA, r21
  svit[svit_index].switch_state = switch_state;
     8ea:	90 93 db 05 	sts	0x05DB, r25
  svit[svit_index].force_on = 0;
     8ee:	10 92 dc 05 	sts	0x05DC, r1

  svit[svit_index].V_mux_num = V_mux_num;
     8f2:	10 92 dd 05 	sts	0x05DD, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     8f6:	b0 93 de 05 	sts	0x05DE, r27
  svit[svit_index].V_upper_limit = V_upper_limit;
     8fa:	20 93 df 05 	sts	0x05DF, r18
  svit[svit_index].V_sample_index = 0;
     8fe:	10 92 e3 05 	sts	0x05E3, r1
  svit[svit_index].V_critical_value = 0;
     902:	10 92 e4 05 	sts	0x05E4, r1

  svit[svit_index].I_mux_num = I_mux_num;
     906:	10 92 e5 05 	sts	0x05E5, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     90a:	60 92 e6 05 	sts	0x05E6, r6
  svit[svit_index].I_upper_limit = I_upper_limit;
     90e:	20 93 e7 05 	sts	0x05E7, r18
  svit[svit_index].I_sample_index = 0;
     912:	10 92 eb 05 	sts	0x05EB, r1
  svit[svit_index].I_critical_value = 0;
     916:	10 92 ec 05 	sts	0x05EC, r1
  svit[svit_index].T_mux_num = T_mux_num;
     91a:	60 93 ed 05 	sts	0x05ED, r22
  svit[svit_index].T_mux_sel = T_mux_sel;
     91e:	73 e0       	ldi	r23, 0x03	; 3
     920:	40 93 ee 05 	sts	0x05EE, r20
  svit[svit_index].T_sample_index = 0;
     924:	10 92 f2 05 	sts	0x05F2, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     928:	40 92 f3 05 	sts	0x05F3, r4
  svit[svit_index].switch_num = switch_num;
     92c:	50 93 f4 05 	sts	0x05F4, r21
  svit[svit_index].switch_state = switch_state;
     930:	90 93 f5 05 	sts	0x05F5, r25
  svit[svit_index].force_on = 0;
     934:	10 92 f6 05 	sts	0x05F6, r1

  svit[svit_index].V_mux_num = V_mux_num;
     938:	10 92 f7 05 	sts	0x05F7, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     93c:	e0 92 f8 05 	sts	0x05F8, r14
  svit[svit_index].V_upper_limit = V_upper_limit;
     940:	20 93 f9 05 	sts	0x05F9, r18
  svit[svit_index].V_sample_index = 0;
     944:	10 92 fd 05 	sts	0x05FD, r1
  svit[svit_index].V_critical_value = 0;
     948:	10 92 fe 05 	sts	0x05FE, r1

  svit[svit_index].I_mux_num = I_mux_num;
     94c:	10 92 ff 05 	sts	0x05FF, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     950:	a0 92 00 06 	sts	0x0600, r10
  svit[svit_index].I_upper_limit = I_upper_limit;
     954:	20 93 01 06 	sts	0x0601, r18
  svit[svit_index].I_sample_index = 0;
     958:	10 92 05 06 	sts	0x0605, r1
  svit[svit_index].I_critical_value = 0;
     95c:	a6 e0       	ldi	r26, 0x06	; 6
     95e:	b6 e0       	ldi	r27, 0x06	; 6
     960:	10 92 06 06 	sts	0x0606, r1
  svit[svit_index].T_mux_num = T_mux_num;
     964:	60 93 07 06 	sts	0x0607, r22
  svit[svit_index].T_mux_sel = T_mux_sel;
     968:	b0 92 08 06 	sts	0x0608, r11
  svit[svit_index].T_sample_index = 0;
     96c:	10 92 0c 06 	sts	0x060C, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     970:	9c e1       	ldi	r25, 0x1C	; 28
     972:	90 93 0d 06 	sts	0x060D, r25
  svit[svit_index].switch_num = switch_num;
     976:	fd 01       	movw	r30, r26
     978:	38 96       	adiw	r30, 0x08	; 8
     97a:	00 93 0e 06 	sts	0x060E, r16
  svit[svit_index].switch_state = switch_state;
     97e:	10 93 0f 06 	sts	0x060F, r17
  svit[svit_index].force_on = 0;
     982:	10 92 10 06 	sts	0x0610, r1

  svit[svit_index].V_mux_num = V_mux_num;
     986:	10 92 11 06 	sts	0x0611, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     98a:	8e e0       	ldi	r24, 0x0E	; 14
     98c:	80 93 12 06 	sts	0x0612, r24
  svit[svit_index].V_upper_limit = V_upper_limit;
     990:	30 93 13 06 	sts	0x0613, r19
  svit[svit_index].V_sample_index = 0;
     994:	10 92 17 06 	sts	0x0617, r1
  svit[svit_index].V_critical_value = 0;
     998:	10 92 18 06 	sts	0x0618, r1

  svit[svit_index].I_mux_num = I_mux_num;
     99c:	10 92 19 06 	sts	0x0619, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     9a0:	89 e1       	ldi	r24, 0x19	; 25
     9a2:	80 93 1a 06 	sts	0x061A, r24
  svit[svit_index].I_upper_limit = I_upper_limit;
     9a6:	30 93 1b 06 	sts	0x061B, r19
  svit[svit_index].I_sample_index = 0;
     9aa:	10 92 1f 06 	sts	0x061F, r1
  svit[svit_index].I_critical_value = 0;
     9ae:	10 92 20 06 	sts	0x0620, r1
  svit[svit_index].T_mux_num = T_mux_num;
     9b2:	70 93 21 06 	sts	0x0621, r23
  svit[svit_index].T_mux_sel = T_mux_sel;
     9b6:	10 92 22 06 	sts	0x0622, r1
  svit[svit_index].T_sample_index = 0;
     9ba:	10 92 26 06 	sts	0x0626, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     9be:	5d e1       	ldi	r21, 0x1D	; 29
     9c0:	50 93 27 06 	sts	0x0627, r21
  svit[svit_index].switch_num = switch_num;
     9c4:	00 93 28 06 	sts	0x0628, r16
  svit[svit_index].switch_state = switch_state;
     9c8:	10 93 29 06 	sts	0x0629, r17
  svit[svit_index].force_on = 0;
     9cc:	10 92 2a 06 	sts	0x062A, r1

  svit[svit_index].V_mux_num = V_mux_num;
     9d0:	10 92 2b 06 	sts	0x062B, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     9d4:	80 e1       	ldi	r24, 0x10	; 16
     9d6:	80 93 2c 06 	sts	0x062C, r24
  svit[svit_index].V_upper_limit = V_upper_limit;
     9da:	30 93 2d 06 	sts	0x062D, r19
  svit[svit_index].V_sample_index = 0;
     9de:	10 92 31 06 	sts	0x0631, r1
  svit[svit_index].V_critical_value = 0;
     9e2:	10 92 32 06 	sts	0x0632, r1

  svit[svit_index].I_mux_num = I_mux_num;
     9e6:	10 92 33 06 	sts	0x0633, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     9ea:	8a e1       	ldi	r24, 0x1A	; 26
     9ec:	80 93 34 06 	sts	0x0634, r24
  svit[svit_index].I_upper_limit = I_upper_limit;
     9f0:	30 93 35 06 	sts	0x0635, r19
  svit[svit_index].I_sample_index = 0;
     9f4:	10 92 39 06 	sts	0x0639, r1
  svit[svit_index].I_critical_value = 0;
     9f8:	10 92 3a 06 	sts	0x063A, r1
  svit[svit_index].T_mux_num = T_mux_num;
     9fc:	70 93 3b 06 	sts	0x063B, r23
  svit[svit_index].T_mux_sel = T_mux_sel;
     a00:	10 92 3c 06 	sts	0x063C, r1
  svit[svit_index].T_sample_index = 0;
     a04:	10 92 40 06 	sts	0x0640, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     a08:	4e e1       	ldi	r20, 0x1E	; 30
     a0a:	40 93 41 06 	sts	0x0641, r20
  svit[svit_index].switch_num = switch_num;
     a0e:	00 93 42 06 	sts	0x0642, r16
  svit[svit_index].switch_state = switch_state;
     a12:	dd 96       	adiw	r26, 0x3d	; 61
     a14:	1c 93       	st	X, r17
     a16:	dd 97       	sbiw	r26, 0x3d	; 61
  svit[svit_index].force_on = 0;
     a18:	de 96       	adiw	r26, 0x3e	; 62
     a1a:	1c 92       	st	X, r1
     a1c:	de 97       	sbiw	r26, 0x3e	; 62

  svit[svit_index].V_mux_num = V_mux_num;
     a1e:	df 96       	adiw	r26, 0x3f	; 63
     a20:	1c 92       	st	X, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     a22:	88 e0       	ldi	r24, 0x08	; 8
     a24:	80 af       	std	Z+56, r24	; 0x38
  svit[svit_index].V_upper_limit = V_upper_limit;
     a26:	31 af       	std	Z+57, r19	; 0x39
  svit[svit_index].V_sample_index = 0;
     a28:	15 ae       	std	Z+61, r1	; 0x3d
  svit[svit_index].V_critical_value = 0;
     a2a:	16 ae       	std	Z+62, r1	; 0x3e

  svit[svit_index].I_mux_num = I_mux_num;
     a2c:	17 ae       	std	Z+63, r1	; 0x3f
  svit[svit_index].I_mux_sel = I_mux_sel;
     a2e:	8b e1       	ldi	r24, 0x1B	; 27
     a30:	80 93 4e 06 	sts	0x064E, r24
  svit[svit_index].I_upper_limit = I_upper_limit;
     a34:	30 93 4f 06 	sts	0x064F, r19
  svit[svit_index].I_sample_index = 0;
     a38:	10 92 53 06 	sts	0x0653, r1
  svit[svit_index].I_critical_value = 0;
     a3c:	10 92 54 06 	sts	0x0654, r1
  svit[svit_index].T_mux_num = T_mux_num;
     a40:	70 93 55 06 	sts	0x0655, r23
  svit[svit_index].T_mux_sel = T_mux_sel;
     a44:	10 92 56 06 	sts	0x0656, r1
  svit[svit_index].T_sample_index = 0;
     a48:	10 92 5a 06 	sts	0x065A, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     a4c:	2f e1       	ldi	r18, 0x1F	; 31
     a4e:	20 93 5b 06 	sts	0x065B, r18
  svit[svit_index].switch_num = switch_num;
     a52:	00 93 5c 06 	sts	0x065C, r16
  svit[svit_index].switch_state = switch_state;
     a56:	10 93 5d 06 	sts	0x065D, r17
  svit[svit_index].force_on = 0;
     a5a:	10 92 5e 06 	sts	0x065E, r1

  svit[svit_index].V_mux_num = V_mux_num;
     a5e:	10 92 5f 06 	sts	0x065F, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     a62:	8d e0       	ldi	r24, 0x0D	; 13
     a64:	80 93 60 06 	sts	0x0660, r24
  svit[svit_index].V_upper_limit = V_upper_limit;
     a68:	30 93 61 06 	sts	0x0661, r19
  svit[svit_index].V_sample_index = 0;
     a6c:	10 92 65 06 	sts	0x0665, r1
  svit[svit_index].V_critical_value = 0;
     a70:	10 92 66 06 	sts	0x0666, r1

  svit[svit_index].I_mux_num = I_mux_num;
     a74:	10 92 67 06 	sts	0x0667, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     a78:	90 93 68 06 	sts	0x0668, r25
  svit[svit_index].I_upper_limit = I_upper_limit;
     a7c:	30 93 69 06 	sts	0x0669, r19
  svit[svit_index].I_sample_index = 0;
     a80:	10 92 6d 06 	sts	0x066D, r1
  svit[svit_index].I_critical_value = 0;
     a84:	10 92 6e 06 	sts	0x066E, r1
  svit[svit_index].T_mux_num = T_mux_num;
     a88:	c0 92 6f 06 	sts	0x066F, r12
  svit[svit_index].T_mux_sel = T_mux_sel;
     a8c:	95 e0       	ldi	r25, 0x05	; 5
     a8e:	90 93 70 06 	sts	0x0670, r25
  svit[svit_index].T_sample_index = 0;
     a92:	10 92 74 06 	sts	0x0674, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     a96:	80 e2       	ldi	r24, 0x20	; 32
     a98:	80 93 75 06 	sts	0x0675, r24
  svit[svit_index].switch_num = switch_num;
     a9c:	00 93 76 06 	sts	0x0676, r16
  svit[svit_index].switch_state = switch_state;
     aa0:	10 93 77 06 	sts	0x0677, r17
  svit[svit_index].force_on = 0;
     aa4:	10 92 78 06 	sts	0x0678, r1

  svit[svit_index].V_mux_num = V_mux_num;
     aa8:	10 92 79 06 	sts	0x0679, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     aac:	8c e0       	ldi	r24, 0x0C	; 12
     aae:	80 93 7a 06 	sts	0x067A, r24
  svit[svit_index].V_upper_limit = V_upper_limit;
     ab2:	30 93 7b 06 	sts	0x067B, r19
  svit[svit_index].V_sample_index = 0;
     ab6:	10 92 7f 06 	sts	0x067F, r1
  svit[svit_index].V_critical_value = 0;
     aba:	10 92 80 06 	sts	0x0680, r1

  svit[svit_index].I_mux_num = I_mux_num;
     abe:	10 92 81 06 	sts	0x0681, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     ac2:	50 93 82 06 	sts	0x0682, r21
  svit[svit_index].I_upper_limit = I_upper_limit;
     ac6:	30 93 83 06 	sts	0x0683, r19
  svit[svit_index].I_sample_index = 0;
     aca:	10 92 87 06 	sts	0x0687, r1
  svit[svit_index].I_critical_value = 0;
     ace:	10 92 88 06 	sts	0x0688, r1
  svit[svit_index].T_mux_num = T_mux_num;
     ad2:	70 93 89 06 	sts	0x0689, r23
  svit[svit_index].T_mux_sel = T_mux_sel;
     ad6:	10 92 8a 06 	sts	0x068A, r1
  svit[svit_index].T_sample_index = 0;
     ada:	10 92 8e 06 	sts	0x068E, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     ade:	81 e2       	ldi	r24, 0x21	; 33
     ae0:	80 93 8f 06 	sts	0x068F, r24
  svit[svit_index].switch_num = switch_num;
     ae4:	00 93 90 06 	sts	0x0690, r16
  svit[svit_index].switch_state = switch_state;
     ae8:	10 93 91 06 	sts	0x0691, r17
  svit[svit_index].force_on = 0;
     aec:	10 92 92 06 	sts	0x0692, r1

  svit[svit_index].V_mux_num = V_mux_num;
     af0:	10 92 93 06 	sts	0x0693, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     af4:	8b e0       	ldi	r24, 0x0B	; 11
     af6:	80 93 94 06 	sts	0x0694, r24
  svit[svit_index].V_upper_limit = V_upper_limit;
     afa:	30 93 95 06 	sts	0x0695, r19
  svit[svit_index].V_sample_index = 0;
     afe:	10 92 99 06 	sts	0x0699, r1
  svit[svit_index].V_critical_value = 0;
     b02:	10 92 9a 06 	sts	0x069A, r1

  svit[svit_index].I_mux_num = I_mux_num;
     b06:	10 92 9b 06 	sts	0x069B, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     b0a:	40 93 9c 06 	sts	0x069C, r20
  svit[svit_index].I_upper_limit = I_upper_limit;
     b0e:	30 93 9d 06 	sts	0x069D, r19
  svit[svit_index].I_sample_index = 0;
     b12:	10 92 a1 06 	sts	0x06A1, r1
  svit[svit_index].I_critical_value = 0;
     b16:	10 92 a2 06 	sts	0x06A2, r1
  svit[svit_index].T_mux_num = T_mux_num;
     b1a:	70 93 a3 06 	sts	0x06A3, r23
  svit[svit_index].T_mux_sel = T_mux_sel;
     b1e:	10 92 a4 06 	sts	0x06A4, r1
  svit[svit_index].T_sample_index = 0;
     b22:	10 92 a8 06 	sts	0x06A8, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     b26:	82 e2       	ldi	r24, 0x22	; 34
     b28:	80 93 a9 06 	sts	0x06A9, r24
  svit[svit_index].switch_num = switch_num;
     b2c:	00 93 aa 06 	sts	0x06AA, r16
  svit[svit_index].switch_state = switch_state;
     b30:	10 93 ab 06 	sts	0x06AB, r17
  svit[svit_index].force_on = 0;
     b34:	10 92 ac 06 	sts	0x06AC, r1

  svit[svit_index].V_mux_num = V_mux_num;
     b38:	10 92 ad 06 	sts	0x06AD, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     b3c:	81 e1       	ldi	r24, 0x11	; 17
     b3e:	80 93 ae 06 	sts	0x06AE, r24
  svit[svit_index].V_upper_limit = V_upper_limit;
     b42:	30 93 af 06 	sts	0x06AF, r19
  svit[svit_index].V_sample_index = 0;
     b46:	10 92 b3 06 	sts	0x06B3, r1
  svit[svit_index].V_critical_value = 0;
     b4a:	10 92 b4 06 	sts	0x06B4, r1

  svit[svit_index].I_mux_num = I_mux_num;
     b4e:	10 92 b5 06 	sts	0x06B5, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     b52:	20 93 b6 06 	sts	0x06B6, r18
  svit[svit_index].I_upper_limit = I_upper_limit;
     b56:	30 93 b7 06 	sts	0x06B7, r19
  svit[svit_index].I_sample_index = 0;
     b5a:	10 92 bb 06 	sts	0x06BB, r1
  svit[svit_index].I_critical_value = 0;
     b5e:	10 92 bc 06 	sts	0x06BC, r1
  svit[svit_index].T_mux_num = T_mux_num;
     b62:	70 93 bd 06 	sts	0x06BD, r23
  svit[svit_index].T_mux_sel = T_mux_sel;
     b66:	10 92 be 06 	sts	0x06BE, r1
  svit[svit_index].T_sample_index = 0;
     b6a:	10 92 c2 06 	sts	0x06C2, r1
// UART file descriptor for debugging purposes
//FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);

void set_component( uint8_t svit_index, uint8_t name, uint8_t switch_num, uint8_t switch_state, uint8_t V_mux_num, uint8_t V_mux_sel, uint8_t V_upper_limit, uint8_t I_mux_num, uint8_t I_mux_sel, uint8_t I_upper_limit, uint8_t T_mux_num, uint8_t T_mux_sel )
{
  svit[svit_index].name = name;
     b6e:	83 e2       	ldi	r24, 0x23	; 35
     b70:	80 93 c3 06 	sts	0x06C3, r24
  svit[svit_index].switch_num = switch_num;
     b74:	00 93 c4 06 	sts	0x06C4, r16
  svit[svit_index].switch_state = switch_state;
     b78:	10 93 c5 06 	sts	0x06C5, r17
  svit[svit_index].force_on = 0;
     b7c:	10 92 c6 06 	sts	0x06C6, r1

  svit[svit_index].V_mux_num = V_mux_num;
     b80:	10 92 c7 06 	sts	0x06C7, r1
  svit[svit_index].V_mux_sel = V_mux_sel;
     b84:	90 93 c8 06 	sts	0x06C8, r25
  svit[svit_index].V_upper_limit = V_upper_limit;
     b88:	30 93 c9 06 	sts	0x06C9, r19
  svit[svit_index].V_sample_index = 0;
     b8c:	10 92 cd 06 	sts	0x06CD, r1
  svit[svit_index].V_critical_value = 0;
     b90:	10 92 ce 06 	sts	0x06CE, r1

  svit[svit_index].I_mux_num = I_mux_num;
     b94:	10 92 cf 06 	sts	0x06CF, r1
  svit[svit_index].I_mux_sel = I_mux_sel;
     b98:	10 92 d0 06 	sts	0x06D0, r1
  svit[svit_index].I_upper_limit = I_upper_limit;
     b9c:	30 93 d1 06 	sts	0x06D1, r19
  svit[svit_index].I_sample_index = 0;
     ba0:	10 92 d5 06 	sts	0x06D5, r1
  svit[svit_index].I_critical_value = 0;
     ba4:	10 92 d6 06 	sts	0x06D6, r1
  svit[svit_index].T_mux_num = T_mux_num;
     ba8:	c0 92 d7 06 	sts	0x06D7, r12
  svit[svit_index].T_mux_sel = T_mux_sel;
     bac:	86 e0       	ldi	r24, 0x06	; 6
     bae:	80 93 d8 06 	sts	0x06D8, r24
  svit[svit_index].T_sample_index = 0;
     bb2:	10 92 dc 06 	sts	0x06DC, r1
  set_component( svit_index++,  SOLAR_9     ,  SW_NULL,     SW_ON,          MUX0,       13,      V_THRESHOLD_VALUE,      MUX0,        28,    I_THRESHOLD_VALUE,    MUX2    ,       5     );  
  set_component( svit_index++,  SOLAR_10    ,  SW_NULL,     SW_ON,          MUX0,       12,      V_THRESHOLD_VALUE,      MUX0,        29,    I_THRESHOLD_VALUE,    MUX_NULL,       0     );  
  set_component( svit_index++,  SOLAR_11    ,  SW_NULL,     SW_ON,          MUX0,       11,      V_THRESHOLD_VALUE,      MUX0,        30,    I_THRESHOLD_VALUE,    MUX_NULL,       0     );  
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE,    MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE,    MUX2    ,       6     );  // Fake Data
}
     bb6:	1f 91       	pop	r17
     bb8:	0f 91       	pop	r16
     bba:	ff 90       	pop	r15
     bbc:	ef 90       	pop	r14
     bbe:	df 90       	pop	r13
     bc0:	cf 90       	pop	r12
     bc2:	bf 90       	pop	r11
     bc4:	af 90       	pop	r10
     bc6:	9f 90       	pop	r9
     bc8:	8f 90       	pop	r8
     bca:	7f 90       	pop	r7
     bcc:	6f 90       	pop	r6
     bce:	5f 90       	pop	r5
     bd0:	4f 90       	pop	r4
     bd2:	3f 90       	pop	r3
     bd4:	08 95       	ret

00000bd6 <assign_charge_fit>:
}


/* Assigns values to the Fourier coefficients of the charge approximation */
void assign_charge_fit( void ) {
  charge_max_time = 10188;
     bd6:	80 e0       	ldi	r24, 0x00	; 0
     bd8:	90 e3       	ldi	r25, 0x30	; 48
     bda:	af e1       	ldi	r26, 0x1F	; 31
     bdc:	b6 e4       	ldi	r27, 0x46	; 70
     bde:	80 93 29 09 	sts	0x0929, r24
     be2:	90 93 2a 09 	sts	0x092A, r25
     be6:	a0 93 2b 09 	sts	0x092B, r26
     bea:	b0 93 2c 09 	sts	0x092C, r27
  // x is normalized by mean 13.13 and std 0.1754
  p1 = 18.57;
     bee:	8c e5       	ldi	r24, 0x5C	; 92
     bf0:	9f e8       	ldi	r25, 0x8F	; 143
     bf2:	a4 e9       	ldi	r26, 0x94	; 148
     bf4:	b1 e4       	ldi	r27, 0x41	; 65
     bf6:	80 93 fd 08 	sts	0x08FD, r24
     bfa:	90 93 fe 08 	sts	0x08FE, r25
     bfe:	a0 93 ff 08 	sts	0x08FF, r26
     c02:	b0 93 00 09 	sts	0x0900, r27
  p2 = 184.8;
     c06:	8d ec       	ldi	r24, 0xCD	; 205
     c08:	9c ec       	ldi	r25, 0xCC	; 204
     c0a:	a8 e3       	ldi	r26, 0x38	; 56
     c0c:	b3 e4       	ldi	r27, 0x43	; 67
     c0e:	80 93 22 03 	sts	0x0322, r24
     c12:	90 93 23 03 	sts	0x0323, r25
     c16:	a0 93 24 03 	sts	0x0324, r26
     c1a:	b0 93 25 03 	sts	0x0325, r27
  p3 = 663.6;
     c1e:	86 e6       	ldi	r24, 0x66	; 102
     c20:	96 ee       	ldi	r25, 0xE6	; 230
     c22:	a5 e2       	ldi	r26, 0x25	; 37
     c24:	b4 e4       	ldi	r27, 0x44	; 68
     c26:	80 93 41 0d 	sts	0x0D41, r24
     c2a:	90 93 42 0d 	sts	0x0D42, r25
     c2e:	a0 93 43 0d 	sts	0x0D43, r26
     c32:	b0 93 44 0d 	sts	0x0D44, r27
  p4 = 838.6;
     c36:	86 e6       	ldi	r24, 0x66	; 102
     c38:	96 ea       	ldi	r25, 0xA6	; 166
     c3a:	a1 e5       	ldi	r26, 0x51	; 81
     c3c:	b4 e4       	ldi	r27, 0x44	; 68
     c3e:	80 93 5b 0d 	sts	0x0D5B, r24
     c42:	90 93 5c 0d 	sts	0x0D5C, r25
     c46:	a0 93 5d 0d 	sts	0x0D5D, r26
     c4a:	b0 93 5e 0d 	sts	0x0D5E, r27
  //where x is normalized by mean 13.7 and std 0.1558
  q1 = 78.49;
     c4e:	81 ee       	ldi	r24, 0xE1	; 225
     c50:	9a ef       	ldi	r25, 0xFA	; 250
     c52:	ac e9       	ldi	r26, 0x9C	; 156
     c54:	b2 e4       	ldi	r27, 0x42	; 66
     c56:	80 93 1e 09 	sts	0x091E, r24
     c5a:	90 93 1f 09 	sts	0x091F, r25
     c5e:	a0 93 20 09 	sts	0x0920, r26
     c62:	b0 93 21 09 	sts	0x0921, r27
  q2 = 543.1;
     c66:	86 e6       	ldi	r24, 0x66	; 102
     c68:	96 ec       	ldi	r25, 0xC6	; 198
     c6a:	a7 e0       	ldi	r26, 0x07	; 7
     c6c:	b4 e4       	ldi	r27, 0x44	; 68
     c6e:	80 93 dd 06 	sts	0x06DD, r24
     c72:	90 93 de 06 	sts	0x06DE, r25
     c76:	a0 93 df 06 	sts	0x06DF, r26
     c7a:	b0 93 e0 06 	sts	0x06E0, r27
  q3 = 2427;
     c7e:	80 e0       	ldi	r24, 0x00	; 0
     c80:	90 eb       	ldi	r25, 0xB0	; 176
     c82:	a7 e1       	ldi	r26, 0x17	; 23
     c84:	b5 e4       	ldi	r27, 0x45	; 69
     c86:	80 93 1a 09 	sts	0x091A, r24
     c8a:	90 93 1b 09 	sts	0x091B, r25
     c8e:	a0 93 1c 09 	sts	0x091C, r26
     c92:	b0 93 1d 09 	sts	0x091D, r27
  q4 = 5587;
     c96:	80 e0       	ldi	r24, 0x00	; 0
     c98:	98 e9       	ldi	r25, 0x98	; 152
     c9a:	ae ea       	ldi	r26, 0xAE	; 174
     c9c:	b5 e4       	ldi	r27, 0x45	; 69
     c9e:	80 93 51 0d 	sts	0x0D51, r24
     ca2:	90 93 52 0d 	sts	0x0D52, r25
     ca6:	a0 93 53 0d 	sts	0x0D53, r26
     caa:	b0 93 54 0d 	sts	0x0D54, r27

}
     cae:	08 95       	ret

00000cb0 <assign_discharge_fit>:

/* Assigns values to the Fourier coefficients of the discharge approximation */
void assign_discharge_fit( void ) {
  discharge_max_time = 17547;
     cb0:	80 e0       	ldi	r24, 0x00	; 0
     cb2:	96 e1       	ldi	r25, 0x16	; 22
     cb4:	a9 e8       	ldi	r26, 0x89	; 137
     cb6:	b6 e4       	ldi	r27, 0x46	; 70
     cb8:	80 93 f2 06 	sts	0x06F2, r24
     cbc:	90 93 f3 06 	sts	0x06F3, r25
     cc0:	a0 93 f4 06 	sts	0x06F4, r26
     cc4:	b0 93 f5 06 	sts	0x06F5, r27
  f0 = -1.543291233254410E4;
     cc8:	88 eb       	ldi	r24, 0xB8	; 184
     cca:	93 ec       	ldi	r25, 0xC3	; 195
     ccc:	90 93 3e 0d 	sts	0x0D3E, r25
     cd0:	80 93 3d 0d 	sts	0x0D3D, r24
  f1 = -1.819810644993805E4;
     cd4:	8a ee       	ldi	r24, 0xEA	; 234
     cd6:	98 eb       	ldi	r25, 0xB8	; 184
     cd8:	90 93 48 0d 	sts	0x0D48, r25
     cdc:	80 93 47 0d 	sts	0x0D47, r24
  b1 = -2.548949173344369E4;
     ce0:	8f e6       	ldi	r24, 0x6F	; 111
     ce2:	9c e9       	ldi	r25, 0x9C	; 156
     ce4:	90 93 e2 06 	sts	0x06E2, r25
     ce8:	80 93 e1 06 	sts	0x06E1, r24
  f2 = 1.141365113433748E4;
     cec:	85 e9       	ldi	r24, 0x95	; 149
     cee:	9c e2       	ldi	r25, 0x2C	; 44
     cf0:	90 93 13 09 	sts	0x0913, r25
     cf4:	80 93 12 09 	sts	0x0912, r24
  b2 = -2.190399298389397E4;
     cf8:	81 e7       	ldi	r24, 0x71	; 113
     cfa:	9a ea       	ldi	r25, 0xAA	; 170
     cfc:	90 93 20 03 	sts	0x0320, r25
     d00:	80 93 1f 03 	sts	0x031F, r24
  f3 = 1.453849538420288E4;
     d04:	8a ec       	ldi	r24, 0xCA	; 202
     d06:	98 e3       	ldi	r25, 0x38	; 56
     d08:	90 93 08 09 	sts	0x0908, r25
     d0c:	80 93 07 09 	sts	0x0907, r24
  b3 = 7.700208204268025E2;
     d10:	82 e0       	ldi	r24, 0x02	; 2
     d12:	93 e0       	ldi	r25, 0x03	; 3
     d14:	90 93 40 0d 	sts	0x0D40, r25
     d18:	80 93 3f 0d 	sts	0x0D3F, r24
  f4 = 1.965482651710955E3;
     d1c:	8d ea       	ldi	r24, 0xAD	; 173
     d1e:	97 e0       	ldi	r25, 0x07	; 7
     d20:	90 93 46 0d 	sts	0x0D46, r25
     d24:	80 93 45 0d 	sts	0x0D45, r24
  b4 = 5.504490550919407E3;
     d28:	80 e8       	ldi	r24, 0x80	; 128
     d2a:	95 e1       	ldi	r25, 0x15	; 21
     d2c:	90 93 fc 06 	sts	0x06FC, r25
     d30:	80 93 fb 06 	sts	0x06FB, r24
  f5 = -9.466488439471518E2;
     d34:	8e e4       	ldi	r24, 0x4E	; 78
     d36:	9c ef       	ldi	r25, 0xFC	; 252
     d38:	90 93 fa 06 	sts	0x06FA, r25
     d3c:	80 93 f9 06 	sts	0x06F9, r24
  b5 = 8.270458368650347E2;
     d40:	8b e3       	ldi	r24, 0x3B	; 59
     d42:	93 e0       	ldi	r25, 0x03	; 3
     d44:	90 93 3c 0d 	sts	0x0D3C, r25
     d48:	80 93 3b 0d 	sts	0x0D3B, r24
  w = 2.725333178515558;
     d4c:	8c ed       	ldi	r24, 0xDC	; 220
     d4e:	9b e6       	ldi	r25, 0x6B	; 107
     d50:	ae e2       	ldi	r26, 0x2E	; 46
     d52:	b0 e4       	ldi	r27, 0x40	; 64
     d54:	80 93 e8 06 	sts	0x06E8, r24
     d58:	90 93 e9 06 	sts	0x06E9, r25
     d5c:	a0 93 ea 06 	sts	0x06EA, r26
     d60:	b0 93 eb 06 	sts	0x06EB, r27
  
  h0 = 2.979485572689352E8;
     d64:	80 e8       	ldi	r24, 0x80	; 128
     d66:	95 e5       	ldi	r25, 0x55	; 85
     d68:	a2 ec       	ldi	r26, 0xC2	; 194
     d6a:	b1 e1       	ldi	r27, 0x11	; 17
     d6c:	80 93 0e 09 	sts	0x090E, r24
     d70:	90 93 0f 09 	sts	0x090F, r25
     d74:	a0 93 10 09 	sts	0x0910, r26
     d78:	b0 93 11 09 	sts	0x0911, r27
  h1 = 2.088787459098652E8;
     d7c:	80 ea       	ldi	r24, 0xA0	; 160
     d7e:	9c e3       	ldi	r25, 0x3C	; 60
     d80:	a3 e7       	ldi	r26, 0x73	; 115
     d82:	bc e0       	ldi	r27, 0x0C	; 12
     d84:	80 93 2a 03 	sts	0x032A, r24
     d88:	90 93 2b 03 	sts	0x032B, r25
     d8c:	a0 93 2c 03 	sts	0x032C, r26
     d90:	b0 93 2d 03 	sts	0x032D, r27
  g1 = 4.359717315569648E8;
     d94:	80 ea       	ldi	r24, 0xA0	; 160
     d96:	96 e6       	ldi	r25, 0x66	; 102
     d98:	ac ef       	ldi	r26, 0xFC	; 252
     d9a:	b9 e1       	ldi	r27, 0x19	; 25
     d9c:	80 93 2f 03 	sts	0x032F, r24
     da0:	90 93 30 03 	sts	0x0330, r25
     da4:	a0 93 31 03 	sts	0x0331, r26
     da8:	b0 93 32 03 	sts	0x0332, r27
  h2 =  -1.569778955752849E8;
     dac:	80 e2       	ldi	r24, 0x20	; 32
     dae:	95 eb       	ldi	r25, 0xB5	; 181
     db0:	a4 ea       	ldi	r26, 0xA4	; 164
     db2:	b6 ef       	ldi	r27, 0xF6	; 246
     db4:	80 93 0a 09 	sts	0x090A, r24
     db8:	90 93 0b 09 	sts	0x090B, r25
     dbc:	a0 93 0c 09 	sts	0x090C, r26
     dc0:	b0 93 0d 09 	sts	0x090D, r27
  g2 =  1.969854815603661E8;
     dc4:	80 e9       	ldi	r24, 0x90	; 144
     dc6:	92 ec       	ldi	r25, 0xC2	; 194
     dc8:	ad eb       	ldi	r26, 0xBD	; 189
     dca:	bb e0       	ldi	r27, 0x0B	; 11
     dcc:	80 93 02 09 	sts	0x0902, r24
     dd0:	90 93 03 09 	sts	0x0903, r25
     dd4:	a0 93 04 09 	sts	0x0904, r26
     dd8:	b0 93 05 09 	sts	0x0905, r27
  h3 =  -7.513816845838763E7;
     ddc:	88 e8       	ldi	r24, 0x88	; 136
     dde:	9b e7       	ldi	r25, 0x7B	; 123
     de0:	a5 e8       	ldi	r26, 0x85	; 133
     de2:	bb ef       	ldi	r27, 0xFB	; 251
     de4:	80 93 49 0d 	sts	0x0D49, r24
     de8:	90 93 4a 0d 	sts	0x0D4A, r25
     dec:	a0 93 4b 0d 	sts	0x0D4B, r26
     df0:	b0 93 4c 0d 	sts	0x0D4C, r27
  g3 =  -1.633385950799686E7;
     df4:	8c ed       	ldi	r24, 0xDC	; 220
     df6:	93 ec       	ldi	r25, 0xC3	; 195
     df8:	a6 e0       	ldi	r26, 0x06	; 6
     dfa:	bf ef       	ldi	r27, 0xFF	; 255
     dfc:	80 93 1b 03 	sts	0x031B, r24
     e00:	90 93 1c 03 	sts	0x031C, r25
     e04:	a0 93 1d 03 	sts	0x031D, r26
     e08:	b0 93 1e 03 	sts	0x031E, r27
  h4 =   -2.642581886559125E6;
     e0c:	8a e6       	ldi	r24, 0x6A	; 106
     e0e:	9d ea       	ldi	r25, 0xAD	; 173
     e10:	a7 ed       	ldi	r26, 0xD7	; 215
     e12:	bf ef       	ldi	r27, 0xFF	; 255
     e14:	80 93 32 0d 	sts	0x0D32, r24
     e18:	90 93 33 0d 	sts	0x0D33, r25
     e1c:	a0 93 34 0d 	sts	0x0D34, r26
     e20:	b0 93 35 0d 	sts	0x0D35, r27
  g4 =   -1.016608352073227E7;
     e24:	8c eb       	ldi	r24, 0xBC	; 188
     e26:	90 ee       	ldi	r25, 0xE0	; 224
     e28:	a4 e6       	ldi	r26, 0x64	; 100
     e2a:	bf ef       	ldi	r27, 0xFF	; 255
     e2c:	80 93 06 03 	sts	0x0306, r24
     e30:	90 93 07 03 	sts	0x0307, r25
     e34:	a0 93 08 03 	sts	0x0308, r26
     e38:	b0 93 09 03 	sts	0x0309, r27
  w2 =  0.364797662747743;
     e3c:	82 ec       	ldi	r24, 0xC2	; 194
     e3e:	96 ec       	ldi	r25, 0xC6	; 198
     e40:	aa eb       	ldi	r26, 0xBA	; 186
     e42:	be e3       	ldi	r27, 0x3E	; 62
     e44:	80 93 2e 0b 	sts	0x0B2E, r24
     e48:	90 93 2f 0b 	sts	0x0B2F, r25
     e4c:	a0 93 30 0b 	sts	0x0B30, r26
     e50:	b0 93 31 0b 	sts	0x0B31, r27
}
     e54:	08 95       	ret

00000e56 <calcSOC>:
	}
	else {} // To avoid annoying compile warning 
}

// Calculates percent state of charge
void calcSOC( void ) {
     e56:	2f 92       	push	r2
     e58:	3f 92       	push	r3
     e5a:	4f 92       	push	r4
     e5c:	5f 92       	push	r5
     e5e:	6f 92       	push	r6
     e60:	7f 92       	push	r7
     e62:	8f 92       	push	r8
     e64:	9f 92       	push	r9
     e66:	af 92       	push	r10
     e68:	bf 92       	push	r11
     e6a:	cf 92       	push	r12
     e6c:	df 92       	push	r13
     e6e:	ef 92       	push	r14
     e70:	ff 92       	push	r15
     e72:	0f 93       	push	r16
     e74:	1f 93       	push	r17
     e76:	df 93       	push	r29
     e78:	cf 93       	push	r28
     e7a:	cd b7       	in	r28, 0x3d	; 61
     e7c:	de b7       	in	r29, 0x3e	; 62
     e7e:	e0 97       	sbiw	r28, 0x30	; 48
     e80:	0f b6       	in	r0, 0x3f	; 63
     e82:	f8 94       	cli
     e84:	de bf       	out	0x3e, r29	; 62
     e86:	0f be       	out	0x3f, r0	; 63
     e88:	cd bf       	out	0x3d, r28	; 61
  uint16_t ADC_val = (high << 2) + (low >> 6);
  //10-bit resolution
  //real = (((batt1_voltage + 1)*5)/1024 - 0.0315)*5.5556645; // 16-bit resolution
  real = (ADC_val + 1)*0.02712726806640625-0.17500343175;
     e8a:	20 91 22 09 	lds	r18, 0x0922
     e8e:	22 95       	swap	r18
     e90:	26 95       	lsr	r18
     e92:	26 95       	lsr	r18
     e94:	23 70       	andi	r18, 0x03	; 3
     e96:	60 91 14 09 	lds	r22, 0x0914
     e9a:	70 e0       	ldi	r23, 0x00	; 0
     e9c:	66 0f       	add	r22, r22
     e9e:	77 1f       	adc	r23, r23
     ea0:	66 0f       	add	r22, r22
     ea2:	77 1f       	adc	r23, r23
     ea4:	62 0f       	add	r22, r18
     ea6:	71 1d       	adc	r23, r1
     ea8:	6f 5f       	subi	r22, 0xFF	; 255
     eaa:	7f 4f       	sbci	r23, 0xFF	; 255
     eac:	80 e0       	ldi	r24, 0x00	; 0
     eae:	90 e0       	ldi	r25, 0x00	; 0
     eb0:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__floatunsisf>
     eb4:	21 e0       	ldi	r18, 0x01	; 1
     eb6:	3a e3       	ldi	r19, 0x3A	; 58
     eb8:	4e ed       	ldi	r20, 0xDE	; 222
     eba:	5c e3       	ldi	r21, 0x3C	; 60
     ebc:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
     ec0:	2a e1       	ldi	r18, 0x1A	; 26
     ec2:	34 e3       	ldi	r19, 0x34	; 52
     ec4:	43 e3       	ldi	r20, 0x33	; 51
     ec6:	5e e3       	ldi	r21, 0x3E	; 62
     ec8:	0e 94 75 17 	call	0x2eea	; 0x2eea <__subsf3>
     ecc:	7b 01       	movw	r14, r22
     ece:	8c 01       	movw	r16, r24
     ed0:	60 93 15 09 	sts	0x0915, r22
     ed4:	70 93 16 09 	sts	0x0916, r23
     ed8:	80 93 17 09 	sts	0x0917, r24
     edc:	90 93 18 09 	sts	0x0918, r25
  //8-bit resolution
  //real = (batt1_voltage+1)*0.1085090723-0.66667974;
  
  // Since approximations are periodic, limit batt_time values within a certain voltage range 
  if (real > 14.2) {
     ee0:	23 e3       	ldi	r18, 0x33	; 51
     ee2:	33 e3       	ldi	r19, 0x33	; 51
     ee4:	43 e6       	ldi	r20, 0x63	; 99
     ee6:	51 e4       	ldi	r21, 0x41	; 65
     ee8:	0e 94 b8 19 	call	0x3370	; 0x3370 <__gesf2>
     eec:	18 16       	cp	r1, r24
     eee:	2c f4       	brge	.+10     	; 0xefa <calcSOC+0xa4>
	 real = 14.2;
     ef0:	83 e3       	ldi	r24, 0x33	; 51
     ef2:	93 e3       	ldi	r25, 0x33	; 51
     ef4:	a3 e6       	ldi	r26, 0x63	; 99
     ef6:	b1 e4       	ldi	r27, 0x41	; 65
     ef8:	0e c0       	rjmp	.+28     	; 0xf16 <calcSOC+0xc0>
  }
  else if (real < 11.2) {
     efa:	c8 01       	movw	r24, r16
     efc:	b7 01       	movw	r22, r14
     efe:	23 e3       	ldi	r18, 0x33	; 51
     f00:	33 e3       	ldi	r19, 0x33	; 51
     f02:	43 e3       	ldi	r20, 0x33	; 51
     f04:	51 e4       	ldi	r21, 0x41	; 65
     f06:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <__cmpsf2>
     f0a:	88 23       	and	r24, r24
     f0c:	64 f4       	brge	.+24     	; 0xf26 <calcSOC+0xd0>
	 real = 11.2;
     f0e:	83 e3       	ldi	r24, 0x33	; 51
     f10:	93 e3       	ldi	r25, 0x33	; 51
     f12:	a3 e3       	ldi	r26, 0x33	; 51
     f14:	b1 e4       	ldi	r27, 0x41	; 65
     f16:	80 93 15 09 	sts	0x0915, r24
     f1a:	90 93 16 09 	sts	0x0916, r25
     f1e:	a0 93 17 09 	sts	0x0917, r26
     f22:	b0 93 18 09 	sts	0x0918, r27
  }
  
  //charging = 0xcc;
  if (charging == 0xdd) // change back to dd for tomorrow 
     f26:	80 91 ed 06 	lds	r24, 0x06ED
     f2a:	60 90 15 09 	lds	r6, 0x0915
     f2e:	70 90 16 09 	lds	r7, 0x0916
     f32:	80 90 17 09 	lds	r8, 0x0917
     f36:	90 90 18 09 	lds	r9, 0x0918
     f3a:	8d 3d       	cpi	r24, 0xDD	; 221
     f3c:	09 f0       	breq	.+2      	; 0xf40 <calcSOC+0xea>
     f3e:	da c2       	rjmp	.+1460   	; 0x14f4 <__stack+0x3f5>
  {
  	if (real > 12.43) 
     f40:	c4 01       	movw	r24, r8
     f42:	b3 01       	movw	r22, r6
     f44:	28 e4       	ldi	r18, 0x48	; 72
     f46:	31 ee       	ldi	r19, 0xE1	; 225
     f48:	46 e4       	ldi	r20, 0x46	; 70
     f4a:	51 e4       	ldi	r21, 0x41	; 65
     f4c:	0e 94 b8 19 	call	0x3370	; 0x3370 <__gesf2>
     f50:	18 16       	cp	r1, r24
     f52:	0c f0       	brlt	.+2      	; 0xf56 <calcSOC+0x100>
     f54:	77 c1       	rjmp	.+750    	; 0x1244 <__stack+0x145>
	{
      debug = 0x0A;
     f56:	8a e0       	ldi	r24, 0x0A	; 10
     f58:	80 93 ec 06 	sts	0x06EC, r24
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     f5c:	a0 90 e8 06 	lds	r10, 0x06E8
     f60:	b0 90 e9 06 	lds	r11, 0x06E9
     f64:	c0 90 ea 06 	lds	r12, 0x06EA
     f68:	d0 90 eb 06 	lds	r13, 0x06EB
     f6c:	c4 01       	movw	r24, r8
     f6e:	b3 01       	movw	r22, r6
     f70:	a6 01       	movw	r20, r12
     f72:	95 01       	movw	r18, r10
     f74:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
     f78:	7b 01       	movw	r14, r22
     f7a:	8c 01       	movw	r16, r24
     f7c:	c8 01       	movw	r24, r16
     f7e:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <cos>
     f82:	6d a7       	std	Y+45, r22	; 0x2d
     f84:	7e a7       	std	Y+46, r23	; 0x2e
     f86:	8f a7       	std	Y+47, r24	; 0x2f
     f88:	98 ab       	std	Y+48, r25	; 0x30
     f8a:	b7 01       	movw	r22, r14
     f8c:	c8 01       	movw	r24, r16
     f8e:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <sin>
     f92:	69 a7       	std	Y+41, r22	; 0x29
     f94:	7a a7       	std	Y+42, r23	; 0x2a
     f96:	8b a7       	std	Y+43, r24	; 0x2b
     f98:	9c a7       	std	Y+44, r25	; 0x2c
     f9a:	c4 01       	movw	r24, r8
     f9c:	b3 01       	movw	r22, r6
     f9e:	a4 01       	movw	r20, r8
     fa0:	93 01       	movw	r18, r6
     fa2:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
     fa6:	a6 01       	movw	r20, r12
     fa8:	95 01       	movw	r18, r10
     faa:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
     fae:	7b 01       	movw	r14, r22
     fb0:	8c 01       	movw	r16, r24
     fb2:	c8 01       	movw	r24, r16
     fb4:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <cos>
     fb8:	6d a3       	std	Y+37, r22	; 0x25
     fba:	7e a3       	std	Y+38, r23	; 0x26
     fbc:	8f a3       	std	Y+39, r24	; 0x27
     fbe:	98 a7       	std	Y+40, r25	; 0x28
     fc0:	b7 01       	movw	r22, r14
     fc2:	c8 01       	movw	r24, r16
     fc4:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <sin>
     fc8:	69 a3       	std	Y+33, r22	; 0x21
     fca:	7a a3       	std	Y+34, r23	; 0x22
     fcc:	8b a3       	std	Y+35, r24	; 0x23
     fce:	9c a3       	std	Y+36, r25	; 0x24
     fd0:	c4 01       	movw	r24, r8
     fd2:	b3 01       	movw	r22, r6
     fd4:	20 e0       	ldi	r18, 0x00	; 0
     fd6:	30 e0       	ldi	r19, 0x00	; 0
     fd8:	40 e4       	ldi	r20, 0x40	; 64
     fda:	50 e4       	ldi	r21, 0x40	; 64
     fdc:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
     fe0:	a6 01       	movw	r20, r12
     fe2:	95 01       	movw	r18, r10
     fe4:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
     fe8:	7b 01       	movw	r14, r22
     fea:	8c 01       	movw	r16, r24
     fec:	c8 01       	movw	r24, r16
     fee:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <cos>
     ff2:	6d 8f       	std	Y+29, r22	; 0x1d
     ff4:	7e 8f       	std	Y+30, r23	; 0x1e
     ff6:	8f 8f       	std	Y+31, r24	; 0x1f
     ff8:	98 a3       	std	Y+32, r25	; 0x20
     ffa:	b7 01       	movw	r22, r14
     ffc:	c8 01       	movw	r24, r16
     ffe:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <sin>
    1002:	69 8f       	std	Y+25, r22	; 0x19
    1004:	7a 8f       	std	Y+26, r23	; 0x1a
    1006:	8b 8f       	std	Y+27, r24	; 0x1b
    1008:	9c 8f       	std	Y+28, r25	; 0x1c
    100a:	c4 01       	movw	r24, r8
    100c:	b3 01       	movw	r22, r6
    100e:	20 e0       	ldi	r18, 0x00	; 0
    1010:	30 e0       	ldi	r19, 0x00	; 0
    1012:	40 e8       	ldi	r20, 0x80	; 128
    1014:	50 e4       	ldi	r21, 0x40	; 64
    1016:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    101a:	a6 01       	movw	r20, r12
    101c:	95 01       	movw	r18, r10
    101e:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1022:	7b 01       	movw	r14, r22
    1024:	8c 01       	movw	r16, r24
    1026:	c8 01       	movw	r24, r16
    1028:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <cos>
    102c:	6d 8b       	std	Y+21, r22	; 0x15
    102e:	7e 8b       	std	Y+22, r23	; 0x16
    1030:	8f 8b       	std	Y+23, r24	; 0x17
    1032:	98 8f       	std	Y+24, r25	; 0x18
    1034:	b7 01       	movw	r22, r14
    1036:	c8 01       	movw	r24, r16
    1038:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <sin>
    103c:	1b 01       	movw	r2, r22
    103e:	2c 01       	movw	r4, r24
    1040:	c4 01       	movw	r24, r8
    1042:	b3 01       	movw	r22, r6
    1044:	20 e0       	ldi	r18, 0x00	; 0
    1046:	30 e0       	ldi	r19, 0x00	; 0
    1048:	40 ea       	ldi	r20, 0xA0	; 160
    104a:	50 e4       	ldi	r21, 0x40	; 64
    104c:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1050:	a6 01       	movw	r20, r12
    1052:	95 01       	movw	r18, r10
    1054:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1058:	7b 01       	movw	r14, r22
    105a:	8c 01       	movw	r16, r24
    105c:	c8 01       	movw	r24, r16
    105e:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <cos>
    1062:	3b 01       	movw	r6, r22
    1064:	4c 01       	movw	r8, r24
    1066:	b7 01       	movw	r22, r14
    1068:	c8 01       	movw	r24, r16
    106a:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <sin>
    106e:	5b 01       	movw	r10, r22
    1070:	6c 01       	movw	r12, r24
    1072:	60 91 3d 0d 	lds	r22, 0x0D3D
    1076:	70 91 3e 0d 	lds	r23, 0x0D3E
    107a:	88 27       	eor	r24, r24
    107c:	77 fd       	sbrc	r23, 7
    107e:	80 95       	com	r24
    1080:	98 2f       	mov	r25, r24
    1082:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    1086:	7b 01       	movw	r14, r22
    1088:	8c 01       	movw	r16, r24
    108a:	60 91 47 0d 	lds	r22, 0x0D47
    108e:	70 91 48 0d 	lds	r23, 0x0D48
    1092:	88 27       	eor	r24, r24
    1094:	77 fd       	sbrc	r23, 7
    1096:	80 95       	com	r24
    1098:	98 2f       	mov	r25, r24
    109a:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    109e:	2d a5       	ldd	r18, Y+45	; 0x2d
    10a0:	3e a5       	ldd	r19, Y+46	; 0x2e
    10a2:	4f a5       	ldd	r20, Y+47	; 0x2f
    10a4:	58 a9       	ldd	r21, Y+48	; 0x30
    10a6:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    10aa:	9b 01       	movw	r18, r22
    10ac:	ac 01       	movw	r20, r24
    10ae:	c8 01       	movw	r24, r16
    10b0:	b7 01       	movw	r22, r14
    10b2:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    10b6:	7b 01       	movw	r14, r22
    10b8:	8c 01       	movw	r16, r24
    10ba:	60 91 e1 06 	lds	r22, 0x06E1
    10be:	70 91 e2 06 	lds	r23, 0x06E2
    10c2:	88 27       	eor	r24, r24
    10c4:	77 fd       	sbrc	r23, 7
    10c6:	80 95       	com	r24
    10c8:	98 2f       	mov	r25, r24
    10ca:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    10ce:	29 a5       	ldd	r18, Y+41	; 0x29
    10d0:	3a a5       	ldd	r19, Y+42	; 0x2a
    10d2:	4b a5       	ldd	r20, Y+43	; 0x2b
    10d4:	5c a5       	ldd	r21, Y+44	; 0x2c
    10d6:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    10da:	9b 01       	movw	r18, r22
    10dc:	ac 01       	movw	r20, r24
    10de:	c8 01       	movw	r24, r16
    10e0:	b7 01       	movw	r22, r14
    10e2:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    10e6:	7b 01       	movw	r14, r22
    10e8:	8c 01       	movw	r16, r24
    10ea:	60 91 12 09 	lds	r22, 0x0912
    10ee:	70 91 13 09 	lds	r23, 0x0913
    10f2:	88 27       	eor	r24, r24
    10f4:	77 fd       	sbrc	r23, 7
    10f6:	80 95       	com	r24
    10f8:	98 2f       	mov	r25, r24
    10fa:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    10fe:	2d a1       	ldd	r18, Y+37	; 0x25
    1100:	3e a1       	ldd	r19, Y+38	; 0x26
    1102:	4f a1       	ldd	r20, Y+39	; 0x27
    1104:	58 a5       	ldd	r21, Y+40	; 0x28
    1106:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    110a:	9b 01       	movw	r18, r22
    110c:	ac 01       	movw	r20, r24
    110e:	c8 01       	movw	r24, r16
    1110:	b7 01       	movw	r22, r14
    1112:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    1116:	7b 01       	movw	r14, r22
    1118:	8c 01       	movw	r16, r24
    111a:	60 91 1f 03 	lds	r22, 0x031F
    111e:	70 91 20 03 	lds	r23, 0x0320
    1122:	88 27       	eor	r24, r24
    1124:	77 fd       	sbrc	r23, 7
    1126:	80 95       	com	r24
    1128:	98 2f       	mov	r25, r24
    112a:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    112e:	29 a1       	ldd	r18, Y+33	; 0x21
    1130:	3a a1       	ldd	r19, Y+34	; 0x22
    1132:	4b a1       	ldd	r20, Y+35	; 0x23
    1134:	5c a1       	ldd	r21, Y+36	; 0x24
    1136:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    113a:	9b 01       	movw	r18, r22
    113c:	ac 01       	movw	r20, r24
    113e:	c8 01       	movw	r24, r16
    1140:	b7 01       	movw	r22, r14
    1142:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    1146:	7b 01       	movw	r14, r22
    1148:	8c 01       	movw	r16, r24
    114a:	60 91 07 09 	lds	r22, 0x0907
    114e:	70 91 08 09 	lds	r23, 0x0908
    1152:	88 27       	eor	r24, r24
    1154:	77 fd       	sbrc	r23, 7
    1156:	80 95       	com	r24
    1158:	98 2f       	mov	r25, r24
    115a:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    115e:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1160:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1162:	4f 8d       	ldd	r20, Y+31	; 0x1f
    1164:	58 a1       	ldd	r21, Y+32	; 0x20
    1166:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    116a:	9b 01       	movw	r18, r22
    116c:	ac 01       	movw	r20, r24
    116e:	c8 01       	movw	r24, r16
    1170:	b7 01       	movw	r22, r14
    1172:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    1176:	7b 01       	movw	r14, r22
    1178:	8c 01       	movw	r16, r24
    117a:	60 91 3f 0d 	lds	r22, 0x0D3F
    117e:	70 91 40 0d 	lds	r23, 0x0D40
    1182:	88 27       	eor	r24, r24
    1184:	77 fd       	sbrc	r23, 7
    1186:	80 95       	com	r24
    1188:	98 2f       	mov	r25, r24
    118a:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    118e:	29 8d       	ldd	r18, Y+25	; 0x19
    1190:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1192:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1194:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1196:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    119a:	9b 01       	movw	r18, r22
    119c:	ac 01       	movw	r20, r24
    119e:	c8 01       	movw	r24, r16
    11a0:	b7 01       	movw	r22, r14
    11a2:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    11a6:	7b 01       	movw	r14, r22
    11a8:	8c 01       	movw	r16, r24
    11aa:	60 91 45 0d 	lds	r22, 0x0D45
    11ae:	70 91 46 0d 	lds	r23, 0x0D46
    11b2:	88 27       	eor	r24, r24
    11b4:	77 fd       	sbrc	r23, 7
    11b6:	80 95       	com	r24
    11b8:	98 2f       	mov	r25, r24
    11ba:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    11be:	2d 89       	ldd	r18, Y+21	; 0x15
    11c0:	3e 89       	ldd	r19, Y+22	; 0x16
    11c2:	4f 89       	ldd	r20, Y+23	; 0x17
    11c4:	58 8d       	ldd	r21, Y+24	; 0x18
    11c6:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    11ca:	9b 01       	movw	r18, r22
    11cc:	ac 01       	movw	r20, r24
    11ce:	c8 01       	movw	r24, r16
    11d0:	b7 01       	movw	r22, r14
    11d2:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    11d6:	7b 01       	movw	r14, r22
    11d8:	8c 01       	movw	r16, r24
    11da:	60 91 fb 06 	lds	r22, 0x06FB
    11de:	70 91 fc 06 	lds	r23, 0x06FC
    11e2:	88 27       	eor	r24, r24
    11e4:	77 fd       	sbrc	r23, 7
    11e6:	80 95       	com	r24
    11e8:	98 2f       	mov	r25, r24
    11ea:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    11ee:	a2 01       	movw	r20, r4
    11f0:	91 01       	movw	r18, r2
    11f2:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    11f6:	9b 01       	movw	r18, r22
    11f8:	ac 01       	movw	r20, r24
    11fa:	c8 01       	movw	r24, r16
    11fc:	b7 01       	movw	r22, r14
    11fe:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    1202:	7b 01       	movw	r14, r22
    1204:	8c 01       	movw	r16, r24
    1206:	60 91 f9 06 	lds	r22, 0x06F9
    120a:	70 91 fa 06 	lds	r23, 0x06FA
    120e:	88 27       	eor	r24, r24
    1210:	77 fd       	sbrc	r23, 7
    1212:	80 95       	com	r24
    1214:	98 2f       	mov	r25, r24
    1216:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    121a:	a4 01       	movw	r20, r8
    121c:	93 01       	movw	r18, r6
    121e:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1222:	9b 01       	movw	r18, r22
    1224:	ac 01       	movw	r20, r24
    1226:	c8 01       	movw	r24, r16
    1228:	b7 01       	movw	r22, r14
    122a:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    122e:	7b 01       	movw	r14, r22
    1230:	8c 01       	movw	r16, r24
    1232:	60 91 3b 0d 	lds	r22, 0x0D3B
    1236:	70 91 3c 0d 	lds	r23, 0x0D3C
    123a:	88 27       	eor	r24, r24
    123c:	77 fd       	sbrc	r23, 7
    123e:	80 95       	com	r24
    1240:	98 2f       	mov	r25, r24
    1242:	29 c1       	rjmp	.+594    	; 0x1496 <__stack+0x397>
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
    1244:	8b e0       	ldi	r24, 0x0B	; 11
    1246:	80 93 ec 06 	sts	0x06EC, r24
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
    124a:	a0 90 2e 0b 	lds	r10, 0x0B2E
    124e:	b0 90 2f 0b 	lds	r11, 0x0B2F
    1252:	c0 90 30 0b 	lds	r12, 0x0B30
    1256:	d0 90 31 0b 	lds	r13, 0x0B31
    125a:	c4 01       	movw	r24, r8
    125c:	b3 01       	movw	r22, r6
    125e:	a6 01       	movw	r20, r12
    1260:	95 01       	movw	r18, r10
    1262:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1266:	7b 01       	movw	r14, r22
    1268:	8c 01       	movw	r16, r24
    126a:	c8 01       	movw	r24, r16
    126c:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <cos>
    1270:	69 8b       	std	Y+17, r22	; 0x11
    1272:	7a 8b       	std	Y+18, r23	; 0x12
    1274:	8b 8b       	std	Y+19, r24	; 0x13
    1276:	9c 8b       	std	Y+20, r25	; 0x14
    1278:	b7 01       	movw	r22, r14
    127a:	c8 01       	movw	r24, r16
    127c:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <sin>
    1280:	6d 87       	std	Y+13, r22	; 0x0d
    1282:	7e 87       	std	Y+14, r23	; 0x0e
    1284:	8f 87       	std	Y+15, r24	; 0x0f
    1286:	98 8b       	std	Y+16, r25	; 0x10
    1288:	c4 01       	movw	r24, r8
    128a:	b3 01       	movw	r22, r6
    128c:	a4 01       	movw	r20, r8
    128e:	93 01       	movw	r18, r6
    1290:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    1294:	a6 01       	movw	r20, r12
    1296:	95 01       	movw	r18, r10
    1298:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    129c:	7b 01       	movw	r14, r22
    129e:	8c 01       	movw	r16, r24
    12a0:	c8 01       	movw	r24, r16
    12a2:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <cos>
    12a6:	69 87       	std	Y+9, r22	; 0x09
    12a8:	7a 87       	std	Y+10, r23	; 0x0a
    12aa:	8b 87       	std	Y+11, r24	; 0x0b
    12ac:	9c 87       	std	Y+12, r25	; 0x0c
    12ae:	b7 01       	movw	r22, r14
    12b0:	c8 01       	movw	r24, r16
    12b2:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <sin>
    12b6:	6d 83       	std	Y+5, r22	; 0x05
    12b8:	7e 83       	std	Y+6, r23	; 0x06
    12ba:	8f 83       	std	Y+7, r24	; 0x07
    12bc:	98 87       	std	Y+8, r25	; 0x08
    12be:	c4 01       	movw	r24, r8
    12c0:	b3 01       	movw	r22, r6
    12c2:	20 e0       	ldi	r18, 0x00	; 0
    12c4:	30 e0       	ldi	r19, 0x00	; 0
    12c6:	40 e4       	ldi	r20, 0x40	; 64
    12c8:	50 e4       	ldi	r21, 0x40	; 64
    12ca:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    12ce:	a6 01       	movw	r20, r12
    12d0:	95 01       	movw	r18, r10
    12d2:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    12d6:	7b 01       	movw	r14, r22
    12d8:	8c 01       	movw	r16, r24
    12da:	c8 01       	movw	r24, r16
    12dc:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <cos>
    12e0:	69 83       	std	Y+1, r22	; 0x01
    12e2:	7a 83       	std	Y+2, r23	; 0x02
    12e4:	8b 83       	std	Y+3, r24	; 0x03
    12e6:	9c 83       	std	Y+4, r25	; 0x04
    12e8:	b7 01       	movw	r22, r14
    12ea:	c8 01       	movw	r24, r16
    12ec:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <sin>
    12f0:	1b 01       	movw	r2, r22
    12f2:	2c 01       	movw	r4, r24
    12f4:	c4 01       	movw	r24, r8
    12f6:	b3 01       	movw	r22, r6
    12f8:	20 e0       	ldi	r18, 0x00	; 0
    12fa:	30 e0       	ldi	r19, 0x00	; 0
    12fc:	40 e8       	ldi	r20, 0x80	; 128
    12fe:	50 e4       	ldi	r21, 0x40	; 64
    1300:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1304:	a6 01       	movw	r20, r12
    1306:	95 01       	movw	r18, r10
    1308:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    130c:	7b 01       	movw	r14, r22
    130e:	8c 01       	movw	r16, r24
    1310:	c8 01       	movw	r24, r16
    1312:	0e 94 de 17 	call	0x2fbc	; 0x2fbc <cos>
    1316:	3b 01       	movw	r6, r22
    1318:	4c 01       	movw	r8, r24
    131a:	b7 01       	movw	r22, r14
    131c:	c8 01       	movw	r24, r16
    131e:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <sin>
    1322:	5b 01       	movw	r10, r22
    1324:	6c 01       	movw	r12, r24
    1326:	60 91 0e 09 	lds	r22, 0x090E
    132a:	70 91 0f 09 	lds	r23, 0x090F
    132e:	80 91 10 09 	lds	r24, 0x0910
    1332:	90 91 11 09 	lds	r25, 0x0911
    1336:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    133a:	7b 01       	movw	r14, r22
    133c:	8c 01       	movw	r16, r24
    133e:	60 91 2a 03 	lds	r22, 0x032A
    1342:	70 91 2b 03 	lds	r23, 0x032B
    1346:	80 91 2c 03 	lds	r24, 0x032C
    134a:	90 91 2d 03 	lds	r25, 0x032D
    134e:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    1352:	29 89       	ldd	r18, Y+17	; 0x11
    1354:	3a 89       	ldd	r19, Y+18	; 0x12
    1356:	4b 89       	ldd	r20, Y+19	; 0x13
    1358:	5c 89       	ldd	r21, Y+20	; 0x14
    135a:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    135e:	9b 01       	movw	r18, r22
    1360:	ac 01       	movw	r20, r24
    1362:	c8 01       	movw	r24, r16
    1364:	b7 01       	movw	r22, r14
    1366:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    136a:	7b 01       	movw	r14, r22
    136c:	8c 01       	movw	r16, r24
    136e:	60 91 2f 03 	lds	r22, 0x032F
    1372:	70 91 30 03 	lds	r23, 0x0330
    1376:	80 91 31 03 	lds	r24, 0x0331
    137a:	90 91 32 03 	lds	r25, 0x0332
    137e:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    1382:	2d 85       	ldd	r18, Y+13	; 0x0d
    1384:	3e 85       	ldd	r19, Y+14	; 0x0e
    1386:	4f 85       	ldd	r20, Y+15	; 0x0f
    1388:	58 89       	ldd	r21, Y+16	; 0x10
    138a:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    138e:	9b 01       	movw	r18, r22
    1390:	ac 01       	movw	r20, r24
    1392:	c8 01       	movw	r24, r16
    1394:	b7 01       	movw	r22, r14
    1396:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    139a:	7b 01       	movw	r14, r22
    139c:	8c 01       	movw	r16, r24
    139e:	60 91 0a 09 	lds	r22, 0x090A
    13a2:	70 91 0b 09 	lds	r23, 0x090B
    13a6:	80 91 0c 09 	lds	r24, 0x090C
    13aa:	90 91 0d 09 	lds	r25, 0x090D
    13ae:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    13b2:	29 85       	ldd	r18, Y+9	; 0x09
    13b4:	3a 85       	ldd	r19, Y+10	; 0x0a
    13b6:	4b 85       	ldd	r20, Y+11	; 0x0b
    13b8:	5c 85       	ldd	r21, Y+12	; 0x0c
    13ba:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    13be:	9b 01       	movw	r18, r22
    13c0:	ac 01       	movw	r20, r24
    13c2:	c8 01       	movw	r24, r16
    13c4:	b7 01       	movw	r22, r14
    13c6:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    13ca:	7b 01       	movw	r14, r22
    13cc:	8c 01       	movw	r16, r24
    13ce:	60 91 02 09 	lds	r22, 0x0902
    13d2:	70 91 03 09 	lds	r23, 0x0903
    13d6:	80 91 04 09 	lds	r24, 0x0904
    13da:	90 91 05 09 	lds	r25, 0x0905
    13de:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    13e2:	2d 81       	ldd	r18, Y+5	; 0x05
    13e4:	3e 81       	ldd	r19, Y+6	; 0x06
    13e6:	4f 81       	ldd	r20, Y+7	; 0x07
    13e8:	58 85       	ldd	r21, Y+8	; 0x08
    13ea:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    13ee:	9b 01       	movw	r18, r22
    13f0:	ac 01       	movw	r20, r24
    13f2:	c8 01       	movw	r24, r16
    13f4:	b7 01       	movw	r22, r14
    13f6:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    13fa:	7b 01       	movw	r14, r22
    13fc:	8c 01       	movw	r16, r24
    13fe:	60 91 49 0d 	lds	r22, 0x0D49
    1402:	70 91 4a 0d 	lds	r23, 0x0D4A
    1406:	80 91 4b 0d 	lds	r24, 0x0D4B
    140a:	90 91 4c 0d 	lds	r25, 0x0D4C
    140e:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    1412:	29 81       	ldd	r18, Y+1	; 0x01
    1414:	3a 81       	ldd	r19, Y+2	; 0x02
    1416:	4b 81       	ldd	r20, Y+3	; 0x03
    1418:	5c 81       	ldd	r21, Y+4	; 0x04
    141a:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    141e:	9b 01       	movw	r18, r22
    1420:	ac 01       	movw	r20, r24
    1422:	c8 01       	movw	r24, r16
    1424:	b7 01       	movw	r22, r14
    1426:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    142a:	7b 01       	movw	r14, r22
    142c:	8c 01       	movw	r16, r24
    142e:	60 91 1b 03 	lds	r22, 0x031B
    1432:	70 91 1c 03 	lds	r23, 0x031C
    1436:	80 91 1d 03 	lds	r24, 0x031D
    143a:	90 91 1e 03 	lds	r25, 0x031E
    143e:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    1442:	a2 01       	movw	r20, r4
    1444:	91 01       	movw	r18, r2
    1446:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    144a:	9b 01       	movw	r18, r22
    144c:	ac 01       	movw	r20, r24
    144e:	c8 01       	movw	r24, r16
    1450:	b7 01       	movw	r22, r14
    1452:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    1456:	7b 01       	movw	r14, r22
    1458:	8c 01       	movw	r16, r24
    145a:	60 91 32 0d 	lds	r22, 0x0D32
    145e:	70 91 33 0d 	lds	r23, 0x0D33
    1462:	80 91 34 0d 	lds	r24, 0x0D34
    1466:	90 91 35 0d 	lds	r25, 0x0D35
    146a:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    146e:	a4 01       	movw	r20, r8
    1470:	93 01       	movw	r18, r6
    1472:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1476:	9b 01       	movw	r18, r22
    1478:	ac 01       	movw	r20, r24
    147a:	c8 01       	movw	r24, r16
    147c:	b7 01       	movw	r22, r14
    147e:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    1482:	7b 01       	movw	r14, r22
    1484:	8c 01       	movw	r16, r24
    1486:	60 91 06 03 	lds	r22, 0x0306
    148a:	70 91 07 03 	lds	r23, 0x0307
    148e:	80 91 08 03 	lds	r24, 0x0308
    1492:	90 91 09 03 	lds	r25, 0x0309
    1496:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    149a:	a6 01       	movw	r20, r12
    149c:	95 01       	movw	r18, r10
    149e:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    14a2:	9b 01       	movw	r18, r22
    14a4:	ac 01       	movw	r20, r24
    14a6:	c8 01       	movw	r24, r16
    14a8:	b7 01       	movw	r22, r14
    14aa:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    14ae:	60 93 25 09 	sts	0x0925, r22
    14b2:	70 93 26 09 	sts	0x0926, r23
    14b6:	80 93 27 09 	sts	0x0927, r24
    14ba:	90 93 28 09 	sts	0x0928, r25
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
	}
  	percent = 100*(1 - batt_time/discharge_max_time);
    14be:	60 91 25 09 	lds	r22, 0x0925
    14c2:	70 91 26 09 	lds	r23, 0x0926
    14c6:	80 91 27 09 	lds	r24, 0x0927
    14ca:	90 91 28 09 	lds	r25, 0x0928
    14ce:	20 91 f2 06 	lds	r18, 0x06F2
    14d2:	30 91 f3 06 	lds	r19, 0x06F3
    14d6:	40 91 f4 06 	lds	r20, 0x06F4
    14da:	50 91 f5 06 	lds	r21, 0x06F5
    14de:	0e 94 e1 17 	call	0x2fc2	; 0x2fc2 <__divsf3>
    14e2:	9b 01       	movw	r18, r22
    14e4:	ac 01       	movw	r20, r24
    14e6:	60 e0       	ldi	r22, 0x00	; 0
    14e8:	70 e0       	ldi	r23, 0x00	; 0
    14ea:	80 e8       	ldi	r24, 0x80	; 128
    14ec:	9f e3       	ldi	r25, 0x3F	; 63
    14ee:	0e 94 75 17 	call	0x2eea	; 0x2eea <__subsf3>
    14f2:	e6 c0       	rjmp	.+460    	; 0x16c0 <__stack+0x5c1>
  }
  else 
  {
    float temp_real = 0;
    if (real < 13.35)
    14f4:	c4 01       	movw	r24, r8
    14f6:	b3 01       	movw	r22, r6
    14f8:	2a e9       	ldi	r18, 0x9A	; 154
    14fa:	39 e9       	ldi	r19, 0x99	; 153
    14fc:	45 e5       	ldi	r20, 0x55	; 85
    14fe:	51 e4       	ldi	r21, 0x41	; 65
    1500:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <__cmpsf2>
    1504:	88 23       	and	r24, r24
    1506:	0c f0       	brlt	.+2      	; 0x150a <__stack+0x40b>
    1508:	60 c0       	rjmp	.+192    	; 0x15ca <__stack+0x4cb>
	{
	  debug = 0x0C;
    150a:	8c e0       	ldi	r24, 0x0C	; 12
    150c:	80 93 ec 06 	sts	0x06EC, r24
	  // voltage is normalized by mean 13.13 and std 0.1754 (real - 13.13)/0.1754
	  temp_real = (real - 13.13)*5.701254;
    1510:	c4 01       	movw	r24, r8
    1512:	b3 01       	movw	r22, r6
    1514:	2b e7       	ldi	r18, 0x7B	; 123
    1516:	34 e1       	ldi	r19, 0x14	; 20
    1518:	42 e5       	ldi	r20, 0x52	; 82
    151a:	51 e4       	ldi	r21, 0x41	; 65
    151c:	0e 94 75 17 	call	0x2eea	; 0x2eea <__subsf3>
    1520:	2c ea       	ldi	r18, 0xAC	; 172
    1522:	30 e7       	ldi	r19, 0x70	; 112
    1524:	46 eb       	ldi	r20, 0xB6	; 182
    1526:	50 e4       	ldi	r21, 0x40	; 64
    1528:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    152c:	3b 01       	movw	r6, r22
    152e:	4c 01       	movw	r8, r24
	  batt_time = p1*pow(temp_real,3) + p2*pow(temp_real,2) + p3*temp_real + p4;
    1530:	20 e0       	ldi	r18, 0x00	; 0
    1532:	30 e0       	ldi	r19, 0x00	; 0
    1534:	40 e4       	ldi	r20, 0x40	; 64
    1536:	50 e4       	ldi	r21, 0x40	; 64
    1538:	0e 94 1f 1a 	call	0x343e	; 0x343e <pow>
    153c:	5b 01       	movw	r10, r22
    153e:	6c 01       	movw	r12, r24
    1540:	c4 01       	movw	r24, r8
    1542:	b3 01       	movw	r22, r6
    1544:	a4 01       	movw	r20, r8
    1546:	93 01       	movw	r18, r6
    1548:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    154c:	7b 01       	movw	r14, r22
    154e:	8c 01       	movw	r16, r24
    1550:	c6 01       	movw	r24, r12
    1552:	b5 01       	movw	r22, r10
    1554:	20 91 fd 08 	lds	r18, 0x08FD
    1558:	30 91 fe 08 	lds	r19, 0x08FE
    155c:	40 91 ff 08 	lds	r20, 0x08FF
    1560:	50 91 00 09 	lds	r21, 0x0900
    1564:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1568:	5b 01       	movw	r10, r22
    156a:	6c 01       	movw	r12, r24
    156c:	c8 01       	movw	r24, r16
    156e:	b7 01       	movw	r22, r14
    1570:	20 91 22 03 	lds	r18, 0x0322
    1574:	30 91 23 03 	lds	r19, 0x0323
    1578:	40 91 24 03 	lds	r20, 0x0324
    157c:	50 91 25 03 	lds	r21, 0x0325
    1580:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1584:	9b 01       	movw	r18, r22
    1586:	ac 01       	movw	r20, r24
    1588:	c6 01       	movw	r24, r12
    158a:	b5 01       	movw	r22, r10
    158c:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    1590:	7b 01       	movw	r14, r22
    1592:	8c 01       	movw	r16, r24
    1594:	c4 01       	movw	r24, r8
    1596:	b3 01       	movw	r22, r6
    1598:	20 91 41 0d 	lds	r18, 0x0D41
    159c:	30 91 42 0d 	lds	r19, 0x0D42
    15a0:	40 91 43 0d 	lds	r20, 0x0D43
    15a4:	50 91 44 0d 	lds	r21, 0x0D44
    15a8:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    15ac:	9b 01       	movw	r18, r22
    15ae:	ac 01       	movw	r20, r24
    15b0:	c8 01       	movw	r24, r16
    15b2:	b7 01       	movw	r22, r14
    15b4:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    15b8:	20 91 5b 0d 	lds	r18, 0x0D5B
    15bc:	30 91 5c 0d 	lds	r19, 0x0D5C
    15c0:	40 91 5d 0d 	lds	r20, 0x0D5D
    15c4:	50 91 5e 0d 	lds	r21, 0x0D5E
    15c8:	5f c0       	rjmp	.+190    	; 0x1688 <__stack+0x589>
	}
	else 
	{
	  debug = 0x0D;
    15ca:	8d e0       	ldi	r24, 0x0D	; 13
    15cc:	80 93 ec 06 	sts	0x06EC, r24
	  // voltage is normalized by mean 13.7 and std 0.1558 (real - 13.7)/0.1558;
	  temp_real = (real - 13.7)*6.418485;
    15d0:	c4 01       	movw	r24, r8
    15d2:	b3 01       	movw	r22, r6
    15d4:	23 e3       	ldi	r18, 0x33	; 51
    15d6:	33 e3       	ldi	r19, 0x33	; 51
    15d8:	4b e5       	ldi	r20, 0x5B	; 91
    15da:	51 e4       	ldi	r21, 0x41	; 65
    15dc:	0e 94 75 17 	call	0x2eea	; 0x2eea <__subsf3>
    15e0:	2b e3       	ldi	r18, 0x3B	; 59
    15e2:	34 e6       	ldi	r19, 0x64	; 100
    15e4:	4d ec       	ldi	r20, 0xCD	; 205
    15e6:	50 e4       	ldi	r21, 0x40	; 64
    15e8:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    15ec:	3b 01       	movw	r6, r22
    15ee:	4c 01       	movw	r8, r24
      batt_time = q1*pow(temp_real,3) + q2*pow(temp_real,2) + q3*temp_real + q4;
    15f0:	20 e0       	ldi	r18, 0x00	; 0
    15f2:	30 e0       	ldi	r19, 0x00	; 0
    15f4:	40 e4       	ldi	r20, 0x40	; 64
    15f6:	50 e4       	ldi	r21, 0x40	; 64
    15f8:	0e 94 1f 1a 	call	0x343e	; 0x343e <pow>
    15fc:	5b 01       	movw	r10, r22
    15fe:	6c 01       	movw	r12, r24
    1600:	c4 01       	movw	r24, r8
    1602:	b3 01       	movw	r22, r6
    1604:	a4 01       	movw	r20, r8
    1606:	93 01       	movw	r18, r6
    1608:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    160c:	7b 01       	movw	r14, r22
    160e:	8c 01       	movw	r16, r24
    1610:	c6 01       	movw	r24, r12
    1612:	b5 01       	movw	r22, r10
    1614:	20 91 1e 09 	lds	r18, 0x091E
    1618:	30 91 1f 09 	lds	r19, 0x091F
    161c:	40 91 20 09 	lds	r20, 0x0920
    1620:	50 91 21 09 	lds	r21, 0x0921
    1624:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1628:	5b 01       	movw	r10, r22
    162a:	6c 01       	movw	r12, r24
    162c:	c8 01       	movw	r24, r16
    162e:	b7 01       	movw	r22, r14
    1630:	20 91 dd 06 	lds	r18, 0x06DD
    1634:	30 91 de 06 	lds	r19, 0x06DE
    1638:	40 91 df 06 	lds	r20, 0x06DF
    163c:	50 91 e0 06 	lds	r21, 0x06E0
    1640:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    1644:	9b 01       	movw	r18, r22
    1646:	ac 01       	movw	r20, r24
    1648:	c6 01       	movw	r24, r12
    164a:	b5 01       	movw	r22, r10
    164c:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    1650:	7b 01       	movw	r14, r22
    1652:	8c 01       	movw	r16, r24
    1654:	c4 01       	movw	r24, r8
    1656:	b3 01       	movw	r22, r6
    1658:	20 91 1a 09 	lds	r18, 0x091A
    165c:	30 91 1b 09 	lds	r19, 0x091B
    1660:	40 91 1c 09 	lds	r20, 0x091C
    1664:	50 91 1d 09 	lds	r21, 0x091D
    1668:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    166c:	9b 01       	movw	r18, r22
    166e:	ac 01       	movw	r20, r24
    1670:	c8 01       	movw	r24, r16
    1672:	b7 01       	movw	r22, r14
    1674:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    1678:	20 91 51 0d 	lds	r18, 0x0D51
    167c:	30 91 52 0d 	lds	r19, 0x0D52
    1680:	40 91 53 0d 	lds	r20, 0x0D53
    1684:	50 91 54 0d 	lds	r21, 0x0D54
    1688:	0e 94 76 17 	call	0x2eec	; 0x2eec <__addsf3>
    168c:	60 93 25 09 	sts	0x0925, r22
    1690:	70 93 26 09 	sts	0x0926, r23
    1694:	80 93 27 09 	sts	0x0927, r24
    1698:	90 93 28 09 	sts	0x0928, r25
	}
  	percent = 100*(batt_time/charge_max_time);
    169c:	60 91 25 09 	lds	r22, 0x0925
    16a0:	70 91 26 09 	lds	r23, 0x0926
    16a4:	80 91 27 09 	lds	r24, 0x0927
    16a8:	90 91 28 09 	lds	r25, 0x0928
    16ac:	20 91 29 09 	lds	r18, 0x0929
    16b0:	30 91 2a 09 	lds	r19, 0x092A
    16b4:	40 91 2b 09 	lds	r20, 0x092B
    16b8:	50 91 2c 09 	lds	r21, 0x092C
    16bc:	0e 94 e1 17 	call	0x2fc2	; 0x2fc2 <__divsf3>
    16c0:	20 e0       	ldi	r18, 0x00	; 0
    16c2:	30 e0       	ldi	r19, 0x00	; 0
    16c4:	48 ec       	ldi	r20, 0xC8	; 200
    16c6:	52 e4       	ldi	r21, 0x42	; 66
    16c8:	0e 94 bc 19 	call	0x3378	; 0x3378 <__mulsf3>
    16cc:	60 93 e4 06 	sts	0x06E4, r22
    16d0:	70 93 e5 06 	sts	0x06E5, r23
    16d4:	80 93 e6 06 	sts	0x06E6, r24
    16d8:	90 93 e7 06 	sts	0x06E7, r25
  }
  
  // Percent limiting for periodic function
  if (percent < 1) 
    16dc:	e0 90 e4 06 	lds	r14, 0x06E4
    16e0:	f0 90 e5 06 	lds	r15, 0x06E5
    16e4:	00 91 e6 06 	lds	r16, 0x06E6
    16e8:	10 91 e7 06 	lds	r17, 0x06E7
    16ec:	c8 01       	movw	r24, r16
    16ee:	b7 01       	movw	r22, r14
    16f0:	20 e0       	ldi	r18, 0x00	; 0
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	40 e8       	ldi	r20, 0x80	; 128
    16f6:	5f e3       	ldi	r21, 0x3F	; 63
    16f8:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <__cmpsf2>
    16fc:	88 23       	and	r24, r24
    16fe:	34 f4       	brge	.+12     	; 0x170c <__stack+0x60d>
  { 
  	debug2 = 0xA0;
    1700:	80 ea       	ldi	r24, 0xA0	; 160
    1702:	80 93 f8 06 	sts	0x06F8, r24
  	soc = 0; 
    1706:	10 92 5d 0f 	sts	0x0F5D, r1
    170a:	24 c0       	rjmp	.+72     	; 0x1754 <__stack+0x655>
  }
  else if (percent > 99) 
    170c:	c8 01       	movw	r24, r16
    170e:	b7 01       	movw	r22, r14
    1710:	20 e0       	ldi	r18, 0x00	; 0
    1712:	30 e0       	ldi	r19, 0x00	; 0
    1714:	46 ec       	ldi	r20, 0xC6	; 198
    1716:	52 e4       	ldi	r21, 0x42	; 66
    1718:	0e 94 b8 19 	call	0x3370	; 0x3370 <__gesf2>
    171c:	18 16       	cp	r1, r24
    171e:	3c f4       	brge	.+14     	; 0x172e <__stack+0x62f>
  { 
  	debug2 = 0xB0;
    1720:	80 eb       	ldi	r24, 0xB0	; 176
    1722:	80 93 f8 06 	sts	0x06F8, r24
  	soc = 255;
    1726:	8f ef       	ldi	r24, 0xFF	; 255
    1728:	80 93 5d 0f 	sts	0x0F5D, r24
    172c:	13 c0       	rjmp	.+38     	; 0x1754 <__stack+0x655>
  }
  else { 
  	debug2 = 0xC0;
    172e:	80 ec       	ldi	r24, 0xC0	; 192
    1730:	80 93 f8 06 	sts	0x06F8, r24
  	soc = (char)floor((int)(percent)); 
    1734:	c8 01       	movw	r24, r16
    1736:	b7 01       	movw	r22, r14
    1738:	0e 94 49 18 	call	0x3092	; 0x3092 <__fixsfsi>
    173c:	88 27       	eor	r24, r24
    173e:	77 fd       	sbrc	r23, 7
    1740:	80 95       	com	r24
    1742:	98 2f       	mov	r25, r24
    1744:	0e 94 7c 18 	call	0x30f8	; 0x30f8 <__floatsisf>
    1748:	0e 94 b7 18 	call	0x316e	; 0x316e <floor>
    174c:	0e 94 4e 18 	call	0x309c	; 0x309c <__fixunssfsi>
    1750:	60 93 5d 0f 	sts	0x0F5D, r22
  }
}
    1754:	e0 96       	adiw	r28, 0x30	; 48
    1756:	0f b6       	in	r0, 0x3f	; 63
    1758:	f8 94       	cli
    175a:	de bf       	out	0x3e, r29	; 62
    175c:	0f be       	out	0x3f, r0	; 63
    175e:	cd bf       	out	0x3d, r28	; 61
    1760:	cf 91       	pop	r28
    1762:	df 91       	pop	r29
    1764:	1f 91       	pop	r17
    1766:	0f 91       	pop	r16
    1768:	ff 90       	pop	r15
    176a:	ef 90       	pop	r14
    176c:	df 90       	pop	r13
    176e:	cf 90       	pop	r12
    1770:	bf 90       	pop	r11
    1772:	af 90       	pop	r10
    1774:	9f 90       	pop	r9
    1776:	8f 90       	pop	r8
    1778:	7f 90       	pop	r7
    177a:	6f 90       	pop	r6
    177c:	5f 90       	pop	r5
    177e:	4f 90       	pop	r4
    1780:	3f 90       	pop	r3
    1782:	2f 90       	pop	r2
    1784:	08 95       	ret

00001786 <receive_message>:
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}

inline void receive_message( uint8_t uart, uint8_t* message, uint8_t message_size )//was inline
{
    1786:	ff 92       	push	r15
    1788:	0f 93       	push	r16
    178a:	1f 93       	push	r17
    178c:	cf 93       	push	r28
    178e:	df 93       	push	r29
    1790:	f8 2e       	mov	r15, r24
    1792:	eb 01       	movw	r28, r22
  uint8_t command = message[VCP_COMMAND_FIELD];
  uint8_t payload = message[VCP_PAYLOAD_FIELD];
    1794:	89 81       	ldd	r24, Y+1	; 0x01

  switch(command)
    1796:	28 81       	ld	r18, Y
    1798:	23 30       	cpi	r18, 0x03	; 3
    179a:	09 f4       	brne	.+2      	; 0x179e <receive_message+0x18>
    179c:	a4 c0       	rjmp	.+328    	; 0x18e6 <receive_message+0x160>
    179e:	24 30       	cpi	r18, 0x04	; 4
    17a0:	40 f4       	brcc	.+16     	; 0x17b2 <receive_message+0x2c>
    17a2:	21 30       	cpi	r18, 0x01	; 1
    17a4:	c1 f1       	breq	.+112    	; 0x1816 <receive_message+0x90>
    17a6:	c8 2f       	mov	r28, r24
    17a8:	d0 e0       	ldi	r29, 0x00	; 0
    17aa:	22 30       	cpi	r18, 0x02	; 2
    17ac:	08 f0       	brcs	.+2      	; 0x17b0 <receive_message+0x2a>
    17ae:	57 c0       	rjmp	.+174    	; 0x185e <receive_message+0xd8>
    17b0:	0d c0       	rjmp	.+26     	; 0x17cc <receive_message+0x46>
    17b2:	25 30       	cpi	r18, 0x05	; 5
    17b4:	09 f4       	brne	.+2      	; 0x17b8 <receive_message+0x32>
    17b6:	9e c0       	rjmp	.+316    	; 0x18f4 <receive_message+0x16e>
    17b8:	25 30       	cpi	r18, 0x05	; 5
    17ba:	08 f4       	brcc	.+2      	; 0x17be <receive_message+0x38>
    17bc:	98 c0       	rjmp	.+304    	; 0x18ee <receive_message+0x168>
    17be:	26 30       	cpi	r18, 0x06	; 6
    17c0:	09 f4       	brne	.+2      	; 0x17c4 <receive_message+0x3e>
    17c2:	be c0       	rjmp	.+380    	; 0x1940 <receive_message+0x1ba>
    17c4:	27 30       	cpi	r18, 0x07	; 7
    17c6:	09 f0       	breq	.+2      	; 0x17ca <receive_message+0x44>
    17c8:	eb c0       	rjmp	.+470    	; 0x19a0 <receive_message+0x21a>
    17ca:	d2 c0       	rjmp	.+420    	; 0x1970 <receive_message+0x1ea>
  {
    case VCP_COMPONENT_ON:
	
	  // Reset CDH IB Heartbeat timer
	  timer1_counter[1] = CYCLE_COUNTER_2;
    17cc:	8c e2       	ldi	r24, 0x2C	; 44
    17ce:	80 93 4e 0d 	sts	0x0D4E, r24
	  
      if ( svit[payload].switch_num != SW_NULL )
    17d2:	8a e1       	ldi	r24, 0x1A	; 26
    17d4:	90 e0       	ldi	r25, 0x00	; 0
    17d6:	c8 9f       	mul	r28, r24
    17d8:	f0 01       	movw	r30, r0
    17da:	c9 9f       	mul	r28, r25
    17dc:	f0 0d       	add	r31, r0
    17de:	d8 9f       	mul	r29, r24
    17e0:	f0 0d       	add	r31, r0
    17e2:	11 24       	eor	r1, r1
    17e4:	eb 5c       	subi	r30, 0xCB	; 203
    17e6:	fc 4f       	sbci	r31, 0xFC	; 252
    17e8:	81 81       	ldd	r24, Z+1	; 0x01
    17ea:	8f 3f       	cpi	r24, 0xFF	; 255
    17ec:	89 f0       	breq	.+34     	; 0x1810 <receive_message+0x8a>
      {
        switch_on( svit[payload].switch_num );
    17ee:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <switch_on>
        svit[payload].switch_state = 1;
    17f2:	8d e0       	ldi	r24, 0x0D	; 13
    17f4:	90 e0       	ldi	r25, 0x00	; 0
    17f6:	c8 9f       	mul	r28, r24
    17f8:	f0 01       	movw	r30, r0
    17fa:	c9 9f       	mul	r28, r25
    17fc:	f0 0d       	add	r31, r0
    17fe:	d8 9f       	mul	r29, r24
    1800:	f0 0d       	add	r31, r0
    1802:	11 24       	eor	r1, r1
    1804:	ee 0f       	add	r30, r30
    1806:	ff 1f       	adc	r31, r31
    1808:	e9 5c       	subi	r30, 0xC9	; 201
    180a:	fc 4f       	sbci	r31, 0xFC	; 252
    180c:	81 e0       	ldi	r24, 0x01	; 1
    180e:	80 83       	st	Z, r24
      }
      transmit_packet( uart, VCP_ACK, command );
    1810:	8f 2d       	mov	r24, r15
    1812:	62 e0       	ldi	r22, 0x02	; 2
    1814:	c7 c0       	rjmp	.+398    	; 0x19a4 <receive_message+0x21e>
      break;
    case VCP_COMPONENT_OFF:
      if ( svit[payload].switch_num != SW_NULL )
    1816:	c8 2f       	mov	r28, r24
    1818:	d0 e0       	ldi	r29, 0x00	; 0
    181a:	8a e1       	ldi	r24, 0x1A	; 26
    181c:	90 e0       	ldi	r25, 0x00	; 0
    181e:	c8 9f       	mul	r28, r24
    1820:	f0 01       	movw	r30, r0
    1822:	c9 9f       	mul	r28, r25
    1824:	f0 0d       	add	r31, r0
    1826:	d8 9f       	mul	r29, r24
    1828:	f0 0d       	add	r31, r0
    182a:	11 24       	eor	r1, r1
    182c:	eb 5c       	subi	r30, 0xCB	; 203
    182e:	fc 4f       	sbci	r31, 0xFC	; 252
    1830:	81 81       	ldd	r24, Z+1	; 0x01
    1832:	8f 3f       	cpi	r24, 0xFF	; 255
    1834:	81 f0       	breq	.+32     	; 0x1856 <receive_message+0xd0>
      {
        switch_off( svit[payload].switch_num );
    1836:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <switch_off>
        svit[payload].switch_state = 0;
    183a:	8d e0       	ldi	r24, 0x0D	; 13
    183c:	90 e0       	ldi	r25, 0x00	; 0
    183e:	c8 9f       	mul	r28, r24
    1840:	f0 01       	movw	r30, r0
    1842:	c9 9f       	mul	r28, r25
    1844:	f0 0d       	add	r31, r0
    1846:	d8 9f       	mul	r29, r24
    1848:	f0 0d       	add	r31, r0
    184a:	11 24       	eor	r1, r1
    184c:	ee 0f       	add	r30, r30
    184e:	ff 1f       	adc	r31, r31
    1850:	e9 5c       	subi	r30, 0xC9	; 201
    1852:	fc 4f       	sbci	r31, 0xFC	; 252
    1854:	10 82       	st	Z, r1
      }
      transmit_packet( uart, VCP_ACK, command );
    1856:	8f 2d       	mov	r24, r15
    1858:	62 e0       	ldi	r22, 0x02	; 2
    185a:	41 e0       	ldi	r20, 0x01	; 1
    185c:	a4 c0       	rjmp	.+328    	; 0x19a6 <receive_message+0x220>
      break;
    case VCP_POWER_CYCLE:
      if ( svit[payload].switch_num != SW_NULL )
    185e:	8a e1       	ldi	r24, 0x1A	; 26
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	c8 9f       	mul	r28, r24
    1864:	f0 01       	movw	r30, r0
    1866:	c9 9f       	mul	r28, r25
    1868:	f0 0d       	add	r31, r0
    186a:	d8 9f       	mul	r29, r24
    186c:	f0 0d       	add	r31, r0
    186e:	11 24       	eor	r1, r1
    1870:	eb 5c       	subi	r30, 0xCB	; 203
    1872:	fc 4f       	sbci	r31, 0xFC	; 252
    1874:	81 81       	ldd	r24, Z+1	; 0x01
    1876:	8f 3f       	cpi	r24, 0xFF	; 255
    1878:	81 f0       	breq	.+32     	; 0x189a <receive_message+0x114>
      {
        switch_off( svit[payload].switch_num );
    187a:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <switch_off>
        svit[payload].switch_state = 0;
    187e:	8d e0       	ldi	r24, 0x0D	; 13
    1880:	90 e0       	ldi	r25, 0x00	; 0
    1882:	c8 9f       	mul	r28, r24
    1884:	f0 01       	movw	r30, r0
    1886:	c9 9f       	mul	r28, r25
    1888:	f0 0d       	add	r31, r0
    188a:	d8 9f       	mul	r29, r24
    188c:	f0 0d       	add	r31, r0
    188e:	11 24       	eor	r1, r1
    1890:	ee 0f       	add	r30, r30
    1892:	ff 1f       	adc	r31, r31
    1894:	e9 5c       	subi	r30, 0xC9	; 201
    1896:	fc 4f       	sbci	r31, 0xFC	; 252
    1898:	10 82       	st	Z, r1
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    189a:	84 e0       	ldi	r24, 0x04	; 4
    189c:	8a 95       	dec	r24
    189e:	f1 f7       	brne	.-4      	; 0x189c <receive_message+0x116>
      }
      _delay_us(1);
      if ( svit[payload].switch_num != SW_NULL )
    18a0:	8a e1       	ldi	r24, 0x1A	; 26
    18a2:	90 e0       	ldi	r25, 0x00	; 0
    18a4:	c8 9f       	mul	r28, r24
    18a6:	f0 01       	movw	r30, r0
    18a8:	c9 9f       	mul	r28, r25
    18aa:	f0 0d       	add	r31, r0
    18ac:	d8 9f       	mul	r29, r24
    18ae:	f0 0d       	add	r31, r0
    18b0:	11 24       	eor	r1, r1
    18b2:	eb 5c       	subi	r30, 0xCB	; 203
    18b4:	fc 4f       	sbci	r31, 0xFC	; 252
    18b6:	81 81       	ldd	r24, Z+1	; 0x01
    18b8:	8f 3f       	cpi	r24, 0xFF	; 255
    18ba:	89 f0       	breq	.+34     	; 0x18de <receive_message+0x158>
      {
        switch_on( svit[payload].switch_num );
    18bc:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <switch_on>
        svit[payload].switch_state = 1;
    18c0:	8d e0       	ldi	r24, 0x0D	; 13
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	c8 9f       	mul	r28, r24
    18c6:	f0 01       	movw	r30, r0
    18c8:	c9 9f       	mul	r28, r25
    18ca:	f0 0d       	add	r31, r0
    18cc:	d8 9f       	mul	r29, r24
    18ce:	f0 0d       	add	r31, r0
    18d0:	11 24       	eor	r1, r1
    18d2:	ee 0f       	add	r30, r30
    18d4:	ff 1f       	adc	r31, r31
    18d6:	e9 5c       	subi	r30, 0xC9	; 201
    18d8:	fc 4f       	sbci	r31, 0xFC	; 252
    18da:	81 e0       	ldi	r24, 0x01	; 1
    18dc:	80 83       	st	Z, r24
      }
      transmit_packet( uart, VCP_ACK, command );
    18de:	8f 2d       	mov	r24, r15
    18e0:	62 e0       	ldi	r22, 0x02	; 2
    18e2:	42 e0       	ldi	r20, 0x02	; 2
    18e4:	60 c0       	rjmp	.+192    	; 0x19a6 <receive_message+0x220>
      break;
    case VCP_TORQ_CTRL:
      transmit_packet( uart, VCP_ACK, command );
    18e6:	8f 2d       	mov	r24, r15
    18e8:	62 e0       	ldi	r22, 0x02	; 2
    18ea:	43 e0       	ldi	r20, 0x03	; 3
    18ec:	5c c0       	rjmp	.+184    	; 0x19a6 <receive_message+0x220>
      break;
    case VCP_GET_TELEMETRY:
      transmit_packet( uart, VCP_POWER_TELEMETRY, 0);
    18ee:	8f 2d       	mov	r24, r15
    18f0:	60 e0       	ldi	r22, 0x00	; 0
    18f2:	58 c0       	rjmp	.+176    	; 0x19a4 <receive_message+0x21e>
      break;
    case VCP_FORCE_ON:
      if ( svit[payload].switch_num != SW_NULL )
    18f4:	08 2f       	mov	r16, r24
    18f6:	10 e0       	ldi	r17, 0x00	; 0
    18f8:	8a e1       	ldi	r24, 0x1A	; 26
    18fa:	90 e0       	ldi	r25, 0x00	; 0
    18fc:	08 9f       	mul	r16, r24
    18fe:	e0 01       	movw	r28, r0
    1900:	09 9f       	mul	r16, r25
    1902:	d0 0d       	add	r29, r0
    1904:	18 9f       	mul	r17, r24
    1906:	d0 0d       	add	r29, r0
    1908:	11 24       	eor	r1, r1
    190a:	cb 5c       	subi	r28, 0xCB	; 203
    190c:	dc 4f       	sbci	r29, 0xFC	; 252
    190e:	89 81       	ldd	r24, Y+1	; 0x01
    1910:	8f 3f       	cpi	r24, 0xFF	; 255
    1912:	91 f0       	breq	.+36     	; 0x1938 <receive_message+0x1b2>
      {
        switch_on( svit[payload].switch_num );
    1914:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <switch_on>
        svit[payload].switch_state = 1;
    1918:	8d e0       	ldi	r24, 0x0D	; 13
    191a:	90 e0       	ldi	r25, 0x00	; 0
    191c:	08 9f       	mul	r16, r24
    191e:	f0 01       	movw	r30, r0
    1920:	09 9f       	mul	r16, r25
    1922:	f0 0d       	add	r31, r0
    1924:	18 9f       	mul	r17, r24
    1926:	f0 0d       	add	r31, r0
    1928:	11 24       	eor	r1, r1
    192a:	ee 0f       	add	r30, r30
    192c:	ff 1f       	adc	r31, r31
    192e:	e9 5c       	subi	r30, 0xC9	; 201
    1930:	fc 4f       	sbci	r31, 0xFC	; 252
    1932:	81 e0       	ldi	r24, 0x01	; 1
    1934:	80 83       	st	Z, r24
        svit[payload].force_on = 1;  
    1936:	8b 83       	std	Y+3, r24	; 0x03
      }
      transmit_packet( uart, VCP_ACK, command );                                                            
    1938:	8f 2d       	mov	r24, r15
    193a:	62 e0       	ldi	r22, 0x02	; 2
    193c:	45 e0       	ldi	r20, 0x05	; 5
    193e:	33 c0       	rjmp	.+102    	; 0x19a6 <receive_message+0x220>
      break;
    case VCP_CRIT_V_CHANGE:
      if ( svit[payload].switch_num != SW_NULL )
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	2a e1       	ldi	r18, 0x1A	; 26
    1944:	30 e0       	ldi	r19, 0x00	; 0
    1946:	82 9f       	mul	r24, r18
    1948:	d0 01       	movw	r26, r0
    194a:	83 9f       	mul	r24, r19
    194c:	b0 0d       	add	r27, r0
    194e:	92 9f       	mul	r25, r18
    1950:	b0 0d       	add	r27, r0
    1952:	11 24       	eor	r1, r1
    1954:	ab 5c       	subi	r26, 0xCB	; 203
    1956:	bc 4f       	sbci	r27, 0xFC	; 252
    1958:	11 96       	adiw	r26, 0x01	; 1
    195a:	8c 91       	ld	r24, X
    195c:	11 97       	sbiw	r26, 0x01	; 1
    195e:	8f 3f       	cpi	r24, 0xFF	; 255
    1960:	21 f1       	breq	.+72     	; 0x19aa <receive_message+0x224>
      {
        svit[payload].V_upper_limit = message[VCP_PAYLOAD_FIELD + 1];
    1962:	8a 81       	ldd	r24, Y+2	; 0x02
    1964:	16 96       	adiw	r26, 0x06	; 6
    1966:	8c 93       	st	X, r24
        V_upper_val_change= message[VCP_PAYLOAD_FIELD + 1];
    1968:	8a 81       	ldd	r24, Y+2	; 0x02
    196a:	80 93 32 0b 	sts	0x0B32, r24
    196e:	1d c0       	rjmp	.+58     	; 0x19aa <receive_message+0x224>
      }
      //transmit_packet( uart, VCP_ACK, 0);
      break;
        case VCP_CRIT_I_CHANGE:
      if ( svit[payload].switch_num != SW_NULL )
    1970:	90 e0       	ldi	r25, 0x00	; 0
    1972:	2a e1       	ldi	r18, 0x1A	; 26
    1974:	30 e0       	ldi	r19, 0x00	; 0
    1976:	82 9f       	mul	r24, r18
    1978:	d0 01       	movw	r26, r0
    197a:	83 9f       	mul	r24, r19
    197c:	b0 0d       	add	r27, r0
    197e:	92 9f       	mul	r25, r18
    1980:	b0 0d       	add	r27, r0
    1982:	11 24       	eor	r1, r1
    1984:	ab 5c       	subi	r26, 0xCB	; 203
    1986:	bc 4f       	sbci	r27, 0xFC	; 252
    1988:	11 96       	adiw	r26, 0x01	; 1
    198a:	8c 91       	ld	r24, X
    198c:	11 97       	sbiw	r26, 0x01	; 1
    198e:	8f 3f       	cpi	r24, 0xFF	; 255
    1990:	61 f0       	breq	.+24     	; 0x19aa <receive_message+0x224>
      {
        svit[payload].I_upper_limit = message[VCP_PAYLOAD_FIELD + 1];
    1992:	8a 81       	ldd	r24, Y+2	; 0x02
    1994:	1e 96       	adiw	r26, 0x0e	; 14
    1996:	8c 93       	st	X, r24
        I_upper_val_change= message[VCP_PAYLOAD_FIELD + 1];
    1998:	8a 81       	ldd	r24, Y+2	; 0x02
    199a:	80 93 2d 0b 	sts	0x0B2D, r24
    199e:	05 c0       	rjmp	.+10     	; 0x19aa <receive_message+0x224>
      }
      //transmit_packet( uart, VCP_ACK, 0);
      break;
    default:
      transmit_packet( uart, VCP_INVALID_COMMAND, 0 );
    19a0:	8f 2d       	mov	r24, r15
    19a2:	61 e0       	ldi	r22, 0x01	; 1
    19a4:	40 e0       	ldi	r20, 0x00	; 0
    19a6:	0e 94 d7 15 	call	0x2bae	; 0x2bae <transmit_packet>
      break;
  }
}
    19aa:	df 91       	pop	r29
    19ac:	cf 91       	pop	r28
    19ae:	1f 91       	pop	r17
    19b0:	0f 91       	pop	r16
    19b2:	ff 90       	pop	r15
    19b4:	08 95       	ret

000019b6 <limit_check>:
we should at least get the framework set up for limit checking on arbitrary values.
The power board should have upper and lower limits for vsense and csense data, 
and turn off components if their voltage/current is too high. ONLY CHECKS
BATTERY 1 VOLTAGE LINE RIGHT NOW.
*/
void limit_check( void ) {
    19b6:	ef 92       	push	r14
    19b8:	ff 92       	push	r15
    19ba:	0f 93       	push	r16
    19bc:	1f 93       	push	r17
    19be:	cf 93       	push	r28
    19c0:	df 93       	push	r29
	unsigned char sw;
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE) {
    19c2:	e0 90 e4 06 	lds	r14, 0x06E4
    19c6:	f0 90 e5 06 	lds	r15, 0x06E5
    19ca:	00 91 e6 06 	lds	r16, 0x06E6
    19ce:	10 91 e7 06 	lds	r17, 0x06E7
    19d2:	c8 01       	movw	r24, r16
    19d4:	b7 01       	movw	r22, r14
    19d6:	20 e0       	ldi	r18, 0x00	; 0
    19d8:	30 e0       	ldi	r19, 0x00	; 0
    19da:	40 e1       	ldi	r20, 0x10	; 16
    19dc:	51 e4       	ldi	r21, 0x41	; 65
    19de:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <__cmpsf2>
    19e2:	88 23       	and	r24, r24
    19e4:	c4 f5       	brge	.+112    	; 0x1a56 <limit_check+0xa0>
		safe_mode = 1;
    19e6:	81 e0       	ldi	r24, 0x01	; 1
    19e8:	80 93 06 09 	sts	0x0906, r24
    19ec:	0b e0       	ldi	r16, 0x0B	; 11
    19ee:	13 e0       	ldi	r17, 0x03	; 3
		for (sw = 0; sw < sizeof(components); sw++) {
			component = &svit[components[sw]];
    19f0:	ba e1       	ldi	r27, 0x1A	; 26
    19f2:	fb 2e       	mov	r15, r27
    19f4:	f8 01       	movw	r30, r16
    19f6:	81 91       	ld	r24, Z+
    19f8:	8f 01       	movw	r16, r30
    19fa:	8f 9d       	mul	r24, r15
    19fc:	e0 01       	movw	r28, r0
    19fe:	11 24       	eor	r1, r1
    1a00:	cb 5c       	subi	r28, 0xCB	; 203
    1a02:	dc 4f       	sbci	r29, 0xFC	; 252
			switch_off( component->switch_num );
    1a04:	89 81       	ldd	r24, Y+1	; 0x01
    1a06:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <switch_off>
			component->switch_state = SW_OFF;
    1a0a:	1a 82       	std	Y+2, r1	; 0x02
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE) {
		safe_mode = 1;
		for (sw = 0; sw < sizeof(components); sw++) {
    1a0c:	f3 e0       	ldi	r31, 0x03	; 3
    1a0e:	0b 31       	cpi	r16, 0x1B	; 27
    1a10:	1f 07       	cpc	r17, r31
    1a12:	81 f7       	brne	.-32     	; 0x19f4 <limit_check+0x3e>
			component = &svit[components[sw]];
			switch_off( component->switch_num );
			component->switch_state = SW_OFF;
		}
		component = &svit[TORQUER_1];
		component->switch_state = SW_OFF;
    1a14:	10 92 f1 04 	sts	0x04F1, r1
		component = &svit[TORQUER_2];
		component->switch_state = SW_OFF;
    1a18:	10 92 0b 05 	sts	0x050B, r1
		component = &svit[TORQUER_3];
		component->switch_state = SW_OFF;
    1a1c:	10 92 25 05 	sts	0x0525, r1
		torquer_off(TORQUER_1);
    1a20:	81 e1       	ldi	r24, 0x11	; 17
    1a22:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <torquer_off>
		torquer_off(TORQUER_2);
    1a26:	82 e1       	ldi	r24, 0x12	; 18
    1a28:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <torquer_off>
		torquer_off(TORQUER_3);
    1a2c:	83 e1       	ldi	r24, 0x13	; 19
    1a2e:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <torquer_off>
		// Only transmit once
		if (!transmit_safe && !been_to_safe) { 
    1a32:	80 91 01 09 	lds	r24, 0x0901
    1a36:	88 23       	and	r24, r24
    1a38:	41 f4       	brne	.+16     	; 0x1a4a <limit_check+0x94>
    1a3a:	80 91 2e 03 	lds	r24, 0x032E
    1a3e:	88 23       	and	r24, r24
    1a40:	21 f4       	brne	.+8      	; 0x1a4a <limit_check+0x94>
			transmit_packet( 0, VCP_ACK, SAFE_MODE);
    1a42:	62 e0       	ldi	r22, 0x02	; 2
    1a44:	49 e0       	ldi	r20, 0x09	; 9
    1a46:	0e 94 d7 15 	call	0x2bae	; 0x2bae <transmit_packet>
			transmit_safe = 1;
		}
		else {}
		been_to_safe = 1;
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
    1a4c:	80 93 2e 03 	sts	0x032E, r24
		transmit_safe = 1;
    1a50:	80 93 01 09 	sts	0x0901, r24
    1a54:	24 c0       	rjmp	.+72     	; 0x1a9e <limit_check+0xe8>
	}
	else if (percent > SHUNT_MODE) {
    1a56:	c8 01       	movw	r24, r16
    1a58:	b7 01       	movw	r22, r14
    1a5a:	20 e0       	ldi	r18, 0x00	; 0
    1a5c:	30 e0       	ldi	r19, 0x00	; 0
    1a5e:	44 eb       	ldi	r20, 0xB4	; 180
    1a60:	52 e4       	ldi	r21, 0x42	; 66
    1a62:	0e 94 b8 19 	call	0x3370	; 0x3370 <__gesf2>
    1a66:	18 16       	cp	r1, r24
    1a68:	d4 f4       	brge	.+52     	; 0x1a9e <limit_check+0xe8>
	    safe_mode = 0;
    1a6a:	10 92 06 09 	sts	0x0906, r1
		// turn on the maestro and send ack_command w/ value of SHUNT_MODE
		component = &svit[MAESTRO];
		switch_on( component->switch_num );
    1a6e:	80 91 88 04 	lds	r24, 0x0488
    1a72:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <switch_on>
		component->switch_state = SW_ON;
    1a76:	81 e0       	ldi	r24, 0x01	; 1
    1a78:	80 93 89 04 	sts	0x0489, r24
		// Only transmit once
		if (!transmit_shunt && !been_to_shunt) {
    1a7c:	80 91 3a 0d 	lds	r24, 0x0D3A
    1a80:	88 23       	and	r24, r24
    1a82:	41 f4       	brne	.+16     	; 0x1a94 <limit_check+0xde>
    1a84:	80 91 24 09 	lds	r24, 0x0924
    1a88:	88 23       	and	r24, r24
    1a8a:	21 f4       	brne	.+8      	; 0x1a94 <limit_check+0xde>
			transmit_packet( 0, VCP_ACK, SHUNT_MODE);
    1a8c:	62 e0       	ldi	r22, 0x02	; 2
    1a8e:	4a e5       	ldi	r20, 0x5A	; 90
    1a90:	0e 94 d7 15 	call	0x2bae	; 0x2bae <transmit_packet>
		}
		else {}	
		been_to_shunt = 1;
    1a94:	81 e0       	ldi	r24, 0x01	; 1
    1a96:	80 93 24 09 	sts	0x0924, r24
		transmit_shunt = 1;	
    1a9a:	80 93 3a 0d 	sts	0x0D3A, r24
	}
	else {} // To avoid annoying compile warning 
}
    1a9e:	df 91       	pop	r29
    1aa0:	cf 91       	pop	r28
    1aa2:	1f 91       	pop	r17
    1aa4:	0f 91       	pop	r16
    1aa6:	ff 90       	pop	r15
    1aa8:	ef 90       	pop	r14
    1aaa:	08 95       	ret

00001aac <compareVoltage>:
void compareVoltage( void ) {
  SVIT_t *component;
  //component = &svit[BATTERY_1_b];
  //chargebackward = average_samples( component->I_samples );
  component = &svit[BATTERY_1];
  chargeforward= average_samples( component->I_samples );
    1aac:	8c e4       	ldi	r24, 0x4C	; 76
    1aae:	95 e0       	ldi	r25, 0x05	; 5
    1ab0:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
    1ab4:	80 93 50 0d 	sts	0x0D50, r24
  if (chargeforward > 2){
    1ab8:	83 30       	cpi	r24, 0x03	; 3
    1aba:	10 f0       	brcs	.+4      	; 0x1ac0 <compareVoltage+0x14>
    charging = 0xdd;//discharging
    1abc:	8d ed       	ldi	r24, 0xDD	; 221
    1abe:	01 c0       	rjmp	.+2      	; 0x1ac2 <compareVoltage+0x16>
    }
  else{
    charging = 0xcc;
    1ac0:	8c ec       	ldi	r24, 0xCC	; 204
    1ac2:	80 93 ed 06 	sts	0x06ED, r24
    1ac6:	08 95       	ret

00001ac8 <initialize>:
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE,    MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE,    MUX2    ,       6     );  // Fake Data
}

void initialize( void )
{
    1ac8:	ef 92       	push	r14
    1aca:	ff 92       	push	r15
    1acc:	0f 93       	push	r16
    1ace:	1f 93       	push	r17
   // pin initialization
  DDRA  = 0b11111111;
    1ad0:	9f ef       	ldi	r25, 0xFF	; 255
    1ad2:	9a bb       	out	0x1a, r25	; 26
  PORTA = 0b00000111;
    1ad4:	87 e0       	ldi	r24, 0x07	; 7
    1ad6:	8b bb       	out	0x1b, r24	; 27

  DDRB  = 0b11111111;
    1ad8:	97 bb       	out	0x17, r25	; 23
  PORTB = 0b11100000;
    1ada:	80 ee       	ldi	r24, 0xE0	; 224
    1adc:	88 bb       	out	0x18, r24	; 24

  DDRC  = 0b11111111;
    1ade:	94 bb       	out	0x14, r25	; 20
  PORTC = 0b11111111;
    1ae0:	95 bb       	out	0x15, r25	; 21

  DDRD  = 0b11111011;
    1ae2:	8b ef       	ldi	r24, 0xFB	; 251
    1ae4:	81 bb       	out	0x11, r24	; 17
  PORTD = 0b11110000;
    1ae6:	90 ef       	ldi	r25, 0xF0	; 240
    1ae8:	92 bb       	out	0x12, r25	; 18

  DDRE  = 0b11111110;
    1aea:	8e ef       	ldi	r24, 0xFE	; 254
    1aec:	82 b9       	out	0x02, r24	; 2
  PORTE = 0b00000000;
    1aee:	13 b8       	out	0x03, r1	; 3

  DDRF  = 0b11110000;
    1af0:	90 93 61 00 	sts	0x0061, r25
  //0b11111111;	//testing
  PORTF = 0b00000000;
    1af4:	10 92 62 00 	sts	0x0062, r1

  DDRG  = 0b00011111;
    1af8:	8f e1       	ldi	r24, 0x1F	; 31
    1afa:	80 93 64 00 	sts	0x0064, r24
  PORTG = 0b00000100;
    1afe:	84 e0       	ldi	r24, 0x04	; 4
    1b00:	80 93 65 00 	sts	0x0065, r24
  // compare value = 124
  // compare match interrupt freq = (14.7456 MHz / 1024 / 100) = 144 Hz
  // use timer0_counter to get 144 / 144 = 1 Hz

  // enable clear on match interrupt
  TIMSK = ( 1 << OCIE0 );
    1b04:	82 e0       	ldi	r24, 0x02	; 2
    1b06:	87 bf       	out	0x37, r24	; 55
  OCR0 = 71;
    1b08:	87 e4       	ldi	r24, 0x47	; 71
    1b0a:	81 bf       	out	0x31, r24	; 49

  // enable clear on match mode, set prescalar to 1024
  TCCR0 = ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );
    1b0c:	8f e0       	ldi	r24, 0x0F	; 15
    1b0e:	83 bf       	out	0x33, r24	; 51

  timer0_counter[0] = 99;
    1b10:	83 e6       	ldi	r24, 0x63	; 99
    1b12:	80 93 2b 0b 	sts	0x0B2B, r24
  timer0_counter[1] = 199;
    1b16:	87 ec       	ldi	r24, 0xC7	; 199
    1b18:	80 93 2c 0b 	sts	0x0B2C, r24
  period of interrupts = 28800 / 14400 Hz = 2 s/interrupt
  use timer1_counter to get a total period of 2*65535 =  s (24 hours is 86400 seconds)
  */
  
  // Enable clear on match interrupt for the 16 bit timer/counter 1, register A
  OCR1A = 28800;		//28800 corresponds to 2 seconds
    1b1c:	80 e8       	ldi	r24, 0x80	; 128
    1b1e:	90 e7       	ldi	r25, 0x70	; 112
    1b20:	9b bd       	out	0x2b, r25	; 43
    1b22:	8a bd       	out	0x2a, r24	; 42

  // Enable clear on match mode, set prescalar to 1024.
  // CS[2:0] = 101 (1024 prescalar)
  // WGM[3:0] = 0100 (Clear Timer on Compare (CTC) when timer matches OCR1A)
  
  TCCR1B = ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS10 );
    1b24:	8d e0       	ldi	r24, 0x0D	; 13
    1b26:	8e bd       	out	0x2e, r24	; 46
  // Explicit Default Defs
  // TCCR1A |= 0;
  // TCNT1 = 0;
  timer1_counter[0] = CYCLE_COUNTER;	//CYCLE_COUNTER   = 900 for 2 seconds interrupt handler = 1800 secs (30 minutes)
    1b28:	84 e8       	ldi	r24, 0x84	; 132
    1b2a:	80 93 4d 0d 	sts	0x0D4D, r24
  timer1_counter[1] = CYCLE_COUNTER_2;	//CYCLE_COUNTER_2 = 300 for 2 seconds interrupt handler = 600 secs  (10 minutes)
    1b2e:	8c e2       	ldi	r24, 0x2C	; 44
    1b30:	80 93 4e 0d 	sts	0x0D4E, r24
  //---------------------------------------------------------------------  
  // End of timer 1 Setup
  //--------------------------------------------------------------------- 
  
  // communication
  uart_init();
    1b34:	0e 94 53 11 	call	0x22a6	; 0x22a6 <uart_init>

  // for use in debugging
  // stdout = stdin = stderr = &uart_str;

  tel_packet_size[0] = 0;
    1b38:	10 92 27 03 	sts	0x0327, r1
    1b3c:	10 92 26 03 	sts	0x0326, r1
  tel_packet_size[1] = 0;
    1b40:	10 92 29 03 	sts	0x0329, r1
    1b44:	10 92 28 03 	sts	0x0328, r1
  tel_packet_index[0] = 0;
    1b48:	10 92 f6 06 	sts	0x06F6, r1
  tel_packet_index[1] = 0;
    1b4c:	10 92 f7 06 	sts	0x06F7, r1
  uart_vcp_buff[0] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
    1b50:	8a e0       	ldi	r24, 0x0A	; 10
    1b52:	90 e0       	ldi	r25, 0x00	; 0
    1b54:	0e 94 b4 1b 	call	0x3768	; 0x3768 <malloc>
    1b58:	80 93 55 0d 	sts	0x0D55, r24
    1b5c:	90 93 56 0d 	sts	0x0D56, r25
  uart_vcp_buff[1] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
    1b60:	8a e0       	ldi	r24, 0x0A	; 10
    1b62:	90 e0       	ldi	r25, 0x00	; 0
    1b64:	0e 94 b4 1b 	call	0x3768	; 0x3768 <malloc>
    1b68:	80 93 57 0d 	sts	0x0D57, r24
    1b6c:	90 93 58 0d 	sts	0x0D58, r25
  vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
    1b70:	80 91 55 0d 	lds	r24, 0x0D55
    1b74:	90 91 56 0d 	lds	r25, 0x0D56
    1b78:	64 e3       	ldi	r22, 0x34	; 52
    1b7a:	7b e0       	ldi	r23, 0x0B	; 11
    1b7c:	4f ef       	ldi	r20, 0xFF	; 255
    1b7e:	50 e0       	ldi	r21, 0x00	; 0
    1b80:	0e 94 7d 11 	call	0x22fa	; 0x22fa <vcpptr_init>
  vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
    1b84:	80 91 57 0d 	lds	r24, 0x0D57
    1b88:	90 91 58 0d 	lds	r25, 0x0D58
    1b8c:	63 e3       	ldi	r22, 0x33	; 51
    1b8e:	7c e0       	ldi	r23, 0x0C	; 12
    1b90:	4f ef       	ldi	r20, 0xFF	; 255
    1b92:	50 e0       	ldi	r21, 0x00	; 0
    1b94:	0e 94 7d 11 	call	0x22fa	; 0x22fa <vcpptr_init>

  rx_flag[0] = 0;
    1b98:	10 92 59 0d 	sts	0x0D59, r1
  rx_flag[1] = 0;
    1b9c:	10 92 5a 0d 	sts	0x0D5A, r1

  // svit
  initialize_svit();
    1ba0:	0e 94 b7 00 	call	0x16e	; 0x16e <initialize_svit>

  // rev up those interrupts
  sei();
    1ba4:	78 94       	sei

  //ADC conversions
  adc_flag = 1;
    1ba6:	11 e0       	ldi	r17, 0x01	; 1
    1ba8:	10 93 fc 08 	sts	0x08FC, r17
	adc_component = 0;
    1bac:	10 92 34 03 	sts	0x0334, r1
	adc_sensor_type = ADC_INIT;//get default case on first interation as to not enter switch
    1bb0:	84 e0       	ldi	r24, 0x04	; 4
    1bb2:	80 93 09 09 	sts	0x0909, r24
  ADC_high = 0;
    1bb6:	10 92 19 09 	sts	0x0919, r1

  V_upper_val_change = 0;
    1bba:	10 92 32 0b 	sts	0x0B32, r1
  I_upper_val_change = 0;
    1bbe:	10 92 2d 0b 	sts	0x0B2D, r1

  //---------------------------------------------------------------------  
  // SOC Initializations
  //--------------------------------------------------------------------- 
  // and shunt and safe transmit flags
  safe_mode = 0;
    1bc2:	10 92 06 09 	sts	0x0906, r1
  transmit_safe = 0;
    1bc6:	10 92 01 09 	sts	0x0901, r1
  transmit_shunt = 0;
    1bca:	10 92 3a 0d 	sts	0x0D3A, r1
  been_to_safe = 0;
    1bce:	10 92 2e 03 	sts	0x032E, r1
  been_to_shunt = 0;
    1bd2:	10 92 24 09 	sts	0x0924, r1
  assign_charge_fit();
    1bd6:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <assign_charge_fit>
  assign_discharge_fit();
    1bda:	0e 94 58 06 	call	0xcb0	; 0xcb0 <assign_discharge_fit>
  
  // First get battery voltage so that the SoC can
  // accurately determine whether batteries are charging or discharging
  batt1_voltage = 0xff;
    1bde:	8f ef       	ldi	r24, 0xFF	; 255
    1be0:	80 93 23 09 	sts	0x0923, r24
  batt2_voltage = 0xff;
    1be4:	80 93 33 0b 	sts	0x0B33, r24
  charging = 0xff;
    1be8:	80 93 ed 06 	sts	0x06ED, r24
  chargeforward = 0;
    1bec:	10 92 50 0d 	sts	0x0D50, r1
  chargebackward = 0;
    1bf0:	10 92 33 03 	sts	0x0333, r1
  debug = 0;
    1bf4:	10 92 ec 06 	sts	0x06EC, r1
  debug2 = 0;
    1bf8:	10 92 f8 06 	sts	0x06F8, r1
  percent = 0;
    1bfc:	80 e0       	ldi	r24, 0x00	; 0
    1bfe:	90 e0       	ldi	r25, 0x00	; 0
    1c00:	a0 e0       	ldi	r26, 0x00	; 0
    1c02:	b0 e0       	ldi	r27, 0x00	; 0
    1c04:	80 93 e4 06 	sts	0x06E4, r24
    1c08:	90 93 e5 06 	sts	0x06E5, r25
    1c0c:	a0 93 e6 06 	sts	0x06E6, r26
    1c10:	b0 93 e7 06 	sts	0x06E7, r27
  soc = 0;
    1c14:	10 92 5d 0f 	sts	0x0F5D, r1
  high = 0;
    1c18:	10 92 14 09 	sts	0x0914, r1
  low = 0;
    1c1c:	10 92 22 09 	sts	0x0922, r1
  limit_check_overriden = 0; // Initially limit checking is NOT OVERRIDEN
    1c20:	10 92 e3 06 	sts	0x06E3, r1
  //--------------------------------------------------------------------- 

  //---------------------------------------------------------------------  
  // Timer Initializations
  //---------------------------------------------------------------------
  cdh_heartbeat_flag = 0;	//Default: do not have flag to restart components on
    1c24:	10 92 21 03 	sts	0x0321, r1
  rad_torq_flag = 1;		//Indicates need to delay radio/torquer on signals later
    1c28:	10 93 0a 03 	sts	0x030A, r17
  SVIT_t *component; 	// Initialize Radios to be OFF
  component = &svit[components[RADIO_1]];
  switch_off( component->switch_num );
    1c2c:	80 91 16 03 	lds	r24, 0x0316
    1c30:	90 e0       	ldi	r25, 0x00	; 0
    1c32:	1a e1       	ldi	r17, 0x1A	; 26
    1c34:	e1 2e       	mov	r14, r17
    1c36:	f1 2c       	mov	r15, r1
    1c38:	8e 9d       	mul	r24, r14
    1c3a:	f0 01       	movw	r30, r0
    1c3c:	8f 9d       	mul	r24, r15
    1c3e:	f0 0d       	add	r31, r0
    1c40:	9e 9d       	mul	r25, r14
    1c42:	f0 0d       	add	r31, r0
    1c44:	11 24       	eor	r1, r1
    1c46:	05 e3       	ldi	r16, 0x35	; 53
    1c48:	13 e0       	ldi	r17, 0x03	; 3
    1c4a:	e0 0f       	add	r30, r16
    1c4c:	f1 1f       	adc	r31, r17
    1c4e:	81 81       	ldd	r24, Z+1	; 0x01
    1c50:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <switch_off>
  component = &svit[components[RADIO_2]];
  switch_off( component->switch_num );
    1c54:	80 91 17 03 	lds	r24, 0x0317
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	9c 01       	movw	r18, r24
    1c5c:	2e 9d       	mul	r18, r14
    1c5e:	c0 01       	movw	r24, r0
    1c60:	2f 9d       	mul	r18, r15
    1c62:	90 0d       	add	r25, r0
    1c64:	3e 9d       	mul	r19, r14
    1c66:	90 0d       	add	r25, r0
    1c68:	11 24       	eor	r1, r1
    1c6a:	08 0f       	add	r16, r24
    1c6c:	19 1f       	adc	r17, r25
    1c6e:	f8 01       	movw	r30, r16
    1c70:	81 81       	ldd	r24, Z+1	; 0x01
    1c72:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <switch_off>
  component = &svit[TORQUER_1];	// Initialize Torque Coils to be OFF
  component->switch_state = SW_OFF;
    1c76:	10 92 f1 04 	sts	0x04F1, r1
  component = &svit[TORQUER_2];
  component->switch_state = SW_OFF;
    1c7a:	10 92 0b 05 	sts	0x050B, r1
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
    1c7e:	10 92 25 05 	sts	0x0525, r1
  torquer_off(TORQUER_1);
    1c82:	81 e1       	ldi	r24, 0x11	; 17
    1c84:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <torquer_off>
  torquer_off(TORQUER_2);
    1c88:	82 e1       	ldi	r24, 0x12	; 18
    1c8a:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <torquer_off>
  torquer_off(TORQUER_3);
    1c8e:	83 e1       	ldi	r24, 0x13	; 19
    1c90:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <torquer_off>
  //---------------------------------------------------------------------  
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}
    1c94:	1f 91       	pop	r17
    1c96:	0f 91       	pop	r16
    1c98:	ff 90       	pop	r15
    1c9a:	ef 90       	pop	r14
    1c9c:	08 95       	ret

00001c9e <main>:
		component->switch_state = SW_ON;
	}
}

int main( void ) 
{  
    1c9e:	ff 92       	push	r15
    1ca0:	0f 93       	push	r16
    1ca2:	1f 93       	push	r17
  initialize();
    1ca4:	0e 94 64 0d 	call	0x1ac8	; 0x1ac8 <initialize>
  //fprintf( stdout, "uart initialized\n" );
	
  //Testing
  cntr = 0;
    1ca8:	10 92 fb 08 	sts	0x08FB, r1

  while(1)
  {
	cntr = 1 - cntr; //Testing
    1cac:	ff 24       	eor	r15, r15
    1cae:	f3 94       	inc	r15
	
    if ( timer0_counter[1] == 0 )
    {
        timer0_counter[1] = 199;
    1cb0:	17 ec       	ldi	r17, 0xC7	; 199
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
    1cb2:	0c e2       	ldi	r16, 0x2C	; 44
  //Testing
  cntr = 0;

  while(1)
  {
	cntr = 1 - cntr; //Testing
    1cb4:	80 91 fb 08 	lds	r24, 0x08FB
    1cb8:	9f 2d       	mov	r25, r15
    1cba:	98 1b       	sub	r25, r24
    1cbc:	90 93 fb 08 	sts	0x08FB, r25
	
    if ( timer0_counter[1] == 0 )
    1cc0:	80 91 2c 0b 	lds	r24, 0x0B2C
    1cc4:	88 23       	and	r24, r24
    1cc6:	39 f4       	brne	.+14     	; 0x1cd6 <main+0x38>
    {
        timer0_counter[1] = 199;
    1cc8:	10 93 2c 0b 	sts	0x0B2C, r17
        transmit_packet( 1, VCP_POWER_TELEMETRY, 0);
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	60 e0       	ldi	r22, 0x00	; 0
    1cd0:	40 e0       	ldi	r20, 0x00	; 0
    1cd2:	0e 94 d7 15 	call	0x2bae	; 0x2bae <transmit_packet>
    }
	  if ( timer0_counter[0] == 0 )
    1cd6:	80 91 2b 0b 	lds	r24, 0x0B2B
    1cda:	88 23       	and	r24, r24
    1cdc:	31 f4       	brne	.+12     	; 0x1cea <main+0x4c>
    {
        timer0_counter[0] = 199;
    1cde:	10 93 2b 0b 	sts	0x0B2B, r17
        transmit_packet( 0, VCP_POWER_TELEMETRY, 0);
    1ce2:	60 e0       	ldi	r22, 0x00	; 0
    1ce4:	40 e0       	ldi	r20, 0x00	; 0
    1ce6:	0e 94 d7 15 	call	0x2bae	; 0x2bae <transmit_packet>
    }
	  if ( rx_flag[0] > 0 )
    1cea:	80 91 59 0d 	lds	r24, 0x0D59
    1cee:	88 23       	and	r24, r24
    1cf0:	c9 f0       	breq	.+50     	; 0x1d24 <main+0x86>
    {
        rx_flag[0]--;
    1cf2:	80 91 59 0d 	lds	r24, 0x0D59
    1cf6:	81 50       	subi	r24, 0x01	; 1
    1cf8:	80 93 59 0d 	sts	0x0D59, r24
        receive_message( 0, uart_vcp_buff[0]->message, uart_vcp_buff[0]->index );
    1cfc:	e0 91 55 0d 	lds	r30, 0x0D55
    1d00:	f0 91 56 0d 	lds	r31, 0x0D56
    1d04:	61 81       	ldd	r22, Z+1	; 0x01
    1d06:	72 81       	ldd	r23, Z+2	; 0x02
    1d08:	80 e0       	ldi	r24, 0x00	; 0
    1d0a:	47 81       	ldd	r20, Z+7	; 0x07
    1d0c:	0e 94 c3 0b 	call	0x1786	; 0x1786 <receive_message>
        vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
    1d10:	80 91 55 0d 	lds	r24, 0x0D55
    1d14:	90 91 56 0d 	lds	r25, 0x0D56
    1d18:	64 e3       	ldi	r22, 0x34	; 52
    1d1a:	7b e0       	ldi	r23, 0x0B	; 11
    1d1c:	4f ef       	ldi	r20, 0xFF	; 255
    1d1e:	50 e0       	ldi	r21, 0x00	; 0
    1d20:	0e 94 7d 11 	call	0x22fa	; 0x22fa <vcpptr_init>
    }
	  if ( rx_flag[1] > 0 )
    1d24:	80 91 5a 0d 	lds	r24, 0x0D5A
    1d28:	88 23       	and	r24, r24
    1d2a:	c9 f0       	breq	.+50     	; 0x1d5e <main+0xc0>
    {
        rx_flag[1]--;
    1d2c:	80 91 5a 0d 	lds	r24, 0x0D5A
    1d30:	81 50       	subi	r24, 0x01	; 1
    1d32:	80 93 5a 0d 	sts	0x0D5A, r24
        receive_message( 1, uart_vcp_buff[1]->message, uart_vcp_buff[1]->index );
    1d36:	e0 91 57 0d 	lds	r30, 0x0D57
    1d3a:	f0 91 58 0d 	lds	r31, 0x0D58
    1d3e:	61 81       	ldd	r22, Z+1	; 0x01
    1d40:	72 81       	ldd	r23, Z+2	; 0x02
    1d42:	81 e0       	ldi	r24, 0x01	; 1
    1d44:	47 81       	ldd	r20, Z+7	; 0x07
    1d46:	0e 94 c3 0b 	call	0x1786	; 0x1786 <receive_message>
        vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
    1d4a:	80 91 57 0d 	lds	r24, 0x0D57
    1d4e:	90 91 58 0d 	lds	r25, 0x0D58
    1d52:	63 e3       	ldi	r22, 0x33	; 51
    1d54:	7c e0       	ldi	r23, 0x0C	; 12
    1d56:	4f ef       	ldi	r20, 0xFF	; 255
    1d58:	50 e0       	ldi	r21, 0x00	; 0
    1d5a:	0e 94 7d 11 	call	0x22fa	; 0x22fa <vcpptr_init>
    }
    if (adc_flag == 1)
    1d5e:	80 91 fc 08 	lds	r24, 0x08FC
    1d62:	81 30       	cpi	r24, 0x01	; 1
    1d64:	91 f4       	brne	.+36     	; 0x1d8a <main+0xec>
    {
        adc_flag = 0;
    1d66:	10 92 fc 08 	sts	0x08FC, r1
        read_VIT();
    1d6a:	0e 94 54 10 	call	0x20a8	; 0x20a8 <read_VIT>
		calcSOC();
    1d6e:	0e 94 2b 07 	call	0xe56	; 0xe56 <calcSOC>

		/*
		Manual Override on Limit Checking: The power board must be able to receive a 
		command to disable and/or change the limits in the limit checking code
		*/
		if (!limit_check_overriden) {
    1d72:	80 91 e3 06 	lds	r24, 0x06E3
    1d76:	88 23       	and	r24, r24
    1d78:	11 f4       	brne	.+4      	; 0x1d7e <main+0xe0>
			limit_check(); // First determine if voltage is within valid range, then switch
    1d7a:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <limit_check>
		}

		if ( adc_component == 23 ) 
    1d7e:	80 91 34 03 	lds	r24, 0x0334
    1d82:	87 31       	cpi	r24, 0x17	; 23
    1d84:	11 f4       	brne	.+4      	; 0x1d8a <main+0xec>
      	{ //23ish anything after battery values are calculated
  			  compareVoltage();
    1d86:	0e 94 56 0d 	call	0x1aac	; 0x1aac <compareVoltage>
	   	}
    }	
	
	//Restart all board components if CDH-IB heartbeat timeout
	if (cdh_heartbeat_flag == 1){
    1d8a:	80 91 21 03 	lds	r24, 0x0321
    1d8e:	81 30       	cpi	r24, 0x01	; 1
    1d90:	09 f0       	breq	.+2      	; 0x1d94 <main+0xf6>
    1d92:	90 cf       	rjmp	.-224    	; 0x1cb4 <main+0x16>
		//Restart all components
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
    1d94:	10 92 21 03 	sts	0x0321, r1
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
    1d98:	00 93 4e 0d 	sts	0x0D4E, r16
    1d9c:	8b cf       	rjmp	.-234    	; 0x1cb4 <main+0x16>

00001d9e <set_mux_sel>:
#include "mcupwr-Defs.h"


void set_mux_sel( uint8_t mux_num, uint8_t mux_sel )
{
  switch( mux_num )
    1d9e:	81 30       	cpi	r24, 0x01	; 1
    1da0:	61 f1       	breq	.+88     	; 0x1dfa <set_mux_sel+0x5c>
    1da2:	81 30       	cpi	r24, 0x01	; 1
    1da4:	20 f0       	brcs	.+8      	; 0x1dae <set_mux_sel+0x10>
    1da6:	82 30       	cpi	r24, 0x02	; 2
    1da8:	09 f0       	breq	.+2      	; 0x1dac <set_mux_sel+0xe>
    1daa:	72 c0       	rjmp	.+228    	; 0x1e90 <set_mux_sel+0xf2>
    1dac:	4c c0       	rjmp	.+152    	; 0x1e46 <set_mux_sel+0xa8>
  {
    case MUX0:
      READ( mux_sel, 4 ) ? SET( PORTA, 7 ) : CLR( PORTA, 7 );
    1dae:	86 2f       	mov	r24, r22
    1db0:	82 95       	swap	r24
    1db2:	8f 70       	andi	r24, 0x0F	; 15
    1db4:	80 ff       	sbrs	r24, 0
    1db6:	02 c0       	rjmp	.+4      	; 0x1dbc <set_mux_sel+0x1e>
    1db8:	df 9a       	sbi	0x1b, 7	; 27
    1dba:	01 c0       	rjmp	.+2      	; 0x1dbe <set_mux_sel+0x20>
    1dbc:	df 98       	cbi	0x1b, 7	; 27
      READ( mux_sel, 3 ) ? SET( PORTA, 6 ) : CLR( PORTA, 6 );
    1dbe:	86 2f       	mov	r24, r22
    1dc0:	86 95       	lsr	r24
    1dc2:	86 95       	lsr	r24
    1dc4:	86 95       	lsr	r24
    1dc6:	80 ff       	sbrs	r24, 0
    1dc8:	02 c0       	rjmp	.+4      	; 0x1dce <set_mux_sel+0x30>
    1dca:	de 9a       	sbi	0x1b, 6	; 27
    1dcc:	01 c0       	rjmp	.+2      	; 0x1dd0 <set_mux_sel+0x32>
    1dce:	de 98       	cbi	0x1b, 6	; 27
      READ( mux_sel, 2 ) ? SET( PORTA, 5 ) : CLR( PORTA, 5 );
    1dd0:	86 2f       	mov	r24, r22
    1dd2:	86 95       	lsr	r24
    1dd4:	86 95       	lsr	r24
    1dd6:	80 ff       	sbrs	r24, 0
    1dd8:	02 c0       	rjmp	.+4      	; 0x1dde <set_mux_sel+0x40>
    1dda:	dd 9a       	sbi	0x1b, 5	; 27
    1ddc:	01 c0       	rjmp	.+2      	; 0x1de0 <set_mux_sel+0x42>
    1dde:	dd 98       	cbi	0x1b, 5	; 27
      READ( mux_sel, 1 ) ? SET( PORTA, 4 ) : CLR( PORTA, 4 );
    1de0:	86 2f       	mov	r24, r22
    1de2:	86 95       	lsr	r24
    1de4:	80 ff       	sbrs	r24, 0
    1de6:	02 c0       	rjmp	.+4      	; 0x1dec <set_mux_sel+0x4e>
    1de8:	dc 9a       	sbi	0x1b, 4	; 27
    1dea:	01 c0       	rjmp	.+2      	; 0x1dee <set_mux_sel+0x50>
    1dec:	dc 98       	cbi	0x1b, 4	; 27
      READ( mux_sel, 0 ) ? SET( PORTA, 3 ) : CLR( PORTA, 3 );
    1dee:	60 ff       	sbrs	r22, 0
    1df0:	02 c0       	rjmp	.+4      	; 0x1df6 <set_mux_sel+0x58>
    1df2:	db 9a       	sbi	0x1b, 3	; 27
    1df4:	08 95       	ret
    1df6:	db 98       	cbi	0x1b, 3	; 27
    1df8:	08 95       	ret

      break;

    case MUX1:
      READ( mux_sel, 4 ) ? SET( PORTB, 0 ) : CLR( PORTB, 0 );
    1dfa:	86 2f       	mov	r24, r22
    1dfc:	82 95       	swap	r24
    1dfe:	8f 70       	andi	r24, 0x0F	; 15
    1e00:	80 ff       	sbrs	r24, 0
    1e02:	02 c0       	rjmp	.+4      	; 0x1e08 <set_mux_sel+0x6a>
    1e04:	c0 9a       	sbi	0x18, 0	; 24
    1e06:	01 c0       	rjmp	.+2      	; 0x1e0a <set_mux_sel+0x6c>
    1e08:	c0 98       	cbi	0x18, 0	; 24
      READ( mux_sel, 3 ) ? SET( PORTB, 1 ) : CLR( PORTB, 1 );
    1e0a:	86 2f       	mov	r24, r22
    1e0c:	86 95       	lsr	r24
    1e0e:	86 95       	lsr	r24
    1e10:	86 95       	lsr	r24
    1e12:	80 ff       	sbrs	r24, 0
    1e14:	02 c0       	rjmp	.+4      	; 0x1e1a <set_mux_sel+0x7c>
    1e16:	c1 9a       	sbi	0x18, 1	; 24
    1e18:	01 c0       	rjmp	.+2      	; 0x1e1c <set_mux_sel+0x7e>
    1e1a:	c1 98       	cbi	0x18, 1	; 24
      READ( mux_sel, 2 ) ? SET( PORTB, 2 ) : CLR( PORTB, 2 );
    1e1c:	86 2f       	mov	r24, r22
    1e1e:	86 95       	lsr	r24
    1e20:	86 95       	lsr	r24
    1e22:	80 ff       	sbrs	r24, 0
    1e24:	02 c0       	rjmp	.+4      	; 0x1e2a <set_mux_sel+0x8c>
    1e26:	c2 9a       	sbi	0x18, 2	; 24
    1e28:	01 c0       	rjmp	.+2      	; 0x1e2c <set_mux_sel+0x8e>
    1e2a:	c2 98       	cbi	0x18, 2	; 24
      READ( mux_sel, 1 ) ? SET( PORTB, 3 ) : CLR( PORTB, 3 );
    1e2c:	86 2f       	mov	r24, r22
    1e2e:	86 95       	lsr	r24
    1e30:	80 ff       	sbrs	r24, 0
    1e32:	02 c0       	rjmp	.+4      	; 0x1e38 <set_mux_sel+0x9a>
    1e34:	c3 9a       	sbi	0x18, 3	; 24
    1e36:	01 c0       	rjmp	.+2      	; 0x1e3a <set_mux_sel+0x9c>
    1e38:	c3 98       	cbi	0x18, 3	; 24
      READ( mux_sel, 0 ) ? SET( PORTB, 4 ) : CLR( PORTB, 4 );
    1e3a:	60 ff       	sbrs	r22, 0
    1e3c:	02 c0       	rjmp	.+4      	; 0x1e42 <set_mux_sel+0xa4>
    1e3e:	c4 9a       	sbi	0x18, 4	; 24
    1e40:	08 95       	ret
    1e42:	c4 98       	cbi	0x18, 4	; 24
    1e44:	08 95       	ret

      break;

    case MUX2:
      READ( mux_sel, 4 ) ? SET( PORTE, 3 ) : CLR( PORTE, 3 );
    1e46:	86 2f       	mov	r24, r22
    1e48:	82 95       	swap	r24
    1e4a:	8f 70       	andi	r24, 0x0F	; 15
    1e4c:	80 ff       	sbrs	r24, 0
    1e4e:	02 c0       	rjmp	.+4      	; 0x1e54 <set_mux_sel+0xb6>
    1e50:	1b 9a       	sbi	0x03, 3	; 3
    1e52:	01 c0       	rjmp	.+2      	; 0x1e56 <set_mux_sel+0xb8>
    1e54:	1b 98       	cbi	0x03, 3	; 3
      READ( mux_sel, 3 ) ? SET( PORTE, 4 ) : CLR( PORTE, 4 );
    1e56:	86 2f       	mov	r24, r22
    1e58:	86 95       	lsr	r24
    1e5a:	86 95       	lsr	r24
    1e5c:	86 95       	lsr	r24
    1e5e:	80 ff       	sbrs	r24, 0
    1e60:	02 c0       	rjmp	.+4      	; 0x1e66 <set_mux_sel+0xc8>
    1e62:	1c 9a       	sbi	0x03, 4	; 3
    1e64:	01 c0       	rjmp	.+2      	; 0x1e68 <set_mux_sel+0xca>
    1e66:	1c 98       	cbi	0x03, 4	; 3
      READ( mux_sel, 2 ) ? SET( PORTE, 5 ) : CLR( PORTE, 5 );
    1e68:	86 2f       	mov	r24, r22
    1e6a:	86 95       	lsr	r24
    1e6c:	86 95       	lsr	r24
    1e6e:	80 ff       	sbrs	r24, 0
    1e70:	02 c0       	rjmp	.+4      	; 0x1e76 <set_mux_sel+0xd8>
    1e72:	1d 9a       	sbi	0x03, 5	; 3
    1e74:	01 c0       	rjmp	.+2      	; 0x1e78 <set_mux_sel+0xda>
    1e76:	1d 98       	cbi	0x03, 5	; 3
      READ( mux_sel, 1 ) ? SET( PORTE, 6 ) : CLR( PORTE, 6 );
    1e78:	86 2f       	mov	r24, r22
    1e7a:	86 95       	lsr	r24
    1e7c:	80 ff       	sbrs	r24, 0
    1e7e:	02 c0       	rjmp	.+4      	; 0x1e84 <set_mux_sel+0xe6>
    1e80:	1e 9a       	sbi	0x03, 6	; 3
    1e82:	01 c0       	rjmp	.+2      	; 0x1e86 <set_mux_sel+0xe8>
    1e84:	1e 98       	cbi	0x03, 6	; 3
      READ( mux_sel, 0 ) ? SET( PORTE, 7 ) : CLR( PORTE, 7 );
    1e86:	60 ff       	sbrs	r22, 0
    1e88:	02 c0       	rjmp	.+4      	; 0x1e8e <set_mux_sel+0xf0>
    1e8a:	1f 9a       	sbi	0x03, 7	; 3
    1e8c:	08 95       	ret
    1e8e:	1f 98       	cbi	0x03, 7	; 3
    1e90:	08 95       	ret

00001e92 <torquer_off>:
  }
}

void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
    1e92:	82 31       	cpi	r24, 0x12	; 18
    1e94:	59 f0       	breq	.+22     	; 0x1eac <torquer_off+0x1a>
    1e96:	83 31       	cpi	r24, 0x13	; 19
    1e98:	81 f0       	breq	.+32     	; 0x1eba <torquer_off+0x28>
    1e9a:	81 31       	cpi	r24, 0x11	; 17
    1e9c:	c1 f4       	brne	.+48     	; 0x1ece <torquer_off+0x3c>
  {
    case TORQUER_1:
      CLR( PORTC, 0 );
    1e9e:	a8 98       	cbi	0x15, 0	; 21
	  CLR( PORTG, 1 );
    1ea0:	80 91 65 00 	lds	r24, 0x0065
    1ea4:	8d 7f       	andi	r24, 0xFD	; 253
    1ea6:	80 93 65 00 	sts	0x0065, r24
    1eaa:	08 95       	ret
      break;

    case TORQUER_2:
      CLR( PORTG, 0 );
    1eac:	80 91 65 00 	lds	r24, 0x0065
    1eb0:	8e 7f       	andi	r24, 0xFE	; 254
    1eb2:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTD, 0 );
    1eb6:	90 98       	cbi	0x12, 0	; 18
    1eb8:	08 95       	ret
      break;

    case TORQUER_3:
      CLR( PORTG, 3 );
    1eba:	80 91 65 00 	lds	r24, 0x0065
    1ebe:	87 7f       	andi	r24, 0xF7	; 247
    1ec0:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTG, 4 );
    1ec4:	80 91 65 00 	lds	r24, 0x0065
    1ec8:	8f 7e       	andi	r24, 0xEF	; 239
    1eca:	80 93 65 00 	sts	0x0065, r24
    1ece:	08 95       	ret

00001ed0 <torquer_on>:
  }  
}

void torquer_on( uint8_t torquer_num )
{
  switch( torquer_num )
    1ed0:	82 31       	cpi	r24, 0x12	; 18
    1ed2:	59 f0       	breq	.+22     	; 0x1eea <torquer_on+0x1a>
    1ed4:	83 31       	cpi	r24, 0x13	; 19
    1ed6:	81 f0       	breq	.+32     	; 0x1ef8 <torquer_on+0x28>
    1ed8:	81 31       	cpi	r24, 0x11	; 17
    1eda:	c1 f4       	brne	.+48     	; 0x1f0c <torquer_on+0x3c>
  {
    case TORQUER_1:
      SET( PORTC, 0 );
    1edc:	a8 9a       	sbi	0x15, 0	; 21
	  SET( PORTG, 1 );
    1ede:	80 91 65 00 	lds	r24, 0x0065
    1ee2:	82 60       	ori	r24, 0x02	; 2
    1ee4:	80 93 65 00 	sts	0x0065, r24
    1ee8:	08 95       	ret
      break;

    case TORQUER_2:
      SET( PORTG, 0 );
    1eea:	80 91 65 00 	lds	r24, 0x0065
    1eee:	81 60       	ori	r24, 0x01	; 1
    1ef0:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTD, 0 );
    1ef4:	90 9a       	sbi	0x12, 0	; 18
    1ef6:	08 95       	ret
      break;

    case TORQUER_3:
      SET( PORTG, 3 );
    1ef8:	80 91 65 00 	lds	r24, 0x0065
    1efc:	88 60       	ori	r24, 0x08	; 8
    1efe:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTG, 4 );
    1f02:	80 91 65 00 	lds	r24, 0x0065
    1f06:	80 61       	ori	r24, 0x10	; 16
    1f08:	80 93 65 00 	sts	0x0065, r24
    1f0c:	08 95       	ret

00001f0e <switch_on>:
  }
}

void switch_on( uint8_t switch_num )
{
  switch ( switch_num )
    1f0e:	88 30       	cpi	r24, 0x08	; 8
    1f10:	91 f1       	breq	.+100    	; 0x1f76 <switch_on+0x68>
    1f12:	89 30       	cpi	r24, 0x09	; 9
    1f14:	80 f4       	brcc	.+32     	; 0x1f36 <switch_on+0x28>
    1f16:	84 30       	cpi	r24, 0x04	; 4
    1f18:	31 f1       	breq	.+76     	; 0x1f66 <switch_on+0x58>
    1f1a:	85 30       	cpi	r24, 0x05	; 5
    1f1c:	38 f4       	brcc	.+14     	; 0x1f2c <switch_on+0x1e>
    1f1e:	82 30       	cpi	r24, 0x02	; 2
    1f20:	f1 f0       	breq	.+60     	; 0x1f5e <switch_on+0x50>
    1f22:	83 30       	cpi	r24, 0x03	; 3
    1f24:	f0 f4       	brcc	.+60     	; 0x1f62 <switch_on+0x54>
    1f26:	81 30       	cpi	r24, 0x01	; 1
    1f28:	d9 f5       	brne	.+118    	; 0x1fa0 <switch_on+0x92>
    1f2a:	17 c0       	rjmp	.+46     	; 0x1f5a <switch_on+0x4c>
    1f2c:	86 30       	cpi	r24, 0x06	; 6
    1f2e:	f9 f0       	breq	.+62     	; 0x1f6e <switch_on+0x60>
    1f30:	87 30       	cpi	r24, 0x07	; 7
    1f32:	f8 f4       	brcc	.+62     	; 0x1f72 <switch_on+0x64>
    1f34:	1a c0       	rjmp	.+52     	; 0x1f6a <switch_on+0x5c>
    1f36:	8c 30       	cpi	r24, 0x0C	; 12
    1f38:	51 f1       	breq	.+84     	; 0x1f8e <switch_on+0x80>
    1f3a:	8d 30       	cpi	r24, 0x0D	; 13
    1f3c:	28 f4       	brcc	.+10     	; 0x1f48 <switch_on+0x3a>
    1f3e:	8a 30       	cpi	r24, 0x0A	; 10
    1f40:	11 f1       	breq	.+68     	; 0x1f86 <switch_on+0x78>
    1f42:	8b 30       	cpi	r24, 0x0B	; 11
    1f44:	10 f5       	brcc	.+68     	; 0x1f8a <switch_on+0x7c>
    1f46:	19 c0       	rjmp	.+50     	; 0x1f7a <switch_on+0x6c>
    1f48:	8e 30       	cpi	r24, 0x0E	; 14
    1f4a:	29 f1       	breq	.+74     	; 0x1f96 <switch_on+0x88>
    1f4c:	8e 30       	cpi	r24, 0x0E	; 14
    1f4e:	08 f1       	brcs	.+66     	; 0x1f92 <switch_on+0x84>
    1f50:	8f 30       	cpi	r24, 0x0F	; 15
    1f52:	19 f1       	breq	.+70     	; 0x1f9a <switch_on+0x8c>
    1f54:	80 31       	cpi	r24, 0x10	; 16
    1f56:	21 f5       	brne	.+72     	; 0x1fa0 <switch_on+0x92>
    1f58:	22 c0       	rjmp	.+68     	; 0x1f9e <switch_on+0x90>
  {
    case 1:
      SET( PORTA, 0 );
    1f5a:	d8 9a       	sbi	0x1b, 0	; 27
    1f5c:	08 95       	ret
      break;

    case 2:
      SET( PORTA, 1 );
    1f5e:	d9 9a       	sbi	0x1b, 1	; 27
    1f60:	08 95       	ret
      break;

    case 3:
      SET( PORTA, 2 );
    1f62:	da 9a       	sbi	0x1b, 2	; 27
    1f64:	08 95       	ret
      break;

    case 4:
      SET( PORTB, 5 );
    1f66:	c5 9a       	sbi	0x18, 5	; 24
    1f68:	08 95       	ret
      break;

    case 5:
      SET( PORTB, 6 );
    1f6a:	c6 9a       	sbi	0x18, 6	; 24
    1f6c:	08 95       	ret
      break;

    case 6:
      SET( PORTB, 7 );
    1f6e:	c7 9a       	sbi	0x18, 7	; 24
    1f70:	08 95       	ret
      break;

    case 7:
      SET( PORTD, 4 );
    1f72:	94 9a       	sbi	0x12, 4	; 18
    1f74:	08 95       	ret
      break;

    case 8:
      SET( PORTD, 5 );
    1f76:	95 9a       	sbi	0x12, 5	; 18
    1f78:	08 95       	ret
      break;

    case 9:
      SET( PORTG, 2 );
    1f7a:	80 91 65 00 	lds	r24, 0x0065
    1f7e:	84 60       	ori	r24, 0x04	; 4
    1f80:	80 93 65 00 	sts	0x0065, r24
    1f84:	08 95       	ret
      break;

    case 10: 
      SET( PORTC, 7 );
    1f86:	af 9a       	sbi	0x15, 7	; 21
    1f88:	08 95       	ret
      break;

    case 11:
      SET( PORTC, 6 );
    1f8a:	ae 9a       	sbi	0x15, 6	; 21
    1f8c:	08 95       	ret
      break;

    case 12:
      SET( PORTC, 5 );
    1f8e:	ad 9a       	sbi	0x15, 5	; 21
    1f90:	08 95       	ret
      break;

    case 13:
      SET( PORTC, 4 );
    1f92:	ac 9a       	sbi	0x15, 4	; 21
    1f94:	08 95       	ret
      break;

    case 14:
      SET( PORTC, 3 );
    1f96:	ab 9a       	sbi	0x15, 3	; 21
    1f98:	08 95       	ret
      break;

    case 15:
      SET( PORTC, 2 );
    1f9a:	aa 9a       	sbi	0x15, 2	; 21
    1f9c:	08 95       	ret
      break;

    case 16:
      SET( PORTC, 1 );
    1f9e:	a9 9a       	sbi	0x15, 1	; 21
    1fa0:	08 95       	ret

00001fa2 <switch_off>:
  }
}

void switch_off( uint8_t switch_num )
{
  switch ( switch_num )
    1fa2:	88 30       	cpi	r24, 0x08	; 8
    1fa4:	91 f1       	breq	.+100    	; 0x200a <switch_off+0x68>
    1fa6:	89 30       	cpi	r24, 0x09	; 9
    1fa8:	80 f4       	brcc	.+32     	; 0x1fca <switch_off+0x28>
    1faa:	84 30       	cpi	r24, 0x04	; 4
    1fac:	31 f1       	breq	.+76     	; 0x1ffa <switch_off+0x58>
    1fae:	85 30       	cpi	r24, 0x05	; 5
    1fb0:	38 f4       	brcc	.+14     	; 0x1fc0 <switch_off+0x1e>
    1fb2:	82 30       	cpi	r24, 0x02	; 2
    1fb4:	f1 f0       	breq	.+60     	; 0x1ff2 <switch_off+0x50>
    1fb6:	83 30       	cpi	r24, 0x03	; 3
    1fb8:	f0 f4       	brcc	.+60     	; 0x1ff6 <switch_off+0x54>
    1fba:	81 30       	cpi	r24, 0x01	; 1
    1fbc:	d9 f5       	brne	.+118    	; 0x2034 <switch_off+0x92>
    1fbe:	17 c0       	rjmp	.+46     	; 0x1fee <switch_off+0x4c>
    1fc0:	86 30       	cpi	r24, 0x06	; 6
    1fc2:	f9 f0       	breq	.+62     	; 0x2002 <switch_off+0x60>
    1fc4:	87 30       	cpi	r24, 0x07	; 7
    1fc6:	f8 f4       	brcc	.+62     	; 0x2006 <switch_off+0x64>
    1fc8:	1a c0       	rjmp	.+52     	; 0x1ffe <switch_off+0x5c>
    1fca:	8c 30       	cpi	r24, 0x0C	; 12
    1fcc:	51 f1       	breq	.+84     	; 0x2022 <switch_off+0x80>
    1fce:	8d 30       	cpi	r24, 0x0D	; 13
    1fd0:	28 f4       	brcc	.+10     	; 0x1fdc <switch_off+0x3a>
    1fd2:	8a 30       	cpi	r24, 0x0A	; 10
    1fd4:	11 f1       	breq	.+68     	; 0x201a <switch_off+0x78>
    1fd6:	8b 30       	cpi	r24, 0x0B	; 11
    1fd8:	10 f5       	brcc	.+68     	; 0x201e <switch_off+0x7c>
    1fda:	19 c0       	rjmp	.+50     	; 0x200e <switch_off+0x6c>
    1fdc:	8e 30       	cpi	r24, 0x0E	; 14
    1fde:	29 f1       	breq	.+74     	; 0x202a <switch_off+0x88>
    1fe0:	8e 30       	cpi	r24, 0x0E	; 14
    1fe2:	08 f1       	brcs	.+66     	; 0x2026 <switch_off+0x84>
    1fe4:	8f 30       	cpi	r24, 0x0F	; 15
    1fe6:	19 f1       	breq	.+70     	; 0x202e <switch_off+0x8c>
    1fe8:	80 31       	cpi	r24, 0x10	; 16
    1fea:	21 f5       	brne	.+72     	; 0x2034 <switch_off+0x92>
    1fec:	22 c0       	rjmp	.+68     	; 0x2032 <switch_off+0x90>
  {
    case 1:
      CLR( PORTA, 0 );
    1fee:	d8 98       	cbi	0x1b, 0	; 27
    1ff0:	08 95       	ret
      break;

    case 2:
      CLR( PORTA, 1 );
    1ff2:	d9 98       	cbi	0x1b, 1	; 27
    1ff4:	08 95       	ret
      break;

    case 3:
      CLR( PORTA, 2 );
    1ff6:	da 98       	cbi	0x1b, 2	; 27
    1ff8:	08 95       	ret
      break;

    case 4:
      CLR( PORTB, 5 );
    1ffa:	c5 98       	cbi	0x18, 5	; 24
    1ffc:	08 95       	ret
      break;

    case 5:
      CLR( PORTB, 6 );
    1ffe:	c6 98       	cbi	0x18, 6	; 24
    2000:	08 95       	ret
      break;

    case 6:
      CLR( PORTB, 7 );
    2002:	c7 98       	cbi	0x18, 7	; 24
    2004:	08 95       	ret
      break;

    case 7:
      CLR( PORTD, 4 );
    2006:	94 98       	cbi	0x12, 4	; 18
    2008:	08 95       	ret
      break;

    case 8:
      CLR( PORTD, 5 );
    200a:	95 98       	cbi	0x12, 5	; 18
    200c:	08 95       	ret
      break;

    case 9:
      CLR( PORTG, 2 );
    200e:	80 91 65 00 	lds	r24, 0x0065
    2012:	8b 7f       	andi	r24, 0xFB	; 251
    2014:	80 93 65 00 	sts	0x0065, r24
    2018:	08 95       	ret
      break;

    case 10: 
      CLR( PORTC, 7 );
    201a:	af 98       	cbi	0x15, 7	; 21
    201c:	08 95       	ret
      break;

    case 11:
      CLR( PORTC, 6 );
    201e:	ae 98       	cbi	0x15, 6	; 21
    2020:	08 95       	ret
      break;

    case 12:
      CLR( PORTC, 5 );
    2022:	ad 98       	cbi	0x15, 5	; 21
    2024:	08 95       	ret
      break;

    case 13:
      CLR( PORTC, 4 );
    2026:	ac 98       	cbi	0x15, 4	; 21
    2028:	08 95       	ret
      break;

    case 14:
      CLR( PORTC, 3 );
    202a:	ab 98       	cbi	0x15, 3	; 21
    202c:	08 95       	ret
      break;

    case 15:
      CLR( PORTC, 2 );
    202e:	aa 98       	cbi	0x15, 2	; 21
    2030:	08 95       	ret
      break;

    case 16:
      CLR( PORTC, 1 );
    2032:	a9 98       	cbi	0x15, 1	; 21
    2034:	08 95       	ret

00002036 <average_samples>:
    return  average_samples( component->I_samples );
  }
}

uint8_t average_samples( uint8_t samples[NUM_SAMPLES] )
{
    2036:	fc 01       	movw	r30, r24
  uint8_t average = 0;
  uint16_t sum = 0;

  for(uint8_t avg_index = 0; avg_index < NUM_SAMPLES; avg_index++)
    sum += samples[avg_index];
    2038:	20 81       	ld	r18, Z
    203a:	81 81       	ldd	r24, Z+1	; 0x01
    203c:	90 e0       	ldi	r25, 0x00	; 0
    203e:	82 0f       	add	r24, r18
    2040:	91 1d       	adc	r25, r1
    2042:	22 81       	ldd	r18, Z+2	; 0x02
    2044:	82 0f       	add	r24, r18
    2046:	91 1d       	adc	r25, r1
    2048:	63 e0       	ldi	r22, 0x03	; 3
    204a:	70 e0       	ldi	r23, 0x00	; 0
    204c:	0e 94 8d 1b 	call	0x371a	; 0x371a <__udivmodhi4>
    2050:	86 2f       	mov	r24, r22

  average = sum / NUM_SAMPLES;

  return average;
}
    2052:	08 95       	ret

00002054 <SVIT_check_I_critical>:
}

uint8_t SVIT_check_I_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    2054:	9a e1       	ldi	r25, 0x1A	; 26
    2056:	89 9f       	mul	r24, r25
    2058:	f0 01       	movw	r30, r0
    205a:	11 24       	eor	r1, r1
    205c:	eb 5c       	subi	r30, 0xCB	; 203
    205e:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->I_critical_value != 0 )
    2060:	83 89       	ldd	r24, Z+19	; 0x13
    2062:	88 23       	and	r24, r24
    2064:	11 f0       	breq	.+4      	; 0x206a <SVIT_check_I_critical+0x16>
  {
    temp= component->I_critical_value;
    component->I_critical_value = 0;
    2066:	13 8a       	std	Z+19, r1	; 0x13
    2068:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->I_samples );
    206a:	cf 01       	movw	r24, r30
    206c:	0f 96       	adiw	r24, 0x0f	; 15
    206e:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
  }
}
    2072:	08 95       	ret

00002074 <SVIT_check_V_critical>:
}

uint8_t SVIT_check_V_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    2074:	9a e1       	ldi	r25, 0x1A	; 26
    2076:	89 9f       	mul	r24, r25
    2078:	f0 01       	movw	r30, r0
    207a:	11 24       	eor	r1, r1
    207c:	eb 5c       	subi	r30, 0xCB	; 203
    207e:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->V_critical_value != 0 )
    2080:	83 85       	ldd	r24, Z+11	; 0x0b
    2082:	88 23       	and	r24, r24
    2084:	11 f0       	breq	.+4      	; 0x208a <SVIT_check_V_critical+0x16>
  {
    temp= component->V_critical_value;
    component->V_critical_value = 0;
    2086:	13 86       	std	Z+11, r1	; 0x0b
    2088:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->V_samples );
    208a:	cf 01       	movw	r24, r30
    208c:	07 96       	adiw	r24, 0x07	; 7
    208e:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
  }
}
    2092:	08 95       	ret

00002094 <perform_ADC>:
}

void perform_ADC( uint8_t mux_num )
{
  // set Vref to AVCC and set the ADC channel to the correct pin ( mux_num )
  ADMUX = (1 << ADLAR) | ( 1 << REFS0 );
    2094:	90 e6       	ldi	r25, 0x60	; 96
    2096:	97 b9       	out	0x07, r25	; 7
  ADMUX &= ~0x3;
    2098:	97 b1       	in	r25, 0x07	; 7
    209a:	9c 7f       	andi	r25, 0xFC	; 252
    209c:	97 b9       	out	0x07, r25	; 7
  ADMUX |= mux_num;
    209e:	97 b1       	in	r25, 0x07	; 7
    20a0:	98 2b       	or	r25, r24
    20a2:	97 b9       	out	0x07, r25	; 7

  // signal ADC to start a new conversion
  ADCSRA |= ( 1 << ADSC );
    20a4:	36 9a       	sbi	0x06, 6	; 6

  // when the conversion finishes, the result is stored in ADCL and ADCH
}
    20a6:	08 95       	ret

000020a8 <read_VIT>:

void read_VIT( void )
{
    20a8:	0f 93       	push	r16
    20aa:	1f 93       	push	r17
    20ac:	cf 93       	push	r28
    20ae:	df 93       	push	r29
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type )
    20b0:	80 91 09 09 	lds	r24, 0x0909
    20b4:	82 30       	cpi	r24, 0x02	; 2
    20b6:	09 f4       	brne	.+2      	; 0x20ba <read_VIT+0x12>
    20b8:	5e c0       	rjmp	.+188    	; 0x2176 <read_VIT+0xce>
    20ba:	83 30       	cpi	r24, 0x03	; 3
    20bc:	20 f4       	brcc	.+8      	; 0x20c6 <read_VIT+0x1e>
    20be:	81 30       	cpi	r24, 0x01	; 1
    20c0:	09 f0       	breq	.+2      	; 0x20c4 <read_VIT+0x1c>
    20c2:	d5 c0       	rjmp	.+426    	; 0x226e <read_VIT+0x1c6>
    20c4:	04 c0       	rjmp	.+8      	; 0x20ce <read_VIT+0x26>
    20c6:	83 30       	cpi	r24, 0x03	; 3
    20c8:	09 f0       	breq	.+2      	; 0x20cc <read_VIT+0x24>
    20ca:	d1 c0       	rjmp	.+418    	; 0x226e <read_VIT+0x1c6>
    20cc:	aa c0       	rjmp	.+340    	; 0x2222 <read_VIT+0x17a>
  {
		case ADC_VOLTAGE:
			component = &svit[adc_component];
    20ce:	80 91 34 03 	lds	r24, 0x0334
    20d2:	9a e1       	ldi	r25, 0x1A	; 26
    20d4:	89 9f       	mul	r24, r25
    20d6:	e0 01       	movw	r28, r0
    20d8:	11 24       	eor	r1, r1
    20da:	cb 5c       	subi	r28, 0xCB	; 203
    20dc:	dc 4f       	sbci	r29, 0xFC	; 252
			sample_index = component->V_sample_index;
			component->V_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    20de:	8a 85       	ldd	r24, Y+10	; 0x0a
    20e0:	e8 2f       	mov	r30, r24
    20e2:	f0 e0       	ldi	r31, 0x00	; 0
    20e4:	cf 01       	movw	r24, r30
    20e6:	01 96       	adiw	r24, 0x01	; 1
    20e8:	63 e0       	ldi	r22, 0x03	; 3
    20ea:	70 e0       	ldi	r23, 0x00	; 0
    20ec:	0e 94 a1 1b 	call	0x3742	; 0x3742 <__divmodhi4>
    20f0:	8a 87       	std	Y+10, r24	; 0x0a

			// SoC: If component is a battery, store in different global variable
			if (component->name == BATTERY_1) {
    20f2:	88 81       	ld	r24, Y
    20f4:	84 31       	cpi	r24, 0x14	; 20
    20f6:	69 f4       	brne	.+26     	; 0x2112 <read_VIT+0x6a>
				batt1_voltage = ADC_high;
    20f8:	80 91 19 09 	lds	r24, 0x0919
    20fc:	80 93 23 09 	sts	0x0923, r24
				high = ADC_high;
    2100:	80 91 19 09 	lds	r24, 0x0919
    2104:	80 93 14 09 	sts	0x0914, r24
				low = ADC_low;
    2108:	80 91 4f 0d 	lds	r24, 0x0D4F
    210c:	80 93 22 09 	sts	0x0922, r24
    2110:	06 c0       	rjmp	.+12     	; 0x211e <read_VIT+0x76>
				//debug = adc_component;
			}
			else if (component->name == BATTERY_2) {
    2112:	85 31       	cpi	r24, 0x15	; 21
    2114:	21 f4       	brne	.+8      	; 0x211e <read_VIT+0x76>
				batt2_voltage = ADC_high;
    2116:	80 91 19 09 	lds	r24, 0x0919
    211a:	80 93 33 0b 	sts	0x0B33, r24
			}
			component->V_samples[sample_index] = ADC_high;
    211e:	80 91 19 09 	lds	r24, 0x0919
    2122:	ec 0f       	add	r30, r28
    2124:	fd 1f       	adc	r31, r29
    2126:	87 83       	std	Z+7, r24	; 0x07
      
	  	if ( ( ADC_high > component->V_upper_limit ) && ( component->force_on != 1 ) )
    2128:	90 91 19 09 	lds	r25, 0x0919
    212c:	8e 81       	ldd	r24, Y+6	; 0x06
    212e:	89 17       	cp	r24, r25
    2130:	d8 f4       	brcc	.+54     	; 0x2168 <read_VIT+0xc0>
    2132:	8b 81       	ldd	r24, Y+3	; 0x03
    2134:	81 30       	cpi	r24, 0x01	; 1
    2136:	c1 f0       	breq	.+48     	; 0x2168 <read_VIT+0xc0>
			{
				if ( component->switch_num != SW_NULL )
    2138:	89 81       	ldd	r24, Y+1	; 0x01
    213a:	8f 3f       	cpi	r24, 0xFF	; 255
    213c:	19 f0       	breq	.+6      	; 0x2144 <read_VIT+0x9c>
				{
			  	switch_off( component->switch_num );
    213e:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <switch_off>
    2142:	0e c0       	rjmp	.+28     	; 0x2160 <read_VIT+0xb8>
				}
		  	else
				{
			  	switch ( component->name )
    2144:	88 81       	ld	r24, Y
    2146:	82 31       	cpi	r24, 0x12	; 18
    2148:	31 f0       	breq	.+12     	; 0x2156 <read_VIT+0xae>
    214a:	83 31       	cpi	r24, 0x13	; 19
    214c:	31 f0       	breq	.+12     	; 0x215a <read_VIT+0xb2>
    214e:	81 31       	cpi	r24, 0x11	; 17
    2150:	39 f4       	brne	.+14     	; 0x2160 <read_VIT+0xb8>
			  	{
						case TORQUER_1:
				  		torquer_off( TORQUER_1 );
    2152:	81 e1       	ldi	r24, 0x11	; 17
    2154:	03 c0       	rjmp	.+6      	; 0x215c <read_VIT+0xb4>
				  		break;
					  case TORQUER_2:
	  			  	torquer_off( TORQUER_2 );
    2156:	82 e1       	ldi	r24, 0x12	; 18
    2158:	01 c0       	rjmp	.+2      	; 0x215c <read_VIT+0xb4>
		  		  	break;
			  		case TORQUER_3:
				    	torquer_off( TORQUER_3 );
    215a:	83 e1       	ldi	r24, 0x13	; 19
    215c:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <torquer_off>
				    	break;
					  default:
				  	  break;
			    }
  			}
        component->switch_state = SW_OFF;
    2160:	1a 82       	std	Y+2, r1	; 0x02
        component->V_critical_value = ADC_high;
    2162:	80 91 19 09 	lds	r24, 0x0919
    2166:	8b 87       	std	Y+11, r24	; 0x0b
		  }
		  adc_sensor_type = ADC_CURRENT;
    2168:	82 e0       	ldi	r24, 0x02	; 2
    216a:	80 93 09 09 	sts	0x0909, r24

      //perform next ADC conversion
      mux_num = component->I_mux_num;
    216e:	1c 85       	ldd	r17, Y+12	; 0x0c
      mux_sel = component->I_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    2170:	81 2f       	mov	r24, r17
    2172:	6d 85       	ldd	r22, Y+13	; 0x0d
    2174:	8a c0       	rjmp	.+276    	; 0x228a <read_VIT+0x1e2>
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    2176:	90 91 34 03 	lds	r25, 0x0334
    217a:	8a e1       	ldi	r24, 0x1A	; 26
    217c:	98 9f       	mul	r25, r24
    217e:	e0 01       	movw	r28, r0
    2180:	11 24       	eor	r1, r1
    2182:	cb 5c       	subi	r28, 0xCB	; 203
    2184:	dc 4f       	sbci	r29, 0xFC	; 252
	  	sample_index = component->I_sample_index;
	  	component->I_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    2186:	ea 89       	ldd	r30, Y+18	; 0x12
    2188:	f0 e0       	ldi	r31, 0x00	; 0
    218a:	cf 01       	movw	r24, r30
    218c:	01 96       	adiw	r24, 0x01	; 1
    218e:	63 e0       	ldi	r22, 0x03	; 3
    2190:	70 e0       	ldi	r23, 0x00	; 0
    2192:	0e 94 a1 1b 	call	0x3742	; 0x3742 <__divmodhi4>
    2196:	8a 8b       	std	Y+18, r24	; 0x12
		// SoC hardcode backward current
//		if (adc_component == BATTERY_1_b) {
			//debug = 5;
		//}

	  	component->I_samples[sample_index] = ADC_high;
    2198:	80 91 19 09 	lds	r24, 0x0919
    219c:	ec 0f       	add	r30, r28
    219e:	fd 1f       	adc	r31, r29
    21a0:	87 87       	std	Z+15, r24	; 0x0f
    
	    if ( ( ADC_high > component->I_upper_limit ) && ( component->force_on != 1 ) )
    21a2:	90 91 19 09 	lds	r25, 0x0919
    21a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    21a8:	89 17       	cp	r24, r25
    21aa:	d8 f4       	brcc	.+54     	; 0x21e2 <read_VIT+0x13a>
    21ac:	8b 81       	ldd	r24, Y+3	; 0x03
    21ae:	81 30       	cpi	r24, 0x01	; 1
    21b0:	c1 f0       	breq	.+48     	; 0x21e2 <read_VIT+0x13a>
	  	{
	  		if ( component->switch_num != SW_NULL )
    21b2:	89 81       	ldd	r24, Y+1	; 0x01
    21b4:	8f 3f       	cpi	r24, 0xFF	; 255
    21b6:	19 f0       	breq	.+6      	; 0x21be <read_VIT+0x116>
	  		{
	  		  switch_off( component->switch_num );
    21b8:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <switch_off>
    21bc:	0e c0       	rjmp	.+28     	; 0x21da <read_VIT+0x132>
	  		}
	  		else
	  		{
	  		  switch ( component->name )
    21be:	88 81       	ld	r24, Y
    21c0:	82 31       	cpi	r24, 0x12	; 18
    21c2:	31 f0       	breq	.+12     	; 0x21d0 <read_VIT+0x128>
    21c4:	83 31       	cpi	r24, 0x13	; 19
    21c6:	31 f0       	breq	.+12     	; 0x21d4 <read_VIT+0x12c>
    21c8:	81 31       	cpi	r24, 0x11	; 17
    21ca:	39 f4       	brne	.+14     	; 0x21da <read_VIT+0x132>
		  	  {
  		  		case TORQUER_1:
	  	  		  torquer_off( TORQUER_1 );
    21cc:	81 e1       	ldi	r24, 0x11	; 17
    21ce:	03 c0       	rjmp	.+6      	; 0x21d6 <read_VIT+0x12e>
		    		  break;
			    	case TORQUER_2:
			  	    torquer_off( TORQUER_2 );
    21d0:	82 e1       	ldi	r24, 0x12	; 18
    21d2:	01 c0       	rjmp	.+2      	; 0x21d6 <read_VIT+0x12e>
			  	    break;
  		  		case TORQUER_3:
	  	  		  torquer_off( TORQUER_3 );
    21d4:	83 e1       	ldi	r24, 0x13	; 19
    21d6:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <torquer_off>
		    		  break;
			     	default:
				      break;
			    }
			  }
			  component->switch_state = 0;
    21da:	1a 82       	std	Y+2, r1	; 0x02
        component->I_critical_value = ADC_high;
    21dc:	80 91 19 09 	lds	r24, 0x0919
    21e0:	8b 8b       	std	Y+19, r24	; 0x13
		  }
      //perform next ADC conversion
      mux_num = component->T_mux_num;
    21e2:	1c 89       	ldd	r17, Y+20	; 0x14
      if( mux_num != MUX_NULL )
    21e4:	13 30       	cpi	r17, 0x03	; 3
    21e6:	29 f0       	breq	.+10     	; 0x21f2 <read_VIT+0x14a>
      {
		    adc_sensor_type = ADC_TEMPERATURE;
    21e8:	83 e0       	ldi	r24, 0x03	; 3
    21ea:	80 93 09 09 	sts	0x0909, r24
        mux_sel = component->T_mux_sel;        
    21ee:	6d 89       	ldd	r22, Y+21	; 0x15
    21f0:	16 c0       	rjmp	.+44     	; 0x221e <read_VIT+0x176>
		  }
      else
      {
        adc_sensor_type = ADC_VOLTAGE;
    21f2:	81 e0       	ldi	r24, 0x01	; 1
    21f4:	80 93 09 09 	sts	0x0909, r24
		    adc_component = ( adc_component + 1 ) % SVIT_SZ;
    21f8:	80 91 34 03 	lds	r24, 0x0334
    21fc:	90 e0       	ldi	r25, 0x00	; 0
    21fe:	01 96       	adiw	r24, 0x01	; 1
    2200:	64 e2       	ldi	r22, 0x24	; 36
    2202:	70 e0       	ldi	r23, 0x00	; 0
    2204:	0e 94 a1 1b 	call	0x3742	; 0x3742 <__divmodhi4>
    2208:	e8 2f       	mov	r30, r24
    220a:	80 93 34 03 	sts	0x0334, r24
        component = &svit[adc_component];
    220e:	8a e1       	ldi	r24, 0x1A	; 26
    2210:	e8 9f       	mul	r30, r24
    2212:	f0 01       	movw	r30, r0
    2214:	11 24       	eor	r1, r1
    2216:	eb 5c       	subi	r30, 0xCB	; 203
    2218:	fc 4f       	sbci	r31, 0xFC	; 252
        mux_num = component->V_mux_num;
    221a:	14 81       	ldd	r17, Z+4	; 0x04
        mux_sel = component->V_mux_sel;
    221c:	65 81       	ldd	r22, Z+5	; 0x05
      }
      set_mux_sel( mux_num, mux_sel );
    221e:	81 2f       	mov	r24, r17
    2220:	34 c0       	rjmp	.+104    	; 0x228a <read_VIT+0x1e2>
      break;
    //-------------------------------------------------------------------
    // Measure temperature
    //-------------------------------------------------------------------
	  case ADC_TEMPERATURE:
		  component = &svit[adc_component];
    2222:	00 91 34 03 	lds	r16, 0x0334
    2226:	4a e1       	ldi	r20, 0x1A	; 26
    2228:	04 9f       	mul	r16, r20
    222a:	f0 01       	movw	r30, r0
    222c:	11 24       	eor	r1, r1
    222e:	eb 5c       	subi	r30, 0xCB	; 203
    2230:	fc 4f       	sbci	r31, 0xFC	; 252
		  sample_index = component->T_sample_index;
		  component->T_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    2232:	21 8d       	ldd	r18, Z+25	; 0x19
    2234:	30 e0       	ldi	r19, 0x00	; 0
    2236:	c9 01       	movw	r24, r18
    2238:	01 96       	adiw	r24, 0x01	; 1
    223a:	63 e0       	ldi	r22, 0x03	; 3
    223c:	70 e0       	ldi	r23, 0x00	; 0
    223e:	0e 94 a1 1b 	call	0x3742	; 0x3742 <__divmodhi4>
    2242:	81 8f       	std	Z+25, r24	; 0x19
		  component->T_samples[sample_index] = ADC_high;
    2244:	80 91 19 09 	lds	r24, 0x0919
    2248:	e2 0f       	add	r30, r18
    224a:	f3 1f       	adc	r31, r19
    224c:	86 8b       	std	Z+22, r24	; 0x16
      //perform next ADC conversion
  	  adc_sensor_type = ADC_VOLTAGE;
    224e:	81 e0       	ldi	r24, 0x01	; 1
    2250:	80 93 09 09 	sts	0x0909, r24
		  adc_component = ( adc_component + 1 ) % SVIT_SZ;
    2254:	10 e0       	ldi	r17, 0x00	; 0
    2256:	c8 01       	movw	r24, r16
    2258:	01 96       	adiw	r24, 0x01	; 1
    225a:	64 e2       	ldi	r22, 0x24	; 36
    225c:	70 e0       	ldi	r23, 0x00	; 0
    225e:	0e 94 a1 1b 	call	0x3742	; 0x3742 <__divmodhi4>
    2262:	80 93 34 03 	sts	0x0334, r24
      component = &svit[adc_component];
    2266:	84 9f       	mul	r24, r20
    2268:	f0 01       	movw	r30, r0
    226a:	11 24       	eor	r1, r1
    226c:	09 c0       	rjmp	.+18     	; 0x2280 <read_VIT+0x1d8>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
      break;
	  default:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    226e:	81 e0       	ldi	r24, 0x01	; 1
    2270:	80 93 09 09 	sts	0x0909, r24
      component = &svit[adc_component];
    2274:	e0 91 34 03 	lds	r30, 0x0334
    2278:	8a e1       	ldi	r24, 0x1A	; 26
    227a:	e8 9f       	mul	r30, r24
    227c:	f0 01       	movw	r30, r0
    227e:	11 24       	eor	r1, r1
    2280:	eb 5c       	subi	r30, 0xCB	; 203
    2282:	fc 4f       	sbci	r31, 0xFC	; 252
      mux_num = component->V_mux_num;
    2284:	14 81       	ldd	r17, Z+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    2286:	81 2f       	mov	r24, r17
    2288:	65 81       	ldd	r22, Z+5	; 0x05
    228a:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <set_mux_sel>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    228e:	83 e3       	ldi	r24, 0x33	; 51
    2290:	93 e7       	ldi	r25, 0x73	; 115
    2292:	01 97       	sbiw	r24, 0x01	; 1
    2294:	f1 f7       	brne	.-4      	; 0x2292 <read_VIT+0x1ea>
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    2296:	81 2f       	mov	r24, r17
    2298:	0e 94 4a 10 	call	0x2094	; 0x2094 <perform_ADC>
      break;
  } 
}
    229c:	df 91       	pop	r29
    229e:	cf 91       	pop	r28
    22a0:	1f 91       	pop	r17
    22a2:	0f 91       	pop	r16
    22a4:	08 95       	ret

000022a6 <uart_init>:
{
  #if F_CPU < 2000000UL && defined(U2X)
  UCSR0A = UCSR1A = _BV(U2X); /* improve baud rate error by using 2x clk */
  UBRR0L = UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  #else
  UBRR0L = UBRR1L = 7;//(F_CPU / (16UL * UART_BAUD)) - 1;//7;
    22a6:	e9 e9       	ldi	r30, 0x99	; 153
    22a8:	f0 e0       	ldi	r31, 0x00	; 0
    22aa:	87 e0       	ldi	r24, 0x07	; 7
    22ac:	80 83       	st	Z, r24
    22ae:	80 81       	ld	r24, Z
    22b0:	89 b9       	out	0x09, r24	; 9
  #endif
  UCSR0B = _BV(TXEN0) | _BV(RXEN0); /* tx/rx enable */
    22b2:	88 e1       	ldi	r24, 0x18	; 24
    22b4:	8a b9       	out	0x0a, r24	; 10
  UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
    22b6:	ea e9       	ldi	r30, 0x9A	; 154
    22b8:	f0 e0       	ldi	r31, 0x00	; 0
    22ba:	80 83       	st	Z, r24


  UCSR1B = UCSR1B | _BV(TXCIE1);
    22bc:	80 81       	ld	r24, Z
    22be:	80 64       	ori	r24, 0x40	; 64
    22c0:	80 83       	st	Z, r24
  UCSR1B = UCSR1B | _BV(RXCIE1);
    22c2:	80 81       	ld	r24, Z
    22c4:	80 68       	ori	r24, 0x80	; 128
    22c6:	80 83       	st	Z, r24
  UCSR0B = UCSR0B | _BV(TXCIE0);
    22c8:	56 9a       	sbi	0x0a, 6	; 10
  UCSR0B = UCSR0B | _BV(RXCIE0);
    22ca:	57 9a       	sbi	0x0a, 7	; 10

}
    22cc:	08 95       	ret

000022ce <append_crc16>:
 *
 * Adds a byte of data into the crc calculation using
 * the table above.
 */
void append_crc16(uint8 byte, uint16ptr crc)
{
    22ce:	db 01       	movw	r26, r22
	*crc = ((*crc) >> 8) ^ ccitt_crc16[((*crc) ^ (byte)) & 0xff];
    22d0:	2d 91       	ld	r18, X+
    22d2:	3c 91       	ld	r19, X
    22d4:	11 97       	sbiw	r26, 0x01	; 1
    22d6:	e8 2f       	mov	r30, r24
    22d8:	f0 e0       	ldi	r31, 0x00	; 0
    22da:	e2 27       	eor	r30, r18
    22dc:	f3 27       	eor	r31, r19
    22de:	f0 70       	andi	r31, 0x00	; 0
    22e0:	ee 0f       	add	r30, r30
    22e2:	ff 1f       	adc	r31, r31
    22e4:	ea 5f       	subi	r30, 0xFA	; 250
    22e6:	fe 4f       	sbci	r31, 0xFE	; 254
    22e8:	23 2f       	mov	r18, r19
    22ea:	33 27       	eor	r19, r19
    22ec:	80 81       	ld	r24, Z
    22ee:	91 81       	ldd	r25, Z+1	; 0x01
    22f0:	82 27       	eor	r24, r18
    22f2:	93 27       	eor	r25, r19
    22f4:	8d 93       	st	X+, r24
    22f6:	9c 93       	st	X, r25
}
    22f8:	08 95       	ret

000022fa <vcpptr_init>:
// Parameters: 
// vcp_ptrbuffer	*buff -					Pointer to the vcp buffer structure
// uint8			*message_buffer -		Pointer to the allocated data buffer
// uint16			message_buffer_size -	Size of the allocated data buffer
void vcpptr_init(vcp_ptrbuffer *buff, uint8 *message_buffer, uint16 message_buffer_size)
{
    22fa:	fc 01       	movw	r30, r24
	buff->address =	0;
    22fc:	10 82       	st	Z, r1
	buff->message =	message_buffer;
    22fe:	72 83       	std	Z+2, r23	; 0x02
    2300:	61 83       	std	Z+1, r22	; 0x01
	buff->size =	message_buffer_size;
    2302:	56 83       	std	Z+6, r21	; 0x06
    2304:	45 83       	std	Z+5, r20	; 0x05
	buff->index	=	0;
    2306:	10 86       	std	Z+8, r1	; 0x08
    2308:	17 82       	std	Z+7, r1	; 0x07
	buff->crc =		CRC16_INIT_VALUE;
    230a:	14 82       	std	Z+4, r1	; 0x04
    230c:	13 82       	std	Z+3, r1	; 0x03
	buff->status =	VCP_IDLE;
    230e:	11 86       	std	Z+9, r1	; 0x09
}
    2310:	08 95       	ret

00002312 <Receive_VCP_byte>:
// and return VCP status.
// Parameters:
// vcp_ptrbuffer	*buff -	Pointer to the vcp buffer structure
// uint8			byte -	received byte
uint8_t Receive_VCP_byte(vcp_ptrbuffer *buff, uint8 byte)
{
    2312:	cf 92       	push	r12
    2314:	df 92       	push	r13
    2316:	ef 92       	push	r14
    2318:	ff 92       	push	r15
    231a:	0f 93       	push	r16
    231c:	1f 93       	push	r17
    231e:	cf 93       	push	r28
    2320:	df 93       	push	r29
    2322:	ec 01       	movw	r28, r24
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
    2324:	e9 81       	ldd	r30, Y+1	; 0x01
    2326:	fa 81       	ldd	r31, Y+2	; 0x02
    2328:	30 97       	sbiw	r30, 0x00	; 0
    232a:	11 f4       	brne	.+4      	; 0x2330 <Receive_VCP_byte+0x1e>
    232c:	85 e0       	ldi	r24, 0x05	; 5
    232e:	82 c0       	rjmp	.+260    	; 0x2434 <Receive_VCP_byte+0x122>
		return VCP_NULL_ERR;
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
    2330:	2f 81       	ldd	r18, Y+7	; 0x07
    2332:	38 85       	ldd	r19, Y+8	; 0x08
    2334:	8d 81       	ldd	r24, Y+5	; 0x05
    2336:	9e 81       	ldd	r25, Y+6	; 0x06
    2338:	01 97       	sbiw	r24, 0x01	; 1
    233a:	28 17       	cp	r18, r24
    233c:	39 07       	cpc	r19, r25
    233e:	10 f0       	brcs	.+4      	; 0x2344 <Receive_VCP_byte+0x32>
    2340:	83 e0       	ldi	r24, 0x03	; 3
    2342:	78 c0       	rjmp	.+240    	; 0x2434 <Receive_VCP_byte+0x122>
		return VCP_OVR_ERR;
	
	// State Machine
	switch (buff->status)
    2344:	89 85       	ldd	r24, Y+9	; 0x09
    2346:	82 30       	cpi	r24, 0x02	; 2
    2348:	49 f1       	breq	.+82     	; 0x239c <Receive_VCP_byte+0x8a>
    234a:	83 30       	cpi	r24, 0x03	; 3
    234c:	18 f4       	brcc	.+6      	; 0x2354 <Receive_VCP_byte+0x42>
    234e:	88 23       	and	r24, r24
    2350:	31 f0       	breq	.+12     	; 0x235e <Receive_VCP_byte+0x4c>
    2352:	39 c0       	rjmp	.+114    	; 0x23c6 <Receive_VCP_byte+0xb4>
    2354:	80 31       	cpi	r24, 0x10	; 16
    2356:	31 f0       	breq	.+12     	; 0x2364 <Receive_VCP_byte+0x52>
    2358:	80 32       	cpi	r24, 0x20	; 32
    235a:	a9 f5       	brne	.+106    	; 0x23c6 <Receive_VCP_byte+0xb4>
    235c:	0b c0       	rjmp	.+22     	; 0x2374 <Receive_VCP_byte+0x62>
	{
		case VCP_IDLE:										
			if (byte == FEND)
    235e:	60 3c       	cpi	r22, 0xC0	; 192
    2360:	99 f5       	brne	.+102    	; 0x23c8 <Receive_VCP_byte+0xb6>
    2362:	0e c0       	rjmp	.+28     	; 0x2380 <Receive_VCP_byte+0x6e>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
    2364:	6c 30       	cpi	r22, 0x0C	; 12
    2366:	20 f0       	brcs	.+8      	; 0x2370 <Receive_VCP_byte+0x5e>
    2368:	68 33       	cpi	r22, 0x38	; 56
    236a:	11 f0       	breq	.+4      	; 0x2370 <Receive_VCP_byte+0x5e>
    236c:	86 e0       	ldi	r24, 0x06	; 6
    236e:	62 c0       	rjmp	.+196    	; 0x2434 <Receive_VCP_byte+0x122>
				return VCP_ADDR_ERR;
			else
			{
				buff->address = byte;
    2370:	68 83       	st	Y, r22
    2372:	26 c0       	rjmp	.+76     	; 0x23c0 <Receive_VCP_byte+0xae>
				buff->status = VCP_RECEIVING;
			}	
			break;
		case VCP_RECEIVING:
			if (byte == FEND)
    2374:	60 3c       	cpi	r22, 0xC0	; 192
    2376:	31 f4       	brne	.+12     	; 0x2384 <Receive_VCP_byte+0x72>
			{
				if (buff->index > 0)
    2378:	23 2b       	or	r18, r19
    237a:	11 f0       	breq	.+4      	; 0x2380 <Receive_VCP_byte+0x6e>
					// Done
					buff->status = VCP_TERM;
    237c:	81 e0       	ldi	r24, 0x01	; 1
    237e:	21 c0       	rjmp	.+66     	; 0x23c2 <Receive_VCP_byte+0xb0>
				else
					// No data between FENDs - assume lost sync and start over
					buff->status = VCP_ADDRESS;
    2380:	80 e1       	ldi	r24, 0x10	; 16
    2382:	1f c0       	rjmp	.+62     	; 0x23c2 <Receive_VCP_byte+0xb0>
			}
			else if (byte == FESC)
    2384:	6b 3d       	cpi	r22, 0xDB	; 219
    2386:	11 f4       	brne	.+4      	; 0x238c <Receive_VCP_byte+0x7a>
				buff->status = VCP_ESC;
    2388:	82 e0       	ldi	r24, 0x02	; 2
    238a:	1b c0       	rjmp	.+54     	; 0x23c2 <Receive_VCP_byte+0xb0>
			else
			{
				buff->message[(buff->index)++] = byte;	
    238c:	e2 0f       	add	r30, r18
    238e:	f3 1f       	adc	r31, r19
    2390:	60 83       	st	Z, r22
    2392:	2f 5f       	subi	r18, 0xFF	; 255
    2394:	3f 4f       	sbci	r19, 0xFF	; 255
    2396:	38 87       	std	Y+8, r19	; 0x08
    2398:	2f 83       	std	Y+7, r18	; 0x07
    239a:	16 c0       	rjmp	.+44     	; 0x23c8 <Receive_VCP_byte+0xb6>
			}						
			break;
		case VCP_ESC:
			if (byte == TFEND)
    239c:	6c 3d       	cpi	r22, 0xDC	; 220
    239e:	21 f4       	brne	.+8      	; 0x23a8 <Receive_VCP_byte+0x96>
			{
				buff->message[(buff->index)++] = FEND;
    23a0:	e2 0f       	add	r30, r18
    23a2:	f3 1f       	adc	r31, r19
    23a4:	80 ec       	ldi	r24, 0xC0	; 192
    23a6:	07 c0       	rjmp	.+14     	; 0x23b6 <Receive_VCP_byte+0xa4>
				buff->status = VCP_RECEIVING;
			}
			else if (byte == TFESC)
    23a8:	6d 3d       	cpi	r22, 0xDD	; 221
    23aa:	11 f0       	breq	.+4      	; 0x23b0 <Receive_VCP_byte+0x9e>
    23ac:	87 e0       	ldi	r24, 0x07	; 7
    23ae:	42 c0       	rjmp	.+132    	; 0x2434 <Receive_VCP_byte+0x122>
			{
				buff->message[(buff->index)++] = FESC;
    23b0:	e2 0f       	add	r30, r18
    23b2:	f3 1f       	adc	r31, r19
    23b4:	8b ed       	ldi	r24, 0xDB	; 219
    23b6:	80 83       	st	Z, r24
    23b8:	2f 5f       	subi	r18, 0xFF	; 255
    23ba:	3f 4f       	sbci	r19, 0xFF	; 255
    23bc:	38 87       	std	Y+8, r19	; 0x08
    23be:	2f 83       	std	Y+7, r18	; 0x07
				buff->status = VCP_RECEIVING;
    23c0:	80 e2       	ldi	r24, 0x20	; 32
    23c2:	89 87       	std	Y+9, r24	; 0x09
    23c4:	01 c0       	rjmp	.+2      	; 0x23c8 <Receive_VCP_byte+0xb6>
			}
			else
				return VCP_ESC_ERR;	
			break;
		default:
			buff->status = VCP_IDLE;
    23c6:	19 86       	std	Y+9, r1	; 0x09
			break; 
	}
	
	// End of frame
	if (buff->status == VCP_TERM)
    23c8:	89 85       	ldd	r24, Y+9	; 0x09
    23ca:	81 30       	cpi	r24, 0x01	; 1
    23cc:	91 f5       	brne	.+100    	; 0x2432 <Receive_VCP_byte+0x120>
	{
		// Message CRC is last 2 bytes 
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
    23ce:	e9 81       	ldd	r30, Y+1	; 0x01
    23d0:	fa 81       	ldd	r31, Y+2	; 0x02
    23d2:	8f 81       	ldd	r24, Y+7	; 0x07
    23d4:	98 85       	ldd	r25, Y+8	; 0x08
    23d6:	e8 0f       	add	r30, r24
    23d8:	f9 1f       	adc	r31, r25
    23da:	32 97       	sbiw	r30, 0x02	; 2
    23dc:	c1 90       	ld	r12, Z+
    23de:	d0 80       	ld	r13, Z
		// Remove CRC bytes from the message
		buff->index -= 2;
    23e0:	02 97       	sbiw	r24, 0x02	; 2
    23e2:	98 87       	std	Y+8, r25	; 0x08
    23e4:	8f 83       	std	Y+7, r24	; 0x07
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
    23e6:	83 e0       	ldi	r24, 0x03	; 3
    23e8:	e8 2e       	mov	r14, r24
    23ea:	f1 2c       	mov	r15, r1
    23ec:	ec 0e       	add	r14, r28
    23ee:	fd 1e       	adc	r15, r29
    23f0:	88 81       	ld	r24, Y
    23f2:	b7 01       	movw	r22, r14
    23f4:	0e 94 67 11 	call	0x22ce	; 0x22ce <append_crc16>
    23f8:	00 e0       	ldi	r16, 0x00	; 0
    23fa:	10 e0       	ldi	r17, 0x00	; 0
    23fc:	0a c0       	rjmp	.+20     	; 0x2412 <Receive_VCP_byte+0x100>
		for (payload_index = 0; payload_index < buff->index; payload_index++)
		{
			append_crc16(buff->message[payload_index], &buff->crc);
    23fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2400:	fa 81       	ldd	r31, Y+2	; 0x02
    2402:	e0 0f       	add	r30, r16
    2404:	f1 1f       	adc	r31, r17
    2406:	80 81       	ld	r24, Z
    2408:	b7 01       	movw	r22, r14
    240a:	0e 94 67 11 	call	0x22ce	; 0x22ce <append_crc16>
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
		// Remove CRC bytes from the message
		buff->index -= 2;
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    240e:	0f 5f       	subi	r16, 0xFF	; 255
    2410:	1f 4f       	sbci	r17, 0xFF	; 255
    2412:	8f 81       	ldd	r24, Y+7	; 0x07
    2414:	98 85       	ldd	r25, Y+8	; 0x08
    2416:	08 17       	cp	r16, r24
    2418:	19 07       	cpc	r17, r25
    241a:	88 f3       	brcs	.-30     	; 0x23fe <Receive_VCP_byte+0xec>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
		}
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
    241c:	9c 2d       	mov	r25, r12
    241e:	80 e0       	ldi	r24, 0x00	; 0
    2420:	8d 0d       	add	r24, r13
    2422:	91 1d       	adc	r25, r1
    2424:	2b 81       	ldd	r18, Y+3	; 0x03
    2426:	3c 81       	ldd	r19, Y+4	; 0x04
    2428:	28 17       	cp	r18, r24
    242a:	39 07       	cpc	r19, r25
    242c:	11 f0       	breq	.+4      	; 0x2432 <Receive_VCP_byte+0x120>
    242e:	84 e0       	ldi	r24, 0x04	; 4
    2430:	01 c0       	rjmp	.+2      	; 0x2434 <Receive_VCP_byte+0x122>
			return VCP_CRC_ERR;
	}

	return buff->status;
    2432:	89 85       	ldd	r24, Y+9	; 0x09
}
    2434:	df 91       	pop	r29
    2436:	cf 91       	pop	r28
    2438:	1f 91       	pop	r17
    243a:	0f 91       	pop	r16
    243c:	ff 90       	pop	r15
    243e:	ef 90       	pop	r14
    2440:	df 90       	pop	r13
    2442:	cf 90       	pop	r12
    2444:	08 95       	ret

00002446 <Create_VCP_frame>:
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
    2446:	4f 92       	push	r4
    2448:	5f 92       	push	r5
    244a:	6f 92       	push	r6
    244c:	7f 92       	push	r7
    244e:	9f 92       	push	r9
    2450:	af 92       	push	r10
    2452:	bf 92       	push	r11
    2454:	cf 92       	push	r12
    2456:	df 92       	push	r13
    2458:	ef 92       	push	r14
    245a:	ff 92       	push	r15
    245c:	0f 93       	push	r16
    245e:	1f 93       	push	r17
    2460:	df 93       	push	r29
    2462:	cf 93       	push	r28
    2464:	00 d0       	rcall	.+0      	; 0x2466 <Create_VCP_frame+0x20>
    2466:	cd b7       	in	r28, 0x3d	; 61
    2468:	de b7       	in	r29, 0x3e	; 62
    246a:	7c 01       	movw	r14, r24
    246c:	2b 01       	movw	r4, r22
    246e:	94 2e       	mov	r9, r20
    2470:	59 01       	movw	r10, r18
    2472:	68 01       	movw	r12, r16
	uint16_t src_index = 0;
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
    2474:	00 97       	sbiw	r24, 0x00	; 0
    2476:	09 f4       	brne	.+2      	; 0x247a <Create_VCP_frame+0x34>
    2478:	76 c0       	rjmp	.+236    	; 0x2566 <Create_VCP_frame+0x120>
    247a:	21 15       	cp	r18, r1
    247c:	31 05       	cpc	r19, r1
    247e:	09 f4       	brne	.+2      	; 0x2482 <Create_VCP_frame+0x3c>
    2480:	72 c0       	rjmp	.+228    	; 0x2566 <Create_VCP_frame+0x120>
		return VCP_NULL_ERR;

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
    2482:	8b e0       	ldi	r24, 0x0B	; 11
    2484:	84 17       	cp	r24, r20
    2486:	28 f4       	brcc	.+10     	; 0x2492 <Create_VCP_frame+0x4c>
    2488:	e8 e3       	ldi	r30, 0x38	; 56
    248a:	4e 17       	cp	r20, r30
    248c:	11 f0       	breq	.+4      	; 0x2492 <Create_VCP_frame+0x4c>
    248e:	86 e0       	ldi	r24, 0x06	; 6
    2490:	6b c0       	rjmp	.+214    	; 0x2568 <Create_VCP_frame+0x122>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    2492:	3e 01       	movw	r6, r28
    2494:	08 94       	sec
    2496:	61 1c       	adc	r6, r1
    2498:	71 1c       	adc	r7, r1
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
	uint16_t crc = CRC16_INIT_VALUE;
    249a:	1a 82       	std	Y+2, r1	; 0x02
    249c:	19 82       	std	Y+1, r1	; 0x01
	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    249e:	89 2d       	mov	r24, r9
    24a0:	b3 01       	movw	r22, r6
    24a2:	0e 94 67 11 	call	0x22ce	; 0x22ce <append_crc16>
    24a6:	00 e0       	ldi	r16, 0x00	; 0
    24a8:	10 e0       	ldi	r17, 0x00	; 0
    24aa:	09 c0       	rjmp	.+18     	; 0x24be <Create_VCP_frame+0x78>

	for (src_index = 0; src_index < src_size; src_index++)
	  append_crc16(src[src_index], &crc);
    24ac:	f5 01       	movw	r30, r10
    24ae:	e0 0f       	add	r30, r16
    24b0:	f1 1f       	adc	r31, r17
    24b2:	80 81       	ld	r24, Z
    24b4:	b3 01       	movw	r22, r6
    24b6:	0e 94 67 11 	call	0x22ce	; 0x22ce <append_crc16>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    24ba:	0f 5f       	subi	r16, 0xFF	; 255
    24bc:	1f 4f       	sbci	r17, 0xFF	; 255
    24be:	0c 15       	cp	r16, r12
    24c0:	1d 05       	cpc	r17, r13
    24c2:	a0 f3       	brcs	.-24     	; 0x24ac <Create_VCP_frame+0x66>
	  append_crc16(src[src_index], &crc);
	
	// Add CRC to the end of the source buffer
	src[src_index++] = ((crc >> 8) & 0xFF);
    24c4:	f5 01       	movw	r30, r10
    24c6:	ec 0d       	add	r30, r12
    24c8:	fd 1d       	adc	r31, r13
    24ca:	8a 81       	ldd	r24, Y+2	; 0x02
    24cc:	80 83       	st	Z, r24
    24ce:	96 01       	movw	r18, r12
    24d0:	2f 5f       	subi	r18, 0xFF	; 255
    24d2:	3f 4f       	sbci	r19, 0xFF	; 255
	src[src_index++] = (crc & 0xFF);
    24d4:	f5 01       	movw	r30, r10
    24d6:	e2 0f       	add	r30, r18
    24d8:	f3 1f       	adc	r31, r19
    24da:	89 81       	ldd	r24, Y+1	; 0x01
    24dc:	80 83       	st	Z, r24
    24de:	89 01       	movw	r16, r18
    24e0:	0f 5f       	subi	r16, 0xFF	; 255
    24e2:	1f 4f       	sbci	r17, 0xFF	; 255
	payload_size = src_index;
	
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
    24e4:	80 ec       	ldi	r24, 0xC0	; 192
    24e6:	f7 01       	movw	r30, r14
    24e8:	80 83       	st	Z, r24
	// then insert VCP address
	dst[dst_index++] =					addr;
    24ea:	91 82       	std	Z+1, r9	; 0x01
    24ec:	60 e0       	ldi	r22, 0x00	; 0
    24ee:	70 e0       	ldi	r23, 0x00	; 0
    24f0:	42 e0       	ldi	r20, 0x02	; 2
    24f2:	50 e0       	ldi	r21, 0x00	; 0
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    24f4:	9d ed       	ldi	r25, 0xDD	; 221
    24f6:	d9 2e       	mov	r13, r25
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
    24f8:	3b ed       	ldi	r19, 0xDB	; 219
			dst[dst_index++] =			TFEND;
    24fa:	2c ed       	ldi	r18, 0xDC	; 220
    24fc:	25 c0       	rjmp	.+74     	; 0x2548 <Create_VCP_frame+0x102>
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
    24fe:	f5 01       	movw	r30, r10
    2500:	e6 0f       	add	r30, r22
    2502:	f7 1f       	adc	r31, r23
    2504:	e0 81       	ld	r30, Z
    2506:	e0 3c       	cpi	r30, 0xC0	; 192
    2508:	59 f4       	brne	.+22     	; 0x2520 <Create_VCP_frame+0xda>
		{
			dst[dst_index++] =			FESC;
    250a:	f7 01       	movw	r30, r14
    250c:	e4 0f       	add	r30, r20
    250e:	f5 1f       	adc	r31, r21
    2510:	30 83       	st	Z, r19
    2512:	ca 01       	movw	r24, r20
    2514:	01 96       	adiw	r24, 0x01	; 1
			dst[dst_index++] =			TFEND;
    2516:	f7 01       	movw	r30, r14
    2518:	e8 0f       	add	r30, r24
    251a:	f9 1f       	adc	r31, r25
    251c:	20 83       	st	Z, r18
    251e:	0c c0       	rjmp	.+24     	; 0x2538 <Create_VCP_frame+0xf2>
    2520:	d7 01       	movw	r26, r14
    2522:	a4 0f       	add	r26, r20
    2524:	b5 1f       	adc	r27, r21
    2526:	ca 01       	movw	r24, r20
    2528:	01 96       	adiw	r24, 0x01	; 1
		}
		else if (src[src_index] == FESC)
    252a:	eb 3d       	cpi	r30, 0xDB	; 219
    252c:	49 f4       	brne	.+18     	; 0x2540 <Create_VCP_frame+0xfa>
		{
			dst[dst_index++] =			FESC;
    252e:	ec 93       	st	X, r30
			dst[dst_index++] =			TFESC;
    2530:	f7 01       	movw	r30, r14
    2532:	e8 0f       	add	r30, r24
    2534:	f9 1f       	adc	r31, r25
    2536:	d0 82       	st	Z, r13
    2538:	ac 01       	movw	r20, r24
    253a:	4f 5f       	subi	r20, 0xFF	; 255
    253c:	5f 4f       	sbci	r21, 0xFF	; 255
    253e:	02 c0       	rjmp	.+4      	; 0x2544 <Create_VCP_frame+0xfe>
		}
		else
		{
			dst[dst_index++] =			src[src_index];
    2540:	ec 93       	st	X, r30
    2542:	ac 01       	movw	r20, r24
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    2544:	6f 5f       	subi	r22, 0xFF	; 255
    2546:	7f 4f       	sbci	r23, 0xFF	; 255
    2548:	60 17       	cp	r22, r16
    254a:	71 07       	cpc	r23, r17
    254c:	c0 f2       	brcs	.-80     	; 0x24fe <Create_VCP_frame+0xb8>
		//if (dst_index >= *dst_size - 1)
			//return VCP_OVR_ERR;
	}
	
	// End the frame with FEND
	dst[dst_index++] =					FEND;
    254e:	e4 0e       	add	r14, r20
    2550:	f5 1e       	adc	r15, r21
    2552:	80 ec       	ldi	r24, 0xC0	; 192
    2554:	f7 01       	movw	r30, r14
    2556:	80 83       	st	Z, r24
	
	// Save the frame size
	*dst_size = dst_index;
    2558:	4f 5f       	subi	r20, 0xFF	; 255
    255a:	5f 4f       	sbci	r21, 0xFF	; 255
    255c:	f2 01       	movw	r30, r4
    255e:	51 83       	std	Z+1, r21	; 0x01
    2560:	40 83       	st	Z, r20
    2562:	81 e0       	ldi	r24, 0x01	; 1
    2564:	01 c0       	rjmp	.+2      	; 0x2568 <Create_VCP_frame+0x122>
	
	// All good
	return VCP_TERM;
    2566:	85 e0       	ldi	r24, 0x05	; 5
}
    2568:	0f 90       	pop	r0
    256a:	0f 90       	pop	r0
    256c:	cf 91       	pop	r28
    256e:	df 91       	pop	r29
    2570:	1f 91       	pop	r17
    2572:	0f 91       	pop	r16
    2574:	ff 90       	pop	r15
    2576:	ef 90       	pop	r14
    2578:	df 90       	pop	r13
    257a:	cf 90       	pop	r12
    257c:	bf 90       	pop	r11
    257e:	af 90       	pop	r10
    2580:	9f 90       	pop	r9
    2582:	7f 90       	pop	r7
    2584:	6f 90       	pop	r6
    2586:	5f 90       	pop	r5
    2588:	4f 90       	pop	r4
    258a:	08 95       	ret

0000258c <__vector_15>:
#include "vcp_library.h"
#include "crclib.h"
#include "uart.h"

ISR(TIMER0_COMP_vect)
{
    258c:	1f 92       	push	r1
    258e:	0f 92       	push	r0
    2590:	0f b6       	in	r0, 0x3f	; 63
    2592:	0f 92       	push	r0
    2594:	11 24       	eor	r1, r1
    2596:	8f 93       	push	r24
  if ( timer0_counter[0] > 0 )
    2598:	80 91 2b 0b 	lds	r24, 0x0B2B
    259c:	88 23       	and	r24, r24
    259e:	29 f0       	breq	.+10     	; 0x25aa <__vector_15+0x1e>
    --timer0_counter[0];
    25a0:	80 91 2b 0b 	lds	r24, 0x0B2B
    25a4:	81 50       	subi	r24, 0x01	; 1
    25a6:	80 93 2b 0b 	sts	0x0B2B, r24
  if ( timer0_counter[1] > 0 )
    25aa:	80 91 2c 0b 	lds	r24, 0x0B2C
    25ae:	88 23       	and	r24, r24
    25b0:	29 f0       	breq	.+10     	; 0x25bc <__vector_15+0x30>
    --timer0_counter[1];
    25b2:	80 91 2c 0b 	lds	r24, 0x0B2C
    25b6:	81 50       	subi	r24, 0x01	; 1
    25b8:	80 93 2c 0b 	sts	0x0B2C, r24
	//if (cntr == 0)
	//	PORTC |= 0x01;
	//else
	//	PORTC &= 0xFE;
	//_delay_ms(500);
}
    25bc:	8f 91       	pop	r24
    25be:	0f 90       	pop	r0
    25c0:	0f be       	out	0x3f, r0	; 63
    25c2:	0f 90       	pop	r0
    25c4:	1f 90       	pop	r1
    25c6:	18 95       	reti

000025c8 <__vector_21>:
    rx_flag[1]++;
  }
}

ISR ( ADC_vect )
{
    25c8:	1f 92       	push	r1
    25ca:	0f 92       	push	r0
    25cc:	0f b6       	in	r0, 0x3f	; 63
    25ce:	0f 92       	push	r0
    25d0:	11 24       	eor	r1, r1
    25d2:	8f 93       	push	r24
  ADC_low = ADCL;	// Left adjusted; read 2 LSB then 8 MSB
    25d4:	84 b1       	in	r24, 0x04	; 4
    25d6:	80 93 4f 0d 	sts	0x0D4F, r24
  ADC_high = ADCH;
    25da:	85 b1       	in	r24, 0x05	; 5
    25dc:	80 93 19 09 	sts	0x0919, r24
  adc_flag = 1;
    25e0:	81 e0       	ldi	r24, 0x01	; 1
    25e2:	80 93 fc 08 	sts	0x08FC, r24
}
    25e6:	8f 91       	pop	r24
    25e8:	0f 90       	pop	r0
    25ea:	0f be       	out	0x3f, r0	; 63
    25ec:	0f 90       	pop	r0
    25ee:	1f 90       	pop	r1
    25f0:	18 95       	reti

000025f2 <tx_put_byte>:
    rx_flag[0]++;
  }
}

void tx_put_byte( uint8_t uart )
{
    25f2:	68 2f       	mov	r22, r24
  if ( uart != 0 && uart != 1 )
    25f4:	82 30       	cpi	r24, 0x02	; 2
    25f6:	c8 f5       	brcc	.+114    	; 0x266a <tx_put_byte+0x78>
    return;
  if( tel_packet_index[uart] < tel_packet_size[uart] )
    25f8:	48 2f       	mov	r20, r24
    25fa:	50 e0       	ldi	r21, 0x00	; 0
    25fc:	da 01       	movw	r26, r20
    25fe:	aa 50       	subi	r26, 0x0A	; 10
    2600:	b9 4f       	sbci	r27, 0xF9	; 249
    2602:	8c 91       	ld	r24, X
    2604:	fa 01       	movw	r30, r20
    2606:	ee 0f       	add	r30, r30
    2608:	ff 1f       	adc	r31, r31
    260a:	ea 5d       	subi	r30, 0xDA	; 218
    260c:	fc 4f       	sbci	r31, 0xFC	; 252
    260e:	20 81       	ld	r18, Z
    2610:	31 81       	ldd	r19, Z+1	; 0x01
    2612:	90 e0       	ldi	r25, 0x00	; 0
    2614:	82 17       	cp	r24, r18
    2616:	93 07       	cpc	r25, r19
    2618:	40 f5       	brcc	.+80     	; 0x266a <tx_put_byte+0x78>
  {
      if ( uart == 0 )
    261a:	66 23       	and	r22, r22
    261c:	99 f4       	brne	.+38     	; 0x2644 <tx_put_byte+0x52>
      UDR0 = tel_packet[uart][tel_packet_index[uart]++];
    261e:	2c 91       	ld	r18, X
    2620:	8f ef       	ldi	r24, 0xFF	; 255
    2622:	90 e0       	ldi	r25, 0x00	; 0
    2624:	48 9f       	mul	r20, r24
    2626:	f0 01       	movw	r30, r0
    2628:	49 9f       	mul	r20, r25
    262a:	f0 0d       	add	r31, r0
    262c:	58 9f       	mul	r21, r24
    262e:	f0 0d       	add	r31, r0
    2630:	11 24       	eor	r1, r1
    2632:	e2 0f       	add	r30, r18
    2634:	f1 1d       	adc	r31, r1
    2636:	e3 50       	subi	r30, 0x03	; 3
    2638:	f9 4f       	sbci	r31, 0xF9	; 249
    263a:	80 81       	ld	r24, Z
    263c:	8c b9       	out	0x0c, r24	; 12
    263e:	2f 5f       	subi	r18, 0xFF	; 255
    2640:	2c 93       	st	X, r18
    2642:	08 95       	ret
    else if ( uart == 1 )
      UDR1 = tel_packet[uart][tel_packet_index[uart]++];
    2644:	2c 91       	ld	r18, X
    2646:	8f ef       	ldi	r24, 0xFF	; 255
    2648:	90 e0       	ldi	r25, 0x00	; 0
    264a:	48 9f       	mul	r20, r24
    264c:	f0 01       	movw	r30, r0
    264e:	49 9f       	mul	r20, r25
    2650:	f0 0d       	add	r31, r0
    2652:	58 9f       	mul	r21, r24
    2654:	f0 0d       	add	r31, r0
    2656:	11 24       	eor	r1, r1
    2658:	e2 0f       	add	r30, r18
    265a:	f1 1d       	adc	r31, r1
    265c:	e3 50       	subi	r30, 0x03	; 3
    265e:	f9 4f       	sbci	r31, 0xF9	; 249
    2660:	80 81       	ld	r24, Z
    2662:	80 93 9c 00 	sts	0x009C, r24
    2666:	2f 5f       	subi	r18, 0xFF	; 255
    2668:	2c 93       	st	X, r18
    266a:	08 95       	ret

0000266c <__vector_20>:
  ADC_high = ADCH;
  adc_flag = 1;
}

ISR( USART0_TX_vect )
{
    266c:	1f 92       	push	r1
    266e:	0f 92       	push	r0
    2670:	0f b6       	in	r0, 0x3f	; 63
    2672:	0f 92       	push	r0
    2674:	0b b6       	in	r0, 0x3b	; 59
    2676:	0f 92       	push	r0
    2678:	11 24       	eor	r1, r1
    267a:	2f 93       	push	r18
    267c:	3f 93       	push	r19
    267e:	4f 93       	push	r20
    2680:	5f 93       	push	r21
    2682:	6f 93       	push	r22
    2684:	7f 93       	push	r23
    2686:	8f 93       	push	r24
    2688:	9f 93       	push	r25
    268a:	af 93       	push	r26
    268c:	bf 93       	push	r27
    268e:	ef 93       	push	r30
    2690:	ff 93       	push	r31
  tx_put_byte( 0 );
    2692:	80 e0       	ldi	r24, 0x00	; 0
    2694:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <tx_put_byte>
}
    2698:	ff 91       	pop	r31
    269a:	ef 91       	pop	r30
    269c:	bf 91       	pop	r27
    269e:	af 91       	pop	r26
    26a0:	9f 91       	pop	r25
    26a2:	8f 91       	pop	r24
    26a4:	7f 91       	pop	r23
    26a6:	6f 91       	pop	r22
    26a8:	5f 91       	pop	r21
    26aa:	4f 91       	pop	r20
    26ac:	3f 91       	pop	r19
    26ae:	2f 91       	pop	r18
    26b0:	0f 90       	pop	r0
    26b2:	0b be       	out	0x3b, r0	; 59
    26b4:	0f 90       	pop	r0
    26b6:	0f be       	out	0x3f, r0	; 63
    26b8:	0f 90       	pop	r0
    26ba:	1f 90       	pop	r1
    26bc:	18 95       	reti

000026be <__vector_32>:
		--timer1_counter[1];
	//}
}

ISR(USART1_TX_vect)
{
    26be:	1f 92       	push	r1
    26c0:	0f 92       	push	r0
    26c2:	0f b6       	in	r0, 0x3f	; 63
    26c4:	0f 92       	push	r0
    26c6:	0b b6       	in	r0, 0x3b	; 59
    26c8:	0f 92       	push	r0
    26ca:	11 24       	eor	r1, r1
    26cc:	2f 93       	push	r18
    26ce:	3f 93       	push	r19
    26d0:	4f 93       	push	r20
    26d2:	5f 93       	push	r21
    26d4:	6f 93       	push	r22
    26d6:	7f 93       	push	r23
    26d8:	8f 93       	push	r24
    26da:	9f 93       	push	r25
    26dc:	af 93       	push	r26
    26de:	bf 93       	push	r27
    26e0:	ef 93       	push	r30
    26e2:	ff 93       	push	r31
  tx_put_byte( 1 );
    26e4:	81 e0       	ldi	r24, 0x01	; 1
    26e6:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <tx_put_byte>
}
    26ea:	ff 91       	pop	r31
    26ec:	ef 91       	pop	r30
    26ee:	bf 91       	pop	r27
    26f0:	af 91       	pop	r26
    26f2:	9f 91       	pop	r25
    26f4:	8f 91       	pop	r24
    26f6:	7f 91       	pop	r23
    26f8:	6f 91       	pop	r22
    26fa:	5f 91       	pop	r21
    26fc:	4f 91       	pop	r20
    26fe:	3f 91       	pop	r19
    2700:	2f 91       	pop	r18
    2702:	0f 90       	pop	r0
    2704:	0b be       	out	0x3b, r0	; 59
    2706:	0f 90       	pop	r0
    2708:	0f be       	out	0x3f, r0	; 63
    270a:	0f 90       	pop	r0
    270c:	1f 90       	pop	r1
    270e:	18 95       	reti

00002710 <construct_telemetry_packet>:
  }
}


void construct_telemetry_packet( uint8_t* packet_payload )
{
    2710:	0f 93       	push	r16
    2712:	1f 93       	push	r17
    2714:	8c 01       	movw	r16, r24
  packet_payload[0] = VCP_POWER_TELEMETRY;
    2716:	fc 01       	movw	r30, r24
    2718:	10 82       	st	Z, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    271a:	90 91 3b 04 	lds	r25, 0x043B
    271e:	99 0f       	add	r25, r25
    2720:	80 91 55 04 	lds	r24, 0x0455
    2724:	88 0f       	add	r24, r24
    2726:	88 0f       	add	r24, r24
    2728:	89 2b       	or	r24, r25
    272a:	90 91 21 04 	lds	r25, 0x0421
    272e:	89 2b       	or	r24, r25
    2730:	90 91 6f 04 	lds	r25, 0x046F
    2734:	99 0f       	add	r25, r25
    2736:	99 0f       	add	r25, r25
    2738:	99 0f       	add	r25, r25
    273a:	98 2b       	or	r25, r24
    273c:	80 91 bd 04 	lds	r24, 0x04BD
    2740:	82 95       	swap	r24
    2742:	80 7f       	andi	r24, 0xF0	; 240
    2744:	89 2b       	or	r24, r25
    2746:	40 91 d7 04 	lds	r20, 0x04D7
    274a:	42 95       	swap	r20
    274c:	44 0f       	add	r20, r20
    274e:	40 7e       	andi	r20, 0xE0	; 224
    2750:	48 2b       	or	r20, r24
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    2752:	90 91 0b 05 	lds	r25, 0x050B
    2756:	99 0f       	add	r25, r25
    2758:	80 91 25 05 	lds	r24, 0x0525
    275c:	88 0f       	add	r24, r24
    275e:	88 0f       	add	r24, r24
    2760:	89 2b       	or	r24, r25
    2762:	90 91 f1 04 	lds	r25, 0x04F1
    2766:	89 2b       	or	r24, r25
    2768:	30 91 89 04 	lds	r19, 0x0489
    276c:	33 0f       	add	r19, r19
    276e:	33 0f       	add	r19, r19
    2770:	33 0f       	add	r19, r19
    2772:	38 2b       	or	r19, r24
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );

  packet_payload[1] = on_off_state0;
    2774:	90 91 51 03 	lds	r25, 0x0351
    2778:	99 0f       	add	r25, r25
    277a:	80 91 6b 03 	lds	r24, 0x036B
    277e:	88 0f       	add	r24, r24
    2780:	88 0f       	add	r24, r24
    2782:	89 2b       	or	r24, r25
    2784:	90 91 37 03 	lds	r25, 0x0337
    2788:	89 2b       	or	r24, r25
    278a:	90 91 9f 03 	lds	r25, 0x039F
    278e:	99 0f       	add	r25, r25
    2790:	99 0f       	add	r25, r25
    2792:	99 0f       	add	r25, r25
    2794:	98 2b       	or	r25, r24
    2796:	80 91 b9 03 	lds	r24, 0x03B9
    279a:	82 95       	swap	r24
    279c:	80 7f       	andi	r24, 0xF0	; 240
    279e:	89 2b       	or	r24, r25
    27a0:	90 91 d3 03 	lds	r25, 0x03D3
    27a4:	92 95       	swap	r25
    27a6:	99 0f       	add	r25, r25
    27a8:	90 7e       	andi	r25, 0xE0	; 224
    27aa:	98 2b       	or	r25, r24
    27ac:	20 91 ed 03 	lds	r18, 0x03ED
    27b0:	22 95       	swap	r18
    27b2:	22 0f       	add	r18, r18
    27b4:	22 0f       	add	r18, r18
    27b6:	20 7c       	andi	r18, 0xC0	; 192
    27b8:	29 2b       	or	r18, r25
    27ba:	80 91 07 04 	lds	r24, 0x0407
    27be:	87 95       	ror	r24
    27c0:	88 27       	eor	r24, r24
    27c2:	87 95       	ror	r24
    27c4:	82 2b       	or	r24, r18
    27c6:	81 83       	std	Z+1, r24	; 0x01
  packet_payload[2] = on_off_state1;
    27c8:	42 83       	std	Z+2, r20	; 0x02
  packet_payload[3] = on_off_state2;
    27ca:	33 83       	std	Z+3, r19	; 0x03
  packet_payload[4] = 0x99;
    27cc:	89 e9       	ldi	r24, 0x99	; 153
    27ce:	84 83       	std	Z+4, r24	; 0x04
  packet_payload[5] = svit[MAESTRO].switch_state;
    27d0:	80 91 89 04 	lds	r24, 0x0489
    27d4:	85 83       	std	Z+5, r24	; 0x05

  // voltage values (raw ADC output)
  packet_payload[6]  = SVIT_check_V_critical( svit[SPECTROMETER].name );
    27d6:	80 91 35 03 	lds	r24, 0x0335
    27da:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    27de:	f8 01       	movw	r30, r16
    27e0:	86 83       	std	Z+6, r24	; 0x06
  packet_payload[7]  = SVIT_check_V_critical( svit[STAR_TRACKER].name );
    27e2:	80 91 4f 03 	lds	r24, 0x034F
    27e6:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    27ea:	f8 01       	movw	r30, r16
    27ec:	87 83       	std	Z+7, r24	; 0x07
  packet_payload[8]  = SVIT_check_V_critical( svit[FC_5V].name );
    27ee:	80 91 69 03 	lds	r24, 0x0369
    27f2:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    27f6:	f8 01       	movw	r30, r16
    27f8:	80 87       	std	Z+8, r24	; 0x08
  packet_payload[9]  = SVIT_check_V_critical( svit[FC_3_3V].name );
    27fa:	80 91 83 03 	lds	r24, 0x0383
    27fe:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2802:	f8 01       	movw	r30, r16
    2804:	81 87       	std	Z+9, r24	; 0x09
  packet_payload[10] = SVIT_check_V_critical( svit[GPS_1].name );
    2806:	80 91 9d 03 	lds	r24, 0x039D
    280a:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    280e:	f8 01       	movw	r30, r16
    2810:	82 87       	std	Z+10, r24	; 0x0a
  packet_payload[11] = SVIT_check_V_critical( svit[CDH_IB].name );
    2812:	80 91 d1 03 	lds	r24, 0x03D1
    2816:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    281a:	f8 01       	movw	r30, r16
    281c:	83 87       	std	Z+11, r24	; 0x0b
  packet_payload[12] = SVIT_check_V_critical( svit[HEATER_1].name );
    281e:	80 91 eb 03 	lds	r24, 0x03EB
    2822:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2826:	f8 01       	movw	r30, r16
    2828:	84 87       	std	Z+12, r24	; 0x0c
  packet_payload[13] = SVIT_check_V_critical( svit[HEATER_2].name );
    282a:	80 91 05 04 	lds	r24, 0x0405
    282e:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2832:	f8 01       	movw	r30, r16
    2834:	85 87       	std	Z+13, r24	; 0x0d
  packet_payload[14] = SVIT_check_V_critical( svit[CMG].name );
    2836:	80 91 1f 04 	lds	r24, 0x041F
    283a:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    283e:	f8 01       	movw	r30, r16
    2840:	86 87       	std	Z+14, r24	; 0x0e
  packet_payload[15] = SVIT_check_V_critical( svit[SUN_SENSOR].name );
    2842:	80 91 39 04 	lds	r24, 0x0439
    2846:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    284a:	f8 01       	movw	r30, r16
    284c:	87 87       	std	Z+15, r24	; 0x0f
  packet_payload[16] = SVIT_check_V_critical( svit[RADIO_1].name );
    284e:	80 91 53 04 	lds	r24, 0x0453
    2852:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2856:	f8 01       	movw	r30, r16
    2858:	80 8b       	std	Z+16, r24	; 0x10
  packet_payload[17] = SVIT_check_V_critical( svit[RADIO_2].name );
    285a:	80 91 6d 04 	lds	r24, 0x046D
    285e:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2862:	f8 01       	movw	r30, r16
    2864:	81 8b       	std	Z+17, r24	; 0x11
  packet_payload[18] = SVIT_check_V_critical( svit[FOG_15V].name );
    2866:	80 91 bb 04 	lds	r24, 0x04BB
    286a:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    286e:	f8 01       	movw	r30, r16
    2870:	82 8b       	std	Z+18, r24	; 0x12
  packet_payload[19] = SVIT_check_V_critical( svit[FOG_5V].name );
    2872:	80 91 d5 04 	lds	r24, 0x04D5
    2876:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    287a:	f8 01       	movw	r30, r16
    287c:	83 8b       	std	Z+19, r24	; 0x13
  packet_payload[20] = SVIT_check_V_critical( svit[TORQUER_1].name );
    287e:	80 91 ef 04 	lds	r24, 0x04EF
    2882:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2886:	f8 01       	movw	r30, r16
    2888:	84 8b       	std	Z+20, r24	; 0x14
  packet_payload[21] = SVIT_check_V_critical( svit[TORQUER_2].name );
    288a:	80 91 09 05 	lds	r24, 0x0509
    288e:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2892:	f8 01       	movw	r30, r16
    2894:	85 8b       	std	Z+21, r24	; 0x15
  packet_payload[22] = SVIT_check_V_critical( svit[TORQUER_3].name );
    2896:	80 91 23 05 	lds	r24, 0x0523
    289a:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    289e:	f8 01       	movw	r30, r16
    28a0:	86 8b       	std	Z+22, r24	; 0x16
  packet_payload[23] = SVIT_check_V_critical( svit[BATTERY_1].name );
    28a2:	80 91 3d 05 	lds	r24, 0x053D
    28a6:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    28aa:	f8 01       	movw	r30, r16
    28ac:	87 8b       	std	Z+23, r24	; 0x17
  packet_payload[24] = SVIT_check_V_critical( svit[BATTERY_2].name );
    28ae:	80 91 57 05 	lds	r24, 0x0557
    28b2:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    28b6:	f8 01       	movw	r30, r16
    28b8:	80 8f       	std	Z+24, r24	; 0x18
  packet_payload[25] = SVIT_check_V_critical( svit[SOLAR_FULL].name );
    28ba:	80 91 71 05 	lds	r24, 0x0571
    28be:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    28c2:	f8 01       	movw	r30, r16
    28c4:	81 8f       	std	Z+25, r24	; 0x19
  packet_payload[26] = SVIT_check_V_critical( svit[SOLAR_1].name );
    28c6:	80 91 8b 05 	lds	r24, 0x058B
    28ca:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    28ce:	f8 01       	movw	r30, r16
    28d0:	82 8f       	std	Z+26, r24	; 0x1a
  packet_payload[27] = SVIT_check_V_critical( svit[SOLAR_2].name );
    28d2:	80 91 a5 05 	lds	r24, 0x05A5
    28d6:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    28da:	f8 01       	movw	r30, r16
    28dc:	83 8f       	std	Z+27, r24	; 0x1b
  packet_payload[28] = SVIT_check_V_critical( svit[SOLAR_3].name );
    28de:	80 91 bf 05 	lds	r24, 0x05BF
    28e2:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    28e6:	f8 01       	movw	r30, r16
    28e8:	84 8f       	std	Z+28, r24	; 0x1c
  packet_payload[29] = SVIT_check_V_critical( svit[SOLAR_4].name );
    28ea:	80 91 d9 05 	lds	r24, 0x05D9
    28ee:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    28f2:	f8 01       	movw	r30, r16
    28f4:	85 8f       	std	Z+29, r24	; 0x1d
  packet_payload[30] = SVIT_check_V_critical( svit[SOLAR_5].name );
    28f6:	80 91 f3 05 	lds	r24, 0x05F3
    28fa:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    28fe:	f8 01       	movw	r30, r16
    2900:	86 8f       	std	Z+30, r24	; 0x1e
  packet_payload[31] = SVIT_check_V_critical( svit[SOLAR_6].name );
    2902:	80 91 0d 06 	lds	r24, 0x060D
    2906:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    290a:	f8 01       	movw	r30, r16
    290c:	87 8f       	std	Z+31, r24	; 0x1f
  packet_payload[32] = SVIT_check_V_critical( svit[SOLAR_7].name );
    290e:	80 91 27 06 	lds	r24, 0x0627
    2912:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2916:	f8 01       	movw	r30, r16
    2918:	80 a3       	std	Z+32, r24	; 0x20
  packet_payload[33] = SVIT_check_V_critical( svit[SOLAR_8].name );
    291a:	80 91 41 06 	lds	r24, 0x0641
    291e:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2922:	f8 01       	movw	r30, r16
    2924:	81 a3       	std	Z+33, r24	; 0x21
  packet_payload[34] = SVIT_check_V_critical( svit[SOLAR_9].name );
    2926:	80 91 5b 06 	lds	r24, 0x065B
    292a:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    292e:	f8 01       	movw	r30, r16
    2930:	82 a3       	std	Z+34, r24	; 0x22
  packet_payload[35] = SVIT_check_V_critical( svit[SOLAR_10].name );
    2932:	80 91 75 06 	lds	r24, 0x0675
    2936:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    293a:	f8 01       	movw	r30, r16
    293c:	83 a3       	std	Z+35, r24	; 0x23
  packet_payload[36] = SVIT_check_V_critical( svit[SOLAR_11].name );
    293e:	80 91 8f 06 	lds	r24, 0x068F
    2942:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2946:	f8 01       	movw	r30, r16
    2948:	84 a3       	std	Z+36, r24	; 0x24
  packet_payload[37] = SVIT_check_V_critical( svit[SOLAR_12].name );
    294a:	80 91 a9 06 	lds	r24, 0x06A9
    294e:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    2952:	f8 01       	movw	r30, r16
    2954:	85 a3       	std	Z+37, r24	; 0x25
  packet_payload[38] = SVIT_check_V_critical( svit[POWER_BOARD].name );
    2956:	80 91 c3 06 	lds	r24, 0x06C3
    295a:	0e 94 3a 10 	call	0x2074	; 0x2074 <SVIT_check_V_critical>
    295e:	f8 01       	movw	r30, r16
    2960:	86 a3       	std	Z+38, r24	; 0x26
  //uint8_t voltage_error1;
  //uint8_t voltage_error2;
  //uint8_t voltage_error3;
  //uint8_t voltage_error4;
 
  packet_payload[39] = 0;
    2962:	17 a2       	std	Z+39, r1	; 0x27
  packet_payload[40] = 0;
    2964:	10 a6       	std	Z+40, r1	; 0x28
  packet_payload[41] = 0;
    2966:	11 a6       	std	Z+41, r1	; 0x29
  packet_payload[42] = 0;
    2968:	12 a6       	std	Z+42, r1	; 0x2a
  packet_payload[43] = 0;
    296a:	13 a6       	std	Z+43, r1	; 0x2b

  // current values (raw ADC output)
  packet_payload[44] = SVIT_check_I_critical( svit[SPECTROMETER].name );
    296c:	80 91 35 03 	lds	r24, 0x0335
    2970:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2974:	f8 01       	movw	r30, r16
    2976:	84 a7       	std	Z+44, r24	; 0x2c
  packet_payload[45] = SVIT_check_I_critical( svit[STAR_TRACKER].name );
    2978:	80 91 4f 03 	lds	r24, 0x034F
    297c:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2980:	f8 01       	movw	r30, r16
    2982:	85 a7       	std	Z+45, r24	; 0x2d
  packet_payload[46] = SVIT_check_I_critical( svit[FC_5V].name );
    2984:	80 91 69 03 	lds	r24, 0x0369
    2988:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    298c:	f8 01       	movw	r30, r16
    298e:	86 a7       	std	Z+46, r24	; 0x2e
  packet_payload[47] = SVIT_check_I_critical( svit[FC_3_3V].name );
    2990:	80 91 83 03 	lds	r24, 0x0383
    2994:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2998:	f8 01       	movw	r30, r16
    299a:	87 a7       	std	Z+47, r24	; 0x2f
  packet_payload[48] = SVIT_check_I_critical( svit[GPS_1].name );
    299c:	80 91 9d 03 	lds	r24, 0x039D
    29a0:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    29a4:	f8 01       	movw	r30, r16
    29a6:	80 ab       	std	Z+48, r24	; 0x30
  packet_payload[49] = SVIT_check_I_critical( svit[CDH_IB].name );
    29a8:	80 91 d1 03 	lds	r24, 0x03D1
    29ac:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    29b0:	f8 01       	movw	r30, r16
    29b2:	81 ab       	std	Z+49, r24	; 0x31
  packet_payload[50] = SVIT_check_I_critical( svit[HEATER_1].name );
    29b4:	80 91 eb 03 	lds	r24, 0x03EB
    29b8:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    29bc:	f8 01       	movw	r30, r16
    29be:	82 ab       	std	Z+50, r24	; 0x32
  packet_payload[51] = SVIT_check_I_critical( svit[HEATER_2].name );
    29c0:	80 91 05 04 	lds	r24, 0x0405
    29c4:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    29c8:	f8 01       	movw	r30, r16
    29ca:	83 ab       	std	Z+51, r24	; 0x33
  packet_payload[52] = SVIT_check_I_critical( svit[CMG].name );
    29cc:	80 91 1f 04 	lds	r24, 0x041F
    29d0:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    29d4:	f8 01       	movw	r30, r16
    29d6:	84 ab       	std	Z+52, r24	; 0x34
  packet_payload[53] = SVIT_check_I_critical( svit[SUN_SENSOR].name );
    29d8:	80 91 39 04 	lds	r24, 0x0439
    29dc:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    29e0:	f8 01       	movw	r30, r16
    29e2:	85 ab       	std	Z+53, r24	; 0x35
  packet_payload[54] = SVIT_check_I_critical( svit[RADIO_1].name );
    29e4:	80 91 53 04 	lds	r24, 0x0453
    29e8:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    29ec:	f8 01       	movw	r30, r16
    29ee:	86 ab       	std	Z+54, r24	; 0x36
  packet_payload[55] = SVIT_check_I_critical( svit[RADIO_2].name );
    29f0:	80 91 6d 04 	lds	r24, 0x046D
    29f4:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    29f8:	f8 01       	movw	r30, r16
    29fa:	87 ab       	std	Z+55, r24	; 0x37
  packet_payload[56] = SVIT_check_I_critical( svit[FOG_15V].name );
    29fc:	80 91 bb 04 	lds	r24, 0x04BB
    2a00:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a04:	f8 01       	movw	r30, r16
    2a06:	80 af       	std	Z+56, r24	; 0x38
  packet_payload[57] = SVIT_check_I_critical( svit[FOG_5V].name );
    2a08:	80 91 d5 04 	lds	r24, 0x04D5
    2a0c:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a10:	f8 01       	movw	r30, r16
    2a12:	81 af       	std	Z+57, r24	; 0x39
  packet_payload[58] = SVIT_check_I_critical( svit[TORQUER_1].name );
    2a14:	80 91 ef 04 	lds	r24, 0x04EF
    2a18:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a1c:	f8 01       	movw	r30, r16
    2a1e:	82 af       	std	Z+58, r24	; 0x3a
  packet_payload[59] = SVIT_check_I_critical( svit[TORQUER_2].name );
    2a20:	80 91 09 05 	lds	r24, 0x0509
    2a24:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a28:	f8 01       	movw	r30, r16
    2a2a:	83 af       	std	Z+59, r24	; 0x3b
  packet_payload[60] = SVIT_check_I_critical( svit[TORQUER_3].name );
    2a2c:	80 91 23 05 	lds	r24, 0x0523
    2a30:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a34:	f8 01       	movw	r30, r16
    2a36:	84 af       	std	Z+60, r24	; 0x3c
  packet_payload[61] = SVIT_check_I_critical( svit[BATTERY_1].name );
    2a38:	80 91 3d 05 	lds	r24, 0x053D
    2a3c:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a40:	f8 01       	movw	r30, r16
    2a42:	85 af       	std	Z+61, r24	; 0x3d
  packet_payload[62] = SVIT_check_I_critical( svit[BATTERY_2].name );
    2a44:	80 91 57 05 	lds	r24, 0x0557
    2a48:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a4c:	f8 01       	movw	r30, r16
    2a4e:	86 af       	std	Z+62, r24	; 0x3e
  packet_payload[63] = SVIT_check_I_critical( svit[SOLAR_FULL].name );
    2a50:	80 91 71 05 	lds	r24, 0x0571
    2a54:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a58:	f8 01       	movw	r30, r16
    2a5a:	87 af       	std	Z+63, r24	; 0x3f
  packet_payload[64] = SVIT_check_I_critical( svit[SOLAR_1].name );
    2a5c:	80 91 8b 05 	lds	r24, 0x058B
    2a60:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a64:	00 5c       	subi	r16, 0xC0	; 192
    2a66:	1f 4f       	sbci	r17, 0xFF	; 255
    2a68:	f8 01       	movw	r30, r16
    2a6a:	81 93       	st	Z+, r24
    2a6c:	8f 01       	movw	r16, r30
  packet_payload[65] = SVIT_check_I_critical( svit[SOLAR_2].name );
    2a6e:	80 91 a5 05 	lds	r24, 0x05A5
    2a72:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a76:	f8 01       	movw	r30, r16
    2a78:	81 93       	st	Z+, r24
    2a7a:	8f 01       	movw	r16, r30
  packet_payload[66] = SVIT_check_I_critical( svit[SOLAR_3].name );
    2a7c:	80 91 bf 05 	lds	r24, 0x05BF
    2a80:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a84:	f8 01       	movw	r30, r16
    2a86:	81 93       	st	Z+, r24
    2a88:	8f 01       	movw	r16, r30
  packet_payload[67] = SVIT_check_I_critical( svit[SOLAR_4].name );
    2a8a:	80 91 d9 05 	lds	r24, 0x05D9
    2a8e:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2a92:	f8 01       	movw	r30, r16
    2a94:	81 93       	st	Z+, r24
    2a96:	8f 01       	movw	r16, r30
  packet_payload[68] = SVIT_check_I_critical( svit[SOLAR_5].name );
    2a98:	80 91 f3 05 	lds	r24, 0x05F3
    2a9c:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2aa0:	f8 01       	movw	r30, r16
    2aa2:	81 93       	st	Z+, r24
    2aa4:	8f 01       	movw	r16, r30
  packet_payload[69] = SVIT_check_I_critical( svit[SOLAR_6].name );
    2aa6:	80 91 0d 06 	lds	r24, 0x060D
    2aaa:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2aae:	f8 01       	movw	r30, r16
    2ab0:	81 93       	st	Z+, r24
    2ab2:	8f 01       	movw	r16, r30
  packet_payload[70] = SVIT_check_I_critical( svit[SOLAR_7].name );
    2ab4:	80 91 27 06 	lds	r24, 0x0627
    2ab8:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2abc:	f8 01       	movw	r30, r16
    2abe:	81 93       	st	Z+, r24
    2ac0:	8f 01       	movw	r16, r30
  packet_payload[71] = SVIT_check_I_critical( svit[SOLAR_8].name );
    2ac2:	80 91 41 06 	lds	r24, 0x0641
    2ac6:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2aca:	f8 01       	movw	r30, r16
    2acc:	81 93       	st	Z+, r24
    2ace:	8f 01       	movw	r16, r30
  packet_payload[72] = SVIT_check_I_critical( svit[SOLAR_9].name );
    2ad0:	80 91 5b 06 	lds	r24, 0x065B
    2ad4:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2ad8:	f8 01       	movw	r30, r16
    2ada:	81 93       	st	Z+, r24
    2adc:	8f 01       	movw	r16, r30
  packet_payload[73] = SVIT_check_I_critical( svit[SOLAR_10].name );
    2ade:	80 91 75 06 	lds	r24, 0x0675
    2ae2:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2ae6:	f8 01       	movw	r30, r16
    2ae8:	81 93       	st	Z+, r24
    2aea:	8f 01       	movw	r16, r30
  packet_payload[74] = SVIT_check_I_critical( svit[SOLAR_11].name );
    2aec:	80 91 8f 06 	lds	r24, 0x068F
    2af0:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2af4:	f8 01       	movw	r30, r16
    2af6:	81 93       	st	Z+, r24
    2af8:	8f 01       	movw	r16, r30
  packet_payload[75] = SVIT_check_I_critical( svit[SOLAR_12].name );
    2afa:	80 91 a9 06 	lds	r24, 0x06A9
    2afe:	0e 94 2a 10 	call	0x2054	; 0x2054 <SVIT_check_I_critical>
    2b02:	f8 01       	movw	r30, r16
    2b04:	81 93       	st	Z+, r24
  packet_payload[76] = 0xFF;//SVIT_check_I_critical( svit[POWER_BOARD].name );
    2b06:	9f ef       	ldi	r25, 0xFF	; 255
    2b08:	91 93       	st	Z+, r25
  //uint8_t current_error1;
  //uint8_t current_error2;
  //uint8_t current_error3;
  //uint8_t current_error4;

  packet_payload[77] = batt1_voltage;//V_ack_change();
    2b0a:	80 91 23 09 	lds	r24, 0x0923
    2b0e:	81 93       	st	Z+, r24
  packet_payload[78] = soc;//soc;// I_ack_change();
    2b10:	80 91 5d 0f 	lds	r24, 0x0F5D
    2b14:	81 93       	st	Z+, r24
  packet_payload[79] = 0x00;//low >> 6;//safe_mode;
    2b16:	11 92       	st	Z+, r1
  packet_payload[80] = 0x00;//charging;
    2b18:	11 92       	st	Z+, r1
  packet_payload[81] = 0x00;//chargeforward;
    2b1a:	11 92       	st	Z+, r1

  // temperature values (raw ADC output)
  packet_payload[82] = debug;//average_samples( svit[STAR_TRACKER].T_samples );
    2b1c:	80 91 ec 06 	lds	r24, 0x06EC
    2b20:	81 93       	st	Z+, r24
  packet_payload[83] = 0xFF;//average_samples( svit[BATTERY_1].T_samples );
    2b22:	91 93       	st	Z+, r25
    2b24:	8f 01       	movw	r16, r30
  packet_payload[84] = average_samples( svit[BATTERY_2].T_samples );
    2b26:	8d e6       	ldi	r24, 0x6D	; 109
    2b28:	95 e0       	ldi	r25, 0x05	; 5
    2b2a:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
    2b2e:	f8 01       	movw	r30, r16
    2b30:	81 93       	st	Z+, r24
    2b32:	8f 01       	movw	r16, r30
  packet_payload[85] = average_samples( svit[SOLAR_1].T_samples );
    2b34:	81 ea       	ldi	r24, 0xA1	; 161
    2b36:	95 e0       	ldi	r25, 0x05	; 5
    2b38:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
    2b3c:	f8 01       	movw	r30, r16
    2b3e:	81 93       	st	Z+, r24
    2b40:	8f 01       	movw	r16, r30
  packet_payload[86] = average_samples( svit[SOLAR_2].T_samples );
    2b42:	8b eb       	ldi	r24, 0xBB	; 187
    2b44:	95 e0       	ldi	r25, 0x05	; 5
    2b46:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
    2b4a:	f8 01       	movw	r30, r16
    2b4c:	81 93       	st	Z+, r24
    2b4e:	8f 01       	movw	r16, r30
  packet_payload[87] = average_samples( svit[SOLAR_3].T_samples );
    2b50:	85 ed       	ldi	r24, 0xD5	; 213
    2b52:	95 e0       	ldi	r25, 0x05	; 5
    2b54:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
    2b58:	f8 01       	movw	r30, r16
    2b5a:	81 93       	st	Z+, r24
    2b5c:	8f 01       	movw	r16, r30
  packet_payload[88] = average_samples( svit[SOLAR_4].T_samples );
    2b5e:	8f ee       	ldi	r24, 0xEF	; 239
    2b60:	95 e0       	ldi	r25, 0x05	; 5
    2b62:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
    2b66:	f8 01       	movw	r30, r16
    2b68:	81 93       	st	Z+, r24
    2b6a:	8f 01       	movw	r16, r30
  packet_payload[89] = average_samples( svit[SOLAR_5].T_samples );
    2b6c:	89 e0       	ldi	r24, 0x09	; 9
    2b6e:	96 e0       	ldi	r25, 0x06	; 6
    2b70:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
    2b74:	f8 01       	movw	r30, r16
    2b76:	81 93       	st	Z+, r24
    2b78:	8f 01       	movw	r16, r30
  packet_payload[90] = average_samples( svit[SOLAR_9].T_samples );
    2b7a:	81 e7       	ldi	r24, 0x71	; 113
    2b7c:	96 e0       	ldi	r25, 0x06	; 6
    2b7e:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
    2b82:	f8 01       	movw	r30, r16
    2b84:	81 93       	st	Z+, r24
    2b86:	8f 01       	movw	r16, r30
  packet_payload[91] = average_samples( svit[POWER_BOARD].T_samples );
    2b88:	89 ed       	ldi	r24, 0xD9	; 217
    2b8a:	96 e0       	ldi	r25, 0x06	; 6
    2b8c:	0e 94 1b 10 	call	0x2036	; 0x2036 <average_samples>
    2b90:	f8 01       	movw	r30, r16
    2b92:	81 93       	st	Z+, r24

uint8_t V_ack_change( void )
{
  uint8_t temp;

  temp = V_upper_val_change;
    2b94:	80 91 32 0b 	lds	r24, 0x0B32
  V_upper_val_change = 0;
    2b98:	10 92 32 0b 	sts	0x0B32, r1
  //uint8_t temperature_error1;
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
    2b9c:	81 93       	st	Z+, r24

uint8_t I_ack_change( void )
{
  uint8_t temp;

  temp = I_upper_val_change;
    2b9e:	80 91 2d 0b 	lds	r24, 0x0B2D
  I_upper_val_change = 0;
    2ba2:	10 92 2d 0b 	sts	0x0B2D, r1
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
  packet_payload[93] = I_ack_change();
    2ba6:	80 83       	st	Z, r24
}
    2ba8:	1f 91       	pop	r17
    2baa:	0f 91       	pop	r16
    2bac:	08 95       	ret

00002bae <transmit_packet>:

void transmit_packet( uint8_t uart, uint8_t packet_type, uint8_t ack_command )
{
    2bae:	7f 92       	push	r7
    2bb0:	8f 92       	push	r8
    2bb2:	9f 92       	push	r9
    2bb4:	af 92       	push	r10
    2bb6:	bf 92       	push	r11
    2bb8:	cf 92       	push	r12
    2bba:	df 92       	push	r13
    2bbc:	ef 92       	push	r14
    2bbe:	ff 92       	push	r15
    2bc0:	0f 93       	push	r16
    2bc2:	1f 93       	push	r17
    2bc4:	cf 93       	push	r28
    2bc6:	df 93       	push	r29
    2bc8:	78 2e       	mov	r7, r24
  uint8_t VCP_tx_status;

  switch( packet_type )
    2bca:	61 30       	cpi	r22, 0x01	; 1
    2bcc:	c9 f0       	breq	.+50     	; 0x2c00 <transmit_packet+0x52>
    2bce:	61 30       	cpi	r22, 0x01	; 1
    2bd0:	20 f0       	brcs	.+8      	; 0x2bda <transmit_packet+0x2c>
    2bd2:	62 30       	cpi	r22, 0x02	; 2
    2bd4:	09 f0       	breq	.+2      	; 0x2bd8 <transmit_packet+0x2a>
    2bd6:	93 c0       	rjmp	.+294    	; 0x2cfe <transmit_packet+0x150>
    2bd8:	28 c0       	rjmp	.+80     	; 0x2c2a <transmit_packet+0x7c>
  {
    case VCP_POWER_TELEMETRY:
      construct_telemetry_packet( tel_packet_payload[uart] );
    2bda:	8f ef       	ldi	r24, 0xFF	; 255
    2bdc:	78 9e       	mul	r7, r24
    2bde:	c0 01       	movw	r24, r0
    2be0:	11 24       	eor	r1, r1
    2be2:	81 5a       	subi	r24, 0xA1	; 161
    2be4:	92 4f       	sbci	r25, 0xF2	; 242
    2be6:	0e 94 88 13 	call	0x2710	; 0x2710 <construct_telemetry_packet>
      tel_packet_payload_size[uart] = 96;
    2bea:	e7 2d       	mov	r30, r7
    2bec:	f0 e0       	ldi	r31, 0x00	; 0
    2bee:	ee 0f       	add	r30, r30
    2bf0:	ff 1f       	adc	r31, r31
    2bf2:	e2 51       	subi	r30, 0x12	; 18
    2bf4:	f9 4f       	sbci	r31, 0xF9	; 249
    2bf6:	80 e6       	ldi	r24, 0x60	; 96
    2bf8:	90 e0       	ldi	r25, 0x00	; 0
    2bfa:	91 83       	std	Z+1, r25	; 0x01
    2bfc:	80 83       	st	Z, r24
    2bfe:	2c c0       	rjmp	.+88     	; 0x2c58 <transmit_packet+0xaa>
      break;
    case VCP_INVALID_COMMAND:
      tel_packet_payload[uart][0] = VCP_INVALID_COMMAND;
    2c00:	a8 2f       	mov	r26, r24
    2c02:	b0 e0       	ldi	r27, 0x00	; 0
    2c04:	8f ef       	ldi	r24, 0xFF	; 255
    2c06:	90 e0       	ldi	r25, 0x00	; 0
    2c08:	a8 9f       	mul	r26, r24
    2c0a:	f0 01       	movw	r30, r0
    2c0c:	a9 9f       	mul	r26, r25
    2c0e:	f0 0d       	add	r31, r0
    2c10:	b8 9f       	mul	r27, r24
    2c12:	f0 0d       	add	r31, r0
    2c14:	11 24       	eor	r1, r1
    2c16:	e1 5a       	subi	r30, 0xA1	; 161
    2c18:	f2 4f       	sbci	r31, 0xF2	; 242
    2c1a:	60 83       	st	Z, r22
      tel_packet_payload_size[uart] = 1;
    2c1c:	aa 0f       	add	r26, r26
    2c1e:	bb 1f       	adc	r27, r27
    2c20:	a2 51       	subi	r26, 0x12	; 18
    2c22:	b9 4f       	sbci	r27, 0xF9	; 249
    2c24:	81 e0       	ldi	r24, 0x01	; 1
    2c26:	90 e0       	ldi	r25, 0x00	; 0
    2c28:	15 c0       	rjmp	.+42     	; 0x2c54 <transmit_packet+0xa6>
      break;
    case VCP_ACK:
      tel_packet_payload[uart][0] = VCP_ACK;
    2c2a:	a8 2f       	mov	r26, r24
    2c2c:	b0 e0       	ldi	r27, 0x00	; 0
    2c2e:	8f ef       	ldi	r24, 0xFF	; 255
    2c30:	90 e0       	ldi	r25, 0x00	; 0
    2c32:	a8 9f       	mul	r26, r24
    2c34:	f0 01       	movw	r30, r0
    2c36:	a9 9f       	mul	r26, r25
    2c38:	f0 0d       	add	r31, r0
    2c3a:	b8 9f       	mul	r27, r24
    2c3c:	f0 0d       	add	r31, r0
    2c3e:	11 24       	eor	r1, r1
    2c40:	e1 5a       	subi	r30, 0xA1	; 161
    2c42:	f2 4f       	sbci	r31, 0xF2	; 242
    2c44:	60 83       	st	Z, r22
      tel_packet_payload[uart][1] = ack_command;
    2c46:	41 83       	std	Z+1, r20	; 0x01
      tel_packet_payload_size[uart] = 2;
    2c48:	aa 0f       	add	r26, r26
    2c4a:	bb 1f       	adc	r27, r27
    2c4c:	a2 51       	subi	r26, 0x12	; 18
    2c4e:	b9 4f       	sbci	r27, 0xF9	; 249
    2c50:	82 e0       	ldi	r24, 0x02	; 2
    2c52:	90 e0       	ldi	r25, 0x00	; 0
    2c54:	8d 93       	st	X+, r24
    2c56:	9c 93       	st	X, r25
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2c58:	c7 2c       	mov	r12, r7
    2c5a:	dd 24       	eor	r13, r13
    2c5c:	8f ef       	ldi	r24, 0xFF	; 255
    2c5e:	90 e0       	ldi	r25, 0x00	; 0
    2c60:	c8 9e       	mul	r12, r24
    2c62:	70 01       	movw	r14, r0
    2c64:	c9 9e       	mul	r12, r25
    2c66:	f0 0c       	add	r15, r0
    2c68:	d8 9e       	mul	r13, r24
    2c6a:	f0 0c       	add	r15, r0
    2c6c:	11 24       	eor	r1, r1
    2c6e:	4d e2       	ldi	r20, 0x2D	; 45
    2c70:	a4 2e       	mov	r10, r20
    2c72:	49 e0       	ldi	r20, 0x09	; 9
    2c74:	b4 2e       	mov	r11, r20
    2c76:	ae 0c       	add	r10, r14
    2c78:	bf 1c       	adc	r11, r15
    2c7a:	e6 01       	movw	r28, r12
    2c7c:	cc 0f       	add	r28, r28
    2c7e:	dd 1f       	adc	r29, r29
    2c80:	26 e3       	ldi	r18, 0x36	; 54
    2c82:	82 2e       	mov	r8, r18
    2c84:	2d e0       	ldi	r18, 0x0D	; 13
    2c86:	92 2e       	mov	r9, r18
    2c88:	8c 0e       	add	r8, r28
    2c8a:	9d 1e       	adc	r9, r29
    2c8c:	97 01       	movw	r18, r14
    2c8e:	21 5a       	subi	r18, 0xA1	; 161
    2c90:	32 4f       	sbci	r19, 0xF2	; 242
    2c92:	fe 01       	movw	r30, r28
    2c94:	e2 51       	subi	r30, 0x12	; 18
    2c96:	f9 4f       	sbci	r31, 0xF9	; 249
    2c98:	00 81       	ld	r16, Z
    2c9a:	11 81       	ldd	r17, Z+1	; 0x01
    2c9c:	c5 01       	movw	r24, r10
    2c9e:	b4 01       	movw	r22, r8
    2ca0:	41 e0       	ldi	r20, 0x01	; 1
    2ca2:	0e 94 23 12 	call	0x2446	; 0x2446 <Create_VCP_frame>
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
                  );

  // VCP frame creation was successful
  if ( VCP_tx_status == VCP_TERM )
    2ca6:	81 30       	cpi	r24, 0x01	; 1
    2ca8:	51 f5       	brne	.+84     	; 0x2cfe <transmit_packet+0x150>
  {
    tel_packet_size[uart] = dest_size[uart];
    2caa:	f4 01       	movw	r30, r8
    2cac:	80 81       	ld	r24, Z
    2cae:	91 81       	ldd	r25, Z+1	; 0x01
    2cb0:	fe 01       	movw	r30, r28
    2cb2:	ea 5d       	subi	r30, 0xDA	; 218
    2cb4:	fc 4f       	sbci	r31, 0xFC	; 252
    2cb6:	91 83       	std	Z+1, r25	; 0x01
    2cb8:	80 83       	st	Z, r24
    memcpy( tel_packet[uart], dest_data[uart], tel_packet_size[uart] );
    2cba:	01 90       	ld	r0, Z+
    2cbc:	f0 81       	ld	r31, Z
    2cbe:	e0 2d       	mov	r30, r0
    2cc0:	97 01       	movw	r18, r14
    2cc2:	23 50       	subi	r18, 0x03	; 3
    2cc4:	39 4f       	sbci	r19, 0xF9	; 249
    2cc6:	c9 01       	movw	r24, r18
    2cc8:	b5 01       	movw	r22, r10
    2cca:	af 01       	movw	r20, r30
    2ccc:	0e 94 b9 1c 	call	0x3972	; 0x3972 <memcpy>
    tel_packet_index[uart] = 0;
    2cd0:	86 ef       	ldi	r24, 0xF6	; 246
    2cd2:	96 e0       	ldi	r25, 0x06	; 6
    2cd4:	c8 0e       	add	r12, r24
    2cd6:	d9 1e       	adc	r13, r25
    2cd8:	f6 01       	movw	r30, r12
    2cda:	10 82       	st	Z, r1
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
    2cdc:	f1 e0       	ldi	r31, 0x01	; 1
    2cde:	7f 16       	cp	r7, r31
    2ce0:	31 f4       	brne	.+12     	; 0x2cee <transmit_packet+0x140>
    2ce2:	80 91 9b 00 	lds	r24, 0x009B
    2ce6:	88 23       	and	r24, r24
    2ce8:	51 f0       	breq	.+20     	; 0x2cfe <transmit_packet+0x150>
      tx_put_byte( uart );
    2cea:	81 e0       	ldi	r24, 0x01	; 1
    2cec:	06 c0       	rjmp	.+12     	; 0x2cfa <transmit_packet+0x14c>
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
    2cee:	77 20       	and	r7, r7
    2cf0:	31 f4       	brne	.+12     	; 0x2cfe <transmit_packet+0x150>
    2cf2:	8b b1       	in	r24, 0x0b	; 11
    2cf4:	88 23       	and	r24, r24
    2cf6:	19 f0       	breq	.+6      	; 0x2cfe <transmit_packet+0x150>
      tx_put_byte( uart );
    2cf8:	80 e0       	ldi	r24, 0x00	; 0
    2cfa:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <tx_put_byte>
  }
}
    2cfe:	df 91       	pop	r29
    2d00:	cf 91       	pop	r28
    2d02:	1f 91       	pop	r17
    2d04:	0f 91       	pop	r16
    2d06:	ff 90       	pop	r15
    2d08:	ef 90       	pop	r14
    2d0a:	df 90       	pop	r13
    2d0c:	cf 90       	pop	r12
    2d0e:	bf 90       	pop	r11
    2d10:	af 90       	pop	r10
    2d12:	9f 90       	pop	r9
    2d14:	8f 90       	pop	r8
    2d16:	7f 90       	pop	r7
    2d18:	08 95       	ret

00002d1a <__vector_18>:
{
  tx_put_byte( 0 );
}

ISR( USART0_RX_vect )
{
    2d1a:	1f 92       	push	r1
    2d1c:	0f 92       	push	r0
    2d1e:	0f b6       	in	r0, 0x3f	; 63
    2d20:	0f 92       	push	r0
    2d22:	0b b6       	in	r0, 0x3b	; 59
    2d24:	0f 92       	push	r0
    2d26:	11 24       	eor	r1, r1
    2d28:	2f 93       	push	r18
    2d2a:	3f 93       	push	r19
    2d2c:	4f 93       	push	r20
    2d2e:	5f 93       	push	r21
    2d30:	6f 93       	push	r22
    2d32:	7f 93       	push	r23
    2d34:	8f 93       	push	r24
    2d36:	9f 93       	push	r25
    2d38:	af 93       	push	r26
    2d3a:	bf 93       	push	r27
    2d3c:	ef 93       	push	r30
    2d3e:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[0], UDR0 ) == VCP_TERM )
    2d40:	6c b1       	in	r22, 0x0c	; 12
    2d42:	80 91 55 0d 	lds	r24, 0x0D55
    2d46:	90 91 56 0d 	lds	r25, 0x0D56
    2d4a:	0e 94 89 11 	call	0x2312	; 0x2312 <Receive_VCP_byte>
    2d4e:	81 30       	cpi	r24, 0x01	; 1
    2d50:	29 f4       	brne	.+10     	; 0x2d5c <__vector_18+0x42>
  {
    rx_flag[0]++;
    2d52:	80 91 59 0d 	lds	r24, 0x0D59
    2d56:	8f 5f       	subi	r24, 0xFF	; 255
    2d58:	80 93 59 0d 	sts	0x0D59, r24
  }
}
    2d5c:	ff 91       	pop	r31
    2d5e:	ef 91       	pop	r30
    2d60:	bf 91       	pop	r27
    2d62:	af 91       	pop	r26
    2d64:	9f 91       	pop	r25
    2d66:	8f 91       	pop	r24
    2d68:	7f 91       	pop	r23
    2d6a:	6f 91       	pop	r22
    2d6c:	5f 91       	pop	r21
    2d6e:	4f 91       	pop	r20
    2d70:	3f 91       	pop	r19
    2d72:	2f 91       	pop	r18
    2d74:	0f 90       	pop	r0
    2d76:	0b be       	out	0x3b, r0	; 59
    2d78:	0f 90       	pop	r0
    2d7a:	0f be       	out	0x3f, r0	; 63
    2d7c:	0f 90       	pop	r0
    2d7e:	1f 90       	pop	r1
    2d80:	18 95       	reti

00002d82 <__vector_30>:
{
  tx_put_byte( 1 );
}

ISR(USART1_RX_vect)
{
    2d82:	1f 92       	push	r1
    2d84:	0f 92       	push	r0
    2d86:	0f b6       	in	r0, 0x3f	; 63
    2d88:	0f 92       	push	r0
    2d8a:	0b b6       	in	r0, 0x3b	; 59
    2d8c:	0f 92       	push	r0
    2d8e:	11 24       	eor	r1, r1
    2d90:	2f 93       	push	r18
    2d92:	3f 93       	push	r19
    2d94:	4f 93       	push	r20
    2d96:	5f 93       	push	r21
    2d98:	6f 93       	push	r22
    2d9a:	7f 93       	push	r23
    2d9c:	8f 93       	push	r24
    2d9e:	9f 93       	push	r25
    2da0:	af 93       	push	r26
    2da2:	bf 93       	push	r27
    2da4:	ef 93       	push	r30
    2da6:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[1], UDR1 ) == VCP_TERM )
    2da8:	60 91 9c 00 	lds	r22, 0x009C
    2dac:	80 91 57 0d 	lds	r24, 0x0D57
    2db0:	90 91 58 0d 	lds	r25, 0x0D58
    2db4:	0e 94 89 11 	call	0x2312	; 0x2312 <Receive_VCP_byte>
    2db8:	81 30       	cpi	r24, 0x01	; 1
    2dba:	29 f4       	brne	.+10     	; 0x2dc6 <__vector_30+0x44>
  {
    rx_flag[1]++;
    2dbc:	80 91 5a 0d 	lds	r24, 0x0D5A
    2dc0:	8f 5f       	subi	r24, 0xFF	; 255
    2dc2:	80 93 5a 0d 	sts	0x0D5A, r24
  }
}
    2dc6:	ff 91       	pop	r31
    2dc8:	ef 91       	pop	r30
    2dca:	bf 91       	pop	r27
    2dcc:	af 91       	pop	r26
    2dce:	9f 91       	pop	r25
    2dd0:	8f 91       	pop	r24
    2dd2:	7f 91       	pop	r23
    2dd4:	6f 91       	pop	r22
    2dd6:	5f 91       	pop	r21
    2dd8:	4f 91       	pop	r20
    2dda:	3f 91       	pop	r19
    2ddc:	2f 91       	pop	r18
    2dde:	0f 90       	pop	r0
    2de0:	0b be       	out	0x3b, r0	; 59
    2de2:	0f 90       	pop	r0
    2de4:	0f be       	out	0x3f, r0	; 63
    2de6:	0f 90       	pop	r0
    2de8:	1f 90       	pop	r1
    2dea:	18 95       	reti

00002dec <__vector_12>:
	//_delay_ms(500);
}

/* Timer 1(A) routine */
ISR(TIMER1_COMPA_vect)		//Handle Radio & Torquer 30 min delays here; handle 10 min CDH-IB no heartbeat restart
{
    2dec:	1f 92       	push	r1
    2dee:	0f 92       	push	r0
    2df0:	0f b6       	in	r0, 0x3f	; 63
    2df2:	0f 92       	push	r0
    2df4:	0b b6       	in	r0, 0x3b	; 59
    2df6:	0f 92       	push	r0
    2df8:	11 24       	eor	r1, r1
    2dfa:	1f 93       	push	r17
    2dfc:	2f 93       	push	r18
    2dfe:	3f 93       	push	r19
    2e00:	4f 93       	push	r20
    2e02:	5f 93       	push	r21
    2e04:	6f 93       	push	r22
    2e06:	7f 93       	push	r23
    2e08:	8f 93       	push	r24
    2e0a:	9f 93       	push	r25
    2e0c:	af 93       	push	r26
    2e0e:	bf 93       	push	r27
    2e10:	ef 93       	push	r30
    2e12:	ff 93       	push	r31
	SVIT_t *component;
	
	//Testing
	//PORTC ^= 0xFF;
		
	if (timer1_counter[0] <= 0	  &&     rad_torq_flag){	//provides 30 minute delay			
    2e14:	80 91 4d 0d 	lds	r24, 0x0D4D
    2e18:	88 23       	and	r24, r24
    2e1a:	89 f5       	brne	.+98     	; 0x2e7e <__vector_12+0x92>
    2e1c:	80 91 0a 03 	lds	r24, 0x030A
    2e20:	88 23       	and	r24, r24
    2e22:	69 f1       	breq	.+90     	; 0x2e7e <__vector_12+0x92>
	//if ( receive_flag == 1){		//If message is received, reset timer1_counter[0] to CYCLE_COUNTER
	    timer1_counter[0] = CYCLE_COUNTER;
    2e24:	84 e8       	ldi	r24, 0x84	; 132
    2e26:	80 93 4d 0d 	sts	0x0D4D, r24
		
		//CHECK: Should the ISR do this code or not?
		
		//Turn on radios
		component = &svit[RADIO_1];
		switch_on( component->switch_num );
    2e2a:	80 91 54 04 	lds	r24, 0x0454
    2e2e:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <switch_on>
		component->switch_state = SW_ON;
    2e32:	11 e0       	ldi	r17, 0x01	; 1
    2e34:	10 93 55 04 	sts	0x0455, r17
		component = &svit[RADIO_2];
		switch_on( component->switch_num );
    2e38:	80 91 6e 04 	lds	r24, 0x046E
    2e3c:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <switch_on>
		component->switch_state = SW_ON;
    2e40:	10 93 6f 04 	sts	0x046F, r17
		
		//Turn on torque coils			
		component = &svit[TORQUER_1];
		switch_on( component->switch_num );
    2e44:	80 91 f0 04 	lds	r24, 0x04F0
    2e48:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <switch_on>
		component->switch_state = SW_ON;
    2e4c:	10 93 f1 04 	sts	0x04F1, r17
		component = &svit[TORQUER_2];
		switch_on( component->switch_num );
    2e50:	80 91 0a 05 	lds	r24, 0x050A
    2e54:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <switch_on>
		component->switch_state = SW_ON;
    2e58:	10 93 0b 05 	sts	0x050B, r17
		component = &svit[TORQUER_3];
		switch_on( component->switch_num );
    2e5c:	80 91 24 05 	lds	r24, 0x0524
    2e60:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <switch_on>
		component->switch_state = SW_ON;
    2e64:	10 93 25 05 	sts	0x0525, r17
		torquer_on(TORQUER_1);
    2e68:	81 e1       	ldi	r24, 0x11	; 17
    2e6a:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <torquer_on>
		torquer_on(TORQUER_2);
    2e6e:	82 e1       	ldi	r24, 0x12	; 18
    2e70:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <torquer_on>
		torquer_on(TORQUER_3);
    2e74:	83 e1       	ldi	r24, 0x13	; 19
    2e76:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <torquer_on>
		
		//PORTC ^= 0x02;	//LED for STK testing
		//PORTC ^= 0x01;
		
		//Don't reexecute this code
		rad_torq_flag = 0;
    2e7a:	10 92 0a 03 	sts	0x030A, r1
	}
	
	if (timer1_counter[1] <= 0   &&   !cdh_heartbeat_flag){		//If heartbeat timer 1 has expired AND we haven't already ordered a restart
    2e7e:	80 91 4e 0d 	lds	r24, 0x0D4E
    2e82:	88 23       	and	r24, r24
    2e84:	39 f4       	brne	.+14     	; 0x2e94 <__vector_12+0xa8>
    2e86:	80 91 21 03 	lds	r24, 0x0321
    2e8a:	88 23       	and	r24, r24
    2e8c:	19 f4       	brne	.+6      	; 0x2e94 <__vector_12+0xa8>
		//Order full component restart
		cdh_heartbeat_flag = 1;
    2e8e:	81 e0       	ldi	r24, 0x01	; 1
    2e90:	80 93 21 03 	sts	0x0321, r24
		
	}
	
	//else{
		PORTC ^= 0x01;		//LED for STK testing at PORTC0
    2e94:	85 b3       	in	r24, 0x15	; 21
    2e96:	91 e0       	ldi	r25, 0x01	; 1
    2e98:	89 27       	eor	r24, r25
    2e9a:	85 bb       	out	0x15, r24	; 21
    2e9c:	88 e8       	ldi	r24, 0x88	; 136
    2e9e:	93 e1       	ldi	r25, 0x13	; 19
    2ea0:	20 e7       	ldi	r18, 0x70	; 112
    2ea2:	31 e0       	ldi	r19, 0x01	; 1
    2ea4:	f9 01       	movw	r30, r18
    2ea6:	31 97       	sbiw	r30, 0x01	; 1
    2ea8:	f1 f7       	brne	.-4      	; 0x2ea6 <__vector_12+0xba>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2eaa:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2eac:	d9 f7       	brne	.-10     	; 0x2ea4 <__vector_12+0xb8>
		_delay_ms(500);
		--timer1_counter[0];
    2eae:	80 91 4d 0d 	lds	r24, 0x0D4D
    2eb2:	81 50       	subi	r24, 0x01	; 1
    2eb4:	80 93 4d 0d 	sts	0x0D4D, r24
		--timer1_counter[1];
    2eb8:	80 91 4e 0d 	lds	r24, 0x0D4E
    2ebc:	81 50       	subi	r24, 0x01	; 1
    2ebe:	80 93 4e 0d 	sts	0x0D4E, r24
	//}
}
    2ec2:	ff 91       	pop	r31
    2ec4:	ef 91       	pop	r30
    2ec6:	bf 91       	pop	r27
    2ec8:	af 91       	pop	r26
    2eca:	9f 91       	pop	r25
    2ecc:	8f 91       	pop	r24
    2ece:	7f 91       	pop	r23
    2ed0:	6f 91       	pop	r22
    2ed2:	5f 91       	pop	r21
    2ed4:	4f 91       	pop	r20
    2ed6:	3f 91       	pop	r19
    2ed8:	2f 91       	pop	r18
    2eda:	1f 91       	pop	r17
    2edc:	0f 90       	pop	r0
    2ede:	0b be       	out	0x3b, r0	; 59
    2ee0:	0f 90       	pop	r0
    2ee2:	0f be       	out	0x3f, r0	; 63
    2ee4:	0f 90       	pop	r0
    2ee6:	1f 90       	pop	r1
    2ee8:	18 95       	reti

00002eea <__subsf3>:
    2eea:	50 58       	subi	r21, 0x80	; 128

00002eec <__addsf3>:
    2eec:	bb 27       	eor	r27, r27
    2eee:	aa 27       	eor	r26, r26
    2ef0:	0e d0       	rcall	.+28     	; 0x2f0e <__addsf3x>
    2ef2:	dc c1       	rjmp	.+952    	; 0x32ac <__fp_round>
    2ef4:	a5 d1       	rcall	.+842    	; 0x3240 <__fp_pscA>
    2ef6:	30 f0       	brcs	.+12     	; 0x2f04 <__addsf3+0x18>
    2ef8:	aa d1       	rcall	.+852    	; 0x324e <__fp_pscB>
    2efa:	20 f0       	brcs	.+8      	; 0x2f04 <__addsf3+0x18>
    2efc:	31 f4       	brne	.+12     	; 0x2f0a <__addsf3+0x1e>
    2efe:	9f 3f       	cpi	r25, 0xFF	; 255
    2f00:	11 f4       	brne	.+4      	; 0x2f06 <__addsf3+0x1a>
    2f02:	1e f4       	brtc	.+6      	; 0x2f0a <__addsf3+0x1e>
    2f04:	9a c1       	rjmp	.+820    	; 0x323a <__fp_nan>
    2f06:	0e f4       	brtc	.+2      	; 0x2f0a <__addsf3+0x1e>
    2f08:	e0 95       	com	r30
    2f0a:	e7 fb       	bst	r30, 7
    2f0c:	67 c1       	rjmp	.+718    	; 0x31dc <__fp_inf>

00002f0e <__addsf3x>:
    2f0e:	e9 2f       	mov	r30, r25
    2f10:	ef d1       	rcall	.+990    	; 0x32f0 <__fp_split3>
    2f12:	80 f3       	brcs	.-32     	; 0x2ef4 <__addsf3+0x8>
    2f14:	ba 17       	cp	r27, r26
    2f16:	62 07       	cpc	r22, r18
    2f18:	73 07       	cpc	r23, r19
    2f1a:	84 07       	cpc	r24, r20
    2f1c:	95 07       	cpc	r25, r21
    2f1e:	18 f0       	brcs	.+6      	; 0x2f26 <__addsf3x+0x18>
    2f20:	71 f4       	brne	.+28     	; 0x2f3e <__addsf3x+0x30>
    2f22:	9e f5       	brtc	.+102    	; 0x2f8a <__addsf3x+0x7c>
    2f24:	1e c2       	rjmp	.+1084   	; 0x3362 <__fp_zero>
    2f26:	0e f4       	brtc	.+2      	; 0x2f2a <__addsf3x+0x1c>
    2f28:	e0 95       	com	r30
    2f2a:	0b 2e       	mov	r0, r27
    2f2c:	ba 2f       	mov	r27, r26
    2f2e:	a0 2d       	mov	r26, r0
    2f30:	0b 01       	movw	r0, r22
    2f32:	b9 01       	movw	r22, r18
    2f34:	90 01       	movw	r18, r0
    2f36:	0c 01       	movw	r0, r24
    2f38:	ca 01       	movw	r24, r20
    2f3a:	a0 01       	movw	r20, r0
    2f3c:	11 24       	eor	r1, r1
    2f3e:	ff 27       	eor	r31, r31
    2f40:	59 1b       	sub	r21, r25
    2f42:	99 f0       	breq	.+38     	; 0x2f6a <__addsf3x+0x5c>
    2f44:	59 3f       	cpi	r21, 0xF9	; 249
    2f46:	50 f4       	brcc	.+20     	; 0x2f5c <__addsf3x+0x4e>
    2f48:	50 3e       	cpi	r21, 0xE0	; 224
    2f4a:	68 f1       	brcs	.+90     	; 0x2fa6 <__addsf3x+0x98>
    2f4c:	1a 16       	cp	r1, r26
    2f4e:	f0 40       	sbci	r31, 0x00	; 0
    2f50:	a2 2f       	mov	r26, r18
    2f52:	23 2f       	mov	r18, r19
    2f54:	34 2f       	mov	r19, r20
    2f56:	44 27       	eor	r20, r20
    2f58:	58 5f       	subi	r21, 0xF8	; 248
    2f5a:	f3 cf       	rjmp	.-26     	; 0x2f42 <__addsf3x+0x34>
    2f5c:	46 95       	lsr	r20
    2f5e:	37 95       	ror	r19
    2f60:	27 95       	ror	r18
    2f62:	a7 95       	ror	r26
    2f64:	f0 40       	sbci	r31, 0x00	; 0
    2f66:	53 95       	inc	r21
    2f68:	c9 f7       	brne	.-14     	; 0x2f5c <__addsf3x+0x4e>
    2f6a:	7e f4       	brtc	.+30     	; 0x2f8a <__addsf3x+0x7c>
    2f6c:	1f 16       	cp	r1, r31
    2f6e:	ba 0b       	sbc	r27, r26
    2f70:	62 0b       	sbc	r22, r18
    2f72:	73 0b       	sbc	r23, r19
    2f74:	84 0b       	sbc	r24, r20
    2f76:	ba f0       	brmi	.+46     	; 0x2fa6 <__addsf3x+0x98>
    2f78:	91 50       	subi	r25, 0x01	; 1
    2f7a:	a1 f0       	breq	.+40     	; 0x2fa4 <__addsf3x+0x96>
    2f7c:	ff 0f       	add	r31, r31
    2f7e:	bb 1f       	adc	r27, r27
    2f80:	66 1f       	adc	r22, r22
    2f82:	77 1f       	adc	r23, r23
    2f84:	88 1f       	adc	r24, r24
    2f86:	c2 f7       	brpl	.-16     	; 0x2f78 <__addsf3x+0x6a>
    2f88:	0e c0       	rjmp	.+28     	; 0x2fa6 <__addsf3x+0x98>
    2f8a:	ba 0f       	add	r27, r26
    2f8c:	62 1f       	adc	r22, r18
    2f8e:	73 1f       	adc	r23, r19
    2f90:	84 1f       	adc	r24, r20
    2f92:	48 f4       	brcc	.+18     	; 0x2fa6 <__addsf3x+0x98>
    2f94:	87 95       	ror	r24
    2f96:	77 95       	ror	r23
    2f98:	67 95       	ror	r22
    2f9a:	b7 95       	ror	r27
    2f9c:	f7 95       	ror	r31
    2f9e:	9e 3f       	cpi	r25, 0xFE	; 254
    2fa0:	08 f0       	brcs	.+2      	; 0x2fa4 <__addsf3x+0x96>
    2fa2:	b3 cf       	rjmp	.-154    	; 0x2f0a <__addsf3+0x1e>
    2fa4:	93 95       	inc	r25
    2fa6:	88 0f       	add	r24, r24
    2fa8:	08 f0       	brcs	.+2      	; 0x2fac <__addsf3x+0x9e>
    2faa:	99 27       	eor	r25, r25
    2fac:	ee 0f       	add	r30, r30
    2fae:	97 95       	ror	r25
    2fb0:	87 95       	ror	r24
    2fb2:	08 95       	ret

00002fb4 <__cmpsf2>:
    2fb4:	ef d0       	rcall	.+478    	; 0x3194 <__fp_cmp>
    2fb6:	08 f4       	brcc	.+2      	; 0x2fba <__cmpsf2+0x6>
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	08 95       	ret

00002fbc <cos>:
    2fbc:	50 d1       	rcall	.+672    	; 0x325e <__fp_rempio2>
    2fbe:	e3 95       	inc	r30
    2fc0:	86 c1       	rjmp	.+780    	; 0x32ce <__fp_sinus>

00002fc2 <__divsf3>:
    2fc2:	0c d0       	rcall	.+24     	; 0x2fdc <__divsf3x>
    2fc4:	73 c1       	rjmp	.+742    	; 0x32ac <__fp_round>
    2fc6:	43 d1       	rcall	.+646    	; 0x324e <__fp_pscB>
    2fc8:	40 f0       	brcs	.+16     	; 0x2fda <__divsf3+0x18>
    2fca:	3a d1       	rcall	.+628    	; 0x3240 <__fp_pscA>
    2fcc:	30 f0       	brcs	.+12     	; 0x2fda <__divsf3+0x18>
    2fce:	21 f4       	brne	.+8      	; 0x2fd8 <__divsf3+0x16>
    2fd0:	5f 3f       	cpi	r21, 0xFF	; 255
    2fd2:	19 f0       	breq	.+6      	; 0x2fda <__divsf3+0x18>
    2fd4:	03 c1       	rjmp	.+518    	; 0x31dc <__fp_inf>
    2fd6:	51 11       	cpse	r21, r1
    2fd8:	c5 c1       	rjmp	.+906    	; 0x3364 <__fp_szero>
    2fda:	2f c1       	rjmp	.+606    	; 0x323a <__fp_nan>

00002fdc <__divsf3x>:
    2fdc:	89 d1       	rcall	.+786    	; 0x32f0 <__fp_split3>
    2fde:	98 f3       	brcs	.-26     	; 0x2fc6 <__divsf3+0x4>

00002fe0 <__divsf3_pse>:
    2fe0:	99 23       	and	r25, r25
    2fe2:	c9 f3       	breq	.-14     	; 0x2fd6 <__divsf3+0x14>
    2fe4:	55 23       	and	r21, r21
    2fe6:	b1 f3       	breq	.-20     	; 0x2fd4 <__divsf3+0x12>
    2fe8:	95 1b       	sub	r25, r21
    2fea:	55 0b       	sbc	r21, r21
    2fec:	bb 27       	eor	r27, r27
    2fee:	aa 27       	eor	r26, r26
    2ff0:	62 17       	cp	r22, r18
    2ff2:	73 07       	cpc	r23, r19
    2ff4:	84 07       	cpc	r24, r20
    2ff6:	38 f0       	brcs	.+14     	; 0x3006 <__divsf3_pse+0x26>
    2ff8:	9f 5f       	subi	r25, 0xFF	; 255
    2ffa:	5f 4f       	sbci	r21, 0xFF	; 255
    2ffc:	22 0f       	add	r18, r18
    2ffe:	33 1f       	adc	r19, r19
    3000:	44 1f       	adc	r20, r20
    3002:	aa 1f       	adc	r26, r26
    3004:	a9 f3       	breq	.-22     	; 0x2ff0 <__divsf3_pse+0x10>
    3006:	33 d0       	rcall	.+102    	; 0x306e <__divsf3_pse+0x8e>
    3008:	0e 2e       	mov	r0, r30
    300a:	3a f0       	brmi	.+14     	; 0x301a <__divsf3_pse+0x3a>
    300c:	e0 e8       	ldi	r30, 0x80	; 128
    300e:	30 d0       	rcall	.+96     	; 0x3070 <__divsf3_pse+0x90>
    3010:	91 50       	subi	r25, 0x01	; 1
    3012:	50 40       	sbci	r21, 0x00	; 0
    3014:	e6 95       	lsr	r30
    3016:	00 1c       	adc	r0, r0
    3018:	ca f7       	brpl	.-14     	; 0x300c <__divsf3_pse+0x2c>
    301a:	29 d0       	rcall	.+82     	; 0x306e <__divsf3_pse+0x8e>
    301c:	fe 2f       	mov	r31, r30
    301e:	27 d0       	rcall	.+78     	; 0x306e <__divsf3_pse+0x8e>
    3020:	66 0f       	add	r22, r22
    3022:	77 1f       	adc	r23, r23
    3024:	88 1f       	adc	r24, r24
    3026:	bb 1f       	adc	r27, r27
    3028:	26 17       	cp	r18, r22
    302a:	37 07       	cpc	r19, r23
    302c:	48 07       	cpc	r20, r24
    302e:	ab 07       	cpc	r26, r27
    3030:	b0 e8       	ldi	r27, 0x80	; 128
    3032:	09 f0       	breq	.+2      	; 0x3036 <__divsf3_pse+0x56>
    3034:	bb 0b       	sbc	r27, r27
    3036:	80 2d       	mov	r24, r0
    3038:	bf 01       	movw	r22, r30
    303a:	ff 27       	eor	r31, r31
    303c:	93 58       	subi	r25, 0x83	; 131
    303e:	5f 4f       	sbci	r21, 0xFF	; 255
    3040:	2a f0       	brmi	.+10     	; 0x304c <__divsf3_pse+0x6c>
    3042:	9e 3f       	cpi	r25, 0xFE	; 254
    3044:	51 05       	cpc	r21, r1
    3046:	68 f0       	brcs	.+26     	; 0x3062 <__divsf3_pse+0x82>
    3048:	c9 c0       	rjmp	.+402    	; 0x31dc <__fp_inf>
    304a:	8c c1       	rjmp	.+792    	; 0x3364 <__fp_szero>
    304c:	5f 3f       	cpi	r21, 0xFF	; 255
    304e:	ec f3       	brlt	.-6      	; 0x304a <__divsf3_pse+0x6a>
    3050:	98 3e       	cpi	r25, 0xE8	; 232
    3052:	dc f3       	brlt	.-10     	; 0x304a <__divsf3_pse+0x6a>
    3054:	86 95       	lsr	r24
    3056:	77 95       	ror	r23
    3058:	67 95       	ror	r22
    305a:	b7 95       	ror	r27
    305c:	f7 95       	ror	r31
    305e:	9f 5f       	subi	r25, 0xFF	; 255
    3060:	c9 f7       	brne	.-14     	; 0x3054 <__divsf3_pse+0x74>
    3062:	88 0f       	add	r24, r24
    3064:	91 1d       	adc	r25, r1
    3066:	96 95       	lsr	r25
    3068:	87 95       	ror	r24
    306a:	97 f9       	bld	r25, 7
    306c:	08 95       	ret
    306e:	e1 e0       	ldi	r30, 0x01	; 1
    3070:	66 0f       	add	r22, r22
    3072:	77 1f       	adc	r23, r23
    3074:	88 1f       	adc	r24, r24
    3076:	bb 1f       	adc	r27, r27
    3078:	62 17       	cp	r22, r18
    307a:	73 07       	cpc	r23, r19
    307c:	84 07       	cpc	r24, r20
    307e:	ba 07       	cpc	r27, r26
    3080:	20 f0       	brcs	.+8      	; 0x308a <__divsf3_pse+0xaa>
    3082:	62 1b       	sub	r22, r18
    3084:	73 0b       	sbc	r23, r19
    3086:	84 0b       	sbc	r24, r20
    3088:	ba 0b       	sbc	r27, r26
    308a:	ee 1f       	adc	r30, r30
    308c:	88 f7       	brcc	.-30     	; 0x3070 <__divsf3_pse+0x90>
    308e:	e0 95       	com	r30
    3090:	08 95       	ret

00003092 <__fixsfsi>:
    3092:	04 d0       	rcall	.+8      	; 0x309c <__fixunssfsi>
    3094:	68 94       	set
    3096:	b1 11       	cpse	r27, r1
    3098:	65 c1       	rjmp	.+714    	; 0x3364 <__fp_szero>
    309a:	08 95       	ret

0000309c <__fixunssfsi>:
    309c:	31 d1       	rcall	.+610    	; 0x3300 <__fp_splitA>
    309e:	88 f0       	brcs	.+34     	; 0x30c2 <__fixunssfsi+0x26>
    30a0:	9f 57       	subi	r25, 0x7F	; 127
    30a2:	90 f0       	brcs	.+36     	; 0x30c8 <__fixunssfsi+0x2c>
    30a4:	b9 2f       	mov	r27, r25
    30a6:	99 27       	eor	r25, r25
    30a8:	b7 51       	subi	r27, 0x17	; 23
    30aa:	a0 f0       	brcs	.+40     	; 0x30d4 <__fixunssfsi+0x38>
    30ac:	d1 f0       	breq	.+52     	; 0x30e2 <__fixunssfsi+0x46>
    30ae:	66 0f       	add	r22, r22
    30b0:	77 1f       	adc	r23, r23
    30b2:	88 1f       	adc	r24, r24
    30b4:	99 1f       	adc	r25, r25
    30b6:	1a f0       	brmi	.+6      	; 0x30be <__fixunssfsi+0x22>
    30b8:	ba 95       	dec	r27
    30ba:	c9 f7       	brne	.-14     	; 0x30ae <__fixunssfsi+0x12>
    30bc:	12 c0       	rjmp	.+36     	; 0x30e2 <__fixunssfsi+0x46>
    30be:	b1 30       	cpi	r27, 0x01	; 1
    30c0:	81 f0       	breq	.+32     	; 0x30e2 <__fixunssfsi+0x46>
    30c2:	4f d1       	rcall	.+670    	; 0x3362 <__fp_zero>
    30c4:	b1 e0       	ldi	r27, 0x01	; 1
    30c6:	08 95       	ret
    30c8:	4c c1       	rjmp	.+664    	; 0x3362 <__fp_zero>
    30ca:	67 2f       	mov	r22, r23
    30cc:	78 2f       	mov	r23, r24
    30ce:	88 27       	eor	r24, r24
    30d0:	b8 5f       	subi	r27, 0xF8	; 248
    30d2:	39 f0       	breq	.+14     	; 0x30e2 <__fixunssfsi+0x46>
    30d4:	b9 3f       	cpi	r27, 0xF9	; 249
    30d6:	cc f3       	brlt	.-14     	; 0x30ca <__fixunssfsi+0x2e>
    30d8:	86 95       	lsr	r24
    30da:	77 95       	ror	r23
    30dc:	67 95       	ror	r22
    30de:	b3 95       	inc	r27
    30e0:	d9 f7       	brne	.-10     	; 0x30d8 <__fixunssfsi+0x3c>
    30e2:	3e f4       	brtc	.+14     	; 0x30f2 <__fixunssfsi+0x56>
    30e4:	90 95       	com	r25
    30e6:	80 95       	com	r24
    30e8:	70 95       	com	r23
    30ea:	61 95       	neg	r22
    30ec:	7f 4f       	sbci	r23, 0xFF	; 255
    30ee:	8f 4f       	sbci	r24, 0xFF	; 255
    30f0:	9f 4f       	sbci	r25, 0xFF	; 255
    30f2:	08 95       	ret

000030f4 <__floatunsisf>:
    30f4:	e8 94       	clt
    30f6:	09 c0       	rjmp	.+18     	; 0x310a <__floatsisf+0x12>

000030f8 <__floatsisf>:
    30f8:	97 fb       	bst	r25, 7
    30fa:	3e f4       	brtc	.+14     	; 0x310a <__floatsisf+0x12>
    30fc:	90 95       	com	r25
    30fe:	80 95       	com	r24
    3100:	70 95       	com	r23
    3102:	61 95       	neg	r22
    3104:	7f 4f       	sbci	r23, 0xFF	; 255
    3106:	8f 4f       	sbci	r24, 0xFF	; 255
    3108:	9f 4f       	sbci	r25, 0xFF	; 255
    310a:	99 23       	and	r25, r25
    310c:	a9 f0       	breq	.+42     	; 0x3138 <__floatsisf+0x40>
    310e:	f9 2f       	mov	r31, r25
    3110:	96 e9       	ldi	r25, 0x96	; 150
    3112:	bb 27       	eor	r27, r27
    3114:	93 95       	inc	r25
    3116:	f6 95       	lsr	r31
    3118:	87 95       	ror	r24
    311a:	77 95       	ror	r23
    311c:	67 95       	ror	r22
    311e:	b7 95       	ror	r27
    3120:	f1 11       	cpse	r31, r1
    3122:	f8 cf       	rjmp	.-16     	; 0x3114 <__floatsisf+0x1c>
    3124:	fa f4       	brpl	.+62     	; 0x3164 <__floatsisf+0x6c>
    3126:	bb 0f       	add	r27, r27
    3128:	11 f4       	brne	.+4      	; 0x312e <__floatsisf+0x36>
    312a:	60 ff       	sbrs	r22, 0
    312c:	1b c0       	rjmp	.+54     	; 0x3164 <__floatsisf+0x6c>
    312e:	6f 5f       	subi	r22, 0xFF	; 255
    3130:	7f 4f       	sbci	r23, 0xFF	; 255
    3132:	8f 4f       	sbci	r24, 0xFF	; 255
    3134:	9f 4f       	sbci	r25, 0xFF	; 255
    3136:	16 c0       	rjmp	.+44     	; 0x3164 <__floatsisf+0x6c>
    3138:	88 23       	and	r24, r24
    313a:	11 f0       	breq	.+4      	; 0x3140 <__floatsisf+0x48>
    313c:	96 e9       	ldi	r25, 0x96	; 150
    313e:	11 c0       	rjmp	.+34     	; 0x3162 <__floatsisf+0x6a>
    3140:	77 23       	and	r23, r23
    3142:	21 f0       	breq	.+8      	; 0x314c <__floatsisf+0x54>
    3144:	9e e8       	ldi	r25, 0x8E	; 142
    3146:	87 2f       	mov	r24, r23
    3148:	76 2f       	mov	r23, r22
    314a:	05 c0       	rjmp	.+10     	; 0x3156 <__floatsisf+0x5e>
    314c:	66 23       	and	r22, r22
    314e:	71 f0       	breq	.+28     	; 0x316c <__floatsisf+0x74>
    3150:	96 e8       	ldi	r25, 0x86	; 134
    3152:	86 2f       	mov	r24, r22
    3154:	70 e0       	ldi	r23, 0x00	; 0
    3156:	60 e0       	ldi	r22, 0x00	; 0
    3158:	2a f0       	brmi	.+10     	; 0x3164 <__floatsisf+0x6c>
    315a:	9a 95       	dec	r25
    315c:	66 0f       	add	r22, r22
    315e:	77 1f       	adc	r23, r23
    3160:	88 1f       	adc	r24, r24
    3162:	da f7       	brpl	.-10     	; 0x315a <__floatsisf+0x62>
    3164:	88 0f       	add	r24, r24
    3166:	96 95       	lsr	r25
    3168:	87 95       	ror	r24
    316a:	97 f9       	bld	r25, 7
    316c:	08 95       	ret

0000316e <floor>:
    316e:	e2 d0       	rcall	.+452    	; 0x3334 <__fp_trunc>
    3170:	80 f0       	brcs	.+32     	; 0x3192 <floor+0x24>
    3172:	9f 37       	cpi	r25, 0x7F	; 127
    3174:	40 f4       	brcc	.+16     	; 0x3186 <floor+0x18>
    3176:	91 11       	cpse	r25, r1
    3178:	0e f0       	brts	.+2      	; 0x317c <floor+0xe>
    317a:	f4 c0       	rjmp	.+488    	; 0x3364 <__fp_szero>
    317c:	60 e0       	ldi	r22, 0x00	; 0
    317e:	70 e0       	ldi	r23, 0x00	; 0
    3180:	80 e8       	ldi	r24, 0x80	; 128
    3182:	9f eb       	ldi	r25, 0xBF	; 191
    3184:	08 95       	ret
    3186:	26 f4       	brtc	.+8      	; 0x3190 <floor+0x22>
    3188:	1b 16       	cp	r1, r27
    318a:	61 1d       	adc	r22, r1
    318c:	71 1d       	adc	r23, r1
    318e:	81 1d       	adc	r24, r1
    3190:	2b c0       	rjmp	.+86     	; 0x31e8 <__fp_mintl>
    3192:	45 c0       	rjmp	.+138    	; 0x321e <__fp_mpack>

00003194 <__fp_cmp>:
    3194:	99 0f       	add	r25, r25
    3196:	00 08       	sbc	r0, r0
    3198:	55 0f       	add	r21, r21
    319a:	aa 0b       	sbc	r26, r26
    319c:	e0 e8       	ldi	r30, 0x80	; 128
    319e:	fe ef       	ldi	r31, 0xFE	; 254
    31a0:	16 16       	cp	r1, r22
    31a2:	17 06       	cpc	r1, r23
    31a4:	e8 07       	cpc	r30, r24
    31a6:	f9 07       	cpc	r31, r25
    31a8:	c0 f0       	brcs	.+48     	; 0x31da <__fp_cmp+0x46>
    31aa:	12 16       	cp	r1, r18
    31ac:	13 06       	cpc	r1, r19
    31ae:	e4 07       	cpc	r30, r20
    31b0:	f5 07       	cpc	r31, r21
    31b2:	98 f0       	brcs	.+38     	; 0x31da <__fp_cmp+0x46>
    31b4:	62 1b       	sub	r22, r18
    31b6:	73 0b       	sbc	r23, r19
    31b8:	84 0b       	sbc	r24, r20
    31ba:	95 0b       	sbc	r25, r21
    31bc:	39 f4       	brne	.+14     	; 0x31cc <__fp_cmp+0x38>
    31be:	0a 26       	eor	r0, r26
    31c0:	61 f0       	breq	.+24     	; 0x31da <__fp_cmp+0x46>
    31c2:	23 2b       	or	r18, r19
    31c4:	24 2b       	or	r18, r20
    31c6:	25 2b       	or	r18, r21
    31c8:	21 f4       	brne	.+8      	; 0x31d2 <__fp_cmp+0x3e>
    31ca:	08 95       	ret
    31cc:	0a 26       	eor	r0, r26
    31ce:	09 f4       	brne	.+2      	; 0x31d2 <__fp_cmp+0x3e>
    31d0:	a1 40       	sbci	r26, 0x01	; 1
    31d2:	a6 95       	lsr	r26
    31d4:	8f ef       	ldi	r24, 0xFF	; 255
    31d6:	81 1d       	adc	r24, r1
    31d8:	81 1d       	adc	r24, r1
    31da:	08 95       	ret

000031dc <__fp_inf>:
    31dc:	97 f9       	bld	r25, 7
    31de:	9f 67       	ori	r25, 0x7F	; 127
    31e0:	80 e8       	ldi	r24, 0x80	; 128
    31e2:	70 e0       	ldi	r23, 0x00	; 0
    31e4:	60 e0       	ldi	r22, 0x00	; 0
    31e6:	08 95       	ret

000031e8 <__fp_mintl>:
    31e8:	88 23       	and	r24, r24
    31ea:	71 f4       	brne	.+28     	; 0x3208 <__fp_mintl+0x20>
    31ec:	77 23       	and	r23, r23
    31ee:	21 f0       	breq	.+8      	; 0x31f8 <__fp_mintl+0x10>
    31f0:	98 50       	subi	r25, 0x08	; 8
    31f2:	87 2b       	or	r24, r23
    31f4:	76 2f       	mov	r23, r22
    31f6:	07 c0       	rjmp	.+14     	; 0x3206 <__fp_mintl+0x1e>
    31f8:	66 23       	and	r22, r22
    31fa:	11 f4       	brne	.+4      	; 0x3200 <__fp_mintl+0x18>
    31fc:	99 27       	eor	r25, r25
    31fe:	0d c0       	rjmp	.+26     	; 0x321a <__fp_mintl+0x32>
    3200:	90 51       	subi	r25, 0x10	; 16
    3202:	86 2b       	or	r24, r22
    3204:	70 e0       	ldi	r23, 0x00	; 0
    3206:	60 e0       	ldi	r22, 0x00	; 0
    3208:	2a f0       	brmi	.+10     	; 0x3214 <__fp_mintl+0x2c>
    320a:	9a 95       	dec	r25
    320c:	66 0f       	add	r22, r22
    320e:	77 1f       	adc	r23, r23
    3210:	88 1f       	adc	r24, r24
    3212:	da f7       	brpl	.-10     	; 0x320a <__fp_mintl+0x22>
    3214:	88 0f       	add	r24, r24
    3216:	96 95       	lsr	r25
    3218:	87 95       	ror	r24
    321a:	97 f9       	bld	r25, 7
    321c:	08 95       	ret

0000321e <__fp_mpack>:
    321e:	9f 3f       	cpi	r25, 0xFF	; 255
    3220:	31 f0       	breq	.+12     	; 0x322e <__fp_mpack_finite+0xc>

00003222 <__fp_mpack_finite>:
    3222:	91 50       	subi	r25, 0x01	; 1
    3224:	20 f4       	brcc	.+8      	; 0x322e <__fp_mpack_finite+0xc>
    3226:	87 95       	ror	r24
    3228:	77 95       	ror	r23
    322a:	67 95       	ror	r22
    322c:	b7 95       	ror	r27
    322e:	88 0f       	add	r24, r24
    3230:	91 1d       	adc	r25, r1
    3232:	96 95       	lsr	r25
    3234:	87 95       	ror	r24
    3236:	97 f9       	bld	r25, 7
    3238:	08 95       	ret

0000323a <__fp_nan>:
    323a:	9f ef       	ldi	r25, 0xFF	; 255
    323c:	80 ec       	ldi	r24, 0xC0	; 192
    323e:	08 95       	ret

00003240 <__fp_pscA>:
    3240:	00 24       	eor	r0, r0
    3242:	0a 94       	dec	r0
    3244:	16 16       	cp	r1, r22
    3246:	17 06       	cpc	r1, r23
    3248:	18 06       	cpc	r1, r24
    324a:	09 06       	cpc	r0, r25
    324c:	08 95       	ret

0000324e <__fp_pscB>:
    324e:	00 24       	eor	r0, r0
    3250:	0a 94       	dec	r0
    3252:	12 16       	cp	r1, r18
    3254:	13 06       	cpc	r1, r19
    3256:	14 06       	cpc	r1, r20
    3258:	05 06       	cpc	r0, r21
    325a:	08 95       	ret
    325c:	ee cf       	rjmp	.-36     	; 0x323a <__fp_nan>

0000325e <__fp_rempio2>:
    325e:	50 d0       	rcall	.+160    	; 0x3300 <__fp_splitA>
    3260:	e8 f3       	brcs	.-6      	; 0x325c <__fp_pscB+0xe>
    3262:	e8 94       	clt
    3264:	e0 e0       	ldi	r30, 0x00	; 0
    3266:	bb 27       	eor	r27, r27
    3268:	9f 57       	subi	r25, 0x7F	; 127
    326a:	f0 f0       	brcs	.+60     	; 0x32a8 <__fp_rempio2+0x4a>
    326c:	2a ed       	ldi	r18, 0xDA	; 218
    326e:	3f e0       	ldi	r19, 0x0F	; 15
    3270:	49 ec       	ldi	r20, 0xC9	; 201
    3272:	06 c0       	rjmp	.+12     	; 0x3280 <__fp_rempio2+0x22>
    3274:	ee 0f       	add	r30, r30
    3276:	bb 0f       	add	r27, r27
    3278:	66 1f       	adc	r22, r22
    327a:	77 1f       	adc	r23, r23
    327c:	88 1f       	adc	r24, r24
    327e:	28 f0       	brcs	.+10     	; 0x328a <__fp_rempio2+0x2c>
    3280:	b2 3a       	cpi	r27, 0xA2	; 162
    3282:	62 07       	cpc	r22, r18
    3284:	73 07       	cpc	r23, r19
    3286:	84 07       	cpc	r24, r20
    3288:	28 f0       	brcs	.+10     	; 0x3294 <__fp_rempio2+0x36>
    328a:	b2 5a       	subi	r27, 0xA2	; 162
    328c:	62 0b       	sbc	r22, r18
    328e:	73 0b       	sbc	r23, r19
    3290:	84 0b       	sbc	r24, r20
    3292:	e3 95       	inc	r30
    3294:	9a 95       	dec	r25
    3296:	72 f7       	brpl	.-36     	; 0x3274 <__fp_rempio2+0x16>
    3298:	80 38       	cpi	r24, 0x80	; 128
    329a:	30 f4       	brcc	.+12     	; 0x32a8 <__fp_rempio2+0x4a>
    329c:	9a 95       	dec	r25
    329e:	bb 0f       	add	r27, r27
    32a0:	66 1f       	adc	r22, r22
    32a2:	77 1f       	adc	r23, r23
    32a4:	88 1f       	adc	r24, r24
    32a6:	d2 f7       	brpl	.-12     	; 0x329c <__fp_rempio2+0x3e>
    32a8:	90 48       	sbci	r25, 0x80	; 128
    32aa:	bb cf       	rjmp	.-138    	; 0x3222 <__fp_mpack_finite>

000032ac <__fp_round>:
    32ac:	09 2e       	mov	r0, r25
    32ae:	03 94       	inc	r0
    32b0:	00 0c       	add	r0, r0
    32b2:	11 f4       	brne	.+4      	; 0x32b8 <__fp_round+0xc>
    32b4:	88 23       	and	r24, r24
    32b6:	52 f0       	brmi	.+20     	; 0x32cc <__fp_round+0x20>
    32b8:	bb 0f       	add	r27, r27
    32ba:	40 f4       	brcc	.+16     	; 0x32cc <__fp_round+0x20>
    32bc:	bf 2b       	or	r27, r31
    32be:	11 f4       	brne	.+4      	; 0x32c4 <__fp_round+0x18>
    32c0:	60 ff       	sbrs	r22, 0
    32c2:	04 c0       	rjmp	.+8      	; 0x32cc <__fp_round+0x20>
    32c4:	6f 5f       	subi	r22, 0xFF	; 255
    32c6:	7f 4f       	sbci	r23, 0xFF	; 255
    32c8:	8f 4f       	sbci	r24, 0xFF	; 255
    32ca:	9f 4f       	sbci	r25, 0xFF	; 255
    32cc:	08 95       	ret

000032ce <__fp_sinus>:
    32ce:	ef 93       	push	r30
    32d0:	e0 ff       	sbrs	r30, 0
    32d2:	06 c0       	rjmp	.+12     	; 0x32e0 <__fp_sinus+0x12>
    32d4:	a2 ea       	ldi	r26, 0xA2	; 162
    32d6:	2a ed       	ldi	r18, 0xDA	; 218
    32d8:	3f e0       	ldi	r19, 0x0F	; 15
    32da:	49 ec       	ldi	r20, 0xC9	; 201
    32dc:	5f eb       	ldi	r21, 0xBF	; 191
    32de:	17 de       	rcall	.-978    	; 0x2f0e <__addsf3x>
    32e0:	e5 df       	rcall	.-54     	; 0x32ac <__fp_round>
    32e2:	0f 90       	pop	r0
    32e4:	03 94       	inc	r0
    32e6:	01 fc       	sbrc	r0, 1
    32e8:	90 58       	subi	r25, 0x80	; 128
    32ea:	ec e8       	ldi	r30, 0x8C	; 140
    32ec:	f0 e0       	ldi	r31, 0x00	; 0
    32ee:	4f c1       	rjmp	.+670    	; 0x358e <__fp_powsodd>

000032f0 <__fp_split3>:
    32f0:	57 fd       	sbrc	r21, 7
    32f2:	90 58       	subi	r25, 0x80	; 128
    32f4:	44 0f       	add	r20, r20
    32f6:	55 1f       	adc	r21, r21
    32f8:	59 f0       	breq	.+22     	; 0x3310 <__fp_splitA+0x10>
    32fa:	5f 3f       	cpi	r21, 0xFF	; 255
    32fc:	71 f0       	breq	.+28     	; 0x331a <__fp_splitA+0x1a>
    32fe:	47 95       	ror	r20

00003300 <__fp_splitA>:
    3300:	88 0f       	add	r24, r24
    3302:	97 fb       	bst	r25, 7
    3304:	99 1f       	adc	r25, r25
    3306:	61 f0       	breq	.+24     	; 0x3320 <__fp_splitA+0x20>
    3308:	9f 3f       	cpi	r25, 0xFF	; 255
    330a:	79 f0       	breq	.+30     	; 0x332a <__fp_splitA+0x2a>
    330c:	87 95       	ror	r24
    330e:	08 95       	ret
    3310:	12 16       	cp	r1, r18
    3312:	13 06       	cpc	r1, r19
    3314:	14 06       	cpc	r1, r20
    3316:	55 1f       	adc	r21, r21
    3318:	f2 cf       	rjmp	.-28     	; 0x32fe <__fp_split3+0xe>
    331a:	46 95       	lsr	r20
    331c:	f1 df       	rcall	.-30     	; 0x3300 <__fp_splitA>
    331e:	08 c0       	rjmp	.+16     	; 0x3330 <__fp_splitA+0x30>
    3320:	16 16       	cp	r1, r22
    3322:	17 06       	cpc	r1, r23
    3324:	18 06       	cpc	r1, r24
    3326:	99 1f       	adc	r25, r25
    3328:	f1 cf       	rjmp	.-30     	; 0x330c <__fp_splitA+0xc>
    332a:	86 95       	lsr	r24
    332c:	71 05       	cpc	r23, r1
    332e:	61 05       	cpc	r22, r1
    3330:	08 94       	sec
    3332:	08 95       	ret

00003334 <__fp_trunc>:
    3334:	e5 df       	rcall	.-54     	; 0x3300 <__fp_splitA>
    3336:	a0 f0       	brcs	.+40     	; 0x3360 <__fp_trunc+0x2c>
    3338:	be e7       	ldi	r27, 0x7E	; 126
    333a:	b9 17       	cp	r27, r25
    333c:	88 f4       	brcc	.+34     	; 0x3360 <__fp_trunc+0x2c>
    333e:	bb 27       	eor	r27, r27
    3340:	9f 38       	cpi	r25, 0x8F	; 143
    3342:	60 f4       	brcc	.+24     	; 0x335c <__fp_trunc+0x28>
    3344:	16 16       	cp	r1, r22
    3346:	b1 1d       	adc	r27, r1
    3348:	67 2f       	mov	r22, r23
    334a:	78 2f       	mov	r23, r24
    334c:	88 27       	eor	r24, r24
    334e:	98 5f       	subi	r25, 0xF8	; 248
    3350:	f7 cf       	rjmp	.-18     	; 0x3340 <__fp_trunc+0xc>
    3352:	86 95       	lsr	r24
    3354:	77 95       	ror	r23
    3356:	67 95       	ror	r22
    3358:	b1 1d       	adc	r27, r1
    335a:	93 95       	inc	r25
    335c:	96 39       	cpi	r25, 0x96	; 150
    335e:	c8 f3       	brcs	.-14     	; 0x3352 <__fp_trunc+0x1e>
    3360:	08 95       	ret

00003362 <__fp_zero>:
    3362:	e8 94       	clt

00003364 <__fp_szero>:
    3364:	bb 27       	eor	r27, r27
    3366:	66 27       	eor	r22, r22
    3368:	77 27       	eor	r23, r23
    336a:	cb 01       	movw	r24, r22
    336c:	97 f9       	bld	r25, 7
    336e:	08 95       	ret

00003370 <__gesf2>:
    3370:	11 df       	rcall	.-478    	; 0x3194 <__fp_cmp>
    3372:	08 f4       	brcc	.+2      	; 0x3376 <__gesf2+0x6>
    3374:	8f ef       	ldi	r24, 0xFF	; 255
    3376:	08 95       	ret

00003378 <__mulsf3>:
    3378:	0b d0       	rcall	.+22     	; 0x3390 <__mulsf3x>
    337a:	98 cf       	rjmp	.-208    	; 0x32ac <__fp_round>
    337c:	61 df       	rcall	.-318    	; 0x3240 <__fp_pscA>
    337e:	28 f0       	brcs	.+10     	; 0x338a <__mulsf3+0x12>
    3380:	66 df       	rcall	.-308    	; 0x324e <__fp_pscB>
    3382:	18 f0       	brcs	.+6      	; 0x338a <__mulsf3+0x12>
    3384:	95 23       	and	r25, r21
    3386:	09 f0       	breq	.+2      	; 0x338a <__mulsf3+0x12>
    3388:	29 cf       	rjmp	.-430    	; 0x31dc <__fp_inf>
    338a:	57 cf       	rjmp	.-338    	; 0x323a <__fp_nan>
    338c:	11 24       	eor	r1, r1
    338e:	ea cf       	rjmp	.-44     	; 0x3364 <__fp_szero>

00003390 <__mulsf3x>:
    3390:	af df       	rcall	.-162    	; 0x32f0 <__fp_split3>
    3392:	a0 f3       	brcs	.-24     	; 0x337c <__mulsf3+0x4>

00003394 <__mulsf3_pse>:
    3394:	95 9f       	mul	r25, r21
    3396:	d1 f3       	breq	.-12     	; 0x338c <__mulsf3+0x14>
    3398:	95 0f       	add	r25, r21
    339a:	50 e0       	ldi	r21, 0x00	; 0
    339c:	55 1f       	adc	r21, r21
    339e:	62 9f       	mul	r22, r18
    33a0:	f0 01       	movw	r30, r0
    33a2:	72 9f       	mul	r23, r18
    33a4:	bb 27       	eor	r27, r27
    33a6:	f0 0d       	add	r31, r0
    33a8:	b1 1d       	adc	r27, r1
    33aa:	63 9f       	mul	r22, r19
    33ac:	aa 27       	eor	r26, r26
    33ae:	f0 0d       	add	r31, r0
    33b0:	b1 1d       	adc	r27, r1
    33b2:	aa 1f       	adc	r26, r26
    33b4:	64 9f       	mul	r22, r20
    33b6:	66 27       	eor	r22, r22
    33b8:	b0 0d       	add	r27, r0
    33ba:	a1 1d       	adc	r26, r1
    33bc:	66 1f       	adc	r22, r22
    33be:	82 9f       	mul	r24, r18
    33c0:	22 27       	eor	r18, r18
    33c2:	b0 0d       	add	r27, r0
    33c4:	a1 1d       	adc	r26, r1
    33c6:	62 1f       	adc	r22, r18
    33c8:	73 9f       	mul	r23, r19
    33ca:	b0 0d       	add	r27, r0
    33cc:	a1 1d       	adc	r26, r1
    33ce:	62 1f       	adc	r22, r18
    33d0:	83 9f       	mul	r24, r19
    33d2:	a0 0d       	add	r26, r0
    33d4:	61 1d       	adc	r22, r1
    33d6:	22 1f       	adc	r18, r18
    33d8:	74 9f       	mul	r23, r20
    33da:	33 27       	eor	r19, r19
    33dc:	a0 0d       	add	r26, r0
    33de:	61 1d       	adc	r22, r1
    33e0:	23 1f       	adc	r18, r19
    33e2:	84 9f       	mul	r24, r20
    33e4:	60 0d       	add	r22, r0
    33e6:	21 1d       	adc	r18, r1
    33e8:	82 2f       	mov	r24, r18
    33ea:	76 2f       	mov	r23, r22
    33ec:	6a 2f       	mov	r22, r26
    33ee:	11 24       	eor	r1, r1
    33f0:	9f 57       	subi	r25, 0x7F	; 127
    33f2:	50 40       	sbci	r21, 0x00	; 0
    33f4:	8a f0       	brmi	.+34     	; 0x3418 <__mulsf3_pse+0x84>
    33f6:	e1 f0       	breq	.+56     	; 0x3430 <__mulsf3_pse+0x9c>
    33f8:	88 23       	and	r24, r24
    33fa:	4a f0       	brmi	.+18     	; 0x340e <__mulsf3_pse+0x7a>
    33fc:	ee 0f       	add	r30, r30
    33fe:	ff 1f       	adc	r31, r31
    3400:	bb 1f       	adc	r27, r27
    3402:	66 1f       	adc	r22, r22
    3404:	77 1f       	adc	r23, r23
    3406:	88 1f       	adc	r24, r24
    3408:	91 50       	subi	r25, 0x01	; 1
    340a:	50 40       	sbci	r21, 0x00	; 0
    340c:	a9 f7       	brne	.-22     	; 0x33f8 <__mulsf3_pse+0x64>
    340e:	9e 3f       	cpi	r25, 0xFE	; 254
    3410:	51 05       	cpc	r21, r1
    3412:	70 f0       	brcs	.+28     	; 0x3430 <__mulsf3_pse+0x9c>
    3414:	e3 ce       	rjmp	.-570    	; 0x31dc <__fp_inf>
    3416:	a6 cf       	rjmp	.-180    	; 0x3364 <__fp_szero>
    3418:	5f 3f       	cpi	r21, 0xFF	; 255
    341a:	ec f3       	brlt	.-6      	; 0x3416 <__mulsf3_pse+0x82>
    341c:	98 3e       	cpi	r25, 0xE8	; 232
    341e:	dc f3       	brlt	.-10     	; 0x3416 <__mulsf3_pse+0x82>
    3420:	86 95       	lsr	r24
    3422:	77 95       	ror	r23
    3424:	67 95       	ror	r22
    3426:	b7 95       	ror	r27
    3428:	f7 95       	ror	r31
    342a:	e7 95       	ror	r30
    342c:	9f 5f       	subi	r25, 0xFF	; 255
    342e:	c1 f7       	brne	.-16     	; 0x3420 <__mulsf3_pse+0x8c>
    3430:	fe 2b       	or	r31, r30
    3432:	88 0f       	add	r24, r24
    3434:	91 1d       	adc	r25, r1
    3436:	96 95       	lsr	r25
    3438:	87 95       	ror	r24
    343a:	97 f9       	bld	r25, 7
    343c:	08 95       	ret

0000343e <pow>:
    343e:	fa 01       	movw	r30, r20
    3440:	ee 0f       	add	r30, r30
    3442:	ff 1f       	adc	r31, r31
    3444:	30 96       	adiw	r30, 0x00	; 0
    3446:	21 05       	cpc	r18, r1
    3448:	31 05       	cpc	r19, r1
    344a:	99 f1       	breq	.+102    	; 0x34b2 <pow+0x74>
    344c:	61 15       	cp	r22, r1
    344e:	71 05       	cpc	r23, r1
    3450:	61 f4       	brne	.+24     	; 0x346a <pow+0x2c>
    3452:	80 38       	cpi	r24, 0x80	; 128
    3454:	bf e3       	ldi	r27, 0x3F	; 63
    3456:	9b 07       	cpc	r25, r27
    3458:	49 f1       	breq	.+82     	; 0x34ac <pow+0x6e>
    345a:	68 94       	set
    345c:	90 38       	cpi	r25, 0x80	; 128
    345e:	81 05       	cpc	r24, r1
    3460:	61 f0       	breq	.+24     	; 0x347a <pow+0x3c>
    3462:	80 38       	cpi	r24, 0x80	; 128
    3464:	bf ef       	ldi	r27, 0xFF	; 255
    3466:	9b 07       	cpc	r25, r27
    3468:	41 f0       	breq	.+16     	; 0x347a <pow+0x3c>
    346a:	99 23       	and	r25, r25
    346c:	42 f5       	brpl	.+80     	; 0x34be <pow+0x80>
    346e:	ff 3f       	cpi	r31, 0xFF	; 255
    3470:	e1 05       	cpc	r30, r1
    3472:	31 05       	cpc	r19, r1
    3474:	21 05       	cpc	r18, r1
    3476:	11 f1       	breq	.+68     	; 0x34bc <pow+0x7e>
    3478:	e8 94       	clt
    347a:	08 94       	sec
    347c:	e7 95       	ror	r30
    347e:	d9 01       	movw	r26, r18
    3480:	aa 23       	and	r26, r26
    3482:	29 f4       	brne	.+10     	; 0x348e <pow+0x50>
    3484:	ab 2f       	mov	r26, r27
    3486:	be 2f       	mov	r27, r30
    3488:	f8 5f       	subi	r31, 0xF8	; 248
    348a:	d0 f3       	brcs	.-12     	; 0x3480 <pow+0x42>
    348c:	10 c0       	rjmp	.+32     	; 0x34ae <pow+0x70>
    348e:	ff 5f       	subi	r31, 0xFF	; 255
    3490:	70 f4       	brcc	.+28     	; 0x34ae <pow+0x70>
    3492:	a6 95       	lsr	r26
    3494:	e0 f7       	brcc	.-8      	; 0x348e <pow+0x50>
    3496:	f7 39       	cpi	r31, 0x97	; 151
    3498:	50 f0       	brcs	.+20     	; 0x34ae <pow+0x70>
    349a:	19 f0       	breq	.+6      	; 0x34a2 <pow+0x64>
    349c:	ff 3a       	cpi	r31, 0xAF	; 175
    349e:	38 f4       	brcc	.+14     	; 0x34ae <pow+0x70>
    34a0:	9f 77       	andi	r25, 0x7F	; 127
    34a2:	9f 93       	push	r25
    34a4:	0c d0       	rcall	.+24     	; 0x34be <pow+0x80>
    34a6:	0f 90       	pop	r0
    34a8:	07 fc       	sbrc	r0, 7
    34aa:	90 58       	subi	r25, 0x80	; 128
    34ac:	08 95       	ret
    34ae:	3e f0       	brts	.+14     	; 0x34be <pow+0x80>
    34b0:	c4 ce       	rjmp	.-632    	; 0x323a <__fp_nan>
    34b2:	60 e0       	ldi	r22, 0x00	; 0
    34b4:	70 e0       	ldi	r23, 0x00	; 0
    34b6:	80 e8       	ldi	r24, 0x80	; 128
    34b8:	9f e3       	ldi	r25, 0x3F	; 63
    34ba:	08 95       	ret
    34bc:	4f e7       	ldi	r20, 0x7F	; 127
    34be:	9f 77       	andi	r25, 0x7F	; 127
    34c0:	5f 93       	push	r21
    34c2:	4f 93       	push	r20
    34c4:	3f 93       	push	r19
    34c6:	2f 93       	push	r18
    34c8:	b5 d0       	rcall	.+362    	; 0x3634 <log>
    34ca:	2f 91       	pop	r18
    34cc:	3f 91       	pop	r19
    34ce:	4f 91       	pop	r20
    34d0:	5f 91       	pop	r21
    34d2:	52 df       	rcall	.-348    	; 0x3378 <__mulsf3>
    34d4:	0b c0       	rjmp	.+22     	; 0x34ec <exp>

000034d6 <sin>:
    34d6:	9f 93       	push	r25
    34d8:	c2 de       	rcall	.-636    	; 0x325e <__fp_rempio2>
    34da:	0f 90       	pop	r0
    34dc:	07 fc       	sbrc	r0, 7
    34de:	ee 5f       	subi	r30, 0xFE	; 254
    34e0:	f6 ce       	rjmp	.-532    	; 0x32ce <__fp_sinus>
    34e2:	19 f4       	brne	.+6      	; 0x34ea <sin+0x14>
    34e4:	0e f0       	brts	.+2      	; 0x34e8 <sin+0x12>
    34e6:	7a ce       	rjmp	.-780    	; 0x31dc <__fp_inf>
    34e8:	3c cf       	rjmp	.-392    	; 0x3362 <__fp_zero>
    34ea:	a7 ce       	rjmp	.-690    	; 0x323a <__fp_nan>

000034ec <exp>:
    34ec:	09 df       	rcall	.-494    	; 0x3300 <__fp_splitA>
    34ee:	c8 f3       	brcs	.-14     	; 0x34e2 <sin+0xc>
    34f0:	96 38       	cpi	r25, 0x86	; 134
    34f2:	c0 f7       	brcc	.-16     	; 0x34e4 <sin+0xe>
    34f4:	07 f8       	bld	r0, 7
    34f6:	0f 92       	push	r0
    34f8:	e8 94       	clt
    34fa:	2b e3       	ldi	r18, 0x3B	; 59
    34fc:	3a ea       	ldi	r19, 0xAA	; 170
    34fe:	48 eb       	ldi	r20, 0xB8	; 184
    3500:	5f e7       	ldi	r21, 0x7F	; 127
    3502:	48 df       	rcall	.-368    	; 0x3394 <__mulsf3_pse>
    3504:	0f 92       	push	r0
    3506:	0f 92       	push	r0
    3508:	0f 92       	push	r0
    350a:	4d b7       	in	r20, 0x3d	; 61
    350c:	5e b7       	in	r21, 0x3e	; 62
    350e:	0f 92       	push	r0
    3510:	d1 d0       	rcall	.+418    	; 0x36b4 <modf>
    3512:	ea ea       	ldi	r30, 0xAA	; 170
    3514:	f0 e0       	ldi	r31, 0x00	; 0
    3516:	16 d0       	rcall	.+44     	; 0x3544 <__fp_powser>
    3518:	4f 91       	pop	r20
    351a:	5f 91       	pop	r21
    351c:	ef 91       	pop	r30
    351e:	ff 91       	pop	r31
    3520:	e5 95       	asr	r30
    3522:	ee 1f       	adc	r30, r30
    3524:	ff 1f       	adc	r31, r31
    3526:	49 f0       	breq	.+18     	; 0x353a <exp+0x4e>
    3528:	fe 57       	subi	r31, 0x7E	; 126
    352a:	e0 68       	ori	r30, 0x80	; 128
    352c:	44 27       	eor	r20, r20
    352e:	ee 0f       	add	r30, r30
    3530:	44 1f       	adc	r20, r20
    3532:	fa 95       	dec	r31
    3534:	e1 f7       	brne	.-8      	; 0x352e <exp+0x42>
    3536:	41 95       	neg	r20
    3538:	55 0b       	sbc	r21, r21
    353a:	43 d0       	rcall	.+134    	; 0x35c2 <ldexp>
    353c:	0f 90       	pop	r0
    353e:	07 fe       	sbrs	r0, 7
    3540:	37 c0       	rjmp	.+110    	; 0x35b0 <inverse>
    3542:	08 95       	ret

00003544 <__fp_powser>:
    3544:	df 93       	push	r29
    3546:	cf 93       	push	r28
    3548:	1f 93       	push	r17
    354a:	0f 93       	push	r16
    354c:	ff 92       	push	r15
    354e:	ef 92       	push	r14
    3550:	df 92       	push	r13
    3552:	7b 01       	movw	r14, r22
    3554:	8c 01       	movw	r16, r24
    3556:	68 94       	set
    3558:	05 c0       	rjmp	.+10     	; 0x3564 <__fp_powser+0x20>
    355a:	da 2e       	mov	r13, r26
    355c:	ef 01       	movw	r28, r30
    355e:	18 df       	rcall	.-464    	; 0x3390 <__mulsf3x>
    3560:	fe 01       	movw	r30, r28
    3562:	e8 94       	clt
    3564:	a5 91       	lpm	r26, Z+
    3566:	25 91       	lpm	r18, Z+
    3568:	35 91       	lpm	r19, Z+
    356a:	45 91       	lpm	r20, Z+
    356c:	55 91       	lpm	r21, Z+
    356e:	ae f3       	brts	.-22     	; 0x355a <__fp_powser+0x16>
    3570:	ef 01       	movw	r28, r30
    3572:	cd dc       	rcall	.-1638   	; 0x2f0e <__addsf3x>
    3574:	fe 01       	movw	r30, r28
    3576:	97 01       	movw	r18, r14
    3578:	a8 01       	movw	r20, r16
    357a:	da 94       	dec	r13
    357c:	79 f7       	brne	.-34     	; 0x355c <__fp_powser+0x18>
    357e:	df 90       	pop	r13
    3580:	ef 90       	pop	r14
    3582:	ff 90       	pop	r15
    3584:	0f 91       	pop	r16
    3586:	1f 91       	pop	r17
    3588:	cf 91       	pop	r28
    358a:	df 91       	pop	r29
    358c:	08 95       	ret

0000358e <__fp_powsodd>:
    358e:	9f 93       	push	r25
    3590:	8f 93       	push	r24
    3592:	7f 93       	push	r23
    3594:	6f 93       	push	r22
    3596:	ff 93       	push	r31
    3598:	ef 93       	push	r30
    359a:	9b 01       	movw	r18, r22
    359c:	ac 01       	movw	r20, r24
    359e:	ec de       	rcall	.-552    	; 0x3378 <__mulsf3>
    35a0:	ef 91       	pop	r30
    35a2:	ff 91       	pop	r31
    35a4:	cf df       	rcall	.-98     	; 0x3544 <__fp_powser>
    35a6:	2f 91       	pop	r18
    35a8:	3f 91       	pop	r19
    35aa:	4f 91       	pop	r20
    35ac:	5f 91       	pop	r21
    35ae:	e4 ce       	rjmp	.-568    	; 0x3378 <__mulsf3>

000035b0 <inverse>:
    35b0:	9b 01       	movw	r18, r22
    35b2:	ac 01       	movw	r20, r24
    35b4:	60 e0       	ldi	r22, 0x00	; 0
    35b6:	70 e0       	ldi	r23, 0x00	; 0
    35b8:	80 e8       	ldi	r24, 0x80	; 128
    35ba:	9f e3       	ldi	r25, 0x3F	; 63
    35bc:	02 cd       	rjmp	.-1532   	; 0x2fc2 <__divsf3>
    35be:	0e ce       	rjmp	.-996    	; 0x31dc <__fp_inf>
    35c0:	2e ce       	rjmp	.-932    	; 0x321e <__fp_mpack>

000035c2 <ldexp>:
    35c2:	9e de       	rcall	.-708    	; 0x3300 <__fp_splitA>
    35c4:	e8 f3       	brcs	.-6      	; 0x35c0 <inverse+0x10>
    35c6:	99 23       	and	r25, r25
    35c8:	d9 f3       	breq	.-10     	; 0x35c0 <inverse+0x10>
    35ca:	94 0f       	add	r25, r20
    35cc:	51 1d       	adc	r21, r1
    35ce:	bb f3       	brvs	.-18     	; 0x35be <inverse+0xe>
    35d0:	91 50       	subi	r25, 0x01	; 1
    35d2:	50 40       	sbci	r21, 0x00	; 0
    35d4:	94 f0       	brlt	.+36     	; 0x35fa <ldexp+0x38>
    35d6:	59 f0       	breq	.+22     	; 0x35ee <ldexp+0x2c>
    35d8:	88 23       	and	r24, r24
    35da:	32 f0       	brmi	.+12     	; 0x35e8 <ldexp+0x26>
    35dc:	66 0f       	add	r22, r22
    35de:	77 1f       	adc	r23, r23
    35e0:	88 1f       	adc	r24, r24
    35e2:	91 50       	subi	r25, 0x01	; 1
    35e4:	50 40       	sbci	r21, 0x00	; 0
    35e6:	c1 f7       	brne	.-16     	; 0x35d8 <ldexp+0x16>
    35e8:	9e 3f       	cpi	r25, 0xFE	; 254
    35ea:	51 05       	cpc	r21, r1
    35ec:	44 f7       	brge	.-48     	; 0x35be <inverse+0xe>
    35ee:	88 0f       	add	r24, r24
    35f0:	91 1d       	adc	r25, r1
    35f2:	96 95       	lsr	r25
    35f4:	87 95       	ror	r24
    35f6:	97 f9       	bld	r25, 7
    35f8:	08 95       	ret
    35fa:	5f 3f       	cpi	r21, 0xFF	; 255
    35fc:	ac f0       	brlt	.+42     	; 0x3628 <ldexp+0x66>
    35fe:	98 3e       	cpi	r25, 0xE8	; 232
    3600:	9c f0       	brlt	.+38     	; 0x3628 <ldexp+0x66>
    3602:	bb 27       	eor	r27, r27
    3604:	86 95       	lsr	r24
    3606:	77 95       	ror	r23
    3608:	67 95       	ror	r22
    360a:	b7 95       	ror	r27
    360c:	08 f4       	brcc	.+2      	; 0x3610 <ldexp+0x4e>
    360e:	b1 60       	ori	r27, 0x01	; 1
    3610:	93 95       	inc	r25
    3612:	c1 f7       	brne	.-16     	; 0x3604 <ldexp+0x42>
    3614:	bb 0f       	add	r27, r27
    3616:	58 f7       	brcc	.-42     	; 0x35ee <ldexp+0x2c>
    3618:	11 f4       	brne	.+4      	; 0x361e <ldexp+0x5c>
    361a:	60 ff       	sbrs	r22, 0
    361c:	e8 cf       	rjmp	.-48     	; 0x35ee <ldexp+0x2c>
    361e:	6f 5f       	subi	r22, 0xFF	; 255
    3620:	7f 4f       	sbci	r23, 0xFF	; 255
    3622:	8f 4f       	sbci	r24, 0xFF	; 255
    3624:	9f 4f       	sbci	r25, 0xFF	; 255
    3626:	e3 cf       	rjmp	.-58     	; 0x35ee <ldexp+0x2c>
    3628:	9d ce       	rjmp	.-710    	; 0x3364 <__fp_szero>
    362a:	0e f0       	brts	.+2      	; 0x362e <ldexp+0x6c>
    362c:	f8 cd       	rjmp	.-1040   	; 0x321e <__fp_mpack>
    362e:	05 ce       	rjmp	.-1014   	; 0x323a <__fp_nan>
    3630:	68 94       	set
    3632:	d4 cd       	rjmp	.-1112   	; 0x31dc <__fp_inf>

00003634 <log>:
    3634:	65 de       	rcall	.-822    	; 0x3300 <__fp_splitA>
    3636:	c8 f3       	brcs	.-14     	; 0x362a <ldexp+0x68>
    3638:	99 23       	and	r25, r25
    363a:	d1 f3       	breq	.-12     	; 0x3630 <ldexp+0x6e>
    363c:	c6 f3       	brts	.-16     	; 0x362e <ldexp+0x6c>
    363e:	df 93       	push	r29
    3640:	cf 93       	push	r28
    3642:	1f 93       	push	r17
    3644:	0f 93       	push	r16
    3646:	ff 92       	push	r15
    3648:	c9 2f       	mov	r28, r25
    364a:	dd 27       	eor	r29, r29
    364c:	88 23       	and	r24, r24
    364e:	2a f0       	brmi	.+10     	; 0x365a <log+0x26>
    3650:	21 97       	sbiw	r28, 0x01	; 1
    3652:	66 0f       	add	r22, r22
    3654:	77 1f       	adc	r23, r23
    3656:	88 1f       	adc	r24, r24
    3658:	da f7       	brpl	.-10     	; 0x3650 <log+0x1c>
    365a:	20 e0       	ldi	r18, 0x00	; 0
    365c:	30 e0       	ldi	r19, 0x00	; 0
    365e:	40 e8       	ldi	r20, 0x80	; 128
    3660:	5f eb       	ldi	r21, 0xBF	; 191
    3662:	9f e3       	ldi	r25, 0x3F	; 63
    3664:	88 39       	cpi	r24, 0x98	; 152
    3666:	20 f0       	brcs	.+8      	; 0x3670 <log+0x3c>
    3668:	80 3e       	cpi	r24, 0xE0	; 224
    366a:	30 f0       	brcs	.+12     	; 0x3678 <log+0x44>
    366c:	21 96       	adiw	r28, 0x01	; 1
    366e:	8f 77       	andi	r24, 0x7F	; 127
    3670:	3d dc       	rcall	.-1926   	; 0x2eec <__addsf3>
    3672:	e2 ed       	ldi	r30, 0xD2	; 210
    3674:	f0 e0       	ldi	r31, 0x00	; 0
    3676:	03 c0       	rjmp	.+6      	; 0x367e <log+0x4a>
    3678:	39 dc       	rcall	.-1934   	; 0x2eec <__addsf3>
    367a:	ef ef       	ldi	r30, 0xFF	; 255
    367c:	f0 e0       	ldi	r31, 0x00	; 0
    367e:	62 df       	rcall	.-316    	; 0x3544 <__fp_powser>
    3680:	8b 01       	movw	r16, r22
    3682:	be 01       	movw	r22, r28
    3684:	ec 01       	movw	r28, r24
    3686:	fb 2e       	mov	r15, r27
    3688:	6f 57       	subi	r22, 0x7F	; 127
    368a:	71 09       	sbc	r23, r1
    368c:	75 95       	asr	r23
    368e:	77 1f       	adc	r23, r23
    3690:	88 0b       	sbc	r24, r24
    3692:	99 0b       	sbc	r25, r25
    3694:	31 dd       	rcall	.-1438   	; 0x30f8 <__floatsisf>
    3696:	28 e1       	ldi	r18, 0x18	; 24
    3698:	32 e7       	ldi	r19, 0x72	; 114
    369a:	41 e3       	ldi	r20, 0x31	; 49
    369c:	5f e3       	ldi	r21, 0x3F	; 63
    369e:	78 de       	rcall	.-784    	; 0x3390 <__mulsf3x>
    36a0:	af 2d       	mov	r26, r15
    36a2:	98 01       	movw	r18, r16
    36a4:	ae 01       	movw	r20, r28
    36a6:	ff 90       	pop	r15
    36a8:	0f 91       	pop	r16
    36aa:	1f 91       	pop	r17
    36ac:	cf 91       	pop	r28
    36ae:	df 91       	pop	r29
    36b0:	2e dc       	rcall	.-1956   	; 0x2f0e <__addsf3x>
    36b2:	fc cd       	rjmp	.-1032   	; 0x32ac <__fp_round>

000036b4 <modf>:
    36b4:	fa 01       	movw	r30, r20
    36b6:	dc 01       	movw	r26, r24
    36b8:	aa 0f       	add	r26, r26
    36ba:	bb 1f       	adc	r27, r27
    36bc:	9b 01       	movw	r18, r22
    36be:	ac 01       	movw	r20, r24
    36c0:	bf 57       	subi	r27, 0x7F	; 127
    36c2:	28 f4       	brcc	.+10     	; 0x36ce <modf+0x1a>
    36c4:	22 27       	eor	r18, r18
    36c6:	33 27       	eor	r19, r19
    36c8:	44 27       	eor	r20, r20
    36ca:	50 78       	andi	r21, 0x80	; 128
    36cc:	1f c0       	rjmp	.+62     	; 0x370c <modf+0x58>
    36ce:	b7 51       	subi	r27, 0x17	; 23
    36d0:	88 f4       	brcc	.+34     	; 0x36f4 <modf+0x40>
    36d2:	ab 2f       	mov	r26, r27
    36d4:	00 24       	eor	r0, r0
    36d6:	46 95       	lsr	r20
    36d8:	37 95       	ror	r19
    36da:	27 95       	ror	r18
    36dc:	01 1c       	adc	r0, r1
    36de:	a3 95       	inc	r26
    36e0:	d2 f3       	brmi	.-12     	; 0x36d6 <modf+0x22>
    36e2:	00 20       	and	r0, r0
    36e4:	69 f0       	breq	.+26     	; 0x3700 <modf+0x4c>
    36e6:	22 0f       	add	r18, r18
    36e8:	33 1f       	adc	r19, r19
    36ea:	44 1f       	adc	r20, r20
    36ec:	b3 95       	inc	r27
    36ee:	da f3       	brmi	.-10     	; 0x36e6 <modf+0x32>
    36f0:	0d d0       	rcall	.+26     	; 0x370c <modf+0x58>
    36f2:	fb cb       	rjmp	.-2058   	; 0x2eea <__subsf3>
    36f4:	61 30       	cpi	r22, 0x01	; 1
    36f6:	71 05       	cpc	r23, r1
    36f8:	a0 e8       	ldi	r26, 0x80	; 128
    36fa:	8a 07       	cpc	r24, r26
    36fc:	b9 46       	sbci	r27, 0x69	; 105
    36fe:	30 f4       	brcc	.+12     	; 0x370c <modf+0x58>
    3700:	9b 01       	movw	r18, r22
    3702:	ac 01       	movw	r20, r24
    3704:	66 27       	eor	r22, r22
    3706:	77 27       	eor	r23, r23
    3708:	88 27       	eor	r24, r24
    370a:	90 78       	andi	r25, 0x80	; 128
    370c:	30 96       	adiw	r30, 0x00	; 0
    370e:	21 f0       	breq	.+8      	; 0x3718 <modf+0x64>
    3710:	20 83       	st	Z, r18
    3712:	31 83       	std	Z+1, r19	; 0x01
    3714:	42 83       	std	Z+2, r20	; 0x02
    3716:	53 83       	std	Z+3, r21	; 0x03
    3718:	08 95       	ret

0000371a <__udivmodhi4>:
    371a:	aa 1b       	sub	r26, r26
    371c:	bb 1b       	sub	r27, r27
    371e:	51 e1       	ldi	r21, 0x11	; 17
    3720:	07 c0       	rjmp	.+14     	; 0x3730 <__udivmodhi4_ep>

00003722 <__udivmodhi4_loop>:
    3722:	aa 1f       	adc	r26, r26
    3724:	bb 1f       	adc	r27, r27
    3726:	a6 17       	cp	r26, r22
    3728:	b7 07       	cpc	r27, r23
    372a:	10 f0       	brcs	.+4      	; 0x3730 <__udivmodhi4_ep>
    372c:	a6 1b       	sub	r26, r22
    372e:	b7 0b       	sbc	r27, r23

00003730 <__udivmodhi4_ep>:
    3730:	88 1f       	adc	r24, r24
    3732:	99 1f       	adc	r25, r25
    3734:	5a 95       	dec	r21
    3736:	a9 f7       	brne	.-22     	; 0x3722 <__udivmodhi4_loop>
    3738:	80 95       	com	r24
    373a:	90 95       	com	r25
    373c:	bc 01       	movw	r22, r24
    373e:	cd 01       	movw	r24, r26
    3740:	08 95       	ret

00003742 <__divmodhi4>:
    3742:	97 fb       	bst	r25, 7
    3744:	09 2e       	mov	r0, r25
    3746:	07 26       	eor	r0, r23
    3748:	0a d0       	rcall	.+20     	; 0x375e <__divmodhi4_neg1>
    374a:	77 fd       	sbrc	r23, 7
    374c:	04 d0       	rcall	.+8      	; 0x3756 <__divmodhi4_neg2>
    374e:	e5 df       	rcall	.-54     	; 0x371a <__udivmodhi4>
    3750:	06 d0       	rcall	.+12     	; 0x375e <__divmodhi4_neg1>
    3752:	00 20       	and	r0, r0
    3754:	1a f4       	brpl	.+6      	; 0x375c <__divmodhi4_exit>

00003756 <__divmodhi4_neg2>:
    3756:	70 95       	com	r23
    3758:	61 95       	neg	r22
    375a:	7f 4f       	sbci	r23, 0xFF	; 255

0000375c <__divmodhi4_exit>:
    375c:	08 95       	ret

0000375e <__divmodhi4_neg1>:
    375e:	f6 f7       	brtc	.-4      	; 0x375c <__divmodhi4_exit>
    3760:	90 95       	com	r25
    3762:	81 95       	neg	r24
    3764:	9f 4f       	sbci	r25, 0xFF	; 255
    3766:	08 95       	ret

00003768 <malloc>:
    3768:	cf 93       	push	r28
    376a:	df 93       	push	r29
    376c:	bc 01       	movw	r22, r24
    376e:	82 30       	cpi	r24, 0x02	; 2
    3770:	91 05       	cpc	r25, r1
    3772:	10 f4       	brcc	.+4      	; 0x3778 <malloc+0x10>
    3774:	62 e0       	ldi	r22, 0x02	; 2
    3776:	70 e0       	ldi	r23, 0x00	; 0
    3778:	a0 91 60 0f 	lds	r26, 0x0F60
    377c:	b0 91 61 0f 	lds	r27, 0x0F61
    3780:	ed 01       	movw	r28, r26
    3782:	e0 e0       	ldi	r30, 0x00	; 0
    3784:	f0 e0       	ldi	r31, 0x00	; 0
    3786:	40 e0       	ldi	r20, 0x00	; 0
    3788:	50 e0       	ldi	r21, 0x00	; 0
    378a:	21 c0       	rjmp	.+66     	; 0x37ce <malloc+0x66>
    378c:	88 81       	ld	r24, Y
    378e:	99 81       	ldd	r25, Y+1	; 0x01
    3790:	86 17       	cp	r24, r22
    3792:	97 07       	cpc	r25, r23
    3794:	69 f4       	brne	.+26     	; 0x37b0 <malloc+0x48>
    3796:	8a 81       	ldd	r24, Y+2	; 0x02
    3798:	9b 81       	ldd	r25, Y+3	; 0x03
    379a:	30 97       	sbiw	r30, 0x00	; 0
    379c:	19 f0       	breq	.+6      	; 0x37a4 <malloc+0x3c>
    379e:	93 83       	std	Z+3, r25	; 0x03
    37a0:	82 83       	std	Z+2, r24	; 0x02
    37a2:	04 c0       	rjmp	.+8      	; 0x37ac <malloc+0x44>
    37a4:	90 93 61 0f 	sts	0x0F61, r25
    37a8:	80 93 60 0f 	sts	0x0F60, r24
    37ac:	fe 01       	movw	r30, r28
    37ae:	34 c0       	rjmp	.+104    	; 0x3818 <malloc+0xb0>
    37b0:	68 17       	cp	r22, r24
    37b2:	79 07       	cpc	r23, r25
    37b4:	38 f4       	brcc	.+14     	; 0x37c4 <malloc+0x5c>
    37b6:	41 15       	cp	r20, r1
    37b8:	51 05       	cpc	r21, r1
    37ba:	19 f0       	breq	.+6      	; 0x37c2 <malloc+0x5a>
    37bc:	84 17       	cp	r24, r20
    37be:	95 07       	cpc	r25, r21
    37c0:	08 f4       	brcc	.+2      	; 0x37c4 <malloc+0x5c>
    37c2:	ac 01       	movw	r20, r24
    37c4:	fe 01       	movw	r30, r28
    37c6:	8a 81       	ldd	r24, Y+2	; 0x02
    37c8:	9b 81       	ldd	r25, Y+3	; 0x03
    37ca:	9c 01       	movw	r18, r24
    37cc:	e9 01       	movw	r28, r18
    37ce:	20 97       	sbiw	r28, 0x00	; 0
    37d0:	e9 f6       	brne	.-70     	; 0x378c <malloc+0x24>
    37d2:	41 15       	cp	r20, r1
    37d4:	51 05       	cpc	r21, r1
    37d6:	a9 f1       	breq	.+106    	; 0x3842 <malloc+0xda>
    37d8:	ca 01       	movw	r24, r20
    37da:	86 1b       	sub	r24, r22
    37dc:	97 0b       	sbc	r25, r23
    37de:	04 97       	sbiw	r24, 0x04	; 4
    37e0:	08 f4       	brcc	.+2      	; 0x37e4 <malloc+0x7c>
    37e2:	ba 01       	movw	r22, r20
    37e4:	e0 e0       	ldi	r30, 0x00	; 0
    37e6:	f0 e0       	ldi	r31, 0x00	; 0
    37e8:	2a c0       	rjmp	.+84     	; 0x383e <malloc+0xd6>
    37ea:	8d 91       	ld	r24, X+
    37ec:	9c 91       	ld	r25, X
    37ee:	11 97       	sbiw	r26, 0x01	; 1
    37f0:	84 17       	cp	r24, r20
    37f2:	95 07       	cpc	r25, r21
    37f4:	f9 f4       	brne	.+62     	; 0x3834 <malloc+0xcc>
    37f6:	64 17       	cp	r22, r20
    37f8:	75 07       	cpc	r23, r21
    37fa:	81 f4       	brne	.+32     	; 0x381c <malloc+0xb4>
    37fc:	12 96       	adiw	r26, 0x02	; 2
    37fe:	8d 91       	ld	r24, X+
    3800:	9c 91       	ld	r25, X
    3802:	13 97       	sbiw	r26, 0x03	; 3
    3804:	30 97       	sbiw	r30, 0x00	; 0
    3806:	19 f0       	breq	.+6      	; 0x380e <malloc+0xa6>
    3808:	93 83       	std	Z+3, r25	; 0x03
    380a:	82 83       	std	Z+2, r24	; 0x02
    380c:	04 c0       	rjmp	.+8      	; 0x3816 <malloc+0xae>
    380e:	90 93 61 0f 	sts	0x0F61, r25
    3812:	80 93 60 0f 	sts	0x0F60, r24
    3816:	fd 01       	movw	r30, r26
    3818:	32 96       	adiw	r30, 0x02	; 2
    381a:	4f c0       	rjmp	.+158    	; 0x38ba <malloc+0x152>
    381c:	ca 01       	movw	r24, r20
    381e:	86 1b       	sub	r24, r22
    3820:	97 0b       	sbc	r25, r23
    3822:	fd 01       	movw	r30, r26
    3824:	e8 0f       	add	r30, r24
    3826:	f9 1f       	adc	r31, r25
    3828:	61 93       	st	Z+, r22
    382a:	71 93       	st	Z+, r23
    382c:	02 97       	sbiw	r24, 0x02	; 2
    382e:	8d 93       	st	X+, r24
    3830:	9c 93       	st	X, r25
    3832:	43 c0       	rjmp	.+134    	; 0x38ba <malloc+0x152>
    3834:	fd 01       	movw	r30, r26
    3836:	82 81       	ldd	r24, Z+2	; 0x02
    3838:	93 81       	ldd	r25, Z+3	; 0x03
    383a:	9c 01       	movw	r18, r24
    383c:	d9 01       	movw	r26, r18
    383e:	10 97       	sbiw	r26, 0x00	; 0
    3840:	a1 f6       	brne	.-88     	; 0x37ea <malloc+0x82>
    3842:	80 91 5e 0f 	lds	r24, 0x0F5E
    3846:	90 91 5f 0f 	lds	r25, 0x0F5F
    384a:	89 2b       	or	r24, r25
    384c:	41 f4       	brne	.+16     	; 0x385e <malloc+0xf6>
    384e:	80 91 02 01 	lds	r24, 0x0102
    3852:	90 91 03 01 	lds	r25, 0x0103
    3856:	90 93 5f 0f 	sts	0x0F5F, r25
    385a:	80 93 5e 0f 	sts	0x0F5E, r24
    385e:	40 91 04 01 	lds	r20, 0x0104
    3862:	50 91 05 01 	lds	r21, 0x0105
    3866:	41 15       	cp	r20, r1
    3868:	51 05       	cpc	r21, r1
    386a:	41 f4       	brne	.+16     	; 0x387c <malloc+0x114>
    386c:	4d b7       	in	r20, 0x3d	; 61
    386e:	5e b7       	in	r21, 0x3e	; 62
    3870:	80 91 00 01 	lds	r24, 0x0100
    3874:	90 91 01 01 	lds	r25, 0x0101
    3878:	48 1b       	sub	r20, r24
    387a:	59 0b       	sbc	r21, r25
    387c:	20 91 5e 0f 	lds	r18, 0x0F5E
    3880:	30 91 5f 0f 	lds	r19, 0x0F5F
    3884:	24 17       	cp	r18, r20
    3886:	35 07       	cpc	r19, r21
    3888:	b0 f4       	brcc	.+44     	; 0x38b6 <malloc+0x14e>
    388a:	ca 01       	movw	r24, r20
    388c:	82 1b       	sub	r24, r18
    388e:	93 0b       	sbc	r25, r19
    3890:	86 17       	cp	r24, r22
    3892:	97 07       	cpc	r25, r23
    3894:	80 f0       	brcs	.+32     	; 0x38b6 <malloc+0x14e>
    3896:	ab 01       	movw	r20, r22
    3898:	4e 5f       	subi	r20, 0xFE	; 254
    389a:	5f 4f       	sbci	r21, 0xFF	; 255
    389c:	84 17       	cp	r24, r20
    389e:	95 07       	cpc	r25, r21
    38a0:	50 f0       	brcs	.+20     	; 0x38b6 <malloc+0x14e>
    38a2:	42 0f       	add	r20, r18
    38a4:	53 1f       	adc	r21, r19
    38a6:	50 93 5f 0f 	sts	0x0F5F, r21
    38aa:	40 93 5e 0f 	sts	0x0F5E, r20
    38ae:	f9 01       	movw	r30, r18
    38b0:	61 93       	st	Z+, r22
    38b2:	71 93       	st	Z+, r23
    38b4:	02 c0       	rjmp	.+4      	; 0x38ba <malloc+0x152>
    38b6:	e0 e0       	ldi	r30, 0x00	; 0
    38b8:	f0 e0       	ldi	r31, 0x00	; 0
    38ba:	cf 01       	movw	r24, r30
    38bc:	df 91       	pop	r29
    38be:	cf 91       	pop	r28
    38c0:	08 95       	ret

000038c2 <free>:
    38c2:	cf 93       	push	r28
    38c4:	df 93       	push	r29
    38c6:	00 97       	sbiw	r24, 0x00	; 0
    38c8:	09 f4       	brne	.+2      	; 0x38cc <free+0xa>
    38ca:	50 c0       	rjmp	.+160    	; 0x396c <free+0xaa>
    38cc:	ec 01       	movw	r28, r24
    38ce:	22 97       	sbiw	r28, 0x02	; 2
    38d0:	1b 82       	std	Y+3, r1	; 0x03
    38d2:	1a 82       	std	Y+2, r1	; 0x02
    38d4:	a0 91 60 0f 	lds	r26, 0x0F60
    38d8:	b0 91 61 0f 	lds	r27, 0x0F61
    38dc:	10 97       	sbiw	r26, 0x00	; 0
    38de:	09 f1       	breq	.+66     	; 0x3922 <free+0x60>
    38e0:	40 e0       	ldi	r20, 0x00	; 0
    38e2:	50 e0       	ldi	r21, 0x00	; 0
    38e4:	ac 17       	cp	r26, r28
    38e6:	bd 07       	cpc	r27, r29
    38e8:	08 f1       	brcs	.+66     	; 0x392c <free+0x6a>
    38ea:	bb 83       	std	Y+3, r27	; 0x03
    38ec:	aa 83       	std	Y+2, r26	; 0x02
    38ee:	fe 01       	movw	r30, r28
    38f0:	21 91       	ld	r18, Z+
    38f2:	31 91       	ld	r19, Z+
    38f4:	e2 0f       	add	r30, r18
    38f6:	f3 1f       	adc	r31, r19
    38f8:	ae 17       	cp	r26, r30
    38fa:	bf 07       	cpc	r27, r31
    38fc:	79 f4       	brne	.+30     	; 0x391c <free+0x5a>
    38fe:	8d 91       	ld	r24, X+
    3900:	9c 91       	ld	r25, X
    3902:	11 97       	sbiw	r26, 0x01	; 1
    3904:	28 0f       	add	r18, r24
    3906:	39 1f       	adc	r19, r25
    3908:	2e 5f       	subi	r18, 0xFE	; 254
    390a:	3f 4f       	sbci	r19, 0xFF	; 255
    390c:	39 83       	std	Y+1, r19	; 0x01
    390e:	28 83       	st	Y, r18
    3910:	12 96       	adiw	r26, 0x02	; 2
    3912:	8d 91       	ld	r24, X+
    3914:	9c 91       	ld	r25, X
    3916:	13 97       	sbiw	r26, 0x03	; 3
    3918:	9b 83       	std	Y+3, r25	; 0x03
    391a:	8a 83       	std	Y+2, r24	; 0x02
    391c:	41 15       	cp	r20, r1
    391e:	51 05       	cpc	r21, r1
    3920:	71 f4       	brne	.+28     	; 0x393e <free+0x7c>
    3922:	d0 93 61 0f 	sts	0x0F61, r29
    3926:	c0 93 60 0f 	sts	0x0F60, r28
    392a:	20 c0       	rjmp	.+64     	; 0x396c <free+0xaa>
    392c:	12 96       	adiw	r26, 0x02	; 2
    392e:	8d 91       	ld	r24, X+
    3930:	9c 91       	ld	r25, X
    3932:	13 97       	sbiw	r26, 0x03	; 3
    3934:	ad 01       	movw	r20, r26
    3936:	00 97       	sbiw	r24, 0x00	; 0
    3938:	11 f0       	breq	.+4      	; 0x393e <free+0x7c>
    393a:	dc 01       	movw	r26, r24
    393c:	d3 cf       	rjmp	.-90     	; 0x38e4 <free+0x22>
    393e:	fa 01       	movw	r30, r20
    3940:	d3 83       	std	Z+3, r29	; 0x03
    3942:	c2 83       	std	Z+2, r28	; 0x02
    3944:	21 91       	ld	r18, Z+
    3946:	31 91       	ld	r19, Z+
    3948:	e2 0f       	add	r30, r18
    394a:	f3 1f       	adc	r31, r19
    394c:	ce 17       	cp	r28, r30
    394e:	df 07       	cpc	r29, r31
    3950:	69 f4       	brne	.+26     	; 0x396c <free+0xaa>
    3952:	88 81       	ld	r24, Y
    3954:	99 81       	ldd	r25, Y+1	; 0x01
    3956:	28 0f       	add	r18, r24
    3958:	39 1f       	adc	r19, r25
    395a:	2e 5f       	subi	r18, 0xFE	; 254
    395c:	3f 4f       	sbci	r19, 0xFF	; 255
    395e:	fa 01       	movw	r30, r20
    3960:	31 83       	std	Z+1, r19	; 0x01
    3962:	20 83       	st	Z, r18
    3964:	8a 81       	ldd	r24, Y+2	; 0x02
    3966:	9b 81       	ldd	r25, Y+3	; 0x03
    3968:	93 83       	std	Z+3, r25	; 0x03
    396a:	82 83       	std	Z+2, r24	; 0x02
    396c:	df 91       	pop	r29
    396e:	cf 91       	pop	r28
    3970:	08 95       	ret

00003972 <memcpy>:
    3972:	fb 01       	movw	r30, r22
    3974:	dc 01       	movw	r26, r24
    3976:	02 c0       	rjmp	.+4      	; 0x397c <memcpy+0xa>
    3978:	01 90       	ld	r0, Z+
    397a:	0d 92       	st	X+, r0
    397c:	41 50       	subi	r20, 0x01	; 1
    397e:	50 40       	sbci	r21, 0x00	; 0
    3980:	d8 f7       	brcc	.-10     	; 0x3978 <memcpy+0x6>
    3982:	08 95       	ret

00003984 <_exit>:
    3984:	f8 94       	cli

00003986 <__stop_program>:
    3986:	ff cf       	rjmp	.-2      	; 0x3986 <__stop_program>
