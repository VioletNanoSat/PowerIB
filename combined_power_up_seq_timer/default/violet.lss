
violet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000362  00800100  00002852  000028e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002852  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c62  00800462  00800462  00002c48  2**0
                  ALLOC
  3 .stab         00003ff0  00000000  00000000  00002c48  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000010d7  00000000  00000000  00006c38  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00007d0f  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000278  00000000  00000000  00007d3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000501a  00000000  00000000  00007fb6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001104  00000000  00000000  0000cfd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001447  00000000  00000000  0000e0d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000974  00000000  00000000  0000f51c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000ad8  00000000  00000000  0000fe90  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002b8d  00000000  00000000  00010968  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000200  00000000  00000000  000134f5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
{
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
 * insert_str
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
{
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
		output[i] = input[i - start_index];

	return i;
}
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 9d 0b 	jmp	0x173a	; 0x173a <__vector_12>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 7f 0b 	jmp	0x16fe	; 0x16fe <__vector_15>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 b8 0c 	jmp	0x1970	; 0x1970 <__vector_18>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 8f 0c 	jmp	0x191e	; 0x191e <__vector_20>
      54:	0c 94 7a 0c 	jmp	0x18f4	; 0x18f4 <__vector_21>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 45 0c 	jmp	0x188a	; 0x188a <__vector_30>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 1c 0c 	jmp	0x1838	; 0x1838 <__vector_32>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	14 e0       	ldi	r17, 0x04	; 4
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e2 e5       	ldi	r30, 0x52	; 82
      a0:	f8 e2       	ldi	r31, 0x28	; 40
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a2 36       	cpi	r26, 0x62	; 98
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	20 e1       	ldi	r18, 0x10	; 16
      b4:	a2 e6       	ldi	r26, 0x62	; 98
      b6:	b4 e0       	ldi	r27, 0x04	; 4
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a4 3c       	cpi	r26, 0xC4	; 196
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 ff 06 	call	0xdfe	; 0xdfe <main>
      c6:	0c 94 27 14 	jmp	0x284e	; 0x284e <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <set_component>:
  else if (real < 11.2) {
	 real = 11.2;
  }
  
  //charging = 0xcc;
  if (charging == 0xdd) // change back to dd for tomorrow 
      ce:	8f 92       	push	r8
      d0:	af 92       	push	r10
      d2:	cf 92       	push	r12
      d4:	ef 92       	push	r14
      d6:	0f 93       	push	r16
      d8:	cf 93       	push	r28
      da:	df 93       	push	r29
      dc:	cd b7       	in	r28, 0x3d	; 61
      de:	de b7       	in	r29, 0x3e	; 62
      e0:	9a e1       	ldi	r25, 0x1A	; 26
  {
  	if (real > 12.43) 
      e2:	89 9f       	mul	r24, r25
      e4:	f0 01       	movw	r30, r0
      e6:	11 24       	eor	r1, r1
      e8:	ee 56       	subi	r30, 0x6E	; 110
      ea:	fb 4f       	sbci	r31, 0xFB	; 251
      ec:	60 83       	st	Z, r22
      ee:	41 83       	std	Z+1, r20	; 0x01
      f0:	22 83       	std	Z+2, r18	; 0x02
      f2:	13 82       	std	Z+3, r1	; 0x03
      f4:	04 83       	std	Z+4, r16	; 0x04
      f6:	e5 82       	std	Z+5, r14	; 0x05
	{
      debug = 0x0A;
      f8:	c6 82       	std	Z+6, r12	; 0x06
      fa:	12 86       	std	Z+10, r1	; 0x0a
      fc:	13 86       	std	Z+11, r1	; 0x0b
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
      fe:	a4 86       	std	Z+12, r10	; 0x0c
     100:	85 86       	std	Z+13, r8	; 0x0d
     102:	8a 85       	ldd	r24, Y+10	; 0x0a
     104:	86 87       	std	Z+14, r24	; 0x0e
     106:	12 8a       	std	Z+18, r1	; 0x12
     108:	13 8a       	std	Z+19, r1	; 0x13
     10a:	8b 85       	ldd	r24, Y+11	; 0x0b
     10c:	84 8b       	std	Z+20, r24	; 0x14
     10e:	8c 85       	ldd	r24, Y+12	; 0x0c
     110:	85 8b       	std	Z+21, r24	; 0x15
     112:	11 8e       	std	Z+25, r1	; 0x19
     114:	df 91       	pop	r29
     116:	cf 91       	pop	r28
     118:	0f 91       	pop	r16
     11a:	ef 90       	pop	r14
     11c:	cf 90       	pop	r12
     11e:	af 90       	pop	r10
     120:	8f 90       	pop	r8
     122:	08 95       	ret

00000124 <initialize_svit>:
     124:	8f 92       	push	r8
     126:	af 92       	push	r10
     128:	cf 92       	push	r12
     12a:	ef 92       	push	r14
     12c:	ff 92       	push	r15
     12e:	0f 93       	push	r16
     130:	1f 93       	push	r17
     132:	cf 93       	push	r28
     134:	df 93       	push	r29
     136:	80 e6       	ldi	r24, 0x60	; 96
     138:	87 b9       	out	0x07, r24	; 7
     13a:	8f e8       	ldi	r24, 0x8F	; 143
     13c:	86 b9       	out	0x06, r24	; 6
     13e:	1f 92       	push	r1
     140:	d3 e0       	ldi	r29, 0x03	; 3
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     142:	df 93       	push	r29
     144:	c1 ee       	ldi	r28, 0xE1	; 225
     146:	cf 93       	push	r28
     148:	86 e0       	ldi	r24, 0x06	; 6
     14a:	88 2e       	mov	r8, r24
     14c:	a1 2c       	mov	r10, r1
     14e:	91 ee       	ldi	r25, 0xE1	; 225
     150:	c9 2e       	mov	r12, r25
     152:	2b e0       	ldi	r18, 0x0B	; 11
     154:	e2 2e       	mov	r14, r18
     156:	00 e0       	ldi	r16, 0x00	; 0
     158:	21 e0       	ldi	r18, 0x01	; 1
     15a:	47 e0       	ldi	r20, 0x07	; 7
     15c:	60 e0       	ldi	r22, 0x00	; 0
     15e:	80 e0       	ldi	r24, 0x00	; 0
     160:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     164:	87 e0       	ldi	r24, 0x07	; 7
     166:	8f 93       	push	r24
     168:	ff 24       	eor	r15, r15
     16a:	f3 94       	inc	r15
     16c:	ff 92       	push	r15
     16e:	cf 93       	push	r28
     170:	37 e0       	ldi	r19, 0x07	; 7
     172:	83 2e       	mov	r8, r19
     174:	47 e1       	ldi	r20, 0x17	; 23
     176:	e4 2e       	mov	r14, r20
     178:	21 e0       	ldi	r18, 0x01	; 1
     17a:	48 e0       	ldi	r20, 0x08	; 8
     17c:	61 e0       	ldi	r22, 0x01	; 1
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     17e:	81 e0       	ldi	r24, 0x01	; 1
     180:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     184:	1f 92       	push	r1
     186:	df 93       	push	r29
     188:	cf 93       	push	r28
     18a:	81 2c       	mov	r8, r1
     18c:	aa 24       	eor	r10, r10
     18e:	a3 94       	inc	r10
     190:	53 e1       	ldi	r21, 0x13	; 19
     192:	e5 2e       	mov	r14, r21
     194:	01 e0       	ldi	r16, 0x01	; 1
     196:	21 e0       	ldi	r18, 0x01	; 1
     198:	41 e0       	ldi	r20, 0x01	; 1
     19a:	62 e0       	ldi	r22, 0x02	; 2
     19c:	82 e0       	ldi	r24, 0x02	; 2
     19e:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1a2:	1f 92       	push	r1
     1a4:	df 93       	push	r29
     1a6:	cf 93       	push	r28
     1a8:	6e e0       	ldi	r22, 0x0E	; 14
     1aa:	86 2e       	mov	r8, r22
     1ac:	72 e0       	ldi	r23, 0x02	; 2
     1ae:	a7 2e       	mov	r10, r23
     1b0:	ed e0       	ldi	r30, 0x0D	; 13
     1b2:	ee 2e       	mov	r14, r30
     1b4:	02 e0       	ldi	r16, 0x02	; 2
     1b6:	21 e0       	ldi	r18, 0x01	; 1
     1b8:	41 e0       	ldi	r20, 0x01	; 1
     1ba:	63 e0       	ldi	r22, 0x03	; 3
     1bc:	83 e0       	ldi	r24, 0x03	; 3
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     1be:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1c2:	1f 92       	push	r1
     1c4:	df 93       	push	r29
     1c6:	cf 93       	push	r28
     1c8:	88 24       	eor	r8, r8
     1ca:	83 94       	inc	r8
     1cc:	aa 24       	eor	r10, r10
     1ce:	a3 94       	inc	r10
     1d0:	f5 e1       	ldi	r31, 0x15	; 21
     1d2:	ef 2e       	mov	r14, r31
     1d4:	01 e0       	ldi	r16, 0x01	; 1
     1d6:	21 e0       	ldi	r18, 0x01	; 1
     1d8:	42 e0       	ldi	r20, 0x02	; 2
     1da:	64 e0       	ldi	r22, 0x04	; 4
     1dc:	84 e0       	ldi	r24, 0x04	; 4
     1de:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1e2:	1f 92       	push	r1
     1e4:	df 93       	push	r29
     1e6:	cf 93       	push	r28
     1e8:	a2 e0       	ldi	r26, 0x02	; 2
     1ea:	8a 2e       	mov	r8, r26
     1ec:	ba e1       	ldi	r27, 0x1A	; 26
     1ee:	eb 2e       	mov	r14, r27
     1f0:	21 e0       	ldi	r18, 0x01	; 1
     1f2:	43 e0       	ldi	r20, 0x03	; 3
     1f4:	65 e0       	ldi	r22, 0x05	; 5
     1f6:	85 e0       	ldi	r24, 0x05	; 5
     1f8:	0e 94 67 00 	call	0xce	; 0xce <set_component>
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     1fc:	1f 92       	push	r1
     1fe:	df 93       	push	r29
     200:	cf 93       	push	r28
     202:	13 e0       	ldi	r17, 0x03	; 3
     204:	81 2e       	mov	r8, r17
     206:	8d e1       	ldi	r24, 0x1D	; 29
     208:	e8 2e       	mov	r14, r24
     20a:	21 e0       	ldi	r18, 0x01	; 1
     20c:	44 e0       	ldi	r20, 0x04	; 4
     20e:	66 e0       	ldi	r22, 0x06	; 6
     210:	86 e0       	ldi	r24, 0x06	; 6
     212:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     216:	1f 92       	push	r1
     218:	df 93       	push	r29
     21a:	cf 93       	push	r28
     21c:	9f e1       	ldi	r25, 0x1F	; 31
     21e:	89 2e       	mov	r8, r25
     220:	2e e0       	ldi	r18, 0x0E	; 14
     222:	e2 2e       	mov	r14, r18
     224:	21 e0       	ldi	r18, 0x01	; 1
     226:	45 e0       	ldi	r20, 0x05	; 5
     228:	67 e0       	ldi	r22, 0x07	; 7
     22a:	87 e0       	ldi	r24, 0x07	; 7
     22c:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     230:	1f 92       	push	r1
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     232:	df 93       	push	r29
     234:	cf 93       	push	r28
     236:	34 e0       	ldi	r19, 0x04	; 4
     238:	83 2e       	mov	r8, r19
     23a:	4b e1       	ldi	r20, 0x1B	; 27
     23c:	e4 2e       	mov	r14, r20
     23e:	21 e0       	ldi	r18, 0x01	; 1
     240:	46 e0       	ldi	r20, 0x06	; 6
     242:	68 e0       	ldi	r22, 0x08	; 8
     244:	88 e0       	ldi	r24, 0x08	; 8
     246:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     24a:	1f 92       	push	r1
     24c:	df 93       	push	r29
     24e:	cf 93       	push	r28
     250:	58 e0       	ldi	r21, 0x08	; 8
     252:	85 2e       	mov	r8, r21
     254:	6f e0       	ldi	r22, 0x0F	; 15
     256:	e6 2e       	mov	r14, r22
     258:	21 e0       	ldi	r18, 0x01	; 1
     25a:	49 e0       	ldi	r20, 0x09	; 9
     25c:	69 e0       	ldi	r22, 0x09	; 9
     25e:	89 e0       	ldi	r24, 0x09	; 9
     260:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     264:	1f 92       	push	r1
     266:	df 93       	push	r29
     268:	cf 93       	push	r28
     26a:	79 e0       	ldi	r23, 0x09	; 9
     26c:	87 2e       	mov	r8, r23
     26e:	e9 e1       	ldi	r30, 0x19	; 25
     270:	ee 2e       	mov	r14, r30
     272:	21 e0       	ldi	r18, 0x01	; 1
     274:	4a e0       	ldi	r20, 0x0A	; 10
     276:	6a e0       	ldi	r22, 0x0A	; 10
     278:	8a e0       	ldi	r24, 0x0A	; 10
     27a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     27e:	8d b7       	in	r24, 0x3d	; 61
     280:	9e b7       	in	r25, 0x3e	; 62
     282:	81 96       	adiw	r24, 0x21	; 33
     284:	0f b6       	in	r0, 0x3f	; 63
     286:	f8 94       	cli
     288:	9e bf       	out	0x3e, r25	; 62
     28a:	0f be       	out	0x3f, r0	; 63
     28c:	8d bf       	out	0x3d, r24	; 61
     28e:	1f 92       	push	r1
     290:	df 93       	push	r29
     292:	cf 93       	push	r28
     294:	fa e0       	ldi	r31, 0x0A	; 10
     296:	8f 2e       	mov	r8, r31
     298:	a8 e1       	ldi	r26, 0x18	; 24
     29a:	ea 2e       	mov	r14, r26
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	4b e0       	ldi	r20, 0x0B	; 11
     2a0:	6b e0       	ldi	r22, 0x0B	; 11
     2a2:	8b e0       	ldi	r24, 0x0B	; 11
     2a4:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2a8:	1f 92       	push	r1
     2aa:	df 93       	push	r29
     2ac:	cf 93       	push	r28
     2ae:	b0 e1       	ldi	r27, 0x10	; 16
     2b0:	8b 2e       	mov	r8, r27
     2b2:	11 e1       	ldi	r17, 0x11	; 17
     2b4:	e1 2e       	mov	r14, r17
     2b6:	20 e0       	ldi	r18, 0x00	; 0
     2b8:	4c e0       	ldi	r20, 0x0C	; 12
     2ba:	6c e0       	ldi	r22, 0x0C	; 12
     2bc:	8c e0       	ldi	r24, 0x0C	; 12
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2be:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	8f 93       	push	r24
     2c6:	12 e0       	ldi	r17, 0x02	; 2
     2c8:	1f 93       	push	r17
     2ca:	cf 93       	push	r28
     2cc:	8c e0       	ldi	r24, 0x0C	; 12
     2ce:	88 2e       	mov	r8, r24
     2d0:	96 e1       	ldi	r25, 0x16	; 22
     2d2:	e9 2e       	mov	r14, r25
     2d4:	21 e0       	ldi	r18, 0x01	; 1
     2d6:	4d e0       	ldi	r20, 0x0D	; 13
     2d8:	6d e0       	ldi	r22, 0x0D	; 13
     2da:	8d e0       	ldi	r24, 0x0D	; 13
     2dc:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2e0:	1f 92       	push	r1
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     2e2:	df 93       	push	r29
     2e4:	cf 93       	push	r28
     2e6:	26 e0       	ldi	r18, 0x06	; 6
     2e8:	82 2e       	mov	r8, r18
     2ea:	a1 2c       	mov	r10, r1
     2ec:	34 e0       	ldi	r19, 0x04	; 4
     2ee:	e3 2e       	mov	r14, r19
     2f0:	00 e0       	ldi	r16, 0x00	; 0
     2f2:	21 e0       	ldi	r18, 0x01	; 1
     2f4:	4e e0       	ldi	r20, 0x0E	; 14
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2f6:	6e e0       	ldi	r22, 0x0E	; 14
     2f8:	8e e0       	ldi	r24, 0x0E	; 14
     2fa:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2fe:	1f 92       	push	r1
     300:	df 93       	push	r29
     302:	cf 93       	push	r28
     304:	81 2c       	mov	r8, r1
     306:	43 e0       	ldi	r20, 0x03	; 3
     308:	a4 2e       	mov	r10, r20
     30a:	55 e1       	ldi	r21, 0x15	; 21
     30c:	e5 2e       	mov	r14, r21
     30e:	02 e0       	ldi	r16, 0x02	; 2
     310:	21 e0       	ldi	r18, 0x01	; 1
     312:	40 e1       	ldi	r20, 0x10	; 16
     314:	6f e0       	ldi	r22, 0x0F	; 15
     316:	8f e0       	ldi	r24, 0x0F	; 15
     318:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     31c:	1f 92       	push	r1
     31e:	df 93       	push	r29
     320:	cf 93       	push	r28
     322:	6d e0       	ldi	r22, 0x0D	; 13
     324:	86 2e       	mov	r8, r22
     326:	aa 24       	eor	r10, r10
     328:	a3 94       	inc	r10
     32a:	72 e1       	ldi	r23, 0x12	; 18
     32c:	e7 2e       	mov	r14, r23
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     32e:	01 e0       	ldi	r16, 0x01	; 1
     330:	21 e0       	ldi	r18, 0x01	; 1
     332:	4f e0       	ldi	r20, 0x0F	; 15
     334:	60 e1       	ldi	r22, 0x10	; 16
     336:	80 e1       	ldi	r24, 0x10	; 16
     338:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     33c:	1f 92       	push	r1
     33e:	df 93       	push	r29
     340:	cf 93       	push	r28
     342:	e5 e0       	ldi	r30, 0x05	; 5
     344:	8e 2e       	mov	r8, r30
     346:	fc e1       	ldi	r31, 0x1C	; 28
     348:	ef 2e       	mov	r14, r31
     34a:	20 e0       	ldi	r18, 0x00	; 0
     34c:	4f ef       	ldi	r20, 0xFF	; 255
     34e:	61 e1       	ldi	r22, 0x11	; 17
     350:	81 e1       	ldi	r24, 0x11	; 17
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     352:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     356:	1f 92       	push	r1
     358:	df 93       	push	r29
     35a:	cf 93       	push	r28
     35c:	a0 e1       	ldi	r26, 0x10	; 16
     35e:	8a 2e       	mov	r8, r26
     360:	b2 e0       	ldi	r27, 0x02	; 2
     362:	ab 2e       	mov	r10, r27
     364:	0f e0       	ldi	r16, 0x0F	; 15
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     366:	e0 2e       	mov	r14, r16
     368:	02 e0       	ldi	r16, 0x02	; 2
     36a:	20 e0       	ldi	r18, 0x00	; 0
     36c:	4f ef       	ldi	r20, 0xFF	; 255
     36e:	62 e1       	ldi	r22, 0x12	; 18
     370:	82 e1       	ldi	r24, 0x12	; 18
     372:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     376:	1f 92       	push	r1
     378:	df 93       	push	r29
     37a:	cf 93       	push	r28
     37c:	82 e1       	ldi	r24, 0x12	; 18
     37e:	88 2e       	mov	r8, r24
     380:	91 e1       	ldi	r25, 0x11	; 17
     382:	e9 2e       	mov	r14, r25
     384:	20 e0       	ldi	r18, 0x00	; 0
     386:	4f ef       	ldi	r20, 0xFF	; 255
     388:	63 e1       	ldi	r22, 0x13	; 19
     38a:	83 e1       	ldi	r24, 0x13	; 19
     38c:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     390:	89 e0       	ldi	r24, 0x09	; 9
     392:	8f 93       	push	r24
     394:	1f 93       	push	r17
     396:	cf 93       	push	r28
     398:	22 e0       	ldi	r18, 0x02	; 2
     39a:	82 2e       	mov	r8, r18
     39c:	a1 2c       	mov	r10, r1
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     39e:	ee 24       	eor	r14, r14
     3a0:	e3 94       	inc	r14
     3a2:	00 e0       	ldi	r16, 0x00	; 0
     3a4:	21 e0       	ldi	r18, 0x01	; 1
     3a6:	4f ef       	ldi	r20, 0xFF	; 255
     3a8:	64 e1       	ldi	r22, 0x14	; 20
     3aa:	84 e1       	ldi	r24, 0x14	; 20
     3ac:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     3b0:	8b e0       	ldi	r24, 0x0B	; 11
     3b2:	8f 93       	push	r24
     3b4:	1f 93       	push	r17
     3b6:	cf 93       	push	r28
     3b8:	3e e1       	ldi	r19, 0x1E	; 30
     3ba:	83 2e       	mov	r8, r19
     3bc:	42 e0       	ldi	r20, 0x02	; 2
     3be:	a4 2e       	mov	r10, r20
     3c0:	54 e1       	ldi	r21, 0x14	; 20
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     3c2:	e5 2e       	mov	r14, r21
     3c4:	02 e0       	ldi	r16, 0x02	; 2
     3c6:	21 e0       	ldi	r18, 0x01	; 1
     3c8:	4f ef       	ldi	r20, 0xFF	; 255
     3ca:	65 e1       	ldi	r22, 0x15	; 21
     3cc:	85 e1       	ldi	r24, 0x15	; 21
     3ce:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     3d2:	8d b7       	in	r24, 0x3d	; 61
     3d4:	9e b7       	in	r25, 0x3e	; 62
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     3d6:	81 96       	adiw	r24, 0x21	; 33
     3d8:	0f b6       	in	r0, 0x3f	; 63
     3da:	f8 94       	cli
     3dc:	9e bf       	out	0x3e, r25	; 62
     3de:	0f be       	out	0x3f, r0	; 63
     3e0:	8d bf       	out	0x3d, r24	; 61
     3e2:	1f 92       	push	r1
     3e4:	df 93       	push	r29
     3e6:	cf 93       	push	r28
     3e8:	63 e0       	ldi	r22, 0x03	; 3
     3ea:	86 2e       	mov	r8, r22
     3ec:	a1 2c       	mov	r10, r1
     3ee:	77 e0       	ldi	r23, 0x07	; 7
     3f0:	e7 2e       	mov	r14, r23
     3f2:	00 e0       	ldi	r16, 0x00	; 0
     3f4:	21 e0       	ldi	r18, 0x01	; 1
     3f6:	4f ef       	ldi	r20, 0xFF	; 255
     3f8:	66 e1       	ldi	r22, 0x16	; 22
     3fa:	86 e1       	ldi	r24, 0x16	; 22
     3fc:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     400:	1f 92       	push	r1
     402:	1f 93       	push	r17
     404:	cf 93       	push	r28
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     406:	e4 e1       	ldi	r30, 0x14	; 20
     408:	8e 2e       	mov	r8, r30
     40a:	f2 e1       	ldi	r31, 0x12	; 18
     40c:	ef 2e       	mov	r14, r31
     40e:	21 e0       	ldi	r18, 0x01	; 1
     410:	4f ef       	ldi	r20, 0xFF	; 255
     412:	67 e1       	ldi	r22, 0x17	; 23
     414:	87 e1       	ldi	r24, 0x17	; 23
     416:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     41a:	ff 92       	push	r15
     41c:	1f 93       	push	r17
     41e:	cf 93       	push	r28
     420:	a5 e1       	ldi	r26, 0x15	; 21
     422:	8a 2e       	mov	r8, r26
     424:	b3 e1       	ldi	r27, 0x13	; 19
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     426:	eb 2e       	mov	r14, r27
     428:	21 e0       	ldi	r18, 0x01	; 1
     42a:	4f ef       	ldi	r20, 0xFF	; 255
     42c:	68 e1       	ldi	r22, 0x18	; 24
     42e:	88 e1       	ldi	r24, 0x18	; 24
     430:	0e 94 67 00 	call	0xce	; 0xce <set_component>
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     434:	1f 93       	push	r17
     436:	1f 93       	push	r17
     438:	cf 93       	push	r28
     43a:	86 e1       	ldi	r24, 0x16	; 22
     43c:	88 2e       	mov	r8, r24
     43e:	9a e0       	ldi	r25, 0x0A	; 10
     440:	e9 2e       	mov	r14, r25
     442:	21 e0       	ldi	r18, 0x01	; 1
	}
    else 
	{
	  debug = 0x0B;
     444:	4f ef       	ldi	r20, 0xFF	; 255
     446:	69 e1       	ldi	r22, 0x19	; 25
     448:	89 e1       	ldi	r24, 0x19	; 25
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     44a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     44e:	df 93       	push	r29
     450:	1f 93       	push	r17
     452:	cf 93       	push	r28
     454:	27 e1       	ldi	r18, 0x17	; 23
     456:	82 2e       	mov	r8, r18
     458:	3f e0       	ldi	r19, 0x0F	; 15
     45a:	e3 2e       	mov	r14, r19
     45c:	21 e0       	ldi	r18, 0x01	; 1
     45e:	4f ef       	ldi	r20, 0xFF	; 255
     460:	6a e1       	ldi	r22, 0x1A	; 26
     462:	8a e1       	ldi	r24, 0x1A	; 26
     464:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     468:	84 e0       	ldi	r24, 0x04	; 4
     46a:	8f 93       	push	r24
     46c:	1f 93       	push	r17
     46e:	cf 93       	push	r28
     470:	48 e1       	ldi	r20, 0x18	; 24
     472:	84 2e       	mov	r8, r20
     474:	59 e0       	ldi	r21, 0x09	; 9
     476:	e5 2e       	mov	r14, r21
     478:	21 e0       	ldi	r18, 0x01	; 1
     47a:	4f ef       	ldi	r20, 0xFF	; 255
     47c:	6b e1       	ldi	r22, 0x1B	; 27
     47e:	8b e1       	ldi	r24, 0x1B	; 27
     480:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     484:	1f 92       	push	r1
     486:	df 93       	push	r29
     488:	cf 93       	push	r28
     48a:	69 e1       	ldi	r22, 0x19	; 25
     48c:	86 2e       	mov	r8, r22
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     48e:	7e e0       	ldi	r23, 0x0E	; 14
     490:	e7 2e       	mov	r14, r23
     492:	21 e0       	ldi	r18, 0x01	; 1
     494:	4f ef       	ldi	r20, 0xFF	; 255
     496:	6c e1       	ldi	r22, 0x1C	; 28
     498:	8c e1       	ldi	r24, 0x1C	; 28
     49a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     49e:	1f 92       	push	r1
     4a0:	df 93       	push	r29
     4a2:	cf 93       	push	r28
     4a4:	ea e1       	ldi	r30, 0x1A	; 26
     4a6:	8e 2e       	mov	r8, r30
     4a8:	f0 e1       	ldi	r31, 0x10	; 16
     4aa:	ef 2e       	mov	r14, r31
     4ac:	21 e0       	ldi	r18, 0x01	; 1
     4ae:	4f ef       	ldi	r20, 0xFF	; 255
     4b0:	6d e1       	ldi	r22, 0x1D	; 29
     4b2:	8d e1       	ldi	r24, 0x1D	; 29
     4b4:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4b8:	1f 92       	push	r1
     4ba:	df 93       	push	r29
     4bc:	cf 93       	push	r28
     4be:	ab e1       	ldi	r26, 0x1B	; 27
     4c0:	8a 2e       	mov	r8, r26
     4c2:	b8 e0       	ldi	r27, 0x08	; 8
     4c4:	eb 2e       	mov	r14, r27
     4c6:	21 e0       	ldi	r18, 0x01	; 1
     4c8:	4f ef       	ldi	r20, 0xFF	; 255
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     4ca:	6e e1       	ldi	r22, 0x1E	; 30
     4cc:	8e e1       	ldi	r24, 0x1E	; 30
     4ce:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4d2:	85 e0       	ldi	r24, 0x05	; 5
     4d4:	8f 93       	push	r24
     4d6:	1f 93       	push	r17
     4d8:	cf 93       	push	r28
     4da:	8c e1       	ldi	r24, 0x1C	; 28
     4dc:	88 2e       	mov	r8, r24
     4de:	9d e0       	ldi	r25, 0x0D	; 13
     4e0:	e9 2e       	mov	r14, r25
     4e2:	21 e0       	ldi	r18, 0x01	; 1
     4e4:	4f ef       	ldi	r20, 0xFF	; 255
     4e6:	6f e1       	ldi	r22, 0x1F	; 31
     4e8:	8f e1       	ldi	r24, 0x1F	; 31
     4ea:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4ee:	1f 92       	push	r1
     4f0:	df 93       	push	r29
     4f2:	cf 93       	push	r28
     4f4:	2d e1       	ldi	r18, 0x1D	; 29
     4f6:	82 2e       	mov	r8, r18
     4f8:	3c e0       	ldi	r19, 0x0C	; 12
     4fa:	e3 2e       	mov	r14, r19
     4fc:	21 e0       	ldi	r18, 0x01	; 1
     4fe:	4f ef       	ldi	r20, 0xFF	; 255
     500:	60 e2       	ldi	r22, 0x20	; 32
     502:	80 e2       	ldi	r24, 0x20	; 32
     504:	0e 94 67 00 	call	0xce	; 0xce <set_component>
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     508:	8d b7       	in	r24, 0x3d	; 61
     50a:	9e b7       	in	r25, 0x3e	; 62
     50c:	81 96       	adiw	r24, 0x21	; 33
     50e:	0f b6       	in	r0, 0x3f	; 63
     510:	f8 94       	cli
     512:	9e bf       	out	0x3e, r25	; 62
     514:	0f be       	out	0x3f, r0	; 63
     516:	8d bf       	out	0x3d, r24	; 61
     518:	1f 92       	push	r1
     51a:	df 93       	push	r29
     51c:	cf 93       	push	r28
     51e:	4e e1       	ldi	r20, 0x1E	; 30
     520:	84 2e       	mov	r8, r20
     522:	5b e0       	ldi	r21, 0x0B	; 11
     524:	e5 2e       	mov	r14, r21
     526:	21 e0       	ldi	r18, 0x01	; 1
     528:	4f ef       	ldi	r20, 0xFF	; 255
     52a:	61 e2       	ldi	r22, 0x21	; 33
     52c:	81 e2       	ldi	r24, 0x21	; 33
     52e:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     532:	1f 92       	push	r1
     534:	df 93       	push	r29
     536:	cf 93       	push	r28
     538:	6f e1       	ldi	r22, 0x1F	; 31
     53a:	86 2e       	mov	r8, r22
     53c:	71 e1       	ldi	r23, 0x11	; 17
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     53e:	e7 2e       	mov	r14, r23
     540:	21 e0       	ldi	r18, 0x01	; 1
     542:	4f ef       	ldi	r20, 0xFF	; 255
     544:	62 e2       	ldi	r22, 0x22	; 34
     546:	82 e2       	ldi	r24, 0x22	; 34
     548:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     54c:	86 e0       	ldi	r24, 0x06	; 6
     54e:	8f 93       	push	r24
     550:	1f 93       	push	r17
     552:	cf 93       	push	r28
     554:	81 2c       	mov	r8, r1
     556:	e5 e0       	ldi	r30, 0x05	; 5
     558:	ee 2e       	mov	r14, r30
     55a:	21 e0       	ldi	r18, 0x01	; 1
     55c:	4f ef       	ldi	r20, 0xFF	; 255
     55e:	63 e2       	ldi	r22, 0x23	; 35
     560:	83 e2       	ldi	r24, 0x23	; 35
     562:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     566:	8d b7       	in	r24, 0x3d	; 61
     568:	9e b7       	in	r25, 0x3e	; 62
     56a:	09 96       	adiw	r24, 0x09	; 9
     56c:	0f b6       	in	r0, 0x3f	; 63
     56e:	f8 94       	cli
     570:	9e bf       	out	0x3e, r25	; 62
     572:	0f be       	out	0x3f, r0	; 63
     574:	8d bf       	out	0x3d, r24	; 61
     576:	df 91       	pop	r29
     578:	cf 91       	pop	r28
     57a:	1f 91       	pop	r17
     57c:	0f 91       	pop	r16
     57e:	ff 90       	pop	r15
     580:	ef 90       	pop	r14
     582:	cf 90       	pop	r12
     584:	af 90       	pop	r10
     586:	8f 90       	pop	r8
     588:	08 95       	ret

0000058a <receive_message>:
     58a:	ff 92       	push	r15
     58c:	0f 93       	push	r16
     58e:	1f 93       	push	r17
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	f8 2e       	mov	r15, r24
     596:	fb 01       	movw	r30, r22
     598:	c1 81       	ldd	r28, Z+1	; 0x01
     59a:	90 81       	ld	r25, Z
     59c:	93 30       	cpi	r25, 0x03	; 3
     59e:	09 f4       	brne	.+2      	; 0x5a2 <receive_message+0x18>
     5a0:	5a c0       	rjmp	.+180    	; 0x656 <receive_message+0xcc>
     5a2:	30 f4       	brcc	.+12     	; 0x5b0 <receive_message+0x26>
     5a4:	0c 2f       	mov	r16, r28
     5a6:	10 e0       	ldi	r17, 0x00	; 0
     5a8:	91 30       	cpi	r25, 0x01	; 1
     5aa:	11 f1       	breq	.+68     	; 0x5f0 <receive_message+0x66>
     5ac:	90 f5       	brcc	.+100    	; 0x612 <receive_message+0x88>
     5ae:	0c c0       	rjmp	.+24     	; 0x5c8 <receive_message+0x3e>
     5b0:	95 30       	cpi	r25, 0x05	; 5
     5b2:	09 f4       	brne	.+2      	; 0x5b6 <receive_message+0x2c>
     5b4:	55 c0       	rjmp	.+170    	; 0x660 <receive_message+0xd6>
     5b6:	08 f4       	brcc	.+2      	; 0x5ba <receive_message+0x30>
     5b8:	50 c0       	rjmp	.+160    	; 0x65a <receive_message+0xd0>
     5ba:	96 30       	cpi	r25, 0x06	; 6
     5bc:	09 f4       	brne	.+2      	; 0x5c0 <receive_message+0x36>
     5be:	60 c0       	rjmp	.+192    	; 0x680 <receive_message+0xf6>
     5c0:	97 30       	cpi	r25, 0x07	; 7
     5c2:	09 f0       	breq	.+2      	; 0x5c6 <receive_message+0x3c>
     5c4:	7b c0       	rjmp	.+246    	; 0x6bc <receive_message+0x132>
     5c6:	6b c0       	rjmp	.+214    	; 0x69e <receive_message+0x114>
     5c8:	8c e2       	ldi	r24, 0x2C	; 44
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     5ca:	80 93 af 0e 	sts	0x0EAF, r24
     5ce:	8a e1       	ldi	r24, 0x1A	; 26
     5d0:	80 9f       	mul	r24, r16
     5d2:	e0 01       	movw	r28, r0
     5d4:	81 9f       	mul	r24, r17
     5d6:	d0 0d       	add	r29, r0
     5d8:	11 24       	eor	r1, r1
     5da:	ce 56       	subi	r28, 0x6E	; 110
     5dc:	db 4f       	sbci	r29, 0xFB	; 251
     5de:	89 81       	ldd	r24, Y+1	; 0x01
     5e0:	8f 3f       	cpi	r24, 0xFF	; 255
     5e2:	21 f0       	breq	.+8      	; 0x5ec <receive_message+0x62>
     5e4:	0e 94 0e 08 	call	0x101c	; 0x101c <switch_on>
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	8a 83       	std	Y+2, r24	; 0x02
     5ec:	40 e0       	ldi	r20, 0x00	; 0
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     5ee:	0f c0       	rjmp	.+30     	; 0x60e <receive_message+0x84>
     5f0:	8a e1       	ldi	r24, 0x1A	; 26
     5f2:	80 9f       	mul	r24, r16
     5f4:	e0 01       	movw	r28, r0
     5f6:	81 9f       	mul	r24, r17
     5f8:	d0 0d       	add	r29, r0
     5fa:	11 24       	eor	r1, r1
     5fc:	ce 56       	subi	r28, 0x6E	; 110
     5fe:	db 4f       	sbci	r29, 0xFB	; 251
     600:	89 81       	ldd	r24, Y+1	; 0x01
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     602:	8f 3f       	cpi	r24, 0xFF	; 255
     604:	19 f0       	breq	.+6      	; 0x60c <receive_message+0x82>
     606:	0e 94 51 08 	call	0x10a2	; 0x10a2 <switch_off>
     60a:	1a 82       	std	Y+2, r1	; 0x02
     60c:	41 e0       	ldi	r20, 0x01	; 1
     60e:	62 e0       	ldi	r22, 0x02	; 2
     610:	57 c0       	rjmp	.+174    	; 0x6c0 <receive_message+0x136>
     612:	8a e1       	ldi	r24, 0x1A	; 26
     614:	80 9f       	mul	r24, r16
     616:	e0 01       	movw	r28, r0
     618:	81 9f       	mul	r24, r17
     61a:	d0 0d       	add	r29, r0
     61c:	11 24       	eor	r1, r1
     61e:	ce 56       	subi	r28, 0x6E	; 110
     620:	db 4f       	sbci	r29, 0xFB	; 251
     622:	89 81       	ldd	r24, Y+1	; 0x01
     624:	8f 3f       	cpi	r24, 0xFF	; 255
     626:	19 f0       	breq	.+6      	; 0x62e <receive_message+0xa4>
     628:	0e 94 51 08 	call	0x10a2	; 0x10a2 <switch_off>
     62c:	1a 82       	std	Y+2, r1	; 0x02
     62e:	85 e0       	ldi	r24, 0x05	; 5
     630:	8a 95       	dec	r24
     632:	f1 f7       	brne	.-4      	; 0x630 <receive_message+0xa6>
     634:	8a e1       	ldi	r24, 0x1A	; 26
     636:	80 9f       	mul	r24, r16
     638:	e0 01       	movw	r28, r0
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     63a:	81 9f       	mul	r24, r17
     63c:	d0 0d       	add	r29, r0
     63e:	11 24       	eor	r1, r1
     640:	ce 56       	subi	r28, 0x6E	; 110
     642:	db 4f       	sbci	r29, 0xFB	; 251
     644:	89 81       	ldd	r24, Y+1	; 0x01
     646:	8f 3f       	cpi	r24, 0xFF	; 255
     648:	21 f0       	breq	.+8      	; 0x652 <receive_message+0xc8>
     64a:	0e 94 0e 08 	call	0x101c	; 0x101c <switch_on>
     64e:	81 e0       	ldi	r24, 0x01	; 1
     650:	8a 83       	std	Y+2, r24	; 0x02
     652:	42 e0       	ldi	r20, 0x02	; 2
     654:	dc cf       	rjmp	.-72     	; 0x60e <receive_message+0x84>
     656:	43 e0       	ldi	r20, 0x03	; 3
     658:	da cf       	rjmp	.-76     	; 0x60e <receive_message+0x84>
     65a:	40 e0       	ldi	r20, 0x00	; 0
     65c:	60 e0       	ldi	r22, 0x00	; 0
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     65e:	30 c0       	rjmp	.+96     	; 0x6c0 <receive_message+0x136>
     660:	8a e1       	ldi	r24, 0x1A	; 26
     662:	c8 9f       	mul	r28, r24
     664:	e0 01       	movw	r28, r0
     666:	11 24       	eor	r1, r1
     668:	ce 56       	subi	r28, 0x6E	; 110
     66a:	db 4f       	sbci	r29, 0xFB	; 251
     66c:	89 81       	ldd	r24, Y+1	; 0x01
     66e:	8f 3f       	cpi	r24, 0xFF	; 255
     670:	29 f0       	breq	.+10     	; 0x67c <receive_message+0xf2>
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     672:	0e 94 0e 08 	call	0x101c	; 0x101c <switch_on>
     676:	81 e0       	ldi	r24, 0x01	; 1
     678:	8a 83       	std	Y+2, r24	; 0x02
     67a:	8b 83       	std	Y+3, r24	; 0x03
     67c:	45 e0       	ldi	r20, 0x05	; 5
     67e:	c7 cf       	rjmp	.-114    	; 0x60e <receive_message+0x84>
     680:	8a e1       	ldi	r24, 0x1A	; 26
     682:	c8 9f       	mul	r28, r24
     684:	e0 01       	movw	r28, r0
     686:	11 24       	eor	r1, r1
     688:	ce 56       	subi	r28, 0x6E	; 110
     68a:	db 4f       	sbci	r29, 0xFB	; 251
     68c:	89 81       	ldd	r24, Y+1	; 0x01
     68e:	8f 3f       	cpi	r24, 0xFF	; 255
     690:	f9 f0       	breq	.+62     	; 0x6d0 <receive_message+0x146>
     692:	82 81       	ldd	r24, Z+2	; 0x02
     694:	8e 83       	std	Y+6, r24	; 0x06
     696:	82 81       	ldd	r24, Z+2	; 0x02
     698:	80 93 91 0c 	sts	0x0C91, r24
     69c:	19 c0       	rjmp	.+50     	; 0x6d0 <receive_message+0x146>
     69e:	8a e1       	ldi	r24, 0x1A	; 26
     6a0:	c8 9f       	mul	r28, r24
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6a2:	e0 01       	movw	r28, r0
     6a4:	11 24       	eor	r1, r1
     6a6:	ce 56       	subi	r28, 0x6E	; 110
     6a8:	db 4f       	sbci	r29, 0xFB	; 251
     6aa:	89 81       	ldd	r24, Y+1	; 0x01
     6ac:	8f 3f       	cpi	r24, 0xFF	; 255
     6ae:	81 f0       	breq	.+32     	; 0x6d0 <receive_message+0x146>
     6b0:	82 81       	ldd	r24, Z+2	; 0x02
     6b2:	8e 87       	std	Y+14, r24	; 0x0e
     6b4:	82 81       	ldd	r24, Z+2	; 0x02
     6b6:	80 93 8c 0c 	sts	0x0C8C, r24
     6ba:	0a c0       	rjmp	.+20     	; 0x6d0 <receive_message+0x146>
     6bc:	40 e0       	ldi	r20, 0x00	; 0
     6be:	61 e0       	ldi	r22, 0x01	; 1
     6c0:	8f 2d       	mov	r24, r15
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     6c2:	df 91       	pop	r29
     6c4:	cf 91       	pop	r28
     6c6:	1f 91       	pop	r17
     6c8:	0f 91       	pop	r16
     6ca:	ff 90       	pop	r15
     6cc:	0c 94 88 10 	jmp	0x2110	; 0x2110 <transmit_packet>
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	1f 91       	pop	r17
     6d6:	0f 91       	pop	r16
     6d8:	ff 90       	pop	r15
     6da:	08 95       	ret

000006dc <StateofCharge>:
     6dc:	cf 93       	push	r28
     6de:	90 91 81 0a 	lds	r25, 0x0A81
     6e2:	9f 3f       	cpi	r25, 0xFF	; 255
     6e4:	09 f4       	brne	.+2      	; 0x6e8 <StateofCharge+0xc>
     6e6:	c2 c0       	rjmp	.+388    	; 0x86c <StateofCharge+0x190>
     6e8:	80 91 6b 0a 	lds	r24, 0x0A6B
     6ec:	88 23       	and	r24, r24
     6ee:	09 f4       	brne	.+2      	; 0x6f2 <StateofCharge+0x16>
     6f0:	bd c0       	rjmp	.+378    	; 0x86c <StateofCharge+0x190>
     6f2:	80 91 82 0a 	lds	r24, 0x0A82
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     6f6:	88 23       	and	r24, r24
     6f8:	21 f0       	breq	.+8      	; 0x702 <StateofCharge+0x26>
     6fa:	81 e0       	ldi	r24, 0x01	; 1
     6fc:	80 93 ba 0e 	sts	0x0EBA, r24
     700:	02 c0       	rjmp	.+4      	; 0x706 <StateofCharge+0x2a>
     702:	10 92 ba 0e 	sts	0x0EBA, r1
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
	}
  	percent = 100*(1 - batt_time/discharge_max_time);
     706:	80 91 ba 0e 	lds	r24, 0x0EBA
     70a:	88 23       	and	r24, r24
     70c:	19 f0       	breq	.+6      	; 0x714 <StateofCharge+0x38>
     70e:	9f 37       	cpi	r25, 0x7F	; 127
     710:	20 f0       	brcs	.+8      	; 0x71a <StateofCharge+0x3e>
     712:	a0 c0       	rjmp	.+320    	; 0x854 <StateofCharge+0x178>
     714:	98 37       	cpi	r25, 0x78	; 120
     716:	08 f0       	brcs	.+2      	; 0x71a <StateofCharge+0x3e>
     718:	9d c0       	rjmp	.+314    	; 0x854 <StateofCharge+0x178>
     71a:	95 36       	cpi	r25, 0x65	; 101
     71c:	08 f4       	brcc	.+2      	; 0x720 <StateofCharge+0x44>
     71e:	95 c0       	rjmp	.+298    	; 0x84a <StateofCharge+0x16e>
     720:	c0 91 62 04 	lds	r28, 0x0462
     724:	2c 2f       	mov	r18, r28
     726:	2f 5f       	subi	r18, 0xFF	; 255
     728:	20 93 62 04 	sts	0x0462, r18
     72c:	88 23       	and	r24, r24
     72e:	f1 f1       	breq	.+124    	; 0x7ac <StateofCharge+0xd0>
     730:	80 91 95 0e 	lds	r24, 0x0E95
     734:	9a 36       	cpi	r25, 0x6A	; 106
     736:	20 f4       	brcc	.+8      	; 0x740 <StateofCharge+0x64>
     738:	82 95       	swap	r24
     73a:	86 95       	lsr	r24
  }
  else 
  {
    float temp_real = 0;
    if (real < 13.35)
     73c:	86 95       	lsr	r24
     73e:	0b c0       	rjmp	.+22     	; 0x756 <StateofCharge+0x7a>
     740:	29 2f       	mov	r18, r25
     742:	2a 56       	subi	r18, 0x6A	; 106
     744:	82 95       	swap	r24
     746:	86 95       	lsr	r24
     748:	86 95       	lsr	r24
     74a:	83 70       	andi	r24, 0x03	; 3
     74c:	2a 30       	cpi	r18, 0x0A	; 10
     74e:	10 f4       	brcc	.+4      	; 0x754 <StateofCharge+0x78>
	{
	  debug = 0x0C;
     750:	8f 5f       	subi	r24, 0xFF	; 255
     752:	01 c0       	rjmp	.+2      	; 0x756 <StateofCharge+0x7a>
     754:	8e 5f       	subi	r24, 0xFE	; 254
	  // voltage is normalized by mean 13.13 and std 0.1754 (real - 13.13)/0.1754
	  temp_real = (real - 13.13)*5.701254;
     756:	83 70       	andi	r24, 0x03	; 3
     758:	80 93 ad 0e 	sts	0x0EAD, r24
     75c:	e9 2f       	mov	r30, r25
     75e:	f0 e0       	ldi	r31, 0x00	; 0
     760:	e5 56       	subi	r30, 0x65	; 101
     762:	f1 09       	sbc	r31, r1
     764:	ee 0f       	add	r30, r30
     766:	ff 1f       	adc	r31, r31
     768:	ee 0f       	add	r30, r30
     76a:	ff 1f       	adc	r31, r31
     76c:	e8 0f       	add	r30, r24
     76e:	f1 1d       	adc	r31, r1
     770:	ee 0f       	add	r30, r30
     772:	ff 1f       	adc	r31, r31
     774:	ea 5f       	subi	r30, 0xFA	; 250
	  batt_time = p1*pow(temp_real,3) + p2*pow(temp_real,2) + p3*temp_real + p4;
     776:	fc 4f       	sbci	r31, 0xFC	; 252
     778:	60 81       	ld	r22, Z
     77a:	71 81       	ldd	r23, Z+1	; 0x01
     77c:	6b 50       	subi	r22, 0x0B	; 11
     77e:	71 09       	sbc	r23, r1
     780:	80 e0       	ldi	r24, 0x00	; 0
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	0e 94 06 12 	call	0x240c	; 0x240c <__floatunsisf>
     788:	28 eb       	ldi	r18, 0xB8	; 184
     78a:	3e e1       	ldi	r19, 0x1E	; 30
     78c:	49 e2       	ldi	r20, 0x29	; 41
     78e:	51 e4       	ldi	r21, 0x41	; 65
     790:	0e 94 9e 11 	call	0x233c	; 0x233c <__divsf3>
     794:	60 93 41 08 	sts	0x0841, r22
     798:	70 93 42 08 	sts	0x0842, r23
     79c:	80 93 43 08 	sts	0x0843, r24
     7a0:	90 93 44 08 	sts	0x0844, r25
     7a4:	c9 5f       	subi	r28, 0xF9	; 249
     7a6:	c0 93 62 04 	sts	0x0462, r28
     7aa:	60 c0       	rjmp	.+192    	; 0x86c <StateofCharge+0x190>
     7ac:	9a 36       	cpi	r25, 0x6A	; 106
     7ae:	30 f4       	brcc	.+12     	; 0x7bc <StateofCharge+0xe0>
     7b0:	80 91 95 0e 	lds	r24, 0x0E95
     7b4:	82 95       	swap	r24
     7b6:	86 95       	lsr	r24
     7b8:	86 95       	lsr	r24
     7ba:	17 c0       	rjmp	.+46     	; 0x7ea <StateofCharge+0x10e>
     7bc:	89 2f       	mov	r24, r25
     7be:	8a 56       	subi	r24, 0x6A	; 106
     7c0:	8a 30       	cpi	r24, 0x0A	; 10
     7c2:	40 f4       	brcc	.+16     	; 0x7d4 <StateofCharge+0xf8>
     7c4:	80 91 95 0e 	lds	r24, 0x0E95
     7c8:	82 95       	swap	r24
     7ca:	86 95       	lsr	r24
     7cc:	86 95       	lsr	r24
     7ce:	83 70       	andi	r24, 0x03	; 3
     7d0:	8f 5f       	subi	r24, 0xFF	; 255
     7d2:	0b c0       	rjmp	.+22     	; 0x7ea <StateofCharge+0x10e>
     7d4:	89 2f       	mov	r24, r25
     7d6:	84 57       	subi	r24, 0x74	; 116
     7d8:	83 30       	cpi	r24, 0x03	; 3
     7da:	48 f4       	brcc	.+18     	; 0x7ee <StateofCharge+0x112>
     7dc:	80 91 95 0e 	lds	r24, 0x0E95
     7e0:	82 95       	swap	r24
     7e2:	86 95       	lsr	r24
     7e4:	86 95       	lsr	r24
     7e6:	83 70       	andi	r24, 0x03	; 3
     7e8:	8e 5f       	subi	r24, 0xFE	; 254
     7ea:	83 70       	andi	r24, 0x03	; 3
     7ec:	01 c0       	rjmp	.+2      	; 0x7f0 <StateofCharge+0x114>
     7ee:	80 e0       	ldi	r24, 0x00	; 0
     7f0:	80 93 ad 0e 	sts	0x0EAD, r24
     7f4:	e7 e7       	ldi	r30, 0x77	; 119
     7f6:	f0 e0       	ldi	r31, 0x00	; 0
     7f8:	e9 1b       	sub	r30, r25
     7fa:	f1 09       	sbc	r31, r1
     7fc:	ee 0f       	add	r30, r30
     7fe:	ff 1f       	adc	r31, r31
     800:	ee 0f       	add	r30, r30
     802:	ff 1f       	adc	r31, r31
     804:	e8 1b       	sub	r30, r24
     806:	f1 09       	sbc	r31, r1
     808:	ee 0f       	add	r30, r30
     80a:	ff 1f       	adc	r31, r31
     80c:	ee 51       	subi	r30, 0x1E	; 30
     80e:	fc 4f       	sbci	r31, 0xFC	; 252
	}
	else 
	{
	  debug = 0x0D;
     810:	60 81       	ld	r22, Z
     812:	71 81       	ldd	r23, Z+1	; 0x01
     814:	80 e0       	ldi	r24, 0x00	; 0
	  // voltage is normalized by mean 13.7 and std 0.1558 (real - 13.7)/0.1558;
	  temp_real = (real - 13.7)*6.418485;
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	0e 94 06 12 	call	0x240c	; 0x240c <__floatunsisf>
     81c:	28 eb       	ldi	r18, 0xB8	; 184
     81e:	3e e1       	ldi	r19, 0x1E	; 30
     820:	41 e2       	ldi	r20, 0x21	; 33
     822:	51 e4       	ldi	r21, 0x41	; 65
     824:	0e 94 9e 11 	call	0x233c	; 0x233c <__divsf3>
     828:	9b 01       	movw	r18, r22
     82a:	ac 01       	movw	r20, r24
     82c:	60 e0       	ldi	r22, 0x00	; 0
     82e:	70 e0       	ldi	r23, 0x00	; 0
     830:	88 ec       	ldi	r24, 0xC8	; 200
     832:	92 e4       	ldi	r25, 0x42	; 66
     834:	0e 94 35 11 	call	0x226a	; 0x226a <__subsf3>
      batt_time = q1*pow(temp_real,3) + q2*pow(temp_real,2) + q3*temp_real + q4;
     838:	60 93 41 08 	sts	0x0841, r22
     83c:	70 93 42 08 	sts	0x0842, r23
     840:	80 93 43 08 	sts	0x0843, r24
     844:	90 93 44 08 	sts	0x0844, r25
     848:	11 c0       	rjmp	.+34     	; 0x86c <StateofCharge+0x190>
     84a:	80 e0       	ldi	r24, 0x00	; 0
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	a0 e8       	ldi	r26, 0x80	; 128
     850:	bf eb       	ldi	r27, 0xBF	; 191
     852:	04 c0       	rjmp	.+8      	; 0x85c <StateofCharge+0x180>
     854:	80 e0       	ldi	r24, 0x00	; 0
     856:	90 e0       	ldi	r25, 0x00	; 0
     858:	a8 ed       	ldi	r26, 0xD8	; 216
     85a:	b2 e4       	ldi	r27, 0x42	; 66
     85c:	80 93 41 08 	sts	0x0841, r24
     860:	90 93 42 08 	sts	0x0842, r25
     864:	a0 93 43 08 	sts	0x0843, r26
     868:	b0 93 44 08 	sts	0x0844, r27
     86c:	80 91 82 0a 	lds	r24, 0x0A82
     870:	81 50       	subi	r24, 0x01	; 1
     872:	8e 3f       	cpi	r24, 0xFE	; 254
     874:	28 f4       	brcc	.+10     	; 0x880 <StateofCharge+0x1a4>
     876:	80 91 62 04 	lds	r24, 0x0462
     87a:	8f 5f       	subi	r24, 0xFF	; 255
     87c:	80 93 62 04 	sts	0x0462, r24
     880:	cf 91       	pop	r28
     882:	08 95       	ret

00000884 <assign_charge_fit>:
     884:	80 e0       	ldi	r24, 0x00	; 0
     886:	90 e3       	ldi	r25, 0x30	; 48
     888:	af e1       	ldi	r26, 0x1F	; 31
     88a:	b6 e4       	ldi	r27, 0x46	; 70
     88c:	80 93 88 0a 	sts	0x0A88, r24
     890:	90 93 89 0a 	sts	0x0A89, r25
     894:	a0 93 8a 0a 	sts	0x0A8A, r26
     898:	b0 93 8b 0a 	sts	0x0A8B, r27
     89c:	8c e5       	ldi	r24, 0x5C	; 92
     89e:	9f e8       	ldi	r25, 0x8F	; 143
     8a0:	a4 e9       	ldi	r26, 0x94	; 148
     8a2:	b1 e4       	ldi	r27, 0x41	; 65
     8a4:	80 93 5a 0a 	sts	0x0A5A, r24
     8a8:	90 93 5b 0a 	sts	0x0A5B, r25
     8ac:	a0 93 5c 0a 	sts	0x0A5C, r26
     8b0:	b0 93 5d 0a 	sts	0x0A5D, r27
     8b4:	8d ec       	ldi	r24, 0xCD	; 205
     8b6:	9c ec       	ldi	r25, 0xCC	; 204
     8b8:	a8 e3       	ldi	r26, 0x38	; 56
     8ba:	b3 e4       	ldi	r27, 0x43	; 67
     8bc:	80 93 7f 04 	sts	0x047F, r24
     8c0:	90 93 80 04 	sts	0x0480, r25
     8c4:	a0 93 81 04 	sts	0x0481, r26
     8c8:	b0 93 82 04 	sts	0x0482, r27
     8cc:	86 e6       	ldi	r24, 0x66	; 102
     8ce:	96 ee       	ldi	r25, 0xE6	; 230
     8d0:	a5 e2       	ldi	r26, 0x25	; 37
     8d2:	b4 e4       	ldi	r27, 0x44	; 68
     8d4:	80 93 a1 0e 	sts	0x0EA1, r24
     8d8:	90 93 a2 0e 	sts	0x0EA2, r25
     8dc:	a0 93 a3 0e 	sts	0x0EA3, r26
     8e0:	b0 93 a4 0e 	sts	0x0EA4, r27
	}
  	percent = 100*(batt_time/charge_max_time);
     8e4:	86 e6       	ldi	r24, 0x66	; 102
     8e6:	96 ea       	ldi	r25, 0xA6	; 166
     8e8:	a1 e5       	ldi	r26, 0x51	; 81
     8ea:	b4 e4       	ldi	r27, 0x44	; 68
     8ec:	80 93 bd 0e 	sts	0x0EBD, r24
     8f0:	90 93 be 0e 	sts	0x0EBE, r25
     8f4:	a0 93 bf 0e 	sts	0x0EBF, r26
     8f8:	b0 93 c0 0e 	sts	0x0EC0, r27
     8fc:	81 ee       	ldi	r24, 0xE1	; 225
     8fe:	9a ef       	ldi	r25, 0xFA	; 250
     900:	ac e9       	ldi	r26, 0x9C	; 156
     902:	b2 e4       	ldi	r27, 0x42	; 66
     904:	80 93 7c 0a 	sts	0x0A7C, r24
     908:	90 93 7d 0a 	sts	0x0A7D, r25
     90c:	a0 93 7e 0a 	sts	0x0A7E, r26
     910:	b0 93 7f 0a 	sts	0x0A7F, r27
     914:	86 e6       	ldi	r24, 0x66	; 102
     916:	96 ec       	ldi	r25, 0xC6	; 198
     918:	a7 e0       	ldi	r26, 0x07	; 7
     91a:	b4 e4       	ldi	r27, 0x44	; 68
     91c:	80 93 3a 08 	sts	0x083A, r24
     920:	90 93 3b 08 	sts	0x083B, r25
  }
  
  // Percent limiting for periodic function
  if (percent < 1) 
     924:	a0 93 3c 08 	sts	0x083C, r26
     928:	b0 93 3d 08 	sts	0x083D, r27
     92c:	80 e0       	ldi	r24, 0x00	; 0
     92e:	90 eb       	ldi	r25, 0xB0	; 176
     930:	a7 e1       	ldi	r26, 0x17	; 23
     932:	b5 e4       	ldi	r27, 0x45	; 69
     934:	80 93 78 0a 	sts	0x0A78, r24
     938:	90 93 79 0a 	sts	0x0A79, r25
     93c:	a0 93 7a 0a 	sts	0x0A7A, r26
     940:	b0 93 7b 0a 	sts	0x0A7B, r27
     944:	80 e0       	ldi	r24, 0x00	; 0
  { 
  	debug2 = 0xA0;
     946:	98 e9       	ldi	r25, 0x98	; 152
     948:	ae ea       	ldi	r26, 0xAE	; 174
     94a:	b5 e4       	ldi	r27, 0x45	; 69
  	soc = 0; 
     94c:	80 93 b2 0e 	sts	0x0EB2, r24
     950:	90 93 b3 0e 	sts	0x0EB3, r25
  }
  else if (percent > 99) 
     954:	a0 93 b4 0e 	sts	0x0EB4, r26
     958:	b0 93 b5 0e 	sts	0x0EB5, r27
     95c:	08 95       	ret

0000095e <assign_discharge_fit>:
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	96 e1       	ldi	r25, 0x16	; 22
     962:	a9 e8       	ldi	r26, 0x89	; 137
     964:	b6 e4       	ldi	r27, 0x46	; 70
  { 
  	debug2 = 0xB0;
     966:	80 93 4f 08 	sts	0x084F, r24
     96a:	90 93 50 08 	sts	0x0850, r25
  	soc = 255;
     96e:	a0 93 51 08 	sts	0x0851, r26
     972:	b0 93 52 08 	sts	0x0852, r27
  }
  else { 
  	debug2 = 0xC0;
     976:	88 eb       	ldi	r24, 0xB8	; 184
     978:	93 ec       	ldi	r25, 0xC3	; 195
  	soc = (char)floor((int)(percent)); 
     97a:	90 93 9e 0e 	sts	0x0E9E, r25
     97e:	80 93 9d 0e 	sts	0x0E9D, r24
     982:	8a ee       	ldi	r24, 0xEA	; 234
     984:	98 eb       	ldi	r25, 0xB8	; 184
     986:	90 93 a8 0e 	sts	0x0EA8, r25
     98a:	80 93 a7 0e 	sts	0x0EA7, r24
     98e:	8f e6       	ldi	r24, 0x6F	; 111
     990:	9c e9       	ldi	r25, 0x9C	; 156
     992:	90 93 3f 08 	sts	0x083F, r25
     996:	80 93 3e 08 	sts	0x083E, r24
  }
}
     99a:	85 e9       	ldi	r24, 0x95	; 149
     99c:	9c e2       	ldi	r25, 0x2C	; 44
     99e:	90 93 71 0a 	sts	0x0A71, r25
     9a2:	80 93 70 0a 	sts	0x0A70, r24
     9a6:	81 e7       	ldi	r24, 0x71	; 113
     9a8:	9a ea       	ldi	r25, 0xAA	; 170
     9aa:	90 93 7d 04 	sts	0x047D, r25
     9ae:	80 93 7c 04 	sts	0x047C, r24
     9b2:	8a ec       	ldi	r24, 0xCA	; 202
     9b4:	98 e3       	ldi	r25, 0x38	; 56
     9b6:	90 93 65 0a 	sts	0x0A65, r25
     9ba:	80 93 64 0a 	sts	0x0A64, r24
     9be:	82 e0       	ldi	r24, 0x02	; 2
     9c0:	93 e0       	ldi	r25, 0x03	; 3
     9c2:	90 93 a0 0e 	sts	0x0EA0, r25
  f1 = -1.819810644993805E4;
  b1 = -2.548949173344369E4;
  f2 = 1.141365113433748E4;
  b2 = -2.190399298389397E4;
  f3 = 1.453849538420288E4;
  b3 = 7.700208204268025E2;
     9c6:	80 93 9f 0e 	sts	0x0E9F, r24
  f4 = 1.965482651710955E3;
     9ca:	8d ea       	ldi	r24, 0xAD	; 173
     9cc:	97 e0       	ldi	r25, 0x07	; 7
     9ce:	90 93 a6 0e 	sts	0x0EA6, r25
     9d2:	80 93 a5 0e 	sts	0x0EA5, r24
  b4 = 5.504490550919407E3;
     9d6:	80 e8       	ldi	r24, 0x80	; 128
     9d8:	95 e1       	ldi	r25, 0x15	; 21
     9da:	90 93 59 08 	sts	0x0859, r25
     9de:	80 93 58 08 	sts	0x0858, r24
  f5 = -9.466488439471518E2;
     9e2:	8e e4       	ldi	r24, 0x4E	; 78
     9e4:	9c ef       	ldi	r25, 0xFC	; 252
     9e6:	90 93 57 08 	sts	0x0857, r25
     9ea:	80 93 56 08 	sts	0x0856, r24
  b5 = 8.270458368650347E2;
     9ee:	8b e3       	ldi	r24, 0x3B	; 59
     9f0:	93 e0       	ldi	r25, 0x03	; 3
     9f2:	90 93 9c 0e 	sts	0x0E9C, r25
     9f6:	80 93 9b 0e 	sts	0x0E9B, r24
  w = 2.725333178515558;
     9fa:	8c ed       	ldi	r24, 0xDC	; 220
     9fc:	9b e6       	ldi	r25, 0x6B	; 107
     9fe:	ae e2       	ldi	r26, 0x2E	; 46
     a00:	b0 e4       	ldi	r27, 0x40	; 64
     a02:	80 93 45 08 	sts	0x0845, r24
     a06:	90 93 46 08 	sts	0x0846, r25
     a0a:	a0 93 47 08 	sts	0x0847, r26
     a0e:	b0 93 48 08 	sts	0x0848, r27
  
  h0 = 2.979485572689352E8;
     a12:	80 e8       	ldi	r24, 0x80	; 128
     a14:	95 e5       	ldi	r25, 0x55	; 85
     a16:	a2 ec       	ldi	r26, 0xC2	; 194
     a18:	b1 e1       	ldi	r27, 0x11	; 17
     a1a:	80 93 6c 0a 	sts	0x0A6C, r24
     a1e:	90 93 6d 0a 	sts	0x0A6D, r25
     a22:	a0 93 6e 0a 	sts	0x0A6E, r26
     a26:	b0 93 6f 0a 	sts	0x0A6F, r27
  h1 = 2.088787459098652E8;
     a2a:	80 ea       	ldi	r24, 0xA0	; 160
     a2c:	9c e3       	ldi	r25, 0x3C	; 60
     a2e:	a3 e7       	ldi	r26, 0x73	; 115
     a30:	bc e0       	ldi	r27, 0x0C	; 12
     a32:	80 93 87 04 	sts	0x0487, r24
     a36:	90 93 88 04 	sts	0x0488, r25
     a3a:	a0 93 89 04 	sts	0x0489, r26
     a3e:	b0 93 8a 04 	sts	0x048A, r27
  g1 = 4.359717315569648E8;
     a42:	80 ea       	ldi	r24, 0xA0	; 160
     a44:	96 e6       	ldi	r25, 0x66	; 102
     a46:	ac ef       	ldi	r26, 0xFC	; 252
     a48:	b9 e1       	ldi	r27, 0x19	; 25
     a4a:	80 93 8c 04 	sts	0x048C, r24
     a4e:	90 93 8d 04 	sts	0x048D, r25
     a52:	a0 93 8e 04 	sts	0x048E, r26
     a56:	b0 93 8f 04 	sts	0x048F, r27
  h2 =  -1.569778955752849E8;
     a5a:	80 e2       	ldi	r24, 0x20	; 32
     a5c:	95 eb       	ldi	r25, 0xB5	; 181
     a5e:	a4 ea       	ldi	r26, 0xA4	; 164
     a60:	b6 ef       	ldi	r27, 0xF6	; 246
     a62:	80 93 67 0a 	sts	0x0A67, r24
     a66:	90 93 68 0a 	sts	0x0A68, r25
     a6a:	a0 93 69 0a 	sts	0x0A69, r26
     a6e:	b0 93 6a 0a 	sts	0x0A6A, r27
  g2 =  1.969854815603661E8;
     a72:	80 e9       	ldi	r24, 0x90	; 144
     a74:	92 ec       	ldi	r25, 0xC2	; 194
     a76:	ad eb       	ldi	r26, 0xBD	; 189
     a78:	bb e0       	ldi	r27, 0x0B	; 11
     a7a:	80 93 5f 0a 	sts	0x0A5F, r24
     a7e:	90 93 60 0a 	sts	0x0A60, r25
     a82:	a0 93 61 0a 	sts	0x0A61, r26
     a86:	b0 93 62 0a 	sts	0x0A62, r27
  h3 =  -7.513816845838763E7;
     a8a:	88 e8       	ldi	r24, 0x88	; 136
     a8c:	9b e7       	ldi	r25, 0x7B	; 123
     a8e:	a5 e8       	ldi	r26, 0x85	; 133
     a90:	bb ef       	ldi	r27, 0xFB	; 251
     a92:	80 93 a9 0e 	sts	0x0EA9, r24
     a96:	90 93 aa 0e 	sts	0x0EAA, r25
     a9a:	a0 93 ab 0e 	sts	0x0EAB, r26
     a9e:	b0 93 ac 0e 	sts	0x0EAC, r27
  g3 =  -1.633385950799686E7;
     aa2:	8c ed       	ldi	r24, 0xDC	; 220
     aa4:	93 ec       	ldi	r25, 0xC3	; 195
     aa6:	a6 e0       	ldi	r26, 0x06	; 6
     aa8:	bf ef       	ldi	r27, 0xFF	; 255
     aaa:	80 93 78 04 	sts	0x0478, r24
     aae:	90 93 79 04 	sts	0x0479, r25
     ab2:	a0 93 7a 04 	sts	0x047A, r26
     ab6:	b0 93 7b 04 	sts	0x047B, r27
  h4 =   -2.642581886559125E6;
     aba:	8a e6       	ldi	r24, 0x6A	; 106
     abc:	9d ea       	ldi	r25, 0xAD	; 173
     abe:	a7 ed       	ldi	r26, 0xD7	; 215
     ac0:	bf ef       	ldi	r27, 0xFF	; 255
     ac2:	80 93 91 0e 	sts	0x0E91, r24
     ac6:	90 93 92 0e 	sts	0x0E92, r25
     aca:	a0 93 93 0e 	sts	0x0E93, r26
     ace:	b0 93 94 0e 	sts	0x0E94, r27
  g4 =   -1.016608352073227E7;
     ad2:	8c eb       	ldi	r24, 0xBC	; 188
     ad4:	90 ee       	ldi	r25, 0xE0	; 224
     ad6:	a4 e6       	ldi	r26, 0x64	; 100
     ad8:	bf ef       	ldi	r27, 0xFF	; 255
     ada:	80 93 63 04 	sts	0x0463, r24
     ade:	90 93 64 04 	sts	0x0464, r25
     ae2:	a0 93 65 04 	sts	0x0465, r26
     ae6:	b0 93 66 04 	sts	0x0466, r27
  w2 =  0.364797662747743;
     aea:	82 ec       	ldi	r24, 0xC2	; 194
     aec:	96 ec       	ldi	r25, 0xC6	; 198
     aee:	aa eb       	ldi	r26, 0xBA	; 186
     af0:	be e3       	ldi	r27, 0x3E	; 62
     af2:	80 93 8d 0c 	sts	0x0C8D, r24
     af6:	90 93 8e 0c 	sts	0x0C8E, r25
     afa:	a0 93 8f 0c 	sts	0x0C8F, r26
     afe:	b0 93 90 0c 	sts	0x0C90, r27
     b02:	08 95       	ret

00000b04 <initialize>:
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE,    MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE,    MUX2    ,       6     );  // Fake Data
}

void initialize( void )
{
     b04:	ef 92       	push	r14
     b06:	ff 92       	push	r15
     b08:	0f 93       	push	r16
     b0a:	1f 93       	push	r17
     b0c:	cf 93       	push	r28
     b0e:	df 93       	push	r29
   // pin initialization
  DDRA  = 0b11111111;
     b10:	1f ef       	ldi	r17, 0xFF	; 255
     b12:	1a bb       	out	0x1a, r17	; 26
  PORTA = 0b00000111;
     b14:	87 e0       	ldi	r24, 0x07	; 7
     b16:	8b bb       	out	0x1b, r24	; 27

  DDRB  = 0b11111111;
     b18:	17 bb       	out	0x17, r17	; 23
  PORTB = 0b11100000;
     b1a:	80 ee       	ldi	r24, 0xE0	; 224
     b1c:	88 bb       	out	0x18, r24	; 24

  DDRC  = 0b11111111;
     b1e:	14 bb       	out	0x14, r17	; 20
  PORTC = 0b11111111;
     b20:	15 bb       	out	0x15, r17	; 21

  DDRD  = 0b11111011;
     b22:	8b ef       	ldi	r24, 0xFB	; 251
     b24:	81 bb       	out	0x11, r24	; 17
  PORTD = 0b11110000;
     b26:	80 ef       	ldi	r24, 0xF0	; 240
     b28:	82 bb       	out	0x12, r24	; 18

  DDRE  = 0b11111110;
     b2a:	9e ef       	ldi	r25, 0xFE	; 254
     b2c:	92 b9       	out	0x02, r25	; 2
  PORTE = 0b00000000;
     b2e:	13 b8       	out	0x03, r1	; 3

  DDRF  = 0b11110000;
     b30:	80 93 61 00 	sts	0x0061, r24
  //0b11111111;	//testing
  PORTF = 0b00000000;
     b34:	10 92 62 00 	sts	0x0062, r1

  DDRG  = 0b00011111;
     b38:	8f e1       	ldi	r24, 0x1F	; 31
     b3a:	80 93 64 00 	sts	0x0064, r24
  PORTG = 0b00000100;
     b3e:	04 e0       	ldi	r16, 0x04	; 4
     b40:	00 93 65 00 	sts	0x0065, r16
  // compare value = 124
  // compare match interrupt freq = (14.7456 MHz / 1024 / 100) = 144 Hz
  // use timer0_counter to get 144 / 144 = 1 Hz

  // enable clear on match interrupt
  TIMSK = ( 1 << OCIE0 );
     b44:	82 e0       	ldi	r24, 0x02	; 2
     b46:	87 bf       	out	0x37, r24	; 55
  OCR0 = 71;
     b48:	87 e4       	ldi	r24, 0x47	; 71
     b4a:	81 bf       	out	0x31, r24	; 49

  // enable clear on match mode, set prescalar to 1024
  TCCR0 = ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );
     b4c:	8f e0       	ldi	r24, 0x0F	; 15
     b4e:	83 bf       	out	0x33, r24	; 51

  timer0_counter[0] = 99;
     b50:	83 e6       	ldi	r24, 0x63	; 99
     b52:	80 93 8a 0c 	sts	0x0C8A, r24
  timer0_counter[1] = 199;
     b56:	87 ec       	ldi	r24, 0xC7	; 199
     b58:	80 93 8b 0c 	sts	0x0C8B, r24
  period of interrupts = 28800 / 14400 Hz = 2 s/interrupt
  use timer1_counter to get a total period of 2*65535 =  s (24 hours is 86400 seconds)
  */
  
  // Enable clear on match interrupt for the 16 bit timer/counter 1, register A
  OCR1A = 28800;		//28800 corresponds to 2 seconds
     b5c:	80 e8       	ldi	r24, 0x80	; 128
     b5e:	90 e7       	ldi	r25, 0x70	; 112
     b60:	9b bd       	out	0x2b, r25	; 43
     b62:	8a bd       	out	0x2a, r24	; 42

  // Enable clear on match mode, set prescalar to 1024.
  // CS[2:0] = 101 (1024 prescalar)
  // WGM[3:0] = 0100 (Clear Timer on Compare (CTC) when timer matches OCR1A)
  
  TCCR1B = ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS10 );
     b64:	8d e0       	ldi	r24, 0x0D	; 13
     b66:	8e bd       	out	0x2e, r24	; 46
  // Explicit Default Defs
  // TCCR1A |= 0;
  // TCNT1 = 0;
  timer1_counter[0] = CYCLE_COUNTER;	//CYCLE_COUNTER   = 900 for 2 seconds interrupt handler = 1800 secs (30 minutes)
     b68:	84 e8       	ldi	r24, 0x84	; 132
     b6a:	80 93 ae 0e 	sts	0x0EAE, r24
  timer1_counter[1] = CYCLE_COUNTER_2;	//CYCLE_COUNTER_2 = 300 for 2 seconds interrupt handler = 600 secs  (10 minutes)
     b6e:	8c e2       	ldi	r24, 0x2C	; 44
     b70:	80 93 af 0e 	sts	0x0EAF, r24
  //---------------------------------------------------------------------  
  // End of timer 1 Setup
  //--------------------------------------------------------------------- 
  
  // communication
  uart_init();
     b74:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <uart_init>

  // for use in debugging
  // stdout = stdin = stderr = &uart_str;

  tel_packet_size[0] = 0;
     b78:	10 92 84 04 	sts	0x0484, r1
     b7c:	10 92 83 04 	sts	0x0483, r1
  tel_packet_size[1] = 0;
     b80:	10 92 86 04 	sts	0x0486, r1
     b84:	10 92 85 04 	sts	0x0485, r1
  tel_packet_index[0] = 0;
     b88:	10 92 53 08 	sts	0x0853, r1
  tel_packet_index[1] = 0;
     b8c:	10 92 54 08 	sts	0x0854, r1
  uart_vcp_buff[0] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     b90:	8a e0       	ldi	r24, 0x0A	; 10
     b92:	90 e0       	ldi	r25, 0x00	; 0
     b94:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <malloc>
     b98:	7c 01       	movw	r14, r24
     b9a:	e6 eb       	ldi	r30, 0xB6	; 182
     b9c:	fe e0       	ldi	r31, 0x0E	; 14
     b9e:	80 83       	st	Z, r24
     ba0:	f1 82       	std	Z+1, r15	; 0x01
  uart_vcp_buff[1] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     ba2:	8a e0       	ldi	r24, 0x0A	; 10
     ba4:	90 e0       	ldi	r25, 0x00	; 0
     ba6:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <malloc>
     baa:	c8 eb       	ldi	r28, 0xB8	; 184
     bac:	de e0       	ldi	r29, 0x0E	; 14
     bae:	88 83       	st	Y, r24
     bb0:	99 83       	std	Y+1, r25	; 0x01
  vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     bb2:	4f ef       	ldi	r20, 0xFF	; 255
     bb4:	50 e0       	ldi	r21, 0x00	; 0
     bb6:	63 e9       	ldi	r22, 0x93	; 147
     bb8:	7c e0       	ldi	r23, 0x0C	; 12
     bba:	c7 01       	movw	r24, r14
     bbc:	0e 94 11 0a 	call	0x1422	; 0x1422 <vcpptr_init>
  vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     bc0:	4f ef       	ldi	r20, 0xFF	; 255
     bc2:	50 e0       	ldi	r21, 0x00	; 0
     bc4:	62 e9       	ldi	r22, 0x92	; 146
     bc6:	7d e0       	ldi	r23, 0x0D	; 13
     bc8:	88 81       	ld	r24, Y
     bca:	99 81       	ldd	r25, Y+1	; 0x01
     bcc:	0e 94 11 0a 	call	0x1422	; 0x1422 <vcpptr_init>

  rx_flag[0] = 0;
     bd0:	10 92 bb 0e 	sts	0x0EBB, r1
  rx_flag[1] = 0;
     bd4:	10 92 bc 0e 	sts	0x0EBC, r1

  // svit
  initialize_svit();
     bd8:	0e 94 92 00 	call	0x124	; 0x124 <initialize_svit>

  // rev up those interrupts
  sei();
     bdc:	78 94       	sei

  //ADC conversions
  adc_flag = 1;
     bde:	c1 e0       	ldi	r28, 0x01	; 1
     be0:	c0 93 59 0a 	sts	0x0A59, r28
	adc_component = 0;
     be4:	10 92 91 04 	sts	0x0491, r1
	adc_sensor_type = ADC_INIT;//get default case on first interation as to not enter switch
     be8:	00 93 66 0a 	sts	0x0A66, r16
  ADC_high = 0;
     bec:	10 92 77 0a 	sts	0x0A77, r1

  V_upper_val_change = 0;
     bf0:	10 92 91 0c 	sts	0x0C91, r1
  I_upper_val_change = 0;
     bf4:	10 92 8c 0c 	sts	0x0C8C, r1

  //---------------------------------------------------------------------  
  // SOC Initializations
  //--------------------------------------------------------------------- 
  // and shunt and safe transmit flags
  safe_mode = 0;
     bf8:	10 92 63 0a 	sts	0x0A63, r1
  transmit_safe = 0;
     bfc:	10 92 5e 0a 	sts	0x0A5E, r1
  transmit_shunt = 0;
     c00:	10 92 9a 0e 	sts	0x0E9A, r1
  been_to_safe = 0;
     c04:	10 92 8b 04 	sts	0x048B, r1
  been_to_shunt = 0;
     c08:	10 92 83 0a 	sts	0x0A83, r1
  assign_charge_fit();
     c0c:	0e 94 42 04 	call	0x884	; 0x884 <assign_charge_fit>
  assign_discharge_fit();
     c10:	0e 94 af 04 	call	0x95e	; 0x95e <assign_discharge_fit>
  
  // First get battery voltage so that the SoC can
  // accurately determine whether batteries are charging or discharging
  batt1_voltage = 0xff;
     c14:	10 93 81 0a 	sts	0x0A81, r17
  batt2_voltage = 0xff;
     c18:	10 93 92 0c 	sts	0x0C92, r17
  charging = 0xff;
     c1c:	10 93 4a 08 	sts	0x084A, r17
  chargeforward = 0;
     c20:	10 92 b1 0e 	sts	0x0EB1, r1
  chargebackward = 0;
     c24:	10 92 90 04 	sts	0x0490, r1
  debug = 0;
     c28:	10 92 49 08 	sts	0x0849, r1
  debug2 = 0;
     c2c:	10 92 55 08 	sts	0x0855, r1
  percent = 0;
     c30:	10 92 41 08 	sts	0x0841, r1
     c34:	10 92 42 08 	sts	0x0842, r1
     c38:	10 92 43 08 	sts	0x0843, r1
     c3c:	10 92 44 08 	sts	0x0844, r1
  soc = 0;
     c40:	10 92 bf 10 	sts	0x10BF, r1
  high = 0;
     c44:	10 92 72 0a 	sts	0x0A72, r1
  low = 0;
     c48:	10 92 80 0a 	sts	0x0A80, r1
  limit_check_overriden = 0; // Initially limit checking is NOT OVERRIDEN
     c4c:	10 92 40 08 	sts	0x0840, r1
  isCharging = 0;
     c50:	10 92 ba 0e 	sts	0x0EBA, r1
  hasCheckedCurr = 0;
     c54:	10 92 6b 0a 	sts	0x0A6B, r1
  //--------------------------------------------------------------------- 

  //---------------------------------------------------------------------  
  // Timer Initializations
  //---------------------------------------------------------------------
  cdh_heartbeat_flag = 0;	//Default: do not have flag to restart components on
     c58:	10 92 7e 04 	sts	0x047E, r1
  rad_torq_flag = 1;		//Indicates need to delay radio/torquer on signals later
     c5c:	c0 93 67 04 	sts	0x0467, r28
  SVIT_t *component; 	// Initialize Radios to be OFF
  component = &svit[components[RADIO_1]];
     c60:	a0 91 73 04 	lds	r26, 0x0473
     c64:	ca e1       	ldi	r28, 0x1A	; 26
     c66:	ca 9f       	mul	r28, r26
     c68:	d0 01       	movw	r26, r0
     c6a:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     c6c:	ae 56       	subi	r26, 0x6E	; 110
     c6e:	bb 4f       	sbci	r27, 0xFB	; 251
     c70:	11 96       	adiw	r26, 0x01	; 1
     c72:	8c 91       	ld	r24, X
     c74:	0e 94 51 08 	call	0x10a2	; 0x10a2 <switch_off>
  component = &svit[components[RADIO_2]];
     c78:	e0 91 74 04 	lds	r30, 0x0474
     c7c:	ce 9f       	mul	r28, r30
     c7e:	f0 01       	movw	r30, r0
     c80:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     c82:	ee 56       	subi	r30, 0x6E	; 110
     c84:	fb 4f       	sbci	r31, 0xFB	; 251
     c86:	81 81       	ldd	r24, Z+1	; 0x01
     c88:	0e 94 51 08 	call	0x10a2	; 0x10a2 <switch_off>
  component = &svit[TORQUER_1];	// Initialize Torque Coils to be OFF
  component->switch_state = SW_OFF;
     c8c:	10 92 4e 06 	sts	0x064E, r1
  component = &svit[TORQUER_2];
  component->switch_state = SW_OFF;
     c90:	10 92 68 06 	sts	0x0668, r1
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
     c94:	10 92 82 06 	sts	0x0682, r1
  torquer_off(TORQUER_1);
     c98:	81 e1       	ldi	r24, 0x11	; 17
     c9a:	0e 94 d7 07 	call	0xfae	; 0xfae <torquer_off>
  torquer_off(TORQUER_2);
     c9e:	82 e1       	ldi	r24, 0x12	; 18
     ca0:	0e 94 d7 07 	call	0xfae	; 0xfae <torquer_off>
  torquer_off(TORQUER_3);
     ca4:	83 e1       	ldi	r24, 0x13	; 19
  //---------------------------------------------------------------------  
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}
     ca6:	df 91       	pop	r29
     ca8:	cf 91       	pop	r28
     caa:	1f 91       	pop	r17
     cac:	0f 91       	pop	r16
     cae:	ff 90       	pop	r15
     cb0:	ef 90       	pop	r14
  component->switch_state = SW_OFF;
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
  torquer_off(TORQUER_1);
  torquer_off(TORQUER_2);
  torquer_off(TORQUER_3);
     cb2:	0c 94 d7 07 	jmp	0xfae	; 0xfae <torquer_off>

00000cb6 <compareVoltage>:
void compareVoltage( void ) {
  SVIT_t *component;
  //component = &svit[BATTERY_1_b];
  //chargebackward = average_samples( component->I_samples );
  component = &svit[BATTERY_1];
  chargeforward= average_samples( component->I_samples );
     cb6:	89 ea       	ldi	r24, 0xA9	; 169
     cb8:	96 e0       	ldi	r25, 0x06	; 6
     cba:	0e 94 94 08 	call	0x1128	; 0x1128 <average_samples>
     cbe:	80 93 b1 0e 	sts	0x0EB1, r24
  if (chargeforward > 2){
     cc2:	83 30       	cpi	r24, 0x03	; 3
     cc4:	10 f0       	brcs	.+4      	; 0xcca <compareVoltage+0x14>
    charging = 0xdd;//discharging
     cc6:	8d ed       	ldi	r24, 0xDD	; 221
     cc8:	01 c0       	rjmp	.+2      	; 0xccc <compareVoltage+0x16>
    }
  else{
    charging = 0xcc;
     cca:	8c ec       	ldi	r24, 0xCC	; 204
     ccc:	80 93 4a 08 	sts	0x084A, r24
     cd0:	08 95       	ret

00000cd2 <limit_check>:
we should at least get the framework set up for limit checking on arbitrary values.
The power board should have upper and lower limits for vsense and csense data, 
and turn off components if their voltage/current is too high. ONLY CHECKS
BATTERY 1 VOLTAGE LINE RIGHT NOW.
*/
void limit_check( void ) {
     cd2:	cf 92       	push	r12
     cd4:	df 92       	push	r13
     cd6:	ef 92       	push	r14
     cd8:	ff 92       	push	r15
     cda:	0f 93       	push	r16
     cdc:	1f 93       	push	r17
     cde:	cf 93       	push	r28
     ce0:	df 93       	push	r29
	unsigned char sw;
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
     ce2:	c0 90 41 08 	lds	r12, 0x0841
     ce6:	d0 90 42 08 	lds	r13, 0x0842
     cea:	e0 90 43 08 	lds	r14, 0x0843
     cee:	f0 90 44 08 	lds	r15, 0x0844
     cf2:	20 e0       	ldi	r18, 0x00	; 0
     cf4:	30 e0       	ldi	r19, 0x00	; 0
     cf6:	a9 01       	movw	r20, r18
     cf8:	c7 01       	movw	r24, r14
     cfa:	b6 01       	movw	r22, r12
     cfc:	0e 94 9a 11 	call	0x2334	; 0x2334 <__cmpsf2>
     d00:	87 ff       	sbrs	r24, 7
     d02:	4c c0       	rjmp	.+152    	; 0xd9c <limit_check+0xca>
     d04:	29 e2       	ldi	r18, 0x29	; 41
     d06:	3c e5       	ldi	r19, 0x5C	; 92
     d08:	4f e0       	ldi	r20, 0x0F	; 15
     d0a:	5f eb       	ldi	r21, 0xBF	; 191
     d0c:	c7 01       	movw	r24, r14
     d0e:	b6 01       	movw	r22, r12
     d10:	0e 94 9a 11 	call	0x2334	; 0x2334 <__cmpsf2>
     d14:	87 ff       	sbrs	r24, 7
     d16:	0a c0       	rjmp	.+20     	; 0xd2c <limit_check+0x5a>
     d18:	25 e8       	ldi	r18, 0x85	; 133
     d1a:	3b ee       	ldi	r19, 0xEB	; 235
     d1c:	41 e1       	ldi	r20, 0x11	; 17
     d1e:	5f eb       	ldi	r21, 0xBF	; 191
     d20:	c7 01       	movw	r24, r14
     d22:	b6 01       	movw	r22, r12
     d24:	0e 94 b8 12 	call	0x2570	; 0x2570 <__gesf2>
     d28:	18 16       	cp	r1, r24
     d2a:	c4 f1       	brlt	.+112    	; 0xd9c <limit_check+0xca>
		safe_mode = 1;
     d2c:	81 e0       	ldi	r24, 0x01	; 1
     d2e:	80 93 63 0a 	sts	0x0A63, r24
     d32:	08 e6       	ldi	r16, 0x68	; 104
     d34:	14 e0       	ldi	r17, 0x04	; 4
		for (sw = 0; sw < sizeof(components); sw++) {
			component = &svit[components[sw]];
     d36:	3a e1       	ldi	r19, 0x1A	; 26
     d38:	f3 2e       	mov	r15, r19
     d3a:	f8 01       	movw	r30, r16
     d3c:	c1 91       	ld	r28, Z+
     d3e:	8f 01       	movw	r16, r30
     d40:	fc 9e       	mul	r15, r28
     d42:	e0 01       	movw	r28, r0
     d44:	11 24       	eor	r1, r1
     d46:	ce 56       	subi	r28, 0x6E	; 110
     d48:	db 4f       	sbci	r29, 0xFB	; 251
			switch_off( component->switch_num );
     d4a:	89 81       	ldd	r24, Y+1	; 0x01
     d4c:	0e 94 51 08 	call	0x10a2	; 0x10a2 <switch_off>
			component->switch_state = SW_OFF;
     d50:	1a 82       	std	Y+2, r1	; 0x02
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
		safe_mode = 1;
		for (sw = 0; sw < sizeof(components); sw++) {
     d52:	f4 e0       	ldi	r31, 0x04	; 4
     d54:	08 37       	cpi	r16, 0x78	; 120
     d56:	1f 07       	cpc	r17, r31
     d58:	81 f7       	brne	.-32     	; 0xd3a <limit_check+0x68>
			component = &svit[components[sw]];
			switch_off( component->switch_num );
			component->switch_state = SW_OFF;
		}
		component = &svit[TORQUER_1];
		component->switch_state = SW_OFF;
     d5a:	10 92 4e 06 	sts	0x064E, r1
		component = &svit[TORQUER_2];
		component->switch_state = SW_OFF;
     d5e:	10 92 68 06 	sts	0x0668, r1
		component = &svit[TORQUER_3];
		component->switch_state = SW_OFF;
     d62:	10 92 82 06 	sts	0x0682, r1
		torquer_off(TORQUER_1);
     d66:	81 e1       	ldi	r24, 0x11	; 17
     d68:	0e 94 d7 07 	call	0xfae	; 0xfae <torquer_off>
		torquer_off(TORQUER_2);
     d6c:	82 e1       	ldi	r24, 0x12	; 18
     d6e:	0e 94 d7 07 	call	0xfae	; 0xfae <torquer_off>
		torquer_off(TORQUER_3);
     d72:	83 e1       	ldi	r24, 0x13	; 19
     d74:	0e 94 d7 07 	call	0xfae	; 0xfae <torquer_off>
		// Only transmit once
		if (!transmit_safe && !been_to_safe) { 
     d78:	80 91 5e 0a 	lds	r24, 0x0A5E
     d7c:	81 11       	cpse	r24, r1
     d7e:	08 c0       	rjmp	.+16     	; 0xd90 <limit_check+0xbe>
     d80:	80 91 8b 04 	lds	r24, 0x048B
     d84:	81 11       	cpse	r24, r1
     d86:	04 c0       	rjmp	.+8      	; 0xd90 <limit_check+0xbe>
			transmit_packet( 0, VCP_ACK, SAFE_MODE);
     d88:	40 e0       	ldi	r20, 0x00	; 0
     d8a:	62 e0       	ldi	r22, 0x02	; 2
     d8c:	0e 94 88 10 	call	0x2110	; 0x2110 <transmit_packet>
			transmit_safe = 1;
		}
		else {}
		been_to_safe = 1;
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	80 93 8b 04 	sts	0x048B, r24
		transmit_safe = 1;
     d96:	80 93 5e 0a 	sts	0x0A5E, r24
     d9a:	28 c0       	rjmp	.+80     	; 0xdec <limit_check+0x11a>
	}
	else if (percent > SHUNT_MODE  && isCharging) {
     d9c:	20 e0       	ldi	r18, 0x00	; 0
     d9e:	30 e0       	ldi	r19, 0x00	; 0
     da0:	48 ec       	ldi	r20, 0xC8	; 200
     da2:	52 e4       	ldi	r21, 0x42	; 66
     da4:	c7 01       	movw	r24, r14
     da6:	b6 01       	movw	r22, r12
     da8:	0e 94 b8 12 	call	0x2570	; 0x2570 <__gesf2>
     dac:	18 16       	cp	r1, r24
     dae:	f4 f4       	brge	.+60     	; 0xdec <limit_check+0x11a>
     db0:	80 91 ba 0e 	lds	r24, 0x0EBA
     db4:	88 23       	and	r24, r24
     db6:	d1 f0       	breq	.+52     	; 0xdec <limit_check+0x11a>
	    safe_mode = 0;
     db8:	10 92 63 0a 	sts	0x0A63, r1
		// turn on the maestro and send ack_command w/ value of SHUNT_MODE
		component = &svit[MAESTRO];
		switch_on( component->switch_num );
     dbc:	80 91 e5 05 	lds	r24, 0x05E5
     dc0:	0e 94 0e 08 	call	0x101c	; 0x101c <switch_on>
		component->switch_state = SW_ON;
     dc4:	81 e0       	ldi	r24, 0x01	; 1
     dc6:	80 93 e6 05 	sts	0x05E6, r24
		// Only transmit once
		if (!transmit_shunt && !been_to_shunt) {
     dca:	80 91 9a 0e 	lds	r24, 0x0E9A
     dce:	81 11       	cpse	r24, r1
     dd0:	08 c0       	rjmp	.+16     	; 0xde2 <limit_check+0x110>
     dd2:	80 91 83 0a 	lds	r24, 0x0A83
     dd6:	81 11       	cpse	r24, r1
     dd8:	04 c0       	rjmp	.+8      	; 0xde2 <limit_check+0x110>
			transmit_packet( 0, VCP_ACK, SHUNT_MODE);
     dda:	44 e6       	ldi	r20, 0x64	; 100
     ddc:	62 e0       	ldi	r22, 0x02	; 2
     dde:	0e 94 88 10 	call	0x2110	; 0x2110 <transmit_packet>
		}
		else {}	
		been_to_shunt = 1;
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	80 93 83 0a 	sts	0x0A83, r24
		transmit_shunt = 1;	
     de8:	80 93 9a 0e 	sts	0x0E9A, r24
	}
	else {} // To avoid annoying compile warning 
}
     dec:	df 91       	pop	r29
     dee:	cf 91       	pop	r28
     df0:	1f 91       	pop	r17
     df2:	0f 91       	pop	r16
     df4:	ff 90       	pop	r15
     df6:	ef 90       	pop	r14
     df8:	df 90       	pop	r13
     dfa:	cf 90       	pop	r12
     dfc:	08 95       	ret

00000dfe <main>:


// MAIN
int main( void ) 
{  
  initialize();
     dfe:	0e 94 82 05 	call	0xb04	; 0xb04 <initialize>
  //fprintf( stdout, "uart initialized\n" );
	
  //Testing
  cntr = 0;
     e02:	10 92 58 0a 	sts	0x0A58, r1

  while(1)
  {
	cntr = 1 - cntr; //Testing
     e06:	11 e0       	ldi	r17, 0x01	; 1
	
    if ( timer0_counter[1] == 0 )
    {
        timer0_counter[1] = 199;
     e08:	c7 ec       	ldi	r28, 0xC7	; 199
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     e0a:	dc e2       	ldi	r29, 0x2C	; 44
  //Testing
  cntr = 0;

  while(1)
  {
	cntr = 1 - cntr; //Testing
     e0c:	80 91 58 0a 	lds	r24, 0x0A58
     e10:	91 2f       	mov	r25, r17
     e12:	98 1b       	sub	r25, r24
     e14:	90 93 58 0a 	sts	0x0A58, r25
	
    if ( timer0_counter[1] == 0 )
     e18:	80 91 8b 0c 	lds	r24, 0x0C8B
     e1c:	81 11       	cpse	r24, r1
     e1e:	07 c0       	rjmp	.+14     	; 0xe2e <main+0x30>
    {
        timer0_counter[1] = 199;
     e20:	c0 93 8b 0c 	sts	0x0C8B, r28
        transmit_packet( 1, VCP_POWER_TELEMETRY, 0);
     e24:	40 e0       	ldi	r20, 0x00	; 0
     e26:	60 e0       	ldi	r22, 0x00	; 0
     e28:	81 e0       	ldi	r24, 0x01	; 1
     e2a:	0e 94 88 10 	call	0x2110	; 0x2110 <transmit_packet>
    }
	  if ( timer0_counter[0] == 0 )
     e2e:	80 91 8a 0c 	lds	r24, 0x0C8A
     e32:	81 11       	cpse	r24, r1
     e34:	06 c0       	rjmp	.+12     	; 0xe42 <main+0x44>
    {
        timer0_counter[0] = 199;
     e36:	c0 93 8a 0c 	sts	0x0C8A, r28
        transmit_packet( 0, VCP_POWER_TELEMETRY, 0);
     e3a:	40 e0       	ldi	r20, 0x00	; 0
     e3c:	60 e0       	ldi	r22, 0x00	; 0
     e3e:	0e 94 88 10 	call	0x2110	; 0x2110 <transmit_packet>
    }
	  if ( rx_flag[0] > 0 )
     e42:	80 91 bb 0e 	lds	r24, 0x0EBB
     e46:	88 23       	and	r24, r24
     e48:	c9 f0       	breq	.+50     	; 0xe7c <main+0x7e>
    {
        rx_flag[0]--;
     e4a:	80 91 bb 0e 	lds	r24, 0x0EBB
     e4e:	81 50       	subi	r24, 0x01	; 1
     e50:	80 93 bb 0e 	sts	0x0EBB, r24
        receive_message( 0, uart_vcp_buff[0]->message, uart_vcp_buff[0]->index );
     e54:	e0 91 b6 0e 	lds	r30, 0x0EB6
     e58:	f0 91 b7 0e 	lds	r31, 0x0EB7
     e5c:	61 81       	ldd	r22, Z+1	; 0x01
     e5e:	72 81       	ldd	r23, Z+2	; 0x02
     e60:	47 81       	ldd	r20, Z+7	; 0x07
     e62:	80 e0       	ldi	r24, 0x00	; 0
     e64:	0e 94 c5 02 	call	0x58a	; 0x58a <receive_message>
        vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     e68:	4f ef       	ldi	r20, 0xFF	; 255
     e6a:	50 e0       	ldi	r21, 0x00	; 0
     e6c:	63 e9       	ldi	r22, 0x93	; 147
     e6e:	7c e0       	ldi	r23, 0x0C	; 12
     e70:	80 91 b6 0e 	lds	r24, 0x0EB6
     e74:	90 91 b7 0e 	lds	r25, 0x0EB7
     e78:	0e 94 11 0a 	call	0x1422	; 0x1422 <vcpptr_init>
    }
	  if ( rx_flag[1] > 0 )
     e7c:	80 91 bc 0e 	lds	r24, 0x0EBC
     e80:	88 23       	and	r24, r24
     e82:	c9 f0       	breq	.+50     	; 0xeb6 <main+0xb8>
    {
        rx_flag[1]--;
     e84:	80 91 bc 0e 	lds	r24, 0x0EBC
     e88:	81 50       	subi	r24, 0x01	; 1
     e8a:	80 93 bc 0e 	sts	0x0EBC, r24
        receive_message( 1, uart_vcp_buff[1]->message, uart_vcp_buff[1]->index );
     e8e:	e0 91 b8 0e 	lds	r30, 0x0EB8
     e92:	f0 91 b9 0e 	lds	r31, 0x0EB9
     e96:	61 81       	ldd	r22, Z+1	; 0x01
     e98:	72 81       	ldd	r23, Z+2	; 0x02
     e9a:	47 81       	ldd	r20, Z+7	; 0x07
     e9c:	81 e0       	ldi	r24, 0x01	; 1
     e9e:	0e 94 c5 02 	call	0x58a	; 0x58a <receive_message>
        vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     ea2:	4f ef       	ldi	r20, 0xFF	; 255
     ea4:	50 e0       	ldi	r21, 0x00	; 0
     ea6:	62 e9       	ldi	r22, 0x92	; 146
     ea8:	7d e0       	ldi	r23, 0x0D	; 13
     eaa:	80 91 b8 0e 	lds	r24, 0x0EB8
     eae:	90 91 b9 0e 	lds	r25, 0x0EB9
     eb2:	0e 94 11 0a 	call	0x1422	; 0x1422 <vcpptr_init>
    }
    if (adc_flag == 1)
     eb6:	80 91 59 0a 	lds	r24, 0x0A59
     eba:	81 30       	cpi	r24, 0x01	; 1
     ebc:	91 f4       	brne	.+36     	; 0xee2 <main+0xe4>
    {
        adc_flag = 0;
     ebe:	10 92 59 0a 	sts	0x0A59, r1
        read_VIT();
     ec2:	0e 94 cb 08 	call	0x1196	; 0x1196 <read_VIT>
		//calcSOC();
		StateofCharge();
     ec6:	0e 94 6e 03 	call	0x6dc	; 0x6dc <StateofCharge>

		/*
		Manual Override on Limit Checking: The power board must be able to receive a 
		command to disable and/or change the limits in the limit checking code
		*/
		if (!limit_check_overriden) {
     eca:	80 91 40 08 	lds	r24, 0x0840
     ece:	81 11       	cpse	r24, r1
     ed0:	02 c0       	rjmp	.+4      	; 0xed6 <main+0xd8>
			limit_check(); // First determine if voltage is within valid range, then switch
     ed2:	0e 94 69 06 	call	0xcd2	; 0xcd2 <limit_check>
		}

		if ( adc_component == 23 ) 
     ed6:	80 91 91 04 	lds	r24, 0x0491
     eda:	87 31       	cpi	r24, 0x17	; 23
     edc:	11 f4       	brne	.+4      	; 0xee2 <main+0xe4>
      	{ //23ish anything after battery values are calculated
  			  compareVoltage();
     ede:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <compareVoltage>
	   	}
    }	
	
	//Restart all board components if CDH-IB heartbeat timeout
	if (cdh_heartbeat_flag == 1){
     ee2:	80 91 7e 04 	lds	r24, 0x047E
     ee6:	81 30       	cpi	r24, 0x01	; 1
     ee8:	09 f0       	breq	.+2      	; 0xeec <main+0xee>
     eea:	90 cf       	rjmp	.-224    	; 0xe0c <main+0xe>
		//Restart all components
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
     eec:	10 92 7e 04 	sts	0x047E, r1
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     ef0:	d0 93 af 0e 	sts	0x0EAF, r29
     ef4:	8b cf       	rjmp	.-234    	; 0xe0c <main+0xe>

00000ef6 <torquer_off.part.0>:
void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
  {
    case TORQUER_1:
      CLR( PORTC, 0 );
     ef6:	a8 98       	cbi	0x15, 0	; 21
	  CLR( PORTG, 1 );
     ef8:	e5 e6       	ldi	r30, 0x65	; 101
     efa:	f0 e0       	ldi	r31, 0x00	; 0
     efc:	80 81       	ld	r24, Z
     efe:	8d 7f       	andi	r24, 0xFD	; 253
     f00:	80 83       	st	Z, r24
     f02:	08 95       	ret

00000f04 <set_mux_sel>:
#include "mcupwr-Defs.h"


void set_mux_sel( uint8_t mux_num, uint8_t mux_sel )
{
  switch( mux_num )
     f04:	81 30       	cpi	r24, 0x01	; 1
     f06:	f9 f0       	breq	.+62     	; 0xf46 <set_mux_sel+0x42>
     f08:	20 f0       	brcs	.+8      	; 0xf12 <set_mux_sel+0xe>
     f0a:	82 30       	cpi	r24, 0x02	; 2
     f0c:	09 f0       	breq	.+2      	; 0xf10 <set_mux_sel+0xc>
     f0e:	4e c0       	rjmp	.+156    	; 0xfac <set_mux_sel+0xa8>
     f10:	34 c0       	rjmp	.+104    	; 0xf7a <set_mux_sel+0x76>
  {
    case MUX0:
      READ( mux_sel, 4 ) ? SET( PORTA, 7 ) : CLR( PORTA, 7 );
     f12:	64 ff       	sbrs	r22, 4
     f14:	02 c0       	rjmp	.+4      	; 0xf1a <set_mux_sel+0x16>
     f16:	df 9a       	sbi	0x1b, 7	; 27
     f18:	01 c0       	rjmp	.+2      	; 0xf1c <set_mux_sel+0x18>
     f1a:	df 98       	cbi	0x1b, 7	; 27
      READ( mux_sel, 3 ) ? SET( PORTA, 6 ) : CLR( PORTA, 6 );
     f1c:	63 ff       	sbrs	r22, 3
     f1e:	02 c0       	rjmp	.+4      	; 0xf24 <set_mux_sel+0x20>
     f20:	de 9a       	sbi	0x1b, 6	; 27
     f22:	01 c0       	rjmp	.+2      	; 0xf26 <set_mux_sel+0x22>
     f24:	de 98       	cbi	0x1b, 6	; 27
      READ( mux_sel, 2 ) ? SET( PORTA, 5 ) : CLR( PORTA, 5 );
     f26:	62 ff       	sbrs	r22, 2
     f28:	02 c0       	rjmp	.+4      	; 0xf2e <set_mux_sel+0x2a>
     f2a:	dd 9a       	sbi	0x1b, 5	; 27
     f2c:	01 c0       	rjmp	.+2      	; 0xf30 <set_mux_sel+0x2c>
     f2e:	dd 98       	cbi	0x1b, 5	; 27
      READ( mux_sel, 1 ) ? SET( PORTA, 4 ) : CLR( PORTA, 4 );
     f30:	61 ff       	sbrs	r22, 1
     f32:	02 c0       	rjmp	.+4      	; 0xf38 <set_mux_sel+0x34>
     f34:	dc 9a       	sbi	0x1b, 4	; 27
     f36:	01 c0       	rjmp	.+2      	; 0xf3a <set_mux_sel+0x36>
     f38:	dc 98       	cbi	0x1b, 4	; 27
      READ( mux_sel, 0 ) ? SET( PORTA, 3 ) : CLR( PORTA, 3 );
     f3a:	60 ff       	sbrs	r22, 0
     f3c:	02 c0       	rjmp	.+4      	; 0xf42 <set_mux_sel+0x3e>
     f3e:	db 9a       	sbi	0x1b, 3	; 27
     f40:	08 95       	ret
     f42:	db 98       	cbi	0x1b, 3	; 27
     f44:	08 95       	ret

      break;

    case MUX1:
      READ( mux_sel, 4 ) ? SET( PORTB, 0 ) : CLR( PORTB, 0 );
     f46:	64 ff       	sbrs	r22, 4
     f48:	02 c0       	rjmp	.+4      	; 0xf4e <set_mux_sel+0x4a>
     f4a:	c0 9a       	sbi	0x18, 0	; 24
     f4c:	01 c0       	rjmp	.+2      	; 0xf50 <set_mux_sel+0x4c>
     f4e:	c0 98       	cbi	0x18, 0	; 24
      READ( mux_sel, 3 ) ? SET( PORTB, 1 ) : CLR( PORTB, 1 );
     f50:	63 ff       	sbrs	r22, 3
     f52:	02 c0       	rjmp	.+4      	; 0xf58 <set_mux_sel+0x54>
     f54:	c1 9a       	sbi	0x18, 1	; 24
     f56:	01 c0       	rjmp	.+2      	; 0xf5a <set_mux_sel+0x56>
     f58:	c1 98       	cbi	0x18, 1	; 24
      READ( mux_sel, 2 ) ? SET( PORTB, 2 ) : CLR( PORTB, 2 );
     f5a:	62 ff       	sbrs	r22, 2
     f5c:	02 c0       	rjmp	.+4      	; 0xf62 <set_mux_sel+0x5e>
     f5e:	c2 9a       	sbi	0x18, 2	; 24
     f60:	01 c0       	rjmp	.+2      	; 0xf64 <set_mux_sel+0x60>
     f62:	c2 98       	cbi	0x18, 2	; 24
      READ( mux_sel, 1 ) ? SET( PORTB, 3 ) : CLR( PORTB, 3 );
     f64:	61 ff       	sbrs	r22, 1
     f66:	02 c0       	rjmp	.+4      	; 0xf6c <set_mux_sel+0x68>
     f68:	c3 9a       	sbi	0x18, 3	; 24
     f6a:	01 c0       	rjmp	.+2      	; 0xf6e <set_mux_sel+0x6a>
     f6c:	c3 98       	cbi	0x18, 3	; 24
      READ( mux_sel, 0 ) ? SET( PORTB, 4 ) : CLR( PORTB, 4 );
     f6e:	60 ff       	sbrs	r22, 0
     f70:	02 c0       	rjmp	.+4      	; 0xf76 <set_mux_sel+0x72>
     f72:	c4 9a       	sbi	0x18, 4	; 24
     f74:	08 95       	ret
     f76:	c4 98       	cbi	0x18, 4	; 24
     f78:	08 95       	ret

      break;

    case MUX2:
      READ( mux_sel, 4 ) ? SET( PORTE, 3 ) : CLR( PORTE, 3 );
     f7a:	64 ff       	sbrs	r22, 4
     f7c:	02 c0       	rjmp	.+4      	; 0xf82 <set_mux_sel+0x7e>
     f7e:	1b 9a       	sbi	0x03, 3	; 3
     f80:	01 c0       	rjmp	.+2      	; 0xf84 <set_mux_sel+0x80>
     f82:	1b 98       	cbi	0x03, 3	; 3
      READ( mux_sel, 3 ) ? SET( PORTE, 4 ) : CLR( PORTE, 4 );
     f84:	63 ff       	sbrs	r22, 3
     f86:	02 c0       	rjmp	.+4      	; 0xf8c <set_mux_sel+0x88>
     f88:	1c 9a       	sbi	0x03, 4	; 3
     f8a:	01 c0       	rjmp	.+2      	; 0xf8e <set_mux_sel+0x8a>
     f8c:	1c 98       	cbi	0x03, 4	; 3
      READ( mux_sel, 2 ) ? SET( PORTE, 5 ) : CLR( PORTE, 5 );
     f8e:	62 ff       	sbrs	r22, 2
     f90:	02 c0       	rjmp	.+4      	; 0xf96 <set_mux_sel+0x92>
     f92:	1d 9a       	sbi	0x03, 5	; 3
     f94:	01 c0       	rjmp	.+2      	; 0xf98 <set_mux_sel+0x94>
     f96:	1d 98       	cbi	0x03, 5	; 3
      READ( mux_sel, 1 ) ? SET( PORTE, 6 ) : CLR( PORTE, 6 );
     f98:	61 ff       	sbrs	r22, 1
     f9a:	02 c0       	rjmp	.+4      	; 0xfa0 <set_mux_sel+0x9c>
     f9c:	1e 9a       	sbi	0x03, 6	; 3
     f9e:	01 c0       	rjmp	.+2      	; 0xfa2 <set_mux_sel+0x9e>
     fa0:	1e 98       	cbi	0x03, 6	; 3
      READ( mux_sel, 0 ) ? SET( PORTE, 7 ) : CLR( PORTE, 7 );
     fa2:	60 ff       	sbrs	r22, 0
     fa4:	02 c0       	rjmp	.+4      	; 0xfaa <set_mux_sel+0xa6>
     fa6:	1f 9a       	sbi	0x03, 7	; 3
     fa8:	08 95       	ret
     faa:	1f 98       	cbi	0x03, 7	; 3
     fac:	08 95       	ret

00000fae <torquer_off>:
  }
}

void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
     fae:	82 31       	cpi	r24, 0x12	; 18
     fb0:	31 f0       	breq	.+12     	; 0xfbe <torquer_off+0x10>
     fb2:	83 31       	cpi	r24, 0x13	; 19
     fb4:	59 f0       	breq	.+22     	; 0xfcc <torquer_off+0x1e>
     fb6:	81 31       	cpi	r24, 0x11	; 17
     fb8:	99 f4       	brne	.+38     	; 0xfe0 <torquer_off+0x32>
     fba:	0c 94 7b 07 	jmp	0xef6	; 0xef6 <torquer_off.part.0>
      CLR( PORTC, 0 );
	  CLR( PORTG, 1 );
      break;

    case TORQUER_2:
      CLR( PORTG, 0 );
     fbe:	80 91 65 00 	lds	r24, 0x0065
     fc2:	8e 7f       	andi	r24, 0xFE	; 254
     fc4:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTD, 0 );
     fc8:	90 98       	cbi	0x12, 0	; 18
      break;
     fca:	08 95       	ret

    case TORQUER_3:
      CLR( PORTG, 3 );
     fcc:	80 91 65 00 	lds	r24, 0x0065
     fd0:	87 7f       	andi	r24, 0xF7	; 247
     fd2:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTG, 4 );
     fd6:	80 91 65 00 	lds	r24, 0x0065
     fda:	8f 7e       	andi	r24, 0xEF	; 239
     fdc:	80 93 65 00 	sts	0x0065, r24
     fe0:	08 95       	ret

00000fe2 <torquer_on>:
  }  
}

void torquer_on( uint8_t torquer_num )
{
  switch( torquer_num )
     fe2:	82 31       	cpi	r24, 0x12	; 18
     fe4:	49 f0       	breq	.+18     	; 0xff8 <torquer_on+0x16>
     fe6:	83 31       	cpi	r24, 0x13	; 19
     fe8:	71 f0       	breq	.+28     	; 0x1006 <torquer_on+0x24>
     fea:	81 31       	cpi	r24, 0x11	; 17
     fec:	b1 f4       	brne	.+44     	; 0x101a <torquer_on+0x38>
  {
    case TORQUER_1:
      SET( PORTC, 0 );
     fee:	a8 9a       	sbi	0x15, 0	; 21
	  SET( PORTG, 1 );
     ff0:	80 91 65 00 	lds	r24, 0x0065
     ff4:	82 60       	ori	r24, 0x02	; 2
     ff6:	0f c0       	rjmp	.+30     	; 0x1016 <torquer_on+0x34>
      break;

    case TORQUER_2:
      SET( PORTG, 0 );
     ff8:	80 91 65 00 	lds	r24, 0x0065
     ffc:	81 60       	ori	r24, 0x01	; 1
     ffe:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTD, 0 );
    1002:	90 9a       	sbi	0x12, 0	; 18
      break;
    1004:	08 95       	ret

    case TORQUER_3:
      SET( PORTG, 3 );
    1006:	80 91 65 00 	lds	r24, 0x0065
    100a:	88 60       	ori	r24, 0x08	; 8
    100c:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTG, 4 );
    1010:	80 91 65 00 	lds	r24, 0x0065
    1014:	80 61       	ori	r24, 0x10	; 16
    1016:	80 93 65 00 	sts	0x0065, r24
    101a:	08 95       	ret

0000101c <switch_on>:
  }
}

void switch_on( uint8_t switch_num )
{
  switch ( switch_num )
    101c:	88 30       	cpi	r24, 0x08	; 8
    101e:	59 f1       	breq	.+86     	; 0x1076 <switch_on+0x5a>
    1020:	68 f4       	brcc	.+26     	; 0x103c <switch_on+0x20>
    1022:	84 30       	cpi	r24, 0x04	; 4
    1024:	01 f1       	breq	.+64     	; 0x1066 <switch_on+0x4a>
    1026:	30 f4       	brcc	.+12     	; 0x1034 <switch_on+0x18>
    1028:	82 30       	cpi	r24, 0x02	; 2
    102a:	c9 f0       	breq	.+50     	; 0x105e <switch_on+0x42>
    102c:	d0 f4       	brcc	.+52     	; 0x1062 <switch_on+0x46>
    102e:	81 30       	cpi	r24, 0x01	; 1
    1030:	b9 f5       	brne	.+110    	; 0x10a0 <switch_on+0x84>
    1032:	13 c0       	rjmp	.+38     	; 0x105a <switch_on+0x3e>
    1034:	86 30       	cpi	r24, 0x06	; 6
    1036:	d9 f0       	breq	.+54     	; 0x106e <switch_on+0x52>
    1038:	e0 f4       	brcc	.+56     	; 0x1072 <switch_on+0x56>
    103a:	17 c0       	rjmp	.+46     	; 0x106a <switch_on+0x4e>
    103c:	8c 30       	cpi	r24, 0x0C	; 12
    103e:	39 f1       	breq	.+78     	; 0x108e <switch_on+0x72>
    1040:	20 f4       	brcc	.+8      	; 0x104a <switch_on+0x2e>
    1042:	8a 30       	cpi	r24, 0x0A	; 10
    1044:	01 f1       	breq	.+64     	; 0x1086 <switch_on+0x6a>
    1046:	08 f5       	brcc	.+66     	; 0x108a <switch_on+0x6e>
    1048:	18 c0       	rjmp	.+48     	; 0x107a <switch_on+0x5e>
    104a:	8e 30       	cpi	r24, 0x0E	; 14
    104c:	21 f1       	breq	.+72     	; 0x1096 <switch_on+0x7a>
    104e:	08 f1       	brcs	.+66     	; 0x1092 <switch_on+0x76>
    1050:	8f 30       	cpi	r24, 0x0F	; 15
    1052:	19 f1       	breq	.+70     	; 0x109a <switch_on+0x7e>
    1054:	80 31       	cpi	r24, 0x10	; 16
    1056:	21 f5       	brne	.+72     	; 0x10a0 <switch_on+0x84>
    1058:	22 c0       	rjmp	.+68     	; 0x109e <switch_on+0x82>
  {
    case 1:
      SET( PORTA, 0 );
    105a:	d8 9a       	sbi	0x1b, 0	; 27
      break;
    105c:	08 95       	ret

    case 2:
      SET( PORTA, 1 );
    105e:	d9 9a       	sbi	0x1b, 1	; 27
      break;
    1060:	08 95       	ret

    case 3:
      SET( PORTA, 2 );
    1062:	da 9a       	sbi	0x1b, 2	; 27
      break;
    1064:	08 95       	ret

    case 4:
      SET( PORTB, 5 );
    1066:	c5 9a       	sbi	0x18, 5	; 24
      break;
    1068:	08 95       	ret

    case 5:
      SET( PORTB, 6 );
    106a:	c6 9a       	sbi	0x18, 6	; 24
      break;
    106c:	08 95       	ret

    case 6:
      SET( PORTB, 7 );
    106e:	c7 9a       	sbi	0x18, 7	; 24
      break;
    1070:	08 95       	ret

    case 7:
      SET( PORTD, 4 );
    1072:	94 9a       	sbi	0x12, 4	; 18
      break;
    1074:	08 95       	ret

    case 8:
      SET( PORTD, 5 );
    1076:	95 9a       	sbi	0x12, 5	; 18
      break;
    1078:	08 95       	ret

    case 9:
      SET( PORTG, 2 );
    107a:	80 91 65 00 	lds	r24, 0x0065
    107e:	84 60       	ori	r24, 0x04	; 4
    1080:	80 93 65 00 	sts	0x0065, r24
      break;
    1084:	08 95       	ret

    case 10: 
      SET( PORTC, 7 );
    1086:	af 9a       	sbi	0x15, 7	; 21
      break;
    1088:	08 95       	ret

    case 11:
      SET( PORTC, 6 );
    108a:	ae 9a       	sbi	0x15, 6	; 21
      break;
    108c:	08 95       	ret

    case 12:
      SET( PORTC, 5 );
    108e:	ad 9a       	sbi	0x15, 5	; 21
      break;
    1090:	08 95       	ret

    case 13:
      SET( PORTC, 4 );
    1092:	ac 9a       	sbi	0x15, 4	; 21
      break;
    1094:	08 95       	ret

    case 14:
      SET( PORTC, 3 );
    1096:	ab 9a       	sbi	0x15, 3	; 21
      break;
    1098:	08 95       	ret

    case 15:
      SET( PORTC, 2 );
    109a:	aa 9a       	sbi	0x15, 2	; 21
      break;
    109c:	08 95       	ret

    case 16:
      SET( PORTC, 1 );
    109e:	a9 9a       	sbi	0x15, 1	; 21
    10a0:	08 95       	ret

000010a2 <switch_off>:
  }
}

void switch_off( uint8_t switch_num )
{
  switch ( switch_num )
    10a2:	88 30       	cpi	r24, 0x08	; 8
    10a4:	59 f1       	breq	.+86     	; 0x10fc <switch_off+0x5a>
    10a6:	68 f4       	brcc	.+26     	; 0x10c2 <switch_off+0x20>
    10a8:	84 30       	cpi	r24, 0x04	; 4
    10aa:	01 f1       	breq	.+64     	; 0x10ec <switch_off+0x4a>
    10ac:	30 f4       	brcc	.+12     	; 0x10ba <switch_off+0x18>
    10ae:	82 30       	cpi	r24, 0x02	; 2
    10b0:	c9 f0       	breq	.+50     	; 0x10e4 <switch_off+0x42>
    10b2:	d0 f4       	brcc	.+52     	; 0x10e8 <switch_off+0x46>
    10b4:	81 30       	cpi	r24, 0x01	; 1
    10b6:	b9 f5       	brne	.+110    	; 0x1126 <__stack+0x27>
    10b8:	13 c0       	rjmp	.+38     	; 0x10e0 <switch_off+0x3e>
    10ba:	86 30       	cpi	r24, 0x06	; 6
    10bc:	d9 f0       	breq	.+54     	; 0x10f4 <switch_off+0x52>
    10be:	e0 f4       	brcc	.+56     	; 0x10f8 <switch_off+0x56>
    10c0:	17 c0       	rjmp	.+46     	; 0x10f0 <switch_off+0x4e>
    10c2:	8c 30       	cpi	r24, 0x0C	; 12
    10c4:	39 f1       	breq	.+78     	; 0x1114 <__stack+0x15>
    10c6:	20 f4       	brcc	.+8      	; 0x10d0 <switch_off+0x2e>
    10c8:	8a 30       	cpi	r24, 0x0A	; 10
    10ca:	01 f1       	breq	.+64     	; 0x110c <__stack+0xd>
    10cc:	08 f5       	brcc	.+66     	; 0x1110 <__stack+0x11>
    10ce:	18 c0       	rjmp	.+48     	; 0x1100 <__stack+0x1>
    10d0:	8e 30       	cpi	r24, 0x0E	; 14
    10d2:	21 f1       	breq	.+72     	; 0x111c <__stack+0x1d>
    10d4:	08 f1       	brcs	.+66     	; 0x1118 <__stack+0x19>
    10d6:	8f 30       	cpi	r24, 0x0F	; 15
    10d8:	19 f1       	breq	.+70     	; 0x1120 <__stack+0x21>
    10da:	80 31       	cpi	r24, 0x10	; 16
    10dc:	21 f5       	brne	.+72     	; 0x1126 <__stack+0x27>
    10de:	22 c0       	rjmp	.+68     	; 0x1124 <__stack+0x25>
  {
    case 1:
      CLR( PORTA, 0 );
    10e0:	d8 98       	cbi	0x1b, 0	; 27
      break;
    10e2:	08 95       	ret

    case 2:
      CLR( PORTA, 1 );
    10e4:	d9 98       	cbi	0x1b, 1	; 27
      break;
    10e6:	08 95       	ret

    case 3:
      CLR( PORTA, 2 );
    10e8:	da 98       	cbi	0x1b, 2	; 27
      break;
    10ea:	08 95       	ret

    case 4:
      CLR( PORTB, 5 );
    10ec:	c5 98       	cbi	0x18, 5	; 24
      break;
    10ee:	08 95       	ret

    case 5:
      CLR( PORTB, 6 );
    10f0:	c6 98       	cbi	0x18, 6	; 24
      break;
    10f2:	08 95       	ret

    case 6:
      CLR( PORTB, 7 );
    10f4:	c7 98       	cbi	0x18, 7	; 24
      break;
    10f6:	08 95       	ret

    case 7:
      CLR( PORTD, 4 );
    10f8:	94 98       	cbi	0x12, 4	; 18
      break;
    10fa:	08 95       	ret

    case 8:
      CLR( PORTD, 5 );
    10fc:	95 98       	cbi	0x12, 5	; 18
      break;
    10fe:	08 95       	ret

    case 9:
      CLR( PORTG, 2 );
    1100:	80 91 65 00 	lds	r24, 0x0065
    1104:	8b 7f       	andi	r24, 0xFB	; 251
    1106:	80 93 65 00 	sts	0x0065, r24
      break;
    110a:	08 95       	ret

    case 10: 
      CLR( PORTC, 7 );
    110c:	af 98       	cbi	0x15, 7	; 21
      break;
    110e:	08 95       	ret

    case 11:
      CLR( PORTC, 6 );
    1110:	ae 98       	cbi	0x15, 6	; 21
      break;
    1112:	08 95       	ret

    case 12:
      CLR( PORTC, 5 );
    1114:	ad 98       	cbi	0x15, 5	; 21
      break;
    1116:	08 95       	ret

    case 13:
      CLR( PORTC, 4 );
    1118:	ac 98       	cbi	0x15, 4	; 21
      break;
    111a:	08 95       	ret

    case 14:
      CLR( PORTC, 3 );
    111c:	ab 98       	cbi	0x15, 3	; 21
      break;
    111e:	08 95       	ret

    case 15:
      CLR( PORTC, 2 );
    1120:	aa 98       	cbi	0x15, 2	; 21
      break;
    1122:	08 95       	ret

    case 16:
      CLR( PORTC, 1 );
    1124:	a9 98       	cbi	0x15, 1	; 21
    1126:	08 95       	ret

00001128 <average_samples>:
    return  average_samples( component->I_samples );
  }
}

uint8_t average_samples( uint8_t samples[NUM_SAMPLES] )
{
    1128:	fc 01       	movw	r30, r24
  uint8_t average = 0;
  uint16_t sum = 0;

  for(uint8_t avg_index = 0; avg_index < NUM_SAMPLES; avg_index++)
    sum += samples[avg_index];
    112a:	21 81       	ldd	r18, Z+1	; 0x01
    112c:	80 81       	ld	r24, Z
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	82 0f       	add	r24, r18
    1132:	91 1d       	adc	r25, r1
    1134:	22 81       	ldd	r18, Z+2	; 0x02
    1136:	82 0f       	add	r24, r18
    1138:	91 1d       	adc	r25, r1

  average = sum / NUM_SAMPLES;
    113a:	63 e0       	ldi	r22, 0x03	; 3
    113c:	70 e0       	ldi	r23, 0x00	; 0
    113e:	0e 94 bc 12 	call	0x2578	; 0x2578 <__udivmodhi4>
    1142:	86 2f       	mov	r24, r22

  return average;
}
    1144:	08 95       	ret

00001146 <SVIT_check_I_critical>:
}

uint8_t SVIT_check_I_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1146:	9a e1       	ldi	r25, 0x1A	; 26
    1148:	89 9f       	mul	r24, r25
    114a:	f0 01       	movw	r30, r0
    114c:	11 24       	eor	r1, r1
    114e:	ee 56       	subi	r30, 0x6E	; 110
    1150:	fb 4f       	sbci	r31, 0xFB	; 251
  if ( component->I_critical_value != 0 )
    1152:	83 89       	ldd	r24, Z+19	; 0x13
    1154:	88 23       	and	r24, r24
    1156:	11 f0       	breq	.+4      	; 0x115c <SVIT_check_I_critical+0x16>
  {
    temp= component->I_critical_value;
    component->I_critical_value = 0;
    1158:	13 8a       	std	Z+19, r1	; 0x13
    115a:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->I_samples );
    115c:	cf 01       	movw	r24, r30
    115e:	0f 96       	adiw	r24, 0x0f	; 15
    1160:	0c 94 94 08 	jmp	0x1128	; 0x1128 <average_samples>

00001164 <SVIT_check_V_critical>:
}

uint8_t SVIT_check_V_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1164:	9a e1       	ldi	r25, 0x1A	; 26
    1166:	89 9f       	mul	r24, r25
    1168:	f0 01       	movw	r30, r0
    116a:	11 24       	eor	r1, r1
    116c:	ee 56       	subi	r30, 0x6E	; 110
    116e:	fb 4f       	sbci	r31, 0xFB	; 251
  if ( component->V_critical_value != 0 )
    1170:	83 85       	ldd	r24, Z+11	; 0x0b
    1172:	88 23       	and	r24, r24
    1174:	11 f0       	breq	.+4      	; 0x117a <SVIT_check_V_critical+0x16>
  {
    temp= component->V_critical_value;
    component->V_critical_value = 0;
    1176:	13 86       	std	Z+11, r1	; 0x0b
    1178:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->V_samples );
    117a:	cf 01       	movw	r24, r30
    117c:	07 96       	adiw	r24, 0x07	; 7
    117e:	0c 94 94 08 	jmp	0x1128	; 0x1128 <average_samples>

00001182 <perform_ADC>:
}

void perform_ADC( uint8_t mux_num )
{
  // set Vref to AVCC and set the ADC channel to the correct pin ( mux_num )
  ADMUX = (1 << ADLAR) | ( 1 << REFS0 );
    1182:	90 e6       	ldi	r25, 0x60	; 96
    1184:	97 b9       	out	0x07, r25	; 7
  ADMUX &= ~0x3;
    1186:	97 b1       	in	r25, 0x07	; 7
    1188:	9c 7f       	andi	r25, 0xFC	; 252
    118a:	97 b9       	out	0x07, r25	; 7
  ADMUX |= mux_num;
    118c:	97 b1       	in	r25, 0x07	; 7
    118e:	98 2b       	or	r25, r24
    1190:	97 b9       	out	0x07, r25	; 7

  // signal ADC to start a new conversion
  ADCSRA |= ( 1 << ADSC );
    1192:	36 9a       	sbi	0x06, 6	; 6
    1194:	08 95       	ret

00001196 <read_VIT>:

  // when the conversion finishes, the result is stored in ADCL and ADCH
}

void read_VIT( void )
{
    1196:	1f 93       	push	r17
    1198:	cf 93       	push	r28
    119a:	df 93       	push	r29
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type )
    119c:	80 91 66 0a 	lds	r24, 0x0A66
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    11a0:	c0 91 91 04 	lds	r28, 0x0491
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type )
    11a4:	82 30       	cpi	r24, 0x02	; 2
    11a6:	09 f4       	brne	.+2      	; 0x11aa <read_VIT+0x14>
    11a8:	61 c0       	rjmp	.+194    	; 0x126c <read_VIT+0xd6>
    11aa:	20 f4       	brcc	.+8      	; 0x11b4 <read_VIT+0x1e>
    11ac:	81 30       	cpi	r24, 0x01	; 1
    11ae:	09 f0       	breq	.+2      	; 0x11b2 <read_VIT+0x1c>
    11b0:	f8 c0       	rjmp	.+496    	; 0x13a2 <read_VIT+0x20c>
    11b2:	07 c0       	rjmp	.+14     	; 0x11c2 <read_VIT+0x2c>
    11b4:	83 30       	cpi	r24, 0x03	; 3
    11b6:	09 f4       	brne	.+2      	; 0x11ba <read_VIT+0x24>
    11b8:	b8 c0       	rjmp	.+368    	; 0x132a <read_VIT+0x194>
    11ba:	84 30       	cpi	r24, 0x04	; 4
    11bc:	09 f0       	breq	.+2      	; 0x11c0 <read_VIT+0x2a>
    11be:	f1 c0       	rjmp	.+482    	; 0x13a2 <read_VIT+0x20c>
    11c0:	dc c0       	rjmp	.+440    	; 0x137a <read_VIT+0x1e4>
  {
		case ADC_VOLTAGE:
			component = &svit[adc_component];
    11c2:	8a e1       	ldi	r24, 0x1A	; 26
    11c4:	c8 9f       	mul	r28, r24
    11c6:	e0 01       	movw	r28, r0
    11c8:	11 24       	eor	r1, r1
    11ca:	ce 56       	subi	r28, 0x6E	; 110
    11cc:	db 4f       	sbci	r29, 0xFB	; 251
			sample_index = component->V_sample_index;
			component->V_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    11ce:	2a 85       	ldd	r18, Y+10	; 0x0a
    11d0:	30 e0       	ldi	r19, 0x00	; 0
    11d2:	c9 01       	movw	r24, r18
    11d4:	01 96       	adiw	r24, 0x01	; 1
    11d6:	63 e0       	ldi	r22, 0x03	; 3
    11d8:	70 e0       	ldi	r23, 0x00	; 0
    11da:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__divmodhi4>
    11de:	8a 87       	std	Y+10, r24	; 0x0a

			// SoC: If component is a battery, store in different global variable
			if (component->name == BATTERY_1) {
    11e0:	98 81       	ld	r25, Y
    11e2:	94 31       	cpi	r25, 0x14	; 20
    11e4:	89 f4       	brne	.+34     	; 0x1208 <read_VIT+0x72>
				batt1_voltage = ADC_high;
    11e6:	80 91 77 0a 	lds	r24, 0x0A77
    11ea:	80 93 81 0a 	sts	0x0A81, r24
				batt1_voltageLow = ADC_low;
    11ee:	80 91 b0 0e 	lds	r24, 0x0EB0
    11f2:	80 93 95 0e 	sts	0x0E95, r24
				high = ADC_high;
    11f6:	80 91 77 0a 	lds	r24, 0x0A77
    11fa:	80 93 72 0a 	sts	0x0A72, r24
				low = ADC_low;
    11fe:	80 91 b0 0e 	lds	r24, 0x0EB0
    1202:	80 93 80 0a 	sts	0x0A80, r24
    1206:	06 c0       	rjmp	.+12     	; 0x1214 <read_VIT+0x7e>
				//debug = adc_component;
			}
			else if (component->name == BATTERY_2) {
    1208:	95 31       	cpi	r25, 0x15	; 21
    120a:	21 f4       	brne	.+8      	; 0x1214 <read_VIT+0x7e>
				batt2_voltage = ADC_high;
    120c:	80 91 77 0a 	lds	r24, 0x0A77
    1210:	80 93 92 0c 	sts	0x0C92, r24
			}
			component->V_samples[sample_index] = ADC_high;
    1214:	80 91 77 0a 	lds	r24, 0x0A77
    1218:	fe 01       	movw	r30, r28
    121a:	e2 0f       	add	r30, r18
    121c:	f3 1f       	adc	r31, r19
    121e:	87 83       	std	Z+7, r24	; 0x07
      
	  	if ( ( ADC_high > component->V_upper_limit ) && ( component->force_on != 1 ) )
    1220:	20 91 77 0a 	lds	r18, 0x0A77
    1224:	8e 81       	ldd	r24, Y+6	; 0x06
    1226:	82 17       	cp	r24, r18
    1228:	d8 f4       	brcc	.+54     	; 0x1260 <read_VIT+0xca>
    122a:	8b 81       	ldd	r24, Y+3	; 0x03
    122c:	81 30       	cpi	r24, 0x01	; 1
    122e:	c1 f0       	breq	.+48     	; 0x1260 <read_VIT+0xca>
			{
				if ( component->switch_num != SW_NULL )
    1230:	89 81       	ldd	r24, Y+1	; 0x01
    1232:	8f 3f       	cpi	r24, 0xFF	; 255
    1234:	19 f0       	breq	.+6      	; 0x123c <read_VIT+0xa6>
				{
			  	switch_off( component->switch_num );
    1236:	0e 94 51 08 	call	0x10a2	; 0x10a2 <switch_off>
    123a:	0e c0       	rjmp	.+28     	; 0x1258 <read_VIT+0xc2>
				}
		  	else
				{
			  	switch ( component->name )
    123c:	92 31       	cpi	r25, 0x12	; 18
    123e:	39 f0       	breq	.+14     	; 0x124e <read_VIT+0xb8>
    1240:	93 31       	cpi	r25, 0x13	; 19
    1242:	39 f0       	breq	.+14     	; 0x1252 <read_VIT+0xbc>
    1244:	91 31       	cpi	r25, 0x11	; 17
    1246:	41 f4       	brne	.+16     	; 0x1258 <read_VIT+0xc2>
    1248:	0e 94 7b 07 	call	0xef6	; 0xef6 <torquer_off.part.0>
    124c:	05 c0       	rjmp	.+10     	; 0x1258 <read_VIT+0xc2>
			  	{
						case TORQUER_1:
				  		torquer_off( TORQUER_1 );
				  		break;
					  case TORQUER_2:
	  			  	torquer_off( TORQUER_2 );
    124e:	82 e1       	ldi	r24, 0x12	; 18
    1250:	01 c0       	rjmp	.+2      	; 0x1254 <read_VIT+0xbe>
		  		  	break;
			  		case TORQUER_3:
				    	torquer_off( TORQUER_3 );
    1252:	83 e1       	ldi	r24, 0x13	; 19
    1254:	0e 94 d7 07 	call	0xfae	; 0xfae <torquer_off>
				    	break;
					  default:
				  	  break;
			    }
  			}
        component->switch_state = SW_OFF;
    1258:	1a 82       	std	Y+2, r1	; 0x02
        component->V_critical_value = ADC_high;
    125a:	80 91 77 0a 	lds	r24, 0x0A77
    125e:	8b 87       	std	Y+11, r24	; 0x0b
		  }
		  adc_sensor_type = ADC_CURRENT;
    1260:	82 e0       	ldi	r24, 0x02	; 2
    1262:	80 93 66 0a 	sts	0x0A66, r24

      //perform next ADC conversion
      mux_num = component->I_mux_num;
    1266:	1c 85       	ldd	r17, Y+12	; 0x0c
      mux_sel = component->I_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    1268:	6d 85       	ldd	r22, Y+13	; 0x0d
    126a:	92 c0       	rjmp	.+292    	; 0x1390 <read_VIT+0x1fa>
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    126c:	9a e1       	ldi	r25, 0x1A	; 26
    126e:	c9 9f       	mul	r28, r25
    1270:	e0 01       	movw	r28, r0
    1272:	11 24       	eor	r1, r1
    1274:	ce 56       	subi	r28, 0x6E	; 110
    1276:	db 4f       	sbci	r29, 0xFB	; 251
	  	sample_index = component->I_sample_index;
	  	component->I_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    1278:	2a 89       	ldd	r18, Y+18	; 0x12
    127a:	30 e0       	ldi	r19, 0x00	; 0
    127c:	c9 01       	movw	r24, r18
    127e:	01 96       	adiw	r24, 0x01	; 1
    1280:	63 e0       	ldi	r22, 0x03	; 3
    1282:	70 e0       	ldi	r23, 0x00	; 0
    1284:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__divmodhi4>
    1288:	8a 8b       	std	Y+18, r24	; 0x12
		// SoC hardcode backward current
//		if (adc_component == BATTERY_1_b) {
			//debug = 5;
		//}
		
		if(component->name == SOLAR_1){
    128a:	98 81       	ld	r25, Y
    128c:	97 31       	cpi	r25, 0x17	; 23
    128e:	39 f4       	brne	.+14     	; 0x129e <read_VIT+0x108>
			solar1_current = ADC_high;
    1290:	80 91 77 0a 	lds	r24, 0x0A77
    1294:	80 93 82 0a 	sts	0x0A82, r24
			hasCheckedCurr = 1;
    1298:	81 e0       	ldi	r24, 0x01	; 1
    129a:	80 93 6b 0a 	sts	0x0A6B, r24
		}

	  	component->I_samples[sample_index] = ADC_high;
    129e:	80 91 77 0a 	lds	r24, 0x0A77
    12a2:	fe 01       	movw	r30, r28
    12a4:	e2 0f       	add	r30, r18
    12a6:	f3 1f       	adc	r31, r19
    12a8:	87 87       	std	Z+15, r24	; 0x0f
    
	    if ( ( ADC_high > component->I_upper_limit ) && ( component->force_on != 1 ) )
    12aa:	20 91 77 0a 	lds	r18, 0x0A77
    12ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    12b0:	82 17       	cp	r24, r18
    12b2:	d8 f4       	brcc	.+54     	; 0x12ea <read_VIT+0x154>
    12b4:	8b 81       	ldd	r24, Y+3	; 0x03
    12b6:	81 30       	cpi	r24, 0x01	; 1
    12b8:	c1 f0       	breq	.+48     	; 0x12ea <read_VIT+0x154>
	  	{
	  		if ( component->switch_num != SW_NULL )
    12ba:	89 81       	ldd	r24, Y+1	; 0x01
    12bc:	8f 3f       	cpi	r24, 0xFF	; 255
    12be:	19 f0       	breq	.+6      	; 0x12c6 <read_VIT+0x130>
	  		{
	  		  switch_off( component->switch_num );
    12c0:	0e 94 51 08 	call	0x10a2	; 0x10a2 <switch_off>
    12c4:	0e c0       	rjmp	.+28     	; 0x12e2 <read_VIT+0x14c>
	  		}
	  		else
	  		{
	  		  switch ( component->name )
    12c6:	92 31       	cpi	r25, 0x12	; 18
    12c8:	39 f0       	breq	.+14     	; 0x12d8 <read_VIT+0x142>
    12ca:	93 31       	cpi	r25, 0x13	; 19
    12cc:	39 f0       	breq	.+14     	; 0x12dc <read_VIT+0x146>
    12ce:	91 31       	cpi	r25, 0x11	; 17
    12d0:	41 f4       	brne	.+16     	; 0x12e2 <read_VIT+0x14c>
    12d2:	0e 94 7b 07 	call	0xef6	; 0xef6 <torquer_off.part.0>
    12d6:	05 c0       	rjmp	.+10     	; 0x12e2 <read_VIT+0x14c>
		  	  {
  		  		case TORQUER_1:
	  	  		  torquer_off( TORQUER_1 );
		    		  break;
			    	case TORQUER_2:
			  	    torquer_off( TORQUER_2 );
    12d8:	82 e1       	ldi	r24, 0x12	; 18
    12da:	01 c0       	rjmp	.+2      	; 0x12de <read_VIT+0x148>
			  	    break;
  		  		case TORQUER_3:
	  	  		  torquer_off( TORQUER_3 );
    12dc:	83 e1       	ldi	r24, 0x13	; 19
    12de:	0e 94 d7 07 	call	0xfae	; 0xfae <torquer_off>
		    		  break;
			     	default:
				      break;
			    }
			  }
			  component->switch_state = 0;
    12e2:	1a 82       	std	Y+2, r1	; 0x02
        component->I_critical_value = ADC_high;
    12e4:	80 91 77 0a 	lds	r24, 0x0A77
    12e8:	8b 8b       	std	Y+19, r24	; 0x13
		  }
      //perform next ADC conversion
      mux_num = component->T_mux_num;
    12ea:	1c 89       	ldd	r17, Y+20	; 0x14
      if( mux_num != MUX_NULL )
    12ec:	13 30       	cpi	r17, 0x03	; 3
    12ee:	29 f0       	breq	.+10     	; 0x12fa <read_VIT+0x164>
      {
		    adc_sensor_type = ADC_TEMPERATURE;
    12f0:	83 e0       	ldi	r24, 0x03	; 3
    12f2:	80 93 66 0a 	sts	0x0A66, r24
        mux_sel = component->T_mux_sel;        
    12f6:	6d 89       	ldd	r22, Y+21	; 0x15
    12f8:	4b c0       	rjmp	.+150    	; 0x1390 <read_VIT+0x1fa>
		  }
      else
      {
        adc_sensor_type = ADC_VOLTAGE;
    12fa:	81 e0       	ldi	r24, 0x01	; 1
    12fc:	80 93 66 0a 	sts	0x0A66, r24
		    adc_component = ( adc_component + 1 ) % SVIT_SZ;
    1300:	80 91 91 04 	lds	r24, 0x0491
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	01 96       	adiw	r24, 0x01	; 1
    1308:	64 e2       	ldi	r22, 0x24	; 36
    130a:	70 e0       	ldi	r23, 0x00	; 0
    130c:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__divmodhi4>
    1310:	80 93 91 04 	sts	0x0491, r24
        component = &svit[adc_component];
    1314:	2a e1       	ldi	r18, 0x1A	; 26
    1316:	28 9f       	mul	r18, r24
    1318:	f0 01       	movw	r30, r0
    131a:	29 9f       	mul	r18, r25
    131c:	f0 0d       	add	r31, r0
    131e:	11 24       	eor	r1, r1
    1320:	ee 56       	subi	r30, 0x6E	; 110
    1322:	fb 4f       	sbci	r31, 0xFB	; 251
        mux_num = component->V_mux_num;
    1324:	14 81       	ldd	r17, Z+4	; 0x04
        mux_sel = component->V_mux_sel;
    1326:	65 81       	ldd	r22, Z+5	; 0x05
    1328:	33 c0       	rjmp	.+102    	; 0x1390 <read_VIT+0x1fa>
      break;
    //-------------------------------------------------------------------
    // Measure temperature
    //-------------------------------------------------------------------
	  case ADC_TEMPERATURE:
		  component = &svit[adc_component];
    132a:	d0 e0       	ldi	r29, 0x00	; 0
    132c:	4a e1       	ldi	r20, 0x1A	; 26
    132e:	4c 9f       	mul	r20, r28
    1330:	f0 01       	movw	r30, r0
    1332:	4d 9f       	mul	r20, r29
    1334:	f0 0d       	add	r31, r0
    1336:	11 24       	eor	r1, r1
    1338:	ee 56       	subi	r30, 0x6E	; 110
    133a:	fb 4f       	sbci	r31, 0xFB	; 251
		  sample_index = component->T_sample_index;
		  component->T_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    133c:	21 8d       	ldd	r18, Z+25	; 0x19
    133e:	30 e0       	ldi	r19, 0x00	; 0
    1340:	c9 01       	movw	r24, r18
    1342:	01 96       	adiw	r24, 0x01	; 1
    1344:	63 e0       	ldi	r22, 0x03	; 3
    1346:	70 e0       	ldi	r23, 0x00	; 0
    1348:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__divmodhi4>
    134c:	81 8f       	std	Z+25, r24	; 0x19
		  component->T_samples[sample_index] = ADC_high;
    134e:	80 91 77 0a 	lds	r24, 0x0A77
    1352:	e2 0f       	add	r30, r18
    1354:	f3 1f       	adc	r31, r19
    1356:	86 8b       	std	Z+22, r24	; 0x16
      //perform next ADC conversion
  	  adc_sensor_type = ADC_VOLTAGE;
    1358:	81 e0       	ldi	r24, 0x01	; 1
    135a:	80 93 66 0a 	sts	0x0A66, r24
		  adc_component = ( adc_component + 1 ) % SVIT_SZ;
    135e:	ce 01       	movw	r24, r28
    1360:	01 96       	adiw	r24, 0x01	; 1
    1362:	64 e2       	ldi	r22, 0x24	; 36
    1364:	70 e0       	ldi	r23, 0x00	; 0
    1366:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__divmodhi4>
    136a:	80 93 91 04 	sts	0x0491, r24
      component = &svit[adc_component];
    136e:	48 9f       	mul	r20, r24
    1370:	f0 01       	movw	r30, r0
    1372:	49 9f       	mul	r20, r25
    1374:	f0 0d       	add	r31, r0
    1376:	11 24       	eor	r1, r1
    1378:	1d c0       	rjmp	.+58     	; 0x13b4 <read_VIT+0x21e>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
		  break;
    case ADC_INIT:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    137a:	81 e0       	ldi	r24, 0x01	; 1
    137c:	80 93 66 0a 	sts	0x0A66, r24
      component = &svit[adc_component];
    1380:	9a e1       	ldi	r25, 0x1A	; 26
    1382:	c9 9f       	mul	r28, r25
    1384:	e0 01       	movw	r28, r0
    1386:	11 24       	eor	r1, r1
    1388:	ce 56       	subi	r28, 0x6E	; 110
    138a:	db 4f       	sbci	r29, 0xFB	; 251
      mux_num = component->V_mux_num;
    138c:	1c 81       	ldd	r17, Y+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    138e:	6d 81       	ldd	r22, Y+5	; 0x05
    1390:	81 2f       	mov	r24, r17
    1392:	0e 94 82 07 	call	0xf04	; 0xf04 <set_mux_sel>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1396:	83 e3       	ldi	r24, 0x33	; 51
    1398:	93 e7       	ldi	r25, 0x73	; 115
    139a:	01 97       	sbiw	r24, 0x01	; 1
    139c:	f1 f7       	brne	.-4      	; 0x139a <read_VIT+0x204>
      //_delay_us(1);
	  //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
    139e:	81 2f       	mov	r24, r17
    13a0:	15 c0       	rjmp	.+42     	; 0x13cc <read_VIT+0x236>
      break;
	  default:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    13a2:	81 e0       	ldi	r24, 0x01	; 1
    13a4:	80 93 66 0a 	sts	0x0A66, r24
      component = &svit[adc_component];
    13a8:	e0 91 91 04 	lds	r30, 0x0491
    13ac:	9a e1       	ldi	r25, 0x1A	; 26
    13ae:	e9 9f       	mul	r30, r25
    13b0:	f0 01       	movw	r30, r0
    13b2:	11 24       	eor	r1, r1
    13b4:	ee 56       	subi	r30, 0x6E	; 110
    13b6:	fb 4f       	sbci	r31, 0xFB	; 251
      mux_num = component->V_mux_num;
    13b8:	c4 81       	ldd	r28, Z+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    13ba:	65 81       	ldd	r22, Z+5	; 0x05
    13bc:	8c 2f       	mov	r24, r28
    13be:	0e 94 82 07 	call	0xf04	; 0xf04 <set_mux_sel>
    13c2:	83 e3       	ldi	r24, 0x33	; 51
    13c4:	93 e7       	ldi	r25, 0x73	; 115
    13c6:	01 97       	sbiw	r24, 0x01	; 1
    13c8:	f1 f7       	brne	.-4      	; 0x13c6 <read_VIT+0x230>
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    13ca:	8c 2f       	mov	r24, r28
      break;
  } 
}
    13cc:	df 91       	pop	r29
    13ce:	cf 91       	pop	r28
    13d0:	1f 91       	pop	r17
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    13d2:	0c 94 c1 08 	jmp	0x1182	; 0x1182 <perform_ADC>

000013d6 <uart_init>:
{
  #if F_CPU < 2000000UL && defined(U2X)
  UCSR0A = UCSR1A = _BV(U2X); /* improve baud rate error by using 2x clk */
  UBRR0L = UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  #else
  UBRR0L = UBRR1L = 7;//(F_CPU / (16UL * UART_BAUD)) - 1;//7;
    13d6:	87 e0       	ldi	r24, 0x07	; 7
    13d8:	80 93 99 00 	sts	0x0099, r24
    13dc:	89 b9       	out	0x09, r24	; 9
  #endif
  UCSR0B = _BV(TXEN0) | _BV(RXEN0); /* tx/rx enable */
    13de:	88 e1       	ldi	r24, 0x18	; 24
    13e0:	8a b9       	out	0x0a, r24	; 10
  UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
    13e2:	ea e9       	ldi	r30, 0x9A	; 154
    13e4:	f0 e0       	ldi	r31, 0x00	; 0
    13e6:	80 83       	st	Z, r24


  UCSR1B = UCSR1B | _BV(TXCIE1);
    13e8:	80 81       	ld	r24, Z
    13ea:	80 64       	ori	r24, 0x40	; 64
    13ec:	80 83       	st	Z, r24
  UCSR1B = UCSR1B | _BV(RXCIE1);
    13ee:	80 81       	ld	r24, Z
    13f0:	80 68       	ori	r24, 0x80	; 128
    13f2:	80 83       	st	Z, r24
  UCSR0B = UCSR0B | _BV(TXCIE0);
    13f4:	56 9a       	sbi	0x0a, 6	; 10
  UCSR0B = UCSR0B | _BV(RXCIE0);
    13f6:	57 9a       	sbi	0x0a, 7	; 10
    13f8:	08 95       	ret

000013fa <append_crc16>:
 * Adds a byte of data into the crc calculation using
 * the table above.
 */
void append_crc16(uint8 byte, uint16ptr crc)
{
	*crc = ((*crc) >> 8) ^ ccitt_crc16[((*crc) ^ (byte)) & 0xff];
    13fa:	fb 01       	movw	r30, r22
    13fc:	20 81       	ld	r18, Z
    13fe:	31 81       	ldd	r19, Z+1	; 0x01
    1400:	f9 01       	movw	r30, r18
    1402:	e8 27       	eor	r30, r24
    1404:	ff 27       	eor	r31, r31
    1406:	ee 0f       	add	r30, r30
    1408:	ff 1f       	adc	r31, r31
    140a:	ea 5f       	subi	r30, 0xFA	; 250
    140c:	fe 4f       	sbci	r31, 0xFE	; 254
    140e:	23 2f       	mov	r18, r19
    1410:	33 27       	eor	r19, r19
    1412:	80 81       	ld	r24, Z
    1414:	91 81       	ldd	r25, Z+1	; 0x01
    1416:	82 27       	eor	r24, r18
    1418:	93 27       	eor	r25, r19
    141a:	fb 01       	movw	r30, r22
    141c:	91 83       	std	Z+1, r25	; 0x01
    141e:	80 83       	st	Z, r24
    1420:	08 95       	ret

00001422 <vcpptr_init>:
// Parameters: 
// vcp_ptrbuffer	*buff -					Pointer to the vcp buffer structure
// uint8			*message_buffer -		Pointer to the allocated data buffer
// uint16			message_buffer_size -	Size of the allocated data buffer
void vcpptr_init(vcp_ptrbuffer *buff, uint8 *message_buffer, uint16 message_buffer_size)
{
    1422:	fc 01       	movw	r30, r24
	buff->address =	0;
    1424:	10 82       	st	Z, r1
	buff->message =	message_buffer;
    1426:	72 83       	std	Z+2, r23	; 0x02
    1428:	61 83       	std	Z+1, r22	; 0x01
	buff->size =	message_buffer_size;
    142a:	56 83       	std	Z+6, r21	; 0x06
    142c:	45 83       	std	Z+5, r20	; 0x05
	buff->index	=	0;
    142e:	10 86       	std	Z+8, r1	; 0x08
    1430:	17 82       	std	Z+7, r1	; 0x07
	buff->crc =		CRC16_INIT_VALUE;
    1432:	14 82       	std	Z+4, r1	; 0x04
    1434:	13 82       	std	Z+3, r1	; 0x03
	buff->status =	VCP_IDLE;
    1436:	11 86       	std	Z+9, r1	; 0x09
    1438:	08 95       	ret

0000143a <Create_VCP_frame>:
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
    143a:	4f 92       	push	r4
    143c:	5f 92       	push	r5
    143e:	6f 92       	push	r6
    1440:	7f 92       	push	r7
    1442:	8f 92       	push	r8
    1444:	9f 92       	push	r9
    1446:	af 92       	push	r10
    1448:	bf 92       	push	r11
    144a:	cf 92       	push	r12
    144c:	df 92       	push	r13
    144e:	ef 92       	push	r14
    1450:	ff 92       	push	r15
    1452:	0f 93       	push	r16
    1454:	1f 93       	push	r17
    1456:	cf 93       	push	r28
    1458:	df 93       	push	r29
    145a:	00 d0       	rcall	.+0      	; 0x145c <Create_VCP_frame+0x22>
    145c:	1f 92       	push	r1
    145e:	cd b7       	in	r28, 0x3d	; 61
    1460:	de b7       	in	r29, 0x3e	; 62
    1462:	6c 01       	movw	r12, r24
    1464:	5b 01       	movw	r10, r22
    1466:	79 01       	movw	r14, r18
	uint16_t crc = CRC16_INIT_VALUE;
    1468:	1a 82       	std	Y+2, r1	; 0x02
    146a:	19 82       	std	Y+1, r1	; 0x01
	uint16_t src_index = 0;
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
    146c:	00 97       	sbiw	r24, 0x00	; 0
    146e:	09 f4       	brne	.+2      	; 0x1472 <Create_VCP_frame+0x38>
    1470:	58 c0       	rjmp	.+176    	; 0x1522 <Create_VCP_frame+0xe8>
    1472:	21 15       	cp	r18, r1
    1474:	31 05       	cpc	r19, r1
    1476:	09 f4       	brne	.+2      	; 0x147a <Create_VCP_frame+0x40>
    1478:	54 c0       	rjmp	.+168    	; 0x1522 <Create_VCP_frame+0xe8>
		return VCP_NULL_ERR;

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
    147a:	4c 30       	cpi	r20, 0x0C	; 12
    147c:	18 f0       	brcs	.+6      	; 0x1484 <Create_VCP_frame+0x4a>
    147e:	48 33       	cpi	r20, 0x38	; 56
    1480:	09 f0       	breq	.+2      	; 0x1484 <Create_VCP_frame+0x4a>
    1482:	51 c0       	rjmp	.+162    	; 0x1526 <Create_VCP_frame+0xec>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    1484:	44 24       	eor	r4, r4
    1486:	43 94       	inc	r4
    1488:	51 2c       	mov	r5, r1
    148a:	4c 0e       	add	r4, r28
    148c:	5d 1e       	adc	r5, r29
    148e:	b2 01       	movw	r22, r4
    1490:	84 2f       	mov	r24, r20
    1492:	4b 83       	std	Y+3, r20	; 0x03
    1494:	0e 94 fd 09 	call	0x13fa	; 0x13fa <append_crc16>
// uint8ptr		dst -		Pointer to the destination buffer
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
    1498:	37 01       	movw	r6, r14
    149a:	60 0e       	add	r6, r16
    149c:	71 1e       	adc	r7, r17
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    149e:	47 01       	movw	r8, r14
    14a0:	07 c0       	rjmp	.+14     	; 0x14b0 <Create_VCP_frame+0x76>
	  append_crc16(src[src_index], &crc);
    14a2:	b2 01       	movw	r22, r4
    14a4:	f4 01       	movw	r30, r8
    14a6:	81 91       	ld	r24, Z+
    14a8:	4f 01       	movw	r8, r30
    14aa:	4b 83       	std	Y+3, r20	; 0x03
    14ac:	0e 94 fd 09 	call	0x13fa	; 0x13fa <append_crc16>
    14b0:	4b 81       	ldd	r20, Y+3	; 0x03
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    14b2:	86 14       	cp	r8, r6
    14b4:	97 04       	cpc	r9, r7
    14b6:	a9 f7       	brne	.-22     	; 0x14a2 <Create_VCP_frame+0x68>
	  append_crc16(src[src_index], &crc);
	
	// Add CRC to the end of the source buffer
	src[src_index++] = ((crc >> 8) & 0xFF);
    14b8:	89 81       	ldd	r24, Y+1	; 0x01
    14ba:	9a 81       	ldd	r25, Y+2	; 0x02
    14bc:	f7 01       	movw	r30, r14
    14be:	e0 0f       	add	r30, r16
    14c0:	f1 1f       	adc	r31, r17
    14c2:	90 83       	st	Z, r25
	src[src_index++] = (crc & 0xFF);
    14c4:	81 83       	std	Z+1, r24	; 0x01
    14c6:	0e 5f       	subi	r16, 0xFE	; 254
    14c8:	1f 4f       	sbci	r17, 0xFF	; 255
	payload_size = src_index;
	
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
    14ca:	80 ec       	ldi	r24, 0xC0	; 192
    14cc:	f6 01       	movw	r30, r12
    14ce:	80 83       	st	Z, r24
	// then insert VCP address
	dst[dst_index++] =					addr;
    14d0:	41 83       	std	Z+1, r20	; 0x01
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    14d2:	d7 01       	movw	r26, r14
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
    14d4:	42 e0       	ldi	r20, 0x02	; 2
    14d6:	50 e0       	ldi	r21, 0x00	; 0
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    14d8:	2d ed       	ldi	r18, 0xDD	; 221
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
    14da:	3b ed       	ldi	r19, 0xDB	; 219
			dst[dst_index++] =			TFEND;
    14dc:	6c ed       	ldi	r22, 0xDC	; 220
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    14de:	0f c0       	rjmp	.+30     	; 0x14fe <Create_VCP_frame+0xc4>
	{
		if (src[src_index] == FEND)
    14e0:	8d 91       	ld	r24, X+
    14e2:	80 3c       	cpi	r24, 0xC0	; 192
    14e4:	19 f4       	brne	.+6      	; 0x14ec <Create_VCP_frame+0xb2>
		{
			dst[dst_index++] =			FESC;
    14e6:	30 83       	st	Z, r19
			dst[dst_index++] =			TFEND;
    14e8:	61 83       	std	Z+1, r22	; 0x01
    14ea:	04 c0       	rjmp	.+8      	; 0x14f4 <Create_VCP_frame+0xba>
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
    14ec:	80 83       	st	Z, r24
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
    14ee:	8b 3d       	cpi	r24, 0xDB	; 219
    14f0:	21 f4       	brne	.+8      	; 0x14fa <Create_VCP_frame+0xc0>
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    14f2:	21 83       	std	Z+1, r18	; 0x01
    14f4:	4e 5f       	subi	r20, 0xFE	; 254
    14f6:	5f 4f       	sbci	r21, 0xFF	; 255
    14f8:	02 c0       	rjmp	.+4      	; 0x14fe <Create_VCP_frame+0xc4>
		}
		else
		{
			dst[dst_index++] =			src[src_index];
    14fa:	4f 5f       	subi	r20, 0xFF	; 255
    14fc:	5f 4f       	sbci	r21, 0xFF	; 255
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    14fe:	cd 01       	movw	r24, r26
    1500:	8e 19       	sub	r24, r14
    1502:	9f 09       	sbc	r25, r15
    1504:	f6 01       	movw	r30, r12
    1506:	e4 0f       	add	r30, r20
    1508:	f5 1f       	adc	r31, r21
    150a:	80 17       	cp	r24, r16
    150c:	91 07       	cpc	r25, r17
    150e:	40 f3       	brcs	.-48     	; 0x14e0 <Create_VCP_frame+0xa6>
		//if (dst_index >= *dst_size - 1)
			//return VCP_OVR_ERR;
	}
	
	// End the frame with FEND
	dst[dst_index++] =					FEND;
    1510:	80 ec       	ldi	r24, 0xC0	; 192
    1512:	80 83       	st	Z, r24
    1514:	4f 5f       	subi	r20, 0xFF	; 255
    1516:	5f 4f       	sbci	r21, 0xFF	; 255
	
	// Save the frame size
	*dst_size = dst_index;
    1518:	f5 01       	movw	r30, r10
    151a:	51 83       	std	Z+1, r21	; 0x01
    151c:	40 83       	st	Z, r20
	
	// All good
	return VCP_TERM;
    151e:	81 e0       	ldi	r24, 0x01	; 1
    1520:	03 c0       	rjmp	.+6      	; 0x1528 <Create_VCP_frame+0xee>
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
		return VCP_NULL_ERR;
    1522:	85 e0       	ldi	r24, 0x05	; 5
    1524:	01 c0       	rjmp	.+2      	; 0x1528 <Create_VCP_frame+0xee>

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
		return VCP_ADDR_ERR;
    1526:	86 e0       	ldi	r24, 0x06	; 6
	// Save the frame size
	*dst_size = dst_index;
	
	// All good
	return VCP_TERM;
}
    1528:	0f 90       	pop	r0
    152a:	0f 90       	pop	r0
    152c:	0f 90       	pop	r0
    152e:	df 91       	pop	r29
    1530:	cf 91       	pop	r28
    1532:	1f 91       	pop	r17
    1534:	0f 91       	pop	r16
    1536:	ff 90       	pop	r15
    1538:	ef 90       	pop	r14
    153a:	df 90       	pop	r13
    153c:	cf 90       	pop	r12
    153e:	bf 90       	pop	r11
    1540:	af 90       	pop	r10
    1542:	9f 90       	pop	r9
    1544:	8f 90       	pop	r8
    1546:	7f 90       	pop	r7
    1548:	6f 90       	pop	r6
    154a:	5f 90       	pop	r5
    154c:	4f 90       	pop	r4
    154e:	08 95       	ret

00001550 <Receive_VCP_byte>:
// and return VCP status.
// Parameters:
// vcp_ptrbuffer	*buff -	Pointer to the vcp buffer structure
// uint8			byte -	received byte
uint8_t Receive_VCP_byte(vcp_ptrbuffer *buff, uint8 byte)
{
    1550:	cf 92       	push	r12
    1552:	df 92       	push	r13
    1554:	ef 92       	push	r14
    1556:	ff 92       	push	r15
    1558:	0f 93       	push	r16
    155a:	1f 93       	push	r17
    155c:	cf 93       	push	r28
    155e:	df 93       	push	r29
    1560:	ec 01       	movw	r28, r24
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
    1562:	29 81       	ldd	r18, Y+1	; 0x01
    1564:	3a 81       	ldd	r19, Y+2	; 0x02
    1566:	21 15       	cp	r18, r1
    1568:	31 05       	cpc	r19, r1
    156a:	09 f4       	brne	.+2      	; 0x156e <Receive_VCP_byte+0x1e>
    156c:	84 c0       	rjmp	.+264    	; 0x1676 <Receive_VCP_byte+0x126>
		return VCP_NULL_ERR;
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
    156e:	8f 81       	ldd	r24, Y+7	; 0x07
    1570:	98 85       	ldd	r25, Y+8	; 0x08
    1572:	4d 81       	ldd	r20, Y+5	; 0x05
    1574:	5e 81       	ldd	r21, Y+6	; 0x06
    1576:	41 50       	subi	r20, 0x01	; 1
    1578:	51 09       	sbc	r21, r1
    157a:	84 17       	cp	r24, r20
    157c:	95 07       	cpc	r25, r21
    157e:	08 f0       	brcs	.+2      	; 0x1582 <Receive_VCP_byte+0x32>
    1580:	7c c0       	rjmp	.+248    	; 0x167a <Receive_VCP_byte+0x12a>
		return VCP_OVR_ERR;
	
	// State Machine
	switch (buff->status)
    1582:	49 85       	ldd	r20, Y+9	; 0x09
    1584:	42 30       	cpi	r20, 0x02	; 2
    1586:	39 f1       	breq	.+78     	; 0x15d6 <Receive_VCP_byte+0x86>
    1588:	18 f4       	brcc	.+6      	; 0x1590 <Receive_VCP_byte+0x40>
    158a:	44 23       	and	r20, r20
    158c:	31 f0       	breq	.+12     	; 0x159a <Receive_VCP_byte+0x4a>
    158e:	38 c0       	rjmp	.+112    	; 0x1600 <Receive_VCP_byte+0xb0>
    1590:	40 31       	cpi	r20, 0x10	; 16
    1592:	31 f0       	breq	.+12     	; 0x15a0 <Receive_VCP_byte+0x50>
    1594:	40 32       	cpi	r20, 0x20	; 32
    1596:	a1 f5       	brne	.+104    	; 0x1600 <Receive_VCP_byte+0xb0>
    1598:	0a c0       	rjmp	.+20     	; 0x15ae <Receive_VCP_byte+0x5e>
	{
		case VCP_IDLE:										
			if (byte == FEND)
    159a:	60 3c       	cpi	r22, 0xC0	; 192
    159c:	91 f5       	brne	.+100    	; 0x1602 <Receive_VCP_byte+0xb2>
    159e:	0d c0       	rjmp	.+26     	; 0x15ba <Receive_VCP_byte+0x6a>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
    15a0:	6c 30       	cpi	r22, 0x0C	; 12
    15a2:	18 f0       	brcs	.+6      	; 0x15aa <Receive_VCP_byte+0x5a>
    15a4:	68 33       	cpi	r22, 0x38	; 56
    15a6:	09 f0       	breq	.+2      	; 0x15aa <Receive_VCP_byte+0x5a>
    15a8:	6a c0       	rjmp	.+212    	; 0x167e <Receive_VCP_byte+0x12e>
				return VCP_ADDR_ERR;
			else
			{
				buff->address = byte;
    15aa:	68 83       	st	Y, r22
    15ac:	26 c0       	rjmp	.+76     	; 0x15fa <Receive_VCP_byte+0xaa>
				buff->status = VCP_RECEIVING;
			}	
			break;
		case VCP_RECEIVING:
			if (byte == FEND)
    15ae:	60 3c       	cpi	r22, 0xC0	; 192
    15b0:	31 f4       	brne	.+12     	; 0x15be <Receive_VCP_byte+0x6e>
			{
				if (buff->index > 0)
    15b2:	89 2b       	or	r24, r25
    15b4:	11 f0       	breq	.+4      	; 0x15ba <Receive_VCP_byte+0x6a>
					// Done
					buff->status = VCP_TERM;
    15b6:	81 e0       	ldi	r24, 0x01	; 1
    15b8:	21 c0       	rjmp	.+66     	; 0x15fc <Receive_VCP_byte+0xac>
				else
					// No data between FENDs - assume lost sync and start over
					buff->status = VCP_ADDRESS;
    15ba:	80 e1       	ldi	r24, 0x10	; 16
    15bc:	1f c0       	rjmp	.+62     	; 0x15fc <Receive_VCP_byte+0xac>
			}
			else if (byte == FESC)
    15be:	6b 3d       	cpi	r22, 0xDB	; 219
    15c0:	11 f4       	brne	.+4      	; 0x15c6 <Receive_VCP_byte+0x76>
				buff->status = VCP_ESC;
    15c2:	82 e0       	ldi	r24, 0x02	; 2
    15c4:	1b c0       	rjmp	.+54     	; 0x15fc <Receive_VCP_byte+0xac>
			else
			{
				buff->message[(buff->index)++] = byte;	
    15c6:	f9 01       	movw	r30, r18
    15c8:	e8 0f       	add	r30, r24
    15ca:	f9 1f       	adc	r31, r25
    15cc:	60 83       	st	Z, r22
    15ce:	01 96       	adiw	r24, 0x01	; 1
    15d0:	98 87       	std	Y+8, r25	; 0x08
    15d2:	8f 83       	std	Y+7, r24	; 0x07
    15d4:	16 c0       	rjmp	.+44     	; 0x1602 <Receive_VCP_byte+0xb2>
			}						
			break;
		case VCP_ESC:
			if (byte == TFEND)
    15d6:	6c 3d       	cpi	r22, 0xDC	; 220
    15d8:	29 f4       	brne	.+10     	; 0x15e4 <Receive_VCP_byte+0x94>
			{
				buff->message[(buff->index)++] = FEND;
    15da:	f9 01       	movw	r30, r18
    15dc:	e8 0f       	add	r30, r24
    15de:	f9 1f       	adc	r31, r25
    15e0:	40 ec       	ldi	r20, 0xC0	; 192
    15e2:	07 c0       	rjmp	.+14     	; 0x15f2 <Receive_VCP_byte+0xa2>
				buff->status = VCP_RECEIVING;
			}
			else if (byte == TFESC)
    15e4:	6d 3d       	cpi	r22, 0xDD	; 221
    15e6:	09 f0       	breq	.+2      	; 0x15ea <Receive_VCP_byte+0x9a>
    15e8:	4c c0       	rjmp	.+152    	; 0x1682 <Receive_VCP_byte+0x132>
			{
				buff->message[(buff->index)++] = FESC;
    15ea:	f9 01       	movw	r30, r18
    15ec:	e8 0f       	add	r30, r24
    15ee:	f9 1f       	adc	r31, r25
    15f0:	4b ed       	ldi	r20, 0xDB	; 219
    15f2:	40 83       	st	Z, r20
    15f4:	01 96       	adiw	r24, 0x01	; 1
    15f6:	98 87       	std	Y+8, r25	; 0x08
    15f8:	8f 83       	std	Y+7, r24	; 0x07
				buff->status = VCP_RECEIVING;
    15fa:	80 e2       	ldi	r24, 0x20	; 32
    15fc:	89 87       	std	Y+9, r24	; 0x09
    15fe:	01 c0       	rjmp	.+2      	; 0x1602 <Receive_VCP_byte+0xb2>
			}
			else
				return VCP_ESC_ERR;	
			break;
		default:
			buff->status = VCP_IDLE;
    1600:	19 86       	std	Y+9, r1	; 0x09
			break; 
	}
	
	// End of frame
	if (buff->status == VCP_TERM)
    1602:	89 85       	ldd	r24, Y+9	; 0x09
    1604:	81 30       	cpi	r24, 0x01	; 1
    1606:	11 f0       	breq	.+4      	; 0x160c <Receive_VCP_byte+0xbc>
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
    1608:	89 85       	ldd	r24, Y+9	; 0x09
    160a:	3c c0       	rjmp	.+120    	; 0x1684 <Receive_VCP_byte+0x134>
	
	// End of frame
	if (buff->status == VCP_TERM)
	{
		// Message CRC is last 2 bytes 
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
    160c:	89 81       	ldd	r24, Y+1	; 0x01
    160e:	9a 81       	ldd	r25, Y+2	; 0x02
    1610:	4f 81       	ldd	r20, Y+7	; 0x07
    1612:	58 85       	ldd	r21, Y+8	; 0x08
    1614:	84 0f       	add	r24, r20
    1616:	95 1f       	adc	r25, r21
    1618:	fc 01       	movw	r30, r24
    161a:	32 97       	sbiw	r30, 0x02	; 2
    161c:	30 81       	ld	r19, Z
    161e:	20 e0       	ldi	r18, 0x00	; 0
    1620:	fc 01       	movw	r30, r24
    1622:	31 97       	sbiw	r30, 0x01	; 1
    1624:	80 81       	ld	r24, Z
    1626:	69 01       	movw	r12, r18
    1628:	c8 0e       	add	r12, r24
    162a:	d1 1c       	adc	r13, r1
		// Remove CRC bytes from the message
		buff->index -= 2;
    162c:	42 50       	subi	r20, 0x02	; 2
    162e:	51 09       	sbc	r21, r1
    1630:	58 87       	std	Y+8, r21	; 0x08
    1632:	4f 83       	std	Y+7, r20	; 0x07
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
    1634:	7e 01       	movw	r14, r28
    1636:	83 e0       	ldi	r24, 0x03	; 3
    1638:	e8 0e       	add	r14, r24
    163a:	f1 1c       	adc	r15, r1
    163c:	b7 01       	movw	r22, r14
    163e:	88 81       	ld	r24, Y
    1640:	0e 94 fd 09 	call	0x13fa	; 0x13fa <append_crc16>
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    1644:	00 e0       	ldi	r16, 0x00	; 0
    1646:	10 e0       	ldi	r17, 0x00	; 0
    1648:	0a c0       	rjmp	.+20     	; 0x165e <Receive_VCP_byte+0x10e>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
    164a:	e9 81       	ldd	r30, Y+1	; 0x01
    164c:	fa 81       	ldd	r31, Y+2	; 0x02
    164e:	e0 0f       	add	r30, r16
    1650:	f1 1f       	adc	r31, r17
    1652:	b7 01       	movw	r22, r14
    1654:	80 81       	ld	r24, Z
    1656:	0e 94 fd 09 	call	0x13fa	; 0x13fa <append_crc16>
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
		// Remove CRC bytes from the message
		buff->index -= 2;
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    165a:	0f 5f       	subi	r16, 0xFF	; 255
    165c:	1f 4f       	sbci	r17, 0xFF	; 255
    165e:	8f 81       	ldd	r24, Y+7	; 0x07
    1660:	98 85       	ldd	r25, Y+8	; 0x08
    1662:	08 17       	cp	r16, r24
    1664:	19 07       	cpc	r17, r25
    1666:	88 f3       	brcs	.-30     	; 0x164a <Receive_VCP_byte+0xfa>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
		}
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
    1668:	8b 81       	ldd	r24, Y+3	; 0x03
    166a:	9c 81       	ldd	r25, Y+4	; 0x04
    166c:	8c 15       	cp	r24, r12
    166e:	9d 05       	cpc	r25, r13
    1670:	59 f2       	breq	.-106    	; 0x1608 <Receive_VCP_byte+0xb8>
			return VCP_CRC_ERR;
    1672:	84 e0       	ldi	r24, 0x04	; 4
    1674:	07 c0       	rjmp	.+14     	; 0x1684 <Receive_VCP_byte+0x134>
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
		return VCP_NULL_ERR;
    1676:	85 e0       	ldi	r24, 0x05	; 5
    1678:	05 c0       	rjmp	.+10     	; 0x1684 <Receive_VCP_byte+0x134>
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
		return VCP_OVR_ERR;
    167a:	83 e0       	ldi	r24, 0x03	; 3
    167c:	03 c0       	rjmp	.+6      	; 0x1684 <Receive_VCP_byte+0x134>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
				return VCP_ADDR_ERR;
    167e:	86 e0       	ldi	r24, 0x06	; 6
    1680:	01 c0       	rjmp	.+2      	; 0x1684 <Receive_VCP_byte+0x134>
			{
				buff->message[(buff->index)++] = FESC;
				buff->status = VCP_RECEIVING;
			}
			else
				return VCP_ESC_ERR;	
    1682:	87 e0       	ldi	r24, 0x07	; 7
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
}
    1684:	df 91       	pop	r29
    1686:	cf 91       	pop	r28
    1688:	1f 91       	pop	r17
    168a:	0f 91       	pop	r16
    168c:	ff 90       	pop	r15
    168e:	ef 90       	pop	r14
    1690:	df 90       	pop	r13
    1692:	cf 90       	pop	r12
    1694:	08 95       	ret

00001696 <tx_put_byte.part.0>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    return;
  if( tel_packet_index[uart] < tel_packet_size[uart] )
    1696:	28 2f       	mov	r18, r24
    1698:	30 e0       	ldi	r19, 0x00	; 0
    169a:	f9 01       	movw	r30, r18
    169c:	ed 5a       	subi	r30, 0xAD	; 173
    169e:	f7 4f       	sbci	r31, 0xF7	; 247
    16a0:	60 81       	ld	r22, Z
    16a2:	d9 01       	movw	r26, r18
    16a4:	aa 0f       	add	r26, r26
    16a6:	bb 1f       	adc	r27, r27
    16a8:	ad 57       	subi	r26, 0x7D	; 125
    16aa:	bb 4f       	sbci	r27, 0xFB	; 251
    16ac:	4d 91       	ld	r20, X+
    16ae:	5c 91       	ld	r21, X
    16b0:	70 e0       	ldi	r23, 0x00	; 0
    16b2:	64 17       	cp	r22, r20
    16b4:	75 07       	cpc	r23, r21
    16b6:	10 f5       	brcc	.+68     	; 0x16fc <tx_put_byte.part.0+0x66>
  {
      if ( uart == 0 )
    16b8:	81 11       	cpse	r24, r1
    16ba:	0e c0       	rjmp	.+28     	; 0x16d8 <tx_put_byte.part.0+0x42>
      UDR0 = tel_packet[uart][tel_packet_index[uart]++];
    16bc:	80 81       	ld	r24, Z
    16be:	9f ef       	ldi	r25, 0xFF	; 255
    16c0:	92 9f       	mul	r25, r18
    16c2:	d0 01       	movw	r26, r0
    16c4:	93 9f       	mul	r25, r19
    16c6:	b0 0d       	add	r27, r0
    16c8:	11 24       	eor	r1, r1
    16ca:	a8 0f       	add	r26, r24
    16cc:	b1 1d       	adc	r27, r1
    16ce:	a6 5a       	subi	r26, 0xA6	; 166
    16d0:	b7 4f       	sbci	r27, 0xF7	; 247
    16d2:	9c 91       	ld	r25, X
    16d4:	9c b9       	out	0x0c, r25	; 12
    16d6:	10 c0       	rjmp	.+32     	; 0x16f8 <tx_put_byte.part.0+0x62>
    else if ( uart == 1 )
    16d8:	81 30       	cpi	r24, 0x01	; 1
    16da:	81 f4       	brne	.+32     	; 0x16fc <tx_put_byte.part.0+0x66>
      UDR1 = tel_packet[uart][tel_packet_index[uart]++];
    16dc:	80 81       	ld	r24, Z
    16de:	9f ef       	ldi	r25, 0xFF	; 255
    16e0:	92 9f       	mul	r25, r18
    16e2:	d0 01       	movw	r26, r0
    16e4:	93 9f       	mul	r25, r19
    16e6:	b0 0d       	add	r27, r0
    16e8:	11 24       	eor	r1, r1
    16ea:	a8 0f       	add	r26, r24
    16ec:	b1 1d       	adc	r27, r1
    16ee:	a6 5a       	subi	r26, 0xA6	; 166
    16f0:	b7 4f       	sbci	r27, 0xF7	; 247
    16f2:	9c 91       	ld	r25, X
    16f4:	90 93 9c 00 	sts	0x009C, r25
    16f8:	8f 5f       	subi	r24, 0xFF	; 255
    16fa:	80 83       	st	Z, r24
    16fc:	08 95       	ret

000016fe <__vector_15>:
#include "vcp_library.h"
#include "crclib.h"
#include "uart.h"

ISR(TIMER0_COMP_vect)
{
    16fe:	1f 92       	push	r1
    1700:	0f 92       	push	r0
    1702:	0f b6       	in	r0, 0x3f	; 63
    1704:	0f 92       	push	r0
    1706:	11 24       	eor	r1, r1
    1708:	8f 93       	push	r24
  if ( timer0_counter[0] > 0 )
    170a:	80 91 8a 0c 	lds	r24, 0x0C8A
    170e:	88 23       	and	r24, r24
    1710:	29 f0       	breq	.+10     	; 0x171c <__vector_15+0x1e>
    --timer0_counter[0];
    1712:	80 91 8a 0c 	lds	r24, 0x0C8A
    1716:	81 50       	subi	r24, 0x01	; 1
    1718:	80 93 8a 0c 	sts	0x0C8A, r24
  if ( timer0_counter[1] > 0 )
    171c:	80 91 8b 0c 	lds	r24, 0x0C8B
    1720:	88 23       	and	r24, r24
    1722:	29 f0       	breq	.+10     	; 0x172e <__vector_15+0x30>
    --timer0_counter[1];
    1724:	80 91 8b 0c 	lds	r24, 0x0C8B
    1728:	81 50       	subi	r24, 0x01	; 1
    172a:	80 93 8b 0c 	sts	0x0C8B, r24
	//if (cntr == 0)
	//	PORTC |= 0x01;
	//else
	//	PORTC &= 0xFE;
	//_delay_ms(500);
}
    172e:	8f 91       	pop	r24
    1730:	0f 90       	pop	r0
    1732:	0f be       	out	0x3f, r0	; 63
    1734:	0f 90       	pop	r0
    1736:	1f 90       	pop	r1
    1738:	18 95       	reti

0000173a <__vector_12>:

/* Timer 1(A) routine */
ISR(TIMER1_COMPA_vect)		//Handle Radio & Torquer 30 min delays here; handle 10 min CDH-IB no heartbeat restart
{
    173a:	1f 92       	push	r1
    173c:	0f 92       	push	r0
    173e:	0f b6       	in	r0, 0x3f	; 63
    1740:	0f 92       	push	r0
    1742:	11 24       	eor	r1, r1
    1744:	0b b6       	in	r0, 0x3b	; 59
    1746:	0f 92       	push	r0
    1748:	2f 93       	push	r18
    174a:	3f 93       	push	r19
    174c:	4f 93       	push	r20
    174e:	5f 93       	push	r21
    1750:	6f 93       	push	r22
    1752:	7f 93       	push	r23
    1754:	8f 93       	push	r24
    1756:	9f 93       	push	r25
    1758:	af 93       	push	r26
    175a:	bf 93       	push	r27
    175c:	cf 93       	push	r28
    175e:	ef 93       	push	r30
    1760:	ff 93       	push	r31
	SVIT_t *component;
	
	//Testing
	//PORTC ^= 0xFF;
		
	if (timer1_counter[0] <= 0	  &&     rad_torq_flag){	//provides 30 minute delay			
    1762:	80 91 ae 0e 	lds	r24, 0x0EAE
    1766:	81 11       	cpse	r24, r1
    1768:	31 c0       	rjmp	.+98     	; 0x17cc <__vector_12+0x92>
    176a:	80 91 67 04 	lds	r24, 0x0467
    176e:	88 23       	and	r24, r24
    1770:	69 f1       	breq	.+90     	; 0x17cc <__vector_12+0x92>
	//if ( receive_flag == 1){		//If message is received, reset timer1_counter[0] to CYCLE_COUNTER
	    timer1_counter[0] = CYCLE_COUNTER;
    1772:	84 e8       	ldi	r24, 0x84	; 132
    1774:	80 93 ae 0e 	sts	0x0EAE, r24
		
		//CHECK: Should the ISR do this code or not?
		
		//Turn on radios
		component = &svit[RADIO_1];
		switch_on( component->switch_num );
    1778:	80 91 b1 05 	lds	r24, 0x05B1
    177c:	0e 94 0e 08 	call	0x101c	; 0x101c <switch_on>
		component->switch_state = SW_ON;
    1780:	c1 e0       	ldi	r28, 0x01	; 1
    1782:	c0 93 b2 05 	sts	0x05B2, r28
		component = &svit[RADIO_2];
		switch_on( component->switch_num );
    1786:	80 91 cb 05 	lds	r24, 0x05CB
    178a:	0e 94 0e 08 	call	0x101c	; 0x101c <switch_on>
		component->switch_state = SW_ON;
    178e:	c0 93 cc 05 	sts	0x05CC, r28
		
		//Turn on torque coils			
		component = &svit[TORQUER_1];
		switch_on( component->switch_num );
    1792:	80 91 4d 06 	lds	r24, 0x064D
    1796:	0e 94 0e 08 	call	0x101c	; 0x101c <switch_on>
		component->switch_state = SW_ON;
    179a:	c0 93 4e 06 	sts	0x064E, r28
		component = &svit[TORQUER_2];
		switch_on( component->switch_num );
    179e:	80 91 67 06 	lds	r24, 0x0667
    17a2:	0e 94 0e 08 	call	0x101c	; 0x101c <switch_on>
		component->switch_state = SW_ON;
    17a6:	c0 93 68 06 	sts	0x0668, r28
		component = &svit[TORQUER_3];
		switch_on( component->switch_num );
    17aa:	80 91 81 06 	lds	r24, 0x0681
    17ae:	0e 94 0e 08 	call	0x101c	; 0x101c <switch_on>
		component->switch_state = SW_ON;
    17b2:	c0 93 82 06 	sts	0x0682, r28
		torquer_on(TORQUER_1);
    17b6:	81 e1       	ldi	r24, 0x11	; 17
    17b8:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <torquer_on>
		torquer_on(TORQUER_2);
    17bc:	82 e1       	ldi	r24, 0x12	; 18
    17be:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <torquer_on>
		torquer_on(TORQUER_3);
    17c2:	83 e1       	ldi	r24, 0x13	; 19
    17c4:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <torquer_on>
		
		//PORTC ^= 0x02;	//LED for STK testing
		//PORTC ^= 0x01;
		
		//Don't reexecute this code
		rad_torq_flag = 0;
    17c8:	10 92 67 04 	sts	0x0467, r1
	}
	
	if (timer1_counter[1] <= 0   &&   !cdh_heartbeat_flag){		//If heartbeat timer 1 has expired AND we haven't already ordered a restart
    17cc:	80 91 af 0e 	lds	r24, 0x0EAF
    17d0:	81 11       	cpse	r24, r1
    17d2:	07 c0       	rjmp	.+14     	; 0x17e2 <__vector_12+0xa8>
    17d4:	80 91 7e 04 	lds	r24, 0x047E
    17d8:	81 11       	cpse	r24, r1
    17da:	03 c0       	rjmp	.+6      	; 0x17e2 <__vector_12+0xa8>
		//Order full component restart
		cdh_heartbeat_flag = 1;
    17dc:	81 e0       	ldi	r24, 0x01	; 1
    17de:	80 93 7e 04 	sts	0x047E, r24
		
	}
	
	//else{
		PORTC ^= 0x01;		//LED for STK testing at PORTC0
    17e2:	85 b3       	in	r24, 0x15	; 21
    17e4:	91 e0       	ldi	r25, 0x01	; 1
    17e6:	89 27       	eor	r24, r25
    17e8:	85 bb       	out	0x15, r24	; 21
    17ea:	2f ef       	ldi	r18, 0xFF	; 255
    17ec:	8f e7       	ldi	r24, 0x7F	; 127
    17ee:	96 e1       	ldi	r25, 0x16	; 22
    17f0:	21 50       	subi	r18, 0x01	; 1
    17f2:	80 40       	sbci	r24, 0x00	; 0
    17f4:	90 40       	sbci	r25, 0x00	; 0
    17f6:	e1 f7       	brne	.-8      	; 0x17f0 <__vector_12+0xb6>
    17f8:	00 c0       	rjmp	.+0      	; 0x17fa <__vector_12+0xc0>
    17fa:	00 00       	nop
		_delay_ms(500);
		--timer1_counter[0];
    17fc:	80 91 ae 0e 	lds	r24, 0x0EAE
    1800:	81 50       	subi	r24, 0x01	; 1
    1802:	80 93 ae 0e 	sts	0x0EAE, r24
		--timer1_counter[1];
    1806:	80 91 af 0e 	lds	r24, 0x0EAF
    180a:	81 50       	subi	r24, 0x01	; 1
    180c:	80 93 af 0e 	sts	0x0EAF, r24
	//}
}
    1810:	ff 91       	pop	r31
    1812:	ef 91       	pop	r30
    1814:	cf 91       	pop	r28
    1816:	bf 91       	pop	r27
    1818:	af 91       	pop	r26
    181a:	9f 91       	pop	r25
    181c:	8f 91       	pop	r24
    181e:	7f 91       	pop	r23
    1820:	6f 91       	pop	r22
    1822:	5f 91       	pop	r21
    1824:	4f 91       	pop	r20
    1826:	3f 91       	pop	r19
    1828:	2f 91       	pop	r18
    182a:	0f 90       	pop	r0
    182c:	0b be       	out	0x3b, r0	; 59
    182e:	0f 90       	pop	r0
    1830:	0f be       	out	0x3f, r0	; 63
    1832:	0f 90       	pop	r0
    1834:	1f 90       	pop	r1
    1836:	18 95       	reti

00001838 <__vector_32>:

ISR(USART1_TX_vect)
{
    1838:	1f 92       	push	r1
    183a:	0f 92       	push	r0
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	0f 92       	push	r0
    1840:	11 24       	eor	r1, r1
    1842:	0b b6       	in	r0, 0x3b	; 59
    1844:	0f 92       	push	r0
    1846:	2f 93       	push	r18
    1848:	3f 93       	push	r19
    184a:	4f 93       	push	r20
    184c:	5f 93       	push	r21
    184e:	6f 93       	push	r22
    1850:	7f 93       	push	r23
    1852:	8f 93       	push	r24
    1854:	9f 93       	push	r25
    1856:	af 93       	push	r26
    1858:	bf 93       	push	r27
    185a:	ef 93       	push	r30
    185c:	ff 93       	push	r31
    185e:	81 e0       	ldi	r24, 0x01	; 1
    1860:	0e 94 4b 0b 	call	0x1696	; 0x1696 <tx_put_byte.part.0>
  tx_put_byte( 1 );
}
    1864:	ff 91       	pop	r31
    1866:	ef 91       	pop	r30
    1868:	bf 91       	pop	r27
    186a:	af 91       	pop	r26
    186c:	9f 91       	pop	r25
    186e:	8f 91       	pop	r24
    1870:	7f 91       	pop	r23
    1872:	6f 91       	pop	r22
    1874:	5f 91       	pop	r21
    1876:	4f 91       	pop	r20
    1878:	3f 91       	pop	r19
    187a:	2f 91       	pop	r18
    187c:	0f 90       	pop	r0
    187e:	0b be       	out	0x3b, r0	; 59
    1880:	0f 90       	pop	r0
    1882:	0f be       	out	0x3f, r0	; 63
    1884:	0f 90       	pop	r0
    1886:	1f 90       	pop	r1
    1888:	18 95       	reti

0000188a <__vector_30>:

ISR(USART1_RX_vect)
{
    188a:	1f 92       	push	r1
    188c:	0f 92       	push	r0
    188e:	0f b6       	in	r0, 0x3f	; 63
    1890:	0f 92       	push	r0
    1892:	11 24       	eor	r1, r1
    1894:	0b b6       	in	r0, 0x3b	; 59
    1896:	0f 92       	push	r0
    1898:	2f 93       	push	r18
    189a:	3f 93       	push	r19
    189c:	4f 93       	push	r20
    189e:	5f 93       	push	r21
    18a0:	6f 93       	push	r22
    18a2:	7f 93       	push	r23
    18a4:	8f 93       	push	r24
    18a6:	9f 93       	push	r25
    18a8:	af 93       	push	r26
    18aa:	bf 93       	push	r27
    18ac:	ef 93       	push	r30
    18ae:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[1], UDR1 ) == VCP_TERM )
    18b0:	60 91 9c 00 	lds	r22, 0x009C
    18b4:	80 91 b8 0e 	lds	r24, 0x0EB8
    18b8:	90 91 b9 0e 	lds	r25, 0x0EB9
    18bc:	0e 94 a8 0a 	call	0x1550	; 0x1550 <Receive_VCP_byte>
    18c0:	81 30       	cpi	r24, 0x01	; 1
    18c2:	29 f4       	brne	.+10     	; 0x18ce <__vector_30+0x44>
  {
    rx_flag[1]++;
    18c4:	80 91 bc 0e 	lds	r24, 0x0EBC
    18c8:	8f 5f       	subi	r24, 0xFF	; 255
    18ca:	80 93 bc 0e 	sts	0x0EBC, r24
  }
}
    18ce:	ff 91       	pop	r31
    18d0:	ef 91       	pop	r30
    18d2:	bf 91       	pop	r27
    18d4:	af 91       	pop	r26
    18d6:	9f 91       	pop	r25
    18d8:	8f 91       	pop	r24
    18da:	7f 91       	pop	r23
    18dc:	6f 91       	pop	r22
    18de:	5f 91       	pop	r21
    18e0:	4f 91       	pop	r20
    18e2:	3f 91       	pop	r19
    18e4:	2f 91       	pop	r18
    18e6:	0f 90       	pop	r0
    18e8:	0b be       	out	0x3b, r0	; 59
    18ea:	0f 90       	pop	r0
    18ec:	0f be       	out	0x3f, r0	; 63
    18ee:	0f 90       	pop	r0
    18f0:	1f 90       	pop	r1
    18f2:	18 95       	reti

000018f4 <__vector_21>:

ISR ( ADC_vect )
{
    18f4:	1f 92       	push	r1
    18f6:	0f 92       	push	r0
    18f8:	0f b6       	in	r0, 0x3f	; 63
    18fa:	0f 92       	push	r0
    18fc:	11 24       	eor	r1, r1
    18fe:	8f 93       	push	r24
  ADC_low = ADCL;	// Left adjusted; read 2 LSB then 8 MSB
    1900:	84 b1       	in	r24, 0x04	; 4
    1902:	80 93 b0 0e 	sts	0x0EB0, r24
  ADC_high = ADCH;
    1906:	85 b1       	in	r24, 0x05	; 5
    1908:	80 93 77 0a 	sts	0x0A77, r24
  adc_flag = 1;
    190c:	81 e0       	ldi	r24, 0x01	; 1
    190e:	80 93 59 0a 	sts	0x0A59, r24
}
    1912:	8f 91       	pop	r24
    1914:	0f 90       	pop	r0
    1916:	0f be       	out	0x3f, r0	; 63
    1918:	0f 90       	pop	r0
    191a:	1f 90       	pop	r1
    191c:	18 95       	reti

0000191e <__vector_20>:

ISR( USART0_TX_vect )
{
    191e:	1f 92       	push	r1
    1920:	0f 92       	push	r0
    1922:	0f b6       	in	r0, 0x3f	; 63
    1924:	0f 92       	push	r0
    1926:	11 24       	eor	r1, r1
    1928:	0b b6       	in	r0, 0x3b	; 59
    192a:	0f 92       	push	r0
    192c:	2f 93       	push	r18
    192e:	3f 93       	push	r19
    1930:	4f 93       	push	r20
    1932:	5f 93       	push	r21
    1934:	6f 93       	push	r22
    1936:	7f 93       	push	r23
    1938:	8f 93       	push	r24
    193a:	9f 93       	push	r25
    193c:	af 93       	push	r26
    193e:	bf 93       	push	r27
    1940:	ef 93       	push	r30
    1942:	ff 93       	push	r31
    1944:	80 e0       	ldi	r24, 0x00	; 0
    1946:	0e 94 4b 0b 	call	0x1696	; 0x1696 <tx_put_byte.part.0>
  tx_put_byte( 0 );
}
    194a:	ff 91       	pop	r31
    194c:	ef 91       	pop	r30
    194e:	bf 91       	pop	r27
    1950:	af 91       	pop	r26
    1952:	9f 91       	pop	r25
    1954:	8f 91       	pop	r24
    1956:	7f 91       	pop	r23
    1958:	6f 91       	pop	r22
    195a:	5f 91       	pop	r21
    195c:	4f 91       	pop	r20
    195e:	3f 91       	pop	r19
    1960:	2f 91       	pop	r18
    1962:	0f 90       	pop	r0
    1964:	0b be       	out	0x3b, r0	; 59
    1966:	0f 90       	pop	r0
    1968:	0f be       	out	0x3f, r0	; 63
    196a:	0f 90       	pop	r0
    196c:	1f 90       	pop	r1
    196e:	18 95       	reti

00001970 <__vector_18>:

ISR( USART0_RX_vect )
{
    1970:	1f 92       	push	r1
    1972:	0f 92       	push	r0
    1974:	0f b6       	in	r0, 0x3f	; 63
    1976:	0f 92       	push	r0
    1978:	11 24       	eor	r1, r1
    197a:	0b b6       	in	r0, 0x3b	; 59
    197c:	0f 92       	push	r0
    197e:	2f 93       	push	r18
    1980:	3f 93       	push	r19
    1982:	4f 93       	push	r20
    1984:	5f 93       	push	r21
    1986:	6f 93       	push	r22
    1988:	7f 93       	push	r23
    198a:	8f 93       	push	r24
    198c:	9f 93       	push	r25
    198e:	af 93       	push	r26
    1990:	bf 93       	push	r27
    1992:	ef 93       	push	r30
    1994:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[0], UDR0 ) == VCP_TERM )
    1996:	6c b1       	in	r22, 0x0c	; 12
    1998:	80 91 b6 0e 	lds	r24, 0x0EB6
    199c:	90 91 b7 0e 	lds	r25, 0x0EB7
    19a0:	0e 94 a8 0a 	call	0x1550	; 0x1550 <Receive_VCP_byte>
    19a4:	81 30       	cpi	r24, 0x01	; 1
    19a6:	29 f4       	brne	.+10     	; 0x19b2 <__vector_18+0x42>
  {
    rx_flag[0]++;
    19a8:	80 91 bb 0e 	lds	r24, 0x0EBB
    19ac:	8f 5f       	subi	r24, 0xFF	; 255
    19ae:	80 93 bb 0e 	sts	0x0EBB, r24
  }
}
    19b2:	ff 91       	pop	r31
    19b4:	ef 91       	pop	r30
    19b6:	bf 91       	pop	r27
    19b8:	af 91       	pop	r26
    19ba:	9f 91       	pop	r25
    19bc:	8f 91       	pop	r24
    19be:	7f 91       	pop	r23
    19c0:	6f 91       	pop	r22
    19c2:	5f 91       	pop	r21
    19c4:	4f 91       	pop	r20
    19c6:	3f 91       	pop	r19
    19c8:	2f 91       	pop	r18
    19ca:	0f 90       	pop	r0
    19cc:	0b be       	out	0x3b, r0	; 59
    19ce:	0f 90       	pop	r0
    19d0:	0f be       	out	0x3f, r0	; 63
    19d2:	0f 90       	pop	r0
    19d4:	1f 90       	pop	r1
    19d6:	18 95       	reti

000019d8 <tx_put_byte>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    19d8:	82 30       	cpi	r24, 0x02	; 2
    19da:	10 f4       	brcc	.+4      	; 0x19e0 <tx_put_byte+0x8>
    19dc:	0c 94 4b 0b 	jmp	0x1696	; 0x1696 <tx_put_byte.part.0>
    19e0:	08 95       	ret

000019e2 <construct_telemetry_packet>:
  }
}


void construct_telemetry_packet( uint8_t* packet_payload )
{
    19e2:	2f 92       	push	r2
    19e4:	3f 92       	push	r3
    19e6:	4f 92       	push	r4
    19e8:	5f 92       	push	r5
    19ea:	6f 92       	push	r6
    19ec:	7f 92       	push	r7
    19ee:	8f 92       	push	r8
    19f0:	9f 92       	push	r9
    19f2:	af 92       	push	r10
    19f4:	bf 92       	push	r11
    19f6:	cf 92       	push	r12
    19f8:	df 92       	push	r13
    19fa:	ef 92       	push	r14
    19fc:	ff 92       	push	r15
    19fe:	0f 93       	push	r16
    1a00:	1f 93       	push	r17
    1a02:	cf 93       	push	r28
    1a04:	df 93       	push	r29
    1a06:	cd b7       	in	r28, 0x3d	; 61
    1a08:	de b7       	in	r29, 0x3e	; 62
    1a0a:	28 97       	sbiw	r28, 0x08	; 8
    1a0c:	0f b6       	in	r0, 0x3f	; 63
    1a0e:	f8 94       	cli
    1a10:	de bf       	out	0x3e, r29	; 62
    1a12:	0f be       	out	0x3f, r0	; 63
    1a14:	cd bf       	out	0x3d, r28	; 61
    1a16:	98 87       	std	Y+8, r25	; 0x08
    1a18:	8f 83       	std	Y+7, r24	; 0x07
  packet_payload[0] = VCP_POWER_TELEMETRY;
    1a1a:	dc 01       	movw	r26, r24
    1a1c:	1c 92       	st	X, r1
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
    1a1e:	30 91 98 05 	lds	r19, 0x0598
    1a22:	33 0f       	add	r19, r19
                  ( svit[RADIO_1].switch_state << 2 )    |
    1a24:	80 91 b2 05 	lds	r24, 0x05B2
    1a28:	b4 e0       	ldi	r27, 0x04	; 4
    1a2a:	8b 9f       	mul	r24, r27
    1a2c:	c0 01       	movw	r24, r0
    1a2e:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1a30:	38 2b       	or	r19, r24
    1a32:	80 91 7e 05 	lds	r24, 0x057E
    1a36:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
    1a38:	80 91 cc 05 	lds	r24, 0x05CC
    1a3c:	e8 e0       	ldi	r30, 0x08	; 8
    1a3e:	8e 9f       	mul	r24, r30
    1a40:	c0 01       	movw	r24, r0
    1a42:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1a44:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
    1a46:	80 91 1a 06 	lds	r24, 0x061A
    1a4a:	f0 e1       	ldi	r31, 0x10	; 16
    1a4c:	8f 9f       	mul	r24, r31
    1a4e:	c0 01       	movw	r24, r0
    1a50:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1a52:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;
    1a54:	80 91 34 06 	lds	r24, 0x0634
    1a58:	20 e2       	ldi	r18, 0x20	; 32
    1a5a:	82 9f       	mul	r24, r18
    1a5c:	c0 01       	movw	r24, r0
    1a5e:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1a60:	38 2b       	or	r19, r24
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
    1a62:	40 91 68 06 	lds	r20, 0x0668
    1a66:	44 0f       	add	r20, r20
                  ( svit[TORQUER_3].switch_state << 2 ) |
    1a68:	80 91 82 06 	lds	r24, 0x0682
    1a6c:	54 e0       	ldi	r21, 0x04	; 4
    1a6e:	85 9f       	mul	r24, r21
    1a70:	c0 01       	movw	r24, r0
    1a72:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1a74:	48 2b       	or	r20, r24
    1a76:	80 91 4e 06 	lds	r24, 0x064E
    1a7a:	48 2b       	or	r20, r24
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );
    1a7c:	e6 ee       	ldi	r30, 0xE6	; 230
    1a7e:	f5 e0       	ldi	r31, 0x05	; 5
    1a80:	80 81       	ld	r24, Z
    1a82:	a8 e0       	ldi	r26, 0x08	; 8
    1a84:	8a 9f       	mul	r24, r26
    1a86:	c0 01       	movw	r24, r0
    1a88:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1a8a:	48 2b       	or	r20, r24
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
    1a8c:	20 91 ae 04 	lds	r18, 0x04AE
    1a90:	22 0f       	add	r18, r18
                  ( svit[FC_5V].switch_state << 2 )        |
    1a92:	80 91 c8 04 	lds	r24, 0x04C8
    1a96:	b4 e0       	ldi	r27, 0x04	; 4
    1a98:	8b 9f       	mul	r24, r27
    1a9a:	c0 01       	movw	r24, r0
    1a9c:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a9e:	28 2b       	or	r18, r24
    1aa0:	80 91 94 04 	lds	r24, 0x0494
    1aa4:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
    1aa6:	80 91 fc 04 	lds	r24, 0x04FC
    1aaa:	58 e0       	ldi	r21, 0x08	; 8
    1aac:	85 9f       	mul	r24, r21
    1aae:	c0 01       	movw	r24, r0
    1ab0:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1ab2:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
    1ab4:	80 91 16 05 	lds	r24, 0x0516
    1ab8:	a0 e1       	ldi	r26, 0x10	; 16
    1aba:	8a 9f       	mul	r24, r26
    1abc:	c0 01       	movw	r24, r0
    1abe:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1ac0:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
    1ac2:	80 91 30 05 	lds	r24, 0x0530
    1ac6:	b0 e2       	ldi	r27, 0x20	; 32
    1ac8:	8b 9f       	mul	r24, r27
    1aca:	c0 01       	movw	r24, r0
    1acc:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1ace:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
    1ad0:	80 91 4a 05 	lds	r24, 0x054A
    1ad4:	50 e4       	ldi	r21, 0x40	; 64
    1ad6:	85 9f       	mul	r24, r21
    1ad8:	c0 01       	movw	r24, r0
    1ada:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1adc:	28 2b       	or	r18, r24
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;
    1ade:	80 91 64 05 	lds	r24, 0x0564
    1ae2:	a0 e8       	ldi	r26, 0x80	; 128
    1ae4:	8a 9f       	mul	r24, r26
    1ae6:	c0 01       	movw	r24, r0
    1ae8:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1aea:	28 2b       	or	r18, r24
  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );

  packet_payload[1] = on_off_state0;
    1aec:	af 81       	ldd	r26, Y+7	; 0x07
    1aee:	b8 85       	ldd	r27, Y+8	; 0x08
    1af0:	11 96       	adiw	r26, 0x01	; 1
    1af2:	2c 93       	st	X, r18
    1af4:	11 97       	sbiw	r26, 0x01	; 1
  packet_payload[2] = on_off_state1;
    1af6:	12 96       	adiw	r26, 0x02	; 2
    1af8:	3c 93       	st	X, r19
    1afa:	12 97       	sbiw	r26, 0x02	; 2
  packet_payload[3] = on_off_state2;
    1afc:	13 96       	adiw	r26, 0x03	; 3
    1afe:	4c 93       	st	X, r20
    1b00:	13 97       	sbiw	r26, 0x03	; 3
  packet_payload[4] = 0x99;
    1b02:	89 e9       	ldi	r24, 0x99	; 153
    1b04:	14 96       	adiw	r26, 0x04	; 4
    1b06:	8c 93       	st	X, r24
    1b08:	14 97       	sbiw	r26, 0x04	; 4
  packet_payload[5] = svit[MAESTRO].switch_state;
    1b0a:	80 81       	ld	r24, Z
    1b0c:	15 96       	adiw	r26, 0x05	; 5
    1b0e:	8c 93       	st	X, r24

  // voltage values (raw ADC output)
  packet_payload[6]  = SVIT_check_V_critical( svit[SPECTROMETER].name );
    1b10:	22 e9       	ldi	r18, 0x92	; 146
    1b12:	62 2e       	mov	r6, r18
    1b14:	24 e0       	ldi	r18, 0x04	; 4
    1b16:	72 2e       	mov	r7, r18
    1b18:	f3 01       	movw	r30, r6
    1b1a:	80 81       	ld	r24, Z
    1b1c:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1b20:	af 81       	ldd	r26, Y+7	; 0x07
    1b22:	b8 85       	ldd	r27, Y+8	; 0x08
    1b24:	16 96       	adiw	r26, 0x06	; 6
    1b26:	8c 93       	st	X, r24
  packet_payload[7]  = SVIT_check_V_critical( svit[STAR_TRACKER].name );
    1b28:	3c ea       	ldi	r19, 0xAC	; 172
    1b2a:	83 2e       	mov	r8, r19
    1b2c:	34 e0       	ldi	r19, 0x04	; 4
    1b2e:	93 2e       	mov	r9, r19
    1b30:	f4 01       	movw	r30, r8
    1b32:	80 81       	ld	r24, Z
    1b34:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1b38:	af 81       	ldd	r26, Y+7	; 0x07
    1b3a:	b8 85       	ldd	r27, Y+8	; 0x08
    1b3c:	17 96       	adiw	r26, 0x07	; 7
    1b3e:	8c 93       	st	X, r24
  packet_payload[8]  = SVIT_check_V_critical( svit[FC_5V].name );
    1b40:	46 ec       	ldi	r20, 0xC6	; 198
    1b42:	a4 2e       	mov	r10, r20
    1b44:	44 e0       	ldi	r20, 0x04	; 4
    1b46:	b4 2e       	mov	r11, r20
    1b48:	f5 01       	movw	r30, r10
    1b4a:	80 81       	ld	r24, Z
    1b4c:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1b50:	af 81       	ldd	r26, Y+7	; 0x07
    1b52:	b8 85       	ldd	r27, Y+8	; 0x08
    1b54:	18 96       	adiw	r26, 0x08	; 8
    1b56:	8c 93       	st	X, r24
  packet_payload[9]  = SVIT_check_V_critical( svit[FC_3_3V].name );
    1b58:	50 ee       	ldi	r21, 0xE0	; 224
    1b5a:	c5 2e       	mov	r12, r21
    1b5c:	54 e0       	ldi	r21, 0x04	; 4
    1b5e:	d5 2e       	mov	r13, r21
    1b60:	f6 01       	movw	r30, r12
    1b62:	80 81       	ld	r24, Z
    1b64:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1b68:	af 81       	ldd	r26, Y+7	; 0x07
    1b6a:	b8 85       	ldd	r27, Y+8	; 0x08
    1b6c:	19 96       	adiw	r26, 0x09	; 9
    1b6e:	8c 93       	st	X, r24
  packet_payload[10] = SVIT_check_V_critical( svit[GPS_1].name );
    1b70:	6a ef       	ldi	r22, 0xFA	; 250
    1b72:	e6 2e       	mov	r14, r22
    1b74:	64 e0       	ldi	r22, 0x04	; 4
    1b76:	f6 2e       	mov	r15, r22
    1b78:	f7 01       	movw	r30, r14
    1b7a:	80 81       	ld	r24, Z
    1b7c:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1b80:	af 81       	ldd	r26, Y+7	; 0x07
    1b82:	b8 85       	ldd	r27, Y+8	; 0x08
    1b84:	1a 96       	adiw	r26, 0x0a	; 10
    1b86:	8c 93       	st	X, r24
  packet_payload[11] = SVIT_check_V_critical( svit[CDH_IB].name );
    1b88:	0e e2       	ldi	r16, 0x2E	; 46
    1b8a:	15 e0       	ldi	r17, 0x05	; 5
    1b8c:	f8 01       	movw	r30, r16
    1b8e:	80 81       	ld	r24, Z
    1b90:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1b94:	af 81       	ldd	r26, Y+7	; 0x07
    1b96:	b8 85       	ldd	r27, Y+8	; 0x08
    1b98:	1b 96       	adiw	r26, 0x0b	; 11
    1b9a:	8c 93       	st	X, r24
  packet_payload[12] = SVIT_check_V_critical( svit[HEATER_1].name );
    1b9c:	e8 e4       	ldi	r30, 0x48	; 72
    1b9e:	f5 e0       	ldi	r31, 0x05	; 5
    1ba0:	80 81       	ld	r24, Z
    1ba2:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1ba6:	af 81       	ldd	r26, Y+7	; 0x07
    1ba8:	b8 85       	ldd	r27, Y+8	; 0x08
    1baa:	1c 96       	adiw	r26, 0x0c	; 12
    1bac:	8c 93       	st	X, r24
  packet_payload[13] = SVIT_check_V_critical( svit[HEATER_2].name );
    1bae:	72 e6       	ldi	r23, 0x62	; 98
    1bb0:	47 2e       	mov	r4, r23
    1bb2:	75 e0       	ldi	r23, 0x05	; 5
    1bb4:	57 2e       	mov	r5, r23
    1bb6:	f2 01       	movw	r30, r4
    1bb8:	80 81       	ld	r24, Z
    1bba:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1bbe:	af 81       	ldd	r26, Y+7	; 0x07
    1bc0:	b8 85       	ldd	r27, Y+8	; 0x08
    1bc2:	1d 96       	adiw	r26, 0x0d	; 13
    1bc4:	8c 93       	st	X, r24
  packet_payload[14] = SVIT_check_V_critical( svit[CMG].name );
    1bc6:	ec e7       	ldi	r30, 0x7C	; 124
    1bc8:	2e 2e       	mov	r2, r30
    1bca:	e5 e0       	ldi	r30, 0x05	; 5
    1bcc:	3e 2e       	mov	r3, r30
    1bce:	f1 01       	movw	r30, r2
    1bd0:	80 81       	ld	r24, Z
    1bd2:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1bd6:	af 81       	ldd	r26, Y+7	; 0x07
    1bd8:	b8 85       	ldd	r27, Y+8	; 0x08
    1bda:	1e 96       	adiw	r26, 0x0e	; 14
    1bdc:	8c 93       	st	X, r24
  packet_payload[15] = SVIT_check_V_critical( svit[SUN_SENSOR].name );
    1bde:	26 e9       	ldi	r18, 0x96	; 150
    1be0:	35 e0       	ldi	r19, 0x05	; 5
    1be2:	f9 01       	movw	r30, r18
    1be4:	80 81       	ld	r24, Z
    1be6:	29 83       	std	Y+1, r18	; 0x01
    1be8:	3a 83       	std	Y+2, r19	; 0x02
    1bea:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1bee:	af 81       	ldd	r26, Y+7	; 0x07
    1bf0:	b8 85       	ldd	r27, Y+8	; 0x08
    1bf2:	1f 96       	adiw	r26, 0x0f	; 15
    1bf4:	8c 93       	st	X, r24
  packet_payload[16] = SVIT_check_V_critical( svit[RADIO_1].name );
    1bf6:	40 eb       	ldi	r20, 0xB0	; 176
    1bf8:	55 e0       	ldi	r21, 0x05	; 5
    1bfa:	fa 01       	movw	r30, r20
    1bfc:	80 81       	ld	r24, Z
    1bfe:	4b 83       	std	Y+3, r20	; 0x03
    1c00:	5c 83       	std	Y+4, r21	; 0x04
    1c02:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1c06:	af 81       	ldd	r26, Y+7	; 0x07
    1c08:	b8 85       	ldd	r27, Y+8	; 0x08
    1c0a:	50 96       	adiw	r26, 0x10	; 16
    1c0c:	8c 93       	st	X, r24
  packet_payload[17] = SVIT_check_V_critical( svit[RADIO_2].name );
    1c0e:	6a ec       	ldi	r22, 0xCA	; 202
    1c10:	75 e0       	ldi	r23, 0x05	; 5
    1c12:	fb 01       	movw	r30, r22
    1c14:	80 81       	ld	r24, Z
    1c16:	6d 83       	std	Y+5, r22	; 0x05
    1c18:	7e 83       	std	Y+6, r23	; 0x06
    1c1a:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1c1e:	af 81       	ldd	r26, Y+7	; 0x07
    1c20:	b8 85       	ldd	r27, Y+8	; 0x08
    1c22:	51 96       	adiw	r26, 0x11	; 17
    1c24:	8c 93       	st	X, r24
  packet_payload[18] = SVIT_check_V_critical( svit[FOG_15V].name );
    1c26:	e8 e1       	ldi	r30, 0x18	; 24
    1c28:	f6 e0       	ldi	r31, 0x06	; 6
    1c2a:	80 81       	ld	r24, Z
    1c2c:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1c30:	af 81       	ldd	r26, Y+7	; 0x07
    1c32:	b8 85       	ldd	r27, Y+8	; 0x08
    1c34:	52 96       	adiw	r26, 0x12	; 18
    1c36:	8c 93       	st	X, r24
  packet_payload[19] = SVIT_check_V_critical( svit[FOG_5V].name );
    1c38:	e2 e3       	ldi	r30, 0x32	; 50
    1c3a:	f6 e0       	ldi	r31, 0x06	; 6
    1c3c:	80 81       	ld	r24, Z
    1c3e:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1c42:	af 81       	ldd	r26, Y+7	; 0x07
    1c44:	b8 85       	ldd	r27, Y+8	; 0x08
    1c46:	53 96       	adiw	r26, 0x13	; 19
    1c48:	8c 93       	st	X, r24
  packet_payload[20] = SVIT_check_V_critical( svit[TORQUER_1].name );
    1c4a:	ec e4       	ldi	r30, 0x4C	; 76
    1c4c:	f6 e0       	ldi	r31, 0x06	; 6
    1c4e:	80 81       	ld	r24, Z
    1c50:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1c54:	af 81       	ldd	r26, Y+7	; 0x07
    1c56:	b8 85       	ldd	r27, Y+8	; 0x08
    1c58:	54 96       	adiw	r26, 0x14	; 20
    1c5a:	8c 93       	st	X, r24
  packet_payload[21] = SVIT_check_V_critical( svit[TORQUER_2].name );
    1c5c:	e6 e6       	ldi	r30, 0x66	; 102
    1c5e:	f6 e0       	ldi	r31, 0x06	; 6
    1c60:	80 81       	ld	r24, Z
    1c62:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1c66:	af 81       	ldd	r26, Y+7	; 0x07
    1c68:	b8 85       	ldd	r27, Y+8	; 0x08
    1c6a:	55 96       	adiw	r26, 0x15	; 21
    1c6c:	8c 93       	st	X, r24
  packet_payload[22] = SVIT_check_V_critical( svit[TORQUER_3].name );
    1c6e:	e0 e8       	ldi	r30, 0x80	; 128
    1c70:	f6 e0       	ldi	r31, 0x06	; 6
    1c72:	80 81       	ld	r24, Z
    1c74:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1c78:	af 81       	ldd	r26, Y+7	; 0x07
    1c7a:	b8 85       	ldd	r27, Y+8	; 0x08
    1c7c:	56 96       	adiw	r26, 0x16	; 22
    1c7e:	8c 93       	st	X, r24
  packet_payload[23] = SVIT_check_V_critical( svit[BATTERY_1].name );
    1c80:	ea e9       	ldi	r30, 0x9A	; 154
    1c82:	f6 e0       	ldi	r31, 0x06	; 6
    1c84:	80 81       	ld	r24, Z
    1c86:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1c8a:	af 81       	ldd	r26, Y+7	; 0x07
    1c8c:	b8 85       	ldd	r27, Y+8	; 0x08
    1c8e:	57 96       	adiw	r26, 0x17	; 23
    1c90:	8c 93       	st	X, r24
  packet_payload[24] = SVIT_check_V_critical( svit[BATTERY_2].name );
    1c92:	e4 eb       	ldi	r30, 0xB4	; 180
    1c94:	f6 e0       	ldi	r31, 0x06	; 6
    1c96:	80 81       	ld	r24, Z
    1c98:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1c9c:	af 81       	ldd	r26, Y+7	; 0x07
    1c9e:	b8 85       	ldd	r27, Y+8	; 0x08
    1ca0:	58 96       	adiw	r26, 0x18	; 24
    1ca2:	8c 93       	st	X, r24
  packet_payload[25] = SVIT_check_V_critical( svit[SOLAR_FULL].name );
    1ca4:	ee ec       	ldi	r30, 0xCE	; 206
    1ca6:	f6 e0       	ldi	r31, 0x06	; 6
    1ca8:	80 81       	ld	r24, Z
    1caa:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1cae:	af 81       	ldd	r26, Y+7	; 0x07
    1cb0:	b8 85       	ldd	r27, Y+8	; 0x08
    1cb2:	59 96       	adiw	r26, 0x19	; 25
    1cb4:	8c 93       	st	X, r24
  packet_payload[26] = SVIT_check_V_critical( svit[SOLAR_1].name );
    1cb6:	e8 ee       	ldi	r30, 0xE8	; 232
    1cb8:	f6 e0       	ldi	r31, 0x06	; 6
    1cba:	80 81       	ld	r24, Z
    1cbc:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1cc0:	af 81       	ldd	r26, Y+7	; 0x07
    1cc2:	b8 85       	ldd	r27, Y+8	; 0x08
    1cc4:	5a 96       	adiw	r26, 0x1a	; 26
    1cc6:	8c 93       	st	X, r24
  packet_payload[27] = SVIT_check_V_critical( svit[SOLAR_2].name );
    1cc8:	e2 e0       	ldi	r30, 0x02	; 2
    1cca:	f7 e0       	ldi	r31, 0x07	; 7
    1ccc:	80 81       	ld	r24, Z
    1cce:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1cd2:	af 81       	ldd	r26, Y+7	; 0x07
    1cd4:	b8 85       	ldd	r27, Y+8	; 0x08
    1cd6:	5b 96       	adiw	r26, 0x1b	; 27
    1cd8:	8c 93       	st	X, r24
  packet_payload[28] = SVIT_check_V_critical( svit[SOLAR_3].name );
    1cda:	ec e1       	ldi	r30, 0x1C	; 28
    1cdc:	f7 e0       	ldi	r31, 0x07	; 7
    1cde:	80 81       	ld	r24, Z
    1ce0:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1ce4:	af 81       	ldd	r26, Y+7	; 0x07
    1ce6:	b8 85       	ldd	r27, Y+8	; 0x08
    1ce8:	5c 96       	adiw	r26, 0x1c	; 28
    1cea:	8c 93       	st	X, r24
  packet_payload[29] = SVIT_check_V_critical( svit[SOLAR_4].name );
    1cec:	e6 e3       	ldi	r30, 0x36	; 54
    1cee:	f7 e0       	ldi	r31, 0x07	; 7
    1cf0:	80 81       	ld	r24, Z
    1cf2:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1cf6:	af 81       	ldd	r26, Y+7	; 0x07
    1cf8:	b8 85       	ldd	r27, Y+8	; 0x08
    1cfa:	5d 96       	adiw	r26, 0x1d	; 29
    1cfc:	8c 93       	st	X, r24
  packet_payload[30] = SVIT_check_V_critical( svit[SOLAR_5].name );
    1cfe:	e0 e5       	ldi	r30, 0x50	; 80
    1d00:	f7 e0       	ldi	r31, 0x07	; 7
    1d02:	80 81       	ld	r24, Z
    1d04:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1d08:	af 81       	ldd	r26, Y+7	; 0x07
    1d0a:	b8 85       	ldd	r27, Y+8	; 0x08
    1d0c:	5e 96       	adiw	r26, 0x1e	; 30
    1d0e:	8c 93       	st	X, r24
  packet_payload[31] = SVIT_check_V_critical( svit[SOLAR_6].name );
    1d10:	ea e6       	ldi	r30, 0x6A	; 106
    1d12:	f7 e0       	ldi	r31, 0x07	; 7
    1d14:	80 81       	ld	r24, Z
    1d16:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1d1a:	af 81       	ldd	r26, Y+7	; 0x07
    1d1c:	b8 85       	ldd	r27, Y+8	; 0x08
    1d1e:	5f 96       	adiw	r26, 0x1f	; 31
    1d20:	8c 93       	st	X, r24
  packet_payload[32] = SVIT_check_V_critical( svit[SOLAR_7].name );
    1d22:	e4 e8       	ldi	r30, 0x84	; 132
    1d24:	f7 e0       	ldi	r31, 0x07	; 7
    1d26:	80 81       	ld	r24, Z
    1d28:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1d2c:	af 81       	ldd	r26, Y+7	; 0x07
    1d2e:	b8 85       	ldd	r27, Y+8	; 0x08
    1d30:	90 96       	adiw	r26, 0x20	; 32
    1d32:	8c 93       	st	X, r24
  packet_payload[33] = SVIT_check_V_critical( svit[SOLAR_8].name );
    1d34:	ee e9       	ldi	r30, 0x9E	; 158
    1d36:	f7 e0       	ldi	r31, 0x07	; 7
    1d38:	80 81       	ld	r24, Z
    1d3a:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1d3e:	af 81       	ldd	r26, Y+7	; 0x07
    1d40:	b8 85       	ldd	r27, Y+8	; 0x08
    1d42:	91 96       	adiw	r26, 0x21	; 33
    1d44:	8c 93       	st	X, r24
  packet_payload[34] = SVIT_check_V_critical( svit[SOLAR_9].name );
    1d46:	e8 eb       	ldi	r30, 0xB8	; 184
    1d48:	f7 e0       	ldi	r31, 0x07	; 7
    1d4a:	80 81       	ld	r24, Z
    1d4c:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1d50:	af 81       	ldd	r26, Y+7	; 0x07
    1d52:	b8 85       	ldd	r27, Y+8	; 0x08
    1d54:	92 96       	adiw	r26, 0x22	; 34
    1d56:	8c 93       	st	X, r24
  packet_payload[35] = SVIT_check_V_critical( svit[SOLAR_10].name );
    1d58:	e2 ed       	ldi	r30, 0xD2	; 210
    1d5a:	f7 e0       	ldi	r31, 0x07	; 7
    1d5c:	80 81       	ld	r24, Z
    1d5e:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1d62:	af 81       	ldd	r26, Y+7	; 0x07
    1d64:	b8 85       	ldd	r27, Y+8	; 0x08
    1d66:	93 96       	adiw	r26, 0x23	; 35
    1d68:	8c 93       	st	X, r24
  packet_payload[36] = SVIT_check_V_critical( svit[SOLAR_11].name );
    1d6a:	ec ee       	ldi	r30, 0xEC	; 236
    1d6c:	f7 e0       	ldi	r31, 0x07	; 7
    1d6e:	80 81       	ld	r24, Z
    1d70:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1d74:	af 81       	ldd	r26, Y+7	; 0x07
    1d76:	b8 85       	ldd	r27, Y+8	; 0x08
    1d78:	94 96       	adiw	r26, 0x24	; 36
    1d7a:	8c 93       	st	X, r24
  packet_payload[37] = SVIT_check_V_critical( svit[SOLAR_12].name );
    1d7c:	e6 e0       	ldi	r30, 0x06	; 6
    1d7e:	f8 e0       	ldi	r31, 0x08	; 8
    1d80:	80 81       	ld	r24, Z
    1d82:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1d86:	af 81       	ldd	r26, Y+7	; 0x07
    1d88:	b8 85       	ldd	r27, Y+8	; 0x08
    1d8a:	95 96       	adiw	r26, 0x25	; 37
    1d8c:	8c 93       	st	X, r24
  packet_payload[38] = SVIT_check_V_critical( svit[POWER_BOARD].name );
    1d8e:	80 91 20 08 	lds	r24, 0x0820
    1d92:	0e 94 b2 08 	call	0x1164	; 0x1164 <SVIT_check_V_critical>
    1d96:	ef 81       	ldd	r30, Y+7	; 0x07
    1d98:	f8 85       	ldd	r31, Y+8	; 0x08
    1d9a:	86 a3       	std	Z+38, r24	; 0x26
  //uint8_t voltage_error1;
  //uint8_t voltage_error2;
  //uint8_t voltage_error3;
  //uint8_t voltage_error4;
 
  packet_payload[39] = 0;
    1d9c:	17 a2       	std	Z+39, r1	; 0x27
  packet_payload[40] = 0;
    1d9e:	10 a6       	std	Z+40, r1	; 0x28
  packet_payload[41] = 0;
    1da0:	11 a6       	std	Z+41, r1	; 0x29
  packet_payload[42] = 0;
    1da2:	12 a6       	std	Z+42, r1	; 0x2a
  packet_payload[43] = 0;
    1da4:	13 a6       	std	Z+43, r1	; 0x2b

  // current values (raw ADC output)
  packet_payload[44] = SVIT_check_I_critical( svit[SPECTROMETER].name );
    1da6:	d3 01       	movw	r26, r6
    1da8:	8c 91       	ld	r24, X
    1daa:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1dae:	ef 81       	ldd	r30, Y+7	; 0x07
    1db0:	f8 85       	ldd	r31, Y+8	; 0x08
    1db2:	84 a7       	std	Z+44, r24	; 0x2c
  packet_payload[45] = SVIT_check_I_critical( svit[STAR_TRACKER].name );
    1db4:	d4 01       	movw	r26, r8
    1db6:	8c 91       	ld	r24, X
    1db8:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1dbc:	ef 81       	ldd	r30, Y+7	; 0x07
    1dbe:	f8 85       	ldd	r31, Y+8	; 0x08
    1dc0:	85 a7       	std	Z+45, r24	; 0x2d
  packet_payload[46] = SVIT_check_I_critical( svit[FC_5V].name );
    1dc2:	d5 01       	movw	r26, r10
    1dc4:	8c 91       	ld	r24, X
    1dc6:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1dca:	ef 81       	ldd	r30, Y+7	; 0x07
    1dcc:	f8 85       	ldd	r31, Y+8	; 0x08
    1dce:	86 a7       	std	Z+46, r24	; 0x2e
  packet_payload[47] = SVIT_check_I_critical( svit[FC_3_3V].name );
    1dd0:	d6 01       	movw	r26, r12
    1dd2:	8c 91       	ld	r24, X
    1dd4:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1dd8:	ef 81       	ldd	r30, Y+7	; 0x07
    1dda:	f8 85       	ldd	r31, Y+8	; 0x08
    1ddc:	87 a7       	std	Z+47, r24	; 0x2f
  packet_payload[48] = SVIT_check_I_critical( svit[GPS_1].name );
    1dde:	d7 01       	movw	r26, r14
    1de0:	8c 91       	ld	r24, X
    1de2:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1de6:	ef 81       	ldd	r30, Y+7	; 0x07
    1de8:	f8 85       	ldd	r31, Y+8	; 0x08
    1dea:	80 ab       	std	Z+48, r24	; 0x30
  packet_payload[49] = SVIT_check_I_critical( svit[CDH_IB].name );
    1dec:	d8 01       	movw	r26, r16
    1dee:	8c 91       	ld	r24, X
    1df0:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1df4:	ef 81       	ldd	r30, Y+7	; 0x07
    1df6:	f8 85       	ldd	r31, Y+8	; 0x08
    1df8:	81 ab       	std	Z+49, r24	; 0x31
  packet_payload[50] = SVIT_check_I_critical( svit[HEATER_1].name );
    1dfa:	a8 e4       	ldi	r26, 0x48	; 72
    1dfc:	b5 e0       	ldi	r27, 0x05	; 5
    1dfe:	8c 91       	ld	r24, X
    1e00:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1e04:	ef 81       	ldd	r30, Y+7	; 0x07
    1e06:	f8 85       	ldd	r31, Y+8	; 0x08
    1e08:	82 ab       	std	Z+50, r24	; 0x32
  packet_payload[51] = SVIT_check_I_critical( svit[HEATER_2].name );
    1e0a:	d2 01       	movw	r26, r4
    1e0c:	8c 91       	ld	r24, X
    1e0e:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1e12:	ef 81       	ldd	r30, Y+7	; 0x07
    1e14:	f8 85       	ldd	r31, Y+8	; 0x08
    1e16:	83 ab       	std	Z+51, r24	; 0x33
  packet_payload[52] = SVIT_check_I_critical( svit[CMG].name );
    1e18:	d1 01       	movw	r26, r2
    1e1a:	8c 91       	ld	r24, X
    1e1c:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1e20:	ef 81       	ldd	r30, Y+7	; 0x07
    1e22:	f8 85       	ldd	r31, Y+8	; 0x08
    1e24:	84 ab       	std	Z+52, r24	; 0x34
  packet_payload[53] = SVIT_check_I_critical( svit[SUN_SENSOR].name );
    1e26:	29 81       	ldd	r18, Y+1	; 0x01
    1e28:	3a 81       	ldd	r19, Y+2	; 0x02
    1e2a:	d9 01       	movw	r26, r18
    1e2c:	8c 91       	ld	r24, X
    1e2e:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1e32:	ef 81       	ldd	r30, Y+7	; 0x07
    1e34:	f8 85       	ldd	r31, Y+8	; 0x08
    1e36:	85 ab       	std	Z+53, r24	; 0x35
  packet_payload[54] = SVIT_check_I_critical( svit[RADIO_1].name );
    1e38:	4b 81       	ldd	r20, Y+3	; 0x03
    1e3a:	5c 81       	ldd	r21, Y+4	; 0x04
    1e3c:	da 01       	movw	r26, r20
    1e3e:	8c 91       	ld	r24, X
    1e40:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1e44:	ef 81       	ldd	r30, Y+7	; 0x07
    1e46:	f8 85       	ldd	r31, Y+8	; 0x08
    1e48:	86 ab       	std	Z+54, r24	; 0x36
  packet_payload[55] = SVIT_check_I_critical( svit[RADIO_2].name );
    1e4a:	6d 81       	ldd	r22, Y+5	; 0x05
    1e4c:	7e 81       	ldd	r23, Y+6	; 0x06
    1e4e:	db 01       	movw	r26, r22
    1e50:	8c 91       	ld	r24, X
    1e52:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1e56:	ef 81       	ldd	r30, Y+7	; 0x07
    1e58:	f8 85       	ldd	r31, Y+8	; 0x08
    1e5a:	87 ab       	std	Z+55, r24	; 0x37
  packet_payload[56] = SVIT_check_I_critical( svit[FOG_15V].name );
    1e5c:	a8 e1       	ldi	r26, 0x18	; 24
    1e5e:	b6 e0       	ldi	r27, 0x06	; 6
    1e60:	8c 91       	ld	r24, X
    1e62:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1e66:	ef 81       	ldd	r30, Y+7	; 0x07
    1e68:	f8 85       	ldd	r31, Y+8	; 0x08
    1e6a:	80 af       	std	Z+56, r24	; 0x38
  packet_payload[57] = SVIT_check_I_critical( svit[FOG_5V].name );
    1e6c:	a2 e3       	ldi	r26, 0x32	; 50
    1e6e:	b6 e0       	ldi	r27, 0x06	; 6
    1e70:	8c 91       	ld	r24, X
    1e72:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1e76:	ef 81       	ldd	r30, Y+7	; 0x07
    1e78:	f8 85       	ldd	r31, Y+8	; 0x08
    1e7a:	81 af       	std	Z+57, r24	; 0x39
  packet_payload[58] = SVIT_check_I_critical( svit[TORQUER_1].name );
    1e7c:	ac e4       	ldi	r26, 0x4C	; 76
    1e7e:	b6 e0       	ldi	r27, 0x06	; 6
    1e80:	8c 91       	ld	r24, X
    1e82:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1e86:	ef 81       	ldd	r30, Y+7	; 0x07
    1e88:	f8 85       	ldd	r31, Y+8	; 0x08
    1e8a:	82 af       	std	Z+58, r24	; 0x3a
  packet_payload[59] = SVIT_check_I_critical( svit[TORQUER_2].name );
    1e8c:	a6 e6       	ldi	r26, 0x66	; 102
    1e8e:	b6 e0       	ldi	r27, 0x06	; 6
    1e90:	8c 91       	ld	r24, X
    1e92:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1e96:	ef 81       	ldd	r30, Y+7	; 0x07
    1e98:	f8 85       	ldd	r31, Y+8	; 0x08
    1e9a:	83 af       	std	Z+59, r24	; 0x3b
  packet_payload[60] = SVIT_check_I_critical( svit[TORQUER_3].name );
    1e9c:	a0 e8       	ldi	r26, 0x80	; 128
    1e9e:	b6 e0       	ldi	r27, 0x06	; 6
    1ea0:	8c 91       	ld	r24, X
    1ea2:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1ea6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ea8:	f8 85       	ldd	r31, Y+8	; 0x08
    1eaa:	84 af       	std	Z+60, r24	; 0x3c
  packet_payload[61] = SVIT_check_I_critical( svit[BATTERY_1].name );
    1eac:	aa e9       	ldi	r26, 0x9A	; 154
    1eae:	b6 e0       	ldi	r27, 0x06	; 6
    1eb0:	8c 91       	ld	r24, X
    1eb2:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1eb6:	ef 81       	ldd	r30, Y+7	; 0x07
    1eb8:	f8 85       	ldd	r31, Y+8	; 0x08
    1eba:	85 af       	std	Z+61, r24	; 0x3d
  packet_payload[62] = SVIT_check_I_critical( svit[BATTERY_2].name );
    1ebc:	a4 eb       	ldi	r26, 0xB4	; 180
    1ebe:	b6 e0       	ldi	r27, 0x06	; 6
    1ec0:	8c 91       	ld	r24, X
    1ec2:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1ec6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ec8:	f8 85       	ldd	r31, Y+8	; 0x08
    1eca:	86 af       	std	Z+62, r24	; 0x3e
  packet_payload[63] = SVIT_check_I_critical( svit[SOLAR_FULL].name );
    1ecc:	ae ec       	ldi	r26, 0xCE	; 206
    1ece:	b6 e0       	ldi	r27, 0x06	; 6
    1ed0:	8c 91       	ld	r24, X
    1ed2:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1ed6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ed8:	f8 85       	ldd	r31, Y+8	; 0x08
    1eda:	87 af       	std	Z+63, r24	; 0x3f
  packet_payload[64] = SVIT_check_I_critical( svit[SOLAR_1].name );
    1edc:	a8 ee       	ldi	r26, 0xE8	; 232
    1ede:	b6 e0       	ldi	r27, 0x06	; 6
    1ee0:	8c 91       	ld	r24, X
    1ee2:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1ee6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ee8:	f8 85       	ldd	r31, Y+8	; 0x08
    1eea:	e0 5c       	subi	r30, 0xC0	; 192
    1eec:	ff 4f       	sbci	r31, 0xFF	; 255
    1eee:	80 83       	st	Z, r24
  packet_payload[65] = SVIT_check_I_critical( svit[SOLAR_2].name );
    1ef0:	e2 e0       	ldi	r30, 0x02	; 2
    1ef2:	f7 e0       	ldi	r31, 0x07	; 7
    1ef4:	80 81       	ld	r24, Z
    1ef6:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1efa:	ef 81       	ldd	r30, Y+7	; 0x07
    1efc:	f8 85       	ldd	r31, Y+8	; 0x08
    1efe:	ef 5b       	subi	r30, 0xBF	; 191
    1f00:	ff 4f       	sbci	r31, 0xFF	; 255
    1f02:	80 83       	st	Z, r24
  packet_payload[66] = SVIT_check_I_critical( svit[SOLAR_3].name );
    1f04:	ac e1       	ldi	r26, 0x1C	; 28
    1f06:	b7 e0       	ldi	r27, 0x07	; 7
    1f08:	8c 91       	ld	r24, X
    1f0a:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1f0e:	ef 81       	ldd	r30, Y+7	; 0x07
    1f10:	f8 85       	ldd	r31, Y+8	; 0x08
    1f12:	ee 5b       	subi	r30, 0xBE	; 190
    1f14:	ff 4f       	sbci	r31, 0xFF	; 255
    1f16:	80 83       	st	Z, r24
  packet_payload[67] = SVIT_check_I_critical( svit[SOLAR_4].name );
    1f18:	e6 e3       	ldi	r30, 0x36	; 54
    1f1a:	f7 e0       	ldi	r31, 0x07	; 7
    1f1c:	80 81       	ld	r24, Z
    1f1e:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1f22:	ef 81       	ldd	r30, Y+7	; 0x07
    1f24:	f8 85       	ldd	r31, Y+8	; 0x08
    1f26:	ed 5b       	subi	r30, 0xBD	; 189
    1f28:	ff 4f       	sbci	r31, 0xFF	; 255
    1f2a:	80 83       	st	Z, r24
  packet_payload[68] = SVIT_check_I_critical( svit[SOLAR_5].name );
    1f2c:	a0 e5       	ldi	r26, 0x50	; 80
    1f2e:	b7 e0       	ldi	r27, 0x07	; 7
    1f30:	8c 91       	ld	r24, X
    1f32:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1f36:	ef 81       	ldd	r30, Y+7	; 0x07
    1f38:	f8 85       	ldd	r31, Y+8	; 0x08
    1f3a:	ec 5b       	subi	r30, 0xBC	; 188
    1f3c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f3e:	80 83       	st	Z, r24
  packet_payload[69] = SVIT_check_I_critical( svit[SOLAR_6].name );
    1f40:	ea e6       	ldi	r30, 0x6A	; 106
    1f42:	f7 e0       	ldi	r31, 0x07	; 7
    1f44:	80 81       	ld	r24, Z
    1f46:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1f4a:	ef 81       	ldd	r30, Y+7	; 0x07
    1f4c:	f8 85       	ldd	r31, Y+8	; 0x08
    1f4e:	eb 5b       	subi	r30, 0xBB	; 187
    1f50:	ff 4f       	sbci	r31, 0xFF	; 255
    1f52:	80 83       	st	Z, r24
  packet_payload[70] = SVIT_check_I_critical( svit[SOLAR_7].name );
    1f54:	a4 e8       	ldi	r26, 0x84	; 132
    1f56:	b7 e0       	ldi	r27, 0x07	; 7
    1f58:	8c 91       	ld	r24, X
    1f5a:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1f5e:	ef 81       	ldd	r30, Y+7	; 0x07
    1f60:	f8 85       	ldd	r31, Y+8	; 0x08
    1f62:	ea 5b       	subi	r30, 0xBA	; 186
    1f64:	ff 4f       	sbci	r31, 0xFF	; 255
    1f66:	80 83       	st	Z, r24
  packet_payload[71] = SVIT_check_I_critical( svit[SOLAR_8].name );
    1f68:	ee e9       	ldi	r30, 0x9E	; 158
    1f6a:	f7 e0       	ldi	r31, 0x07	; 7
    1f6c:	80 81       	ld	r24, Z
    1f6e:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1f72:	ef 81       	ldd	r30, Y+7	; 0x07
    1f74:	f8 85       	ldd	r31, Y+8	; 0x08
    1f76:	e9 5b       	subi	r30, 0xB9	; 185
    1f78:	ff 4f       	sbci	r31, 0xFF	; 255
    1f7a:	80 83       	st	Z, r24
  packet_payload[72] = SVIT_check_I_critical( svit[SOLAR_9].name );
    1f7c:	a8 eb       	ldi	r26, 0xB8	; 184
    1f7e:	b7 e0       	ldi	r27, 0x07	; 7
    1f80:	8c 91       	ld	r24, X
    1f82:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1f86:	ef 81       	ldd	r30, Y+7	; 0x07
    1f88:	f8 85       	ldd	r31, Y+8	; 0x08
    1f8a:	e8 5b       	subi	r30, 0xB8	; 184
    1f8c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f8e:	80 83       	st	Z, r24
  packet_payload[73] = SVIT_check_I_critical( svit[SOLAR_10].name );
    1f90:	e2 ed       	ldi	r30, 0xD2	; 210
    1f92:	f7 e0       	ldi	r31, 0x07	; 7
    1f94:	80 81       	ld	r24, Z
    1f96:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1f9a:	ef 81       	ldd	r30, Y+7	; 0x07
    1f9c:	f8 85       	ldd	r31, Y+8	; 0x08
    1f9e:	e7 5b       	subi	r30, 0xB7	; 183
    1fa0:	ff 4f       	sbci	r31, 0xFF	; 255
    1fa2:	80 83       	st	Z, r24
  packet_payload[74] = SVIT_check_I_critical( svit[SOLAR_11].name );
    1fa4:	ac ee       	ldi	r26, 0xEC	; 236
    1fa6:	b7 e0       	ldi	r27, 0x07	; 7
    1fa8:	8c 91       	ld	r24, X
    1faa:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1fae:	ef 81       	ldd	r30, Y+7	; 0x07
    1fb0:	f8 85       	ldd	r31, Y+8	; 0x08
    1fb2:	e6 5b       	subi	r30, 0xB6	; 182
    1fb4:	ff 4f       	sbci	r31, 0xFF	; 255
    1fb6:	80 83       	st	Z, r24
  packet_payload[75] = SVIT_check_I_critical( svit[SOLAR_12].name );
    1fb8:	e6 e0       	ldi	r30, 0x06	; 6
    1fba:	f8 e0       	ldi	r31, 0x08	; 8
    1fbc:	80 81       	ld	r24, Z
    1fbe:	0e 94 a3 08 	call	0x1146	; 0x1146 <SVIT_check_I_critical>
    1fc2:	ef 81       	ldd	r30, Y+7	; 0x07
    1fc4:	f8 85       	ldd	r31, Y+8	; 0x08
    1fc6:	e5 5b       	subi	r30, 0xB5	; 181
    1fc8:	ff 4f       	sbci	r31, 0xFF	; 255
    1fca:	80 83       	st	Z, r24
  packet_payload[76] = 0xFF;//SVIT_check_I_critical( svit[POWER_BOARD].name );
    1fcc:	ef 81       	ldd	r30, Y+7	; 0x07
    1fce:	f8 85       	ldd	r31, Y+8	; 0x08
    1fd0:	e4 5b       	subi	r30, 0xB4	; 180
    1fd2:	ff 4f       	sbci	r31, 0xFF	; 255
    1fd4:	8f ef       	ldi	r24, 0xFF	; 255
    1fd6:	80 83       	st	Z, r24
  //uint8_t current_error1;
  //uint8_t current_error2;
  //uint8_t current_error3;
  //uint8_t current_error4;

  packet_payload[77] = batt1_voltage;//V_ack_change();
    1fd8:	ef 81       	ldd	r30, Y+7	; 0x07
    1fda:	f8 85       	ldd	r31, Y+8	; 0x08
    1fdc:	e3 5b       	subi	r30, 0xB3	; 179
    1fde:	ff 4f       	sbci	r31, 0xFF	; 255
    1fe0:	90 91 81 0a 	lds	r25, 0x0A81
    1fe4:	90 83       	st	Z, r25
  packet_payload[78] = soc;//soc;// I_ack_change();
    1fe6:	ef 81       	ldd	r30, Y+7	; 0x07
    1fe8:	f8 85       	ldd	r31, Y+8	; 0x08
    1fea:	e2 5b       	subi	r30, 0xB2	; 178
    1fec:	ff 4f       	sbci	r31, 0xFF	; 255
    1fee:	90 91 bf 10 	lds	r25, 0x10BF
    1ff2:	90 83       	st	Z, r25
  packet_payload[79] = 0x00;//low >> 6;//safe_mode;
    1ff4:	ef 81       	ldd	r30, Y+7	; 0x07
    1ff6:	f8 85       	ldd	r31, Y+8	; 0x08
    1ff8:	e1 5b       	subi	r30, 0xB1	; 177
    1ffa:	ff 4f       	sbci	r31, 0xFF	; 255
    1ffc:	10 82       	st	Z, r1
  packet_payload[80] = 0x00;//charging;
    1ffe:	ef 81       	ldd	r30, Y+7	; 0x07
    2000:	f8 85       	ldd	r31, Y+8	; 0x08
    2002:	e0 5b       	subi	r30, 0xB0	; 176
    2004:	ff 4f       	sbci	r31, 0xFF	; 255
    2006:	10 82       	st	Z, r1
  packet_payload[81] = 0x00;//chargeforward;
    2008:	ef 81       	ldd	r30, Y+7	; 0x07
    200a:	f8 85       	ldd	r31, Y+8	; 0x08
    200c:	ef 5a       	subi	r30, 0xAF	; 175
    200e:	ff 4f       	sbci	r31, 0xFF	; 255
    2010:	10 82       	st	Z, r1

  // temperature values (raw ADC output)
  packet_payload[82] = debug;//average_samples( svit[STAR_TRACKER].T_samples );
    2012:	ef 81       	ldd	r30, Y+7	; 0x07
    2014:	f8 85       	ldd	r31, Y+8	; 0x08
    2016:	ee 5a       	subi	r30, 0xAE	; 174
    2018:	ff 4f       	sbci	r31, 0xFF	; 255
    201a:	90 91 49 08 	lds	r25, 0x0849
    201e:	90 83       	st	Z, r25
  packet_payload[83] = 0xFF;//average_samples( svit[BATTERY_1].T_samples );
    2020:	ef 81       	ldd	r30, Y+7	; 0x07
    2022:	f8 85       	ldd	r31, Y+8	; 0x08
    2024:	ed 5a       	subi	r30, 0xAD	; 173
    2026:	ff 4f       	sbci	r31, 0xFF	; 255
    2028:	80 83       	st	Z, r24
  packet_payload[84] = average_samples( svit[BATTERY_2].T_samples );
    202a:	8a ec       	ldi	r24, 0xCA	; 202
    202c:	96 e0       	ldi	r25, 0x06	; 6
    202e:	0e 94 94 08 	call	0x1128	; 0x1128 <average_samples>
    2032:	ef 81       	ldd	r30, Y+7	; 0x07
    2034:	f8 85       	ldd	r31, Y+8	; 0x08
    2036:	ec 5a       	subi	r30, 0xAC	; 172
    2038:	ff 4f       	sbci	r31, 0xFF	; 255
    203a:	80 83       	st	Z, r24
  packet_payload[85] = average_samples( svit[SOLAR_1].T_samples );
    203c:	8e ef       	ldi	r24, 0xFE	; 254
    203e:	96 e0       	ldi	r25, 0x06	; 6
    2040:	0e 94 94 08 	call	0x1128	; 0x1128 <average_samples>
    2044:	ef 81       	ldd	r30, Y+7	; 0x07
    2046:	f8 85       	ldd	r31, Y+8	; 0x08
    2048:	eb 5a       	subi	r30, 0xAB	; 171
    204a:	ff 4f       	sbci	r31, 0xFF	; 255
    204c:	80 83       	st	Z, r24
  packet_payload[86] = average_samples( svit[SOLAR_2].T_samples );
    204e:	88 e1       	ldi	r24, 0x18	; 24
    2050:	97 e0       	ldi	r25, 0x07	; 7
    2052:	0e 94 94 08 	call	0x1128	; 0x1128 <average_samples>
    2056:	ef 81       	ldd	r30, Y+7	; 0x07
    2058:	f8 85       	ldd	r31, Y+8	; 0x08
    205a:	ea 5a       	subi	r30, 0xAA	; 170
    205c:	ff 4f       	sbci	r31, 0xFF	; 255
    205e:	80 83       	st	Z, r24
  packet_payload[87] = average_samples( svit[SOLAR_3].T_samples );
    2060:	82 e3       	ldi	r24, 0x32	; 50
    2062:	97 e0       	ldi	r25, 0x07	; 7
    2064:	0e 94 94 08 	call	0x1128	; 0x1128 <average_samples>
    2068:	ef 81       	ldd	r30, Y+7	; 0x07
    206a:	f8 85       	ldd	r31, Y+8	; 0x08
    206c:	e9 5a       	subi	r30, 0xA9	; 169
    206e:	ff 4f       	sbci	r31, 0xFF	; 255
    2070:	80 83       	st	Z, r24
  packet_payload[88] = average_samples( svit[SOLAR_4].T_samples );
    2072:	8c e4       	ldi	r24, 0x4C	; 76
    2074:	97 e0       	ldi	r25, 0x07	; 7
    2076:	0e 94 94 08 	call	0x1128	; 0x1128 <average_samples>
    207a:	ef 81       	ldd	r30, Y+7	; 0x07
    207c:	f8 85       	ldd	r31, Y+8	; 0x08
    207e:	e8 5a       	subi	r30, 0xA8	; 168
    2080:	ff 4f       	sbci	r31, 0xFF	; 255
    2082:	80 83       	st	Z, r24
  packet_payload[89] = average_samples( svit[SOLAR_5].T_samples );
    2084:	86 e6       	ldi	r24, 0x66	; 102
    2086:	97 e0       	ldi	r25, 0x07	; 7
    2088:	0e 94 94 08 	call	0x1128	; 0x1128 <average_samples>
    208c:	ef 81       	ldd	r30, Y+7	; 0x07
    208e:	f8 85       	ldd	r31, Y+8	; 0x08
    2090:	e7 5a       	subi	r30, 0xA7	; 167
    2092:	ff 4f       	sbci	r31, 0xFF	; 255
    2094:	80 83       	st	Z, r24
  packet_payload[90] = average_samples( svit[SOLAR_9].T_samples );
    2096:	8e ec       	ldi	r24, 0xCE	; 206
    2098:	97 e0       	ldi	r25, 0x07	; 7
    209a:	0e 94 94 08 	call	0x1128	; 0x1128 <average_samples>
    209e:	ef 81       	ldd	r30, Y+7	; 0x07
    20a0:	f8 85       	ldd	r31, Y+8	; 0x08
    20a2:	e6 5a       	subi	r30, 0xA6	; 166
    20a4:	ff 4f       	sbci	r31, 0xFF	; 255
    20a6:	80 83       	st	Z, r24
  packet_payload[91] = average_samples( svit[POWER_BOARD].T_samples );
    20a8:	86 e3       	ldi	r24, 0x36	; 54
    20aa:	98 e0       	ldi	r25, 0x08	; 8
    20ac:	0e 94 94 08 	call	0x1128	; 0x1128 <average_samples>
    20b0:	ef 81       	ldd	r30, Y+7	; 0x07
    20b2:	f8 85       	ldd	r31, Y+8	; 0x08
    20b4:	e5 5a       	subi	r30, 0xA5	; 165
    20b6:	ff 4f       	sbci	r31, 0xFF	; 255
    20b8:	80 83       	st	Z, r24

uint8_t V_ack_change( void )
{
  uint8_t temp;

  temp = V_upper_val_change;
    20ba:	80 91 91 0c 	lds	r24, 0x0C91
  V_upper_val_change = 0;
    20be:	10 92 91 0c 	sts	0x0C91, r1
  //uint8_t temperature_error1;
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
    20c2:	ef 81       	ldd	r30, Y+7	; 0x07
    20c4:	f8 85       	ldd	r31, Y+8	; 0x08
    20c6:	e4 5a       	subi	r30, 0xA4	; 164
    20c8:	ff 4f       	sbci	r31, 0xFF	; 255
    20ca:	80 83       	st	Z, r24

uint8_t I_ack_change( void )
{
  uint8_t temp;

  temp = I_upper_val_change;
    20cc:	80 91 8c 0c 	lds	r24, 0x0C8C
  I_upper_val_change = 0;
    20d0:	10 92 8c 0c 	sts	0x0C8C, r1
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
  packet_payload[93] = I_ack_change();
    20d4:	ef 81       	ldd	r30, Y+7	; 0x07
    20d6:	f8 85       	ldd	r31, Y+8	; 0x08
    20d8:	e3 5a       	subi	r30, 0xA3	; 163
    20da:	ff 4f       	sbci	r31, 0xFF	; 255
    20dc:	80 83       	st	Z, r24
}
    20de:	28 96       	adiw	r28, 0x08	; 8
    20e0:	0f b6       	in	r0, 0x3f	; 63
    20e2:	f8 94       	cli
    20e4:	de bf       	out	0x3e, r29	; 62
    20e6:	0f be       	out	0x3f, r0	; 63
    20e8:	cd bf       	out	0x3d, r28	; 61
    20ea:	df 91       	pop	r29
    20ec:	cf 91       	pop	r28
    20ee:	1f 91       	pop	r17
    20f0:	0f 91       	pop	r16
    20f2:	ff 90       	pop	r15
    20f4:	ef 90       	pop	r14
    20f6:	df 90       	pop	r13
    20f8:	cf 90       	pop	r12
    20fa:	bf 90       	pop	r11
    20fc:	af 90       	pop	r10
    20fe:	9f 90       	pop	r9
    2100:	8f 90       	pop	r8
    2102:	7f 90       	pop	r7
    2104:	6f 90       	pop	r6
    2106:	5f 90       	pop	r5
    2108:	4f 90       	pop	r4
    210a:	3f 90       	pop	r3
    210c:	2f 90       	pop	r2
    210e:	08 95       	ret

00002110 <transmit_packet>:

void transmit_packet( uint8_t uart, uint8_t packet_type, uint8_t ack_command )
{
    2110:	6f 92       	push	r6
    2112:	7f 92       	push	r7
    2114:	8f 92       	push	r8
    2116:	9f 92       	push	r9
    2118:	bf 92       	push	r11
    211a:	cf 92       	push	r12
    211c:	df 92       	push	r13
    211e:	ef 92       	push	r14
    2120:	ff 92       	push	r15
    2122:	0f 93       	push	r16
    2124:	1f 93       	push	r17
    2126:	cf 93       	push	r28
    2128:	df 93       	push	r29
    212a:	b8 2e       	mov	r11, r24
  uint8_t VCP_tx_status;

  switch( packet_type )
    212c:	61 30       	cpi	r22, 0x01	; 1
    212e:	b9 f0       	breq	.+46     	; 0x215e <transmit_packet+0x4e>
    2130:	20 f0       	brcs	.+8      	; 0x213a <transmit_packet+0x2a>
    2132:	62 30       	cpi	r22, 0x02	; 2
    2134:	09 f0       	breq	.+2      	; 0x2138 <transmit_packet+0x28>
    2136:	8b c0       	rjmp	.+278    	; 0x224e <transmit_packet+0x13e>
    2138:	22 c0       	rjmp	.+68     	; 0x217e <transmit_packet+0x6e>
  {
    case VCP_POWER_TELEMETRY:
      construct_telemetry_packet( tel_packet_payload[uart] );
    213a:	c8 2f       	mov	r28, r24
    213c:	d0 e0       	ldi	r29, 0x00	; 0
    213e:	2f ef       	ldi	r18, 0xFF	; 255
    2140:	82 9f       	mul	r24, r18
    2142:	c0 01       	movw	r24, r0
    2144:	11 24       	eor	r1, r1
    2146:	8f 53       	subi	r24, 0x3F	; 63
    2148:	91 4f       	sbci	r25, 0xF1	; 241
    214a:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <construct_telemetry_packet>
      tel_packet_payload_size[uart] = 96;
    214e:	fe 01       	movw	r30, r28
    2150:	ee 0f       	add	r30, r30
    2152:	ff 1f       	adc	r31, r31
    2154:	e5 5b       	subi	r30, 0xB5	; 181
    2156:	f7 4f       	sbci	r31, 0xF7	; 247
    2158:	80 e6       	ldi	r24, 0x60	; 96
    215a:	90 e0       	ldi	r25, 0x00	; 0
    215c:	21 c0       	rjmp	.+66     	; 0x21a0 <transmit_packet+0x90>
      break;
    case VCP_INVALID_COMMAND:
      tel_packet_payload[uart][0] = VCP_INVALID_COMMAND;
    215e:	e8 2f       	mov	r30, r24
    2160:	f0 e0       	ldi	r31, 0x00	; 0
    2162:	8f ef       	ldi	r24, 0xFF	; 255
    2164:	b8 9e       	mul	r11, r24
    2166:	d0 01       	movw	r26, r0
    2168:	11 24       	eor	r1, r1
    216a:	af 53       	subi	r26, 0x3F	; 63
    216c:	b1 4f       	sbci	r27, 0xF1	; 241
    216e:	6c 93       	st	X, r22
      tel_packet_payload_size[uart] = 1;
    2170:	ee 0f       	add	r30, r30
    2172:	ff 1f       	adc	r31, r31
    2174:	e5 5b       	subi	r30, 0xB5	; 181
    2176:	f7 4f       	sbci	r31, 0xF7	; 247
    2178:	81 e0       	ldi	r24, 0x01	; 1
    217a:	90 e0       	ldi	r25, 0x00	; 0
    217c:	11 c0       	rjmp	.+34     	; 0x21a0 <transmit_packet+0x90>
      break;
    case VCP_ACK:
      tel_packet_payload[uart][0] = VCP_ACK;
    217e:	e8 2f       	mov	r30, r24
    2180:	f0 e0       	ldi	r31, 0x00	; 0
    2182:	2f ef       	ldi	r18, 0xFF	; 255
    2184:	82 9f       	mul	r24, r18
    2186:	d0 01       	movw	r26, r0
    2188:	11 24       	eor	r1, r1
    218a:	af 53       	subi	r26, 0x3F	; 63
    218c:	b1 4f       	sbci	r27, 0xF1	; 241
    218e:	6c 93       	st	X, r22
      tel_packet_payload[uart][1] = ack_command;
    2190:	11 96       	adiw	r26, 0x01	; 1
    2192:	4c 93       	st	X, r20
      tel_packet_payload_size[uart] = 2;
    2194:	ee 0f       	add	r30, r30
    2196:	ff 1f       	adc	r31, r31
    2198:	e5 5b       	subi	r30, 0xB5	; 181
    219a:	f7 4f       	sbci	r31, 0xF7	; 247
    219c:	82 e0       	ldi	r24, 0x02	; 2
    219e:	90 e0       	ldi	r25, 0x00	; 0
    21a0:	91 83       	std	Z+1, r25	; 0x01
    21a2:	80 83       	st	Z, r24
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    21a4:	8b 2c       	mov	r8, r11
    21a6:	91 2c       	mov	r9, r1
    21a8:	8f ef       	ldi	r24, 0xFF	; 255
    21aa:	b8 9e       	mul	r11, r24
    21ac:	70 01       	movw	r14, r0
    21ae:	11 24       	eor	r1, r1
    21b0:	e7 01       	movw	r28, r14
    21b2:	c4 57       	subi	r28, 0x74	; 116
    21b4:	d5 4f       	sbci	r29, 0xF5	; 245
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
    21b6:	64 01       	movw	r12, r8
    21b8:	cc 0c       	add	r12, r12
    21ba:	dd 1c       	adc	r13, r13
    21bc:	f6 01       	movw	r30, r12
    21be:	e5 5b       	subi	r30, 0xB5	; 181
    21c0:	f7 4f       	sbci	r31, 0xF7	; 247
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    21c2:	00 81       	ld	r16, Z
    21c4:	11 81       	ldd	r17, Z+1	; 0x01
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
    21c6:	97 01       	movw	r18, r14
    21c8:	2f 53       	subi	r18, 0x3F	; 63
    21ca:	31 4f       	sbci	r19, 0xF1	; 241
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    21cc:	a6 e9       	ldi	r26, 0x96	; 150
    21ce:	6a 2e       	mov	r6, r26
    21d0:	ae e0       	ldi	r26, 0x0E	; 14
    21d2:	7a 2e       	mov	r7, r26
    21d4:	6c 0c       	add	r6, r12
    21d6:	7d 1c       	adc	r7, r13
    21d8:	41 e0       	ldi	r20, 0x01	; 1
    21da:	b3 01       	movw	r22, r6
    21dc:	ce 01       	movw	r24, r28
    21de:	0e 94 1d 0a 	call	0x143a	; 0x143a <Create_VCP_frame>
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
                  );

  // VCP frame creation was successful
  if ( VCP_tx_status == VCP_TERM )
    21e2:	81 30       	cpi	r24, 0x01	; 1
    21e4:	a1 f5       	brne	.+104    	; 0x224e <transmit_packet+0x13e>
  {
    tel_packet_size[uart] = dest_size[uart];
    21e6:	f3 01       	movw	r30, r6
    21e8:	80 81       	ld	r24, Z
    21ea:	91 81       	ldd	r25, Z+1	; 0x01
    21ec:	f6 01       	movw	r30, r12
    21ee:	ed 57       	subi	r30, 0x7D	; 125
    21f0:	fb 4f       	sbci	r31, 0xFB	; 251
    21f2:	91 83       	std	Z+1, r25	; 0x01
    21f4:	80 83       	st	Z, r24
    memcpy( tel_packet[uart], dest_data[uart], tel_packet_size[uart] );
    21f6:	80 81       	ld	r24, Z
    21f8:	91 81       	ldd	r25, Z+1	; 0x01
    21fa:	97 01       	movw	r18, r14
    21fc:	26 5a       	subi	r18, 0xA6	; 166
    21fe:	37 4f       	sbci	r19, 0xF7	; 247
    2200:	ac 01       	movw	r20, r24
    2202:	be 01       	movw	r22, r28
    2204:	c9 01       	movw	r24, r18
    2206:	0e 94 1e 14 	call	0x283c	; 0x283c <memcpy>
    tel_packet_index[uart] = 0;
    220a:	f4 01       	movw	r30, r8
    220c:	ed 5a       	subi	r30, 0xAD	; 173
    220e:	f7 4f       	sbci	r31, 0xF7	; 247
    2210:	10 82       	st	Z, r1
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
    2212:	f1 e0       	ldi	r31, 0x01	; 1
    2214:	bf 12       	cpse	r11, r31
    2216:	06 c0       	rjmp	.+12     	; 0x2224 <transmit_packet+0x114>
    2218:	80 91 9b 00 	lds	r24, 0x009B
    221c:	88 23       	and	r24, r24
    221e:	b9 f0       	breq	.+46     	; 0x224e <transmit_packet+0x13e>
      tx_put_byte( uart );
    2220:	81 e0       	ldi	r24, 0x01	; 1
    2222:	06 c0       	rjmp	.+12     	; 0x2230 <transmit_packet+0x120>
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
    2224:	b1 10       	cpse	r11, r1
    2226:	13 c0       	rjmp	.+38     	; 0x224e <transmit_packet+0x13e>
    2228:	8b b1       	in	r24, 0x0b	; 11
    222a:	88 23       	and	r24, r24
    222c:	81 f0       	breq	.+32     	; 0x224e <transmit_packet+0x13e>
      tx_put_byte( uart );
    222e:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    2230:	df 91       	pop	r29
    2232:	cf 91       	pop	r28
    2234:	1f 91       	pop	r17
    2236:	0f 91       	pop	r16
    2238:	ff 90       	pop	r15
    223a:	ef 90       	pop	r14
    223c:	df 90       	pop	r13
    223e:	cf 90       	pop	r12
    2240:	bf 90       	pop	r11
    2242:	9f 90       	pop	r9
    2244:	8f 90       	pop	r8
    2246:	7f 90       	pop	r7
    2248:	6f 90       	pop	r6
    tel_packet_index[uart] = 0;
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    224a:	0c 94 ec 0c 	jmp	0x19d8	; 0x19d8 <tx_put_byte>
  }
}
    224e:	df 91       	pop	r29
    2250:	cf 91       	pop	r28
    2252:	1f 91       	pop	r17
    2254:	0f 91       	pop	r16
    2256:	ff 90       	pop	r15
    2258:	ef 90       	pop	r14
    225a:	df 90       	pop	r13
    225c:	cf 90       	pop	r12
    225e:	bf 90       	pop	r11
    2260:	9f 90       	pop	r9
    2262:	8f 90       	pop	r8
    2264:	7f 90       	pop	r7
    2266:	6f 90       	pop	r6
    2268:	08 95       	ret

0000226a <__subsf3>:
    226a:	50 58       	subi	r21, 0x80	; 128

0000226c <__addsf3>:
    226c:	bb 27       	eor	r27, r27
    226e:	aa 27       	eor	r26, r26
    2270:	0e d0       	rcall	.+28     	; 0x228e <__addsf3x>
    2272:	44 c1       	rjmp	.+648    	; 0x24fc <__fp_round>
    2274:	35 d1       	rcall	.+618    	; 0x24e0 <__fp_pscA>
    2276:	30 f0       	brcs	.+12     	; 0x2284 <__addsf3+0x18>
    2278:	3a d1       	rcall	.+628    	; 0x24ee <__fp_pscB>
    227a:	20 f0       	brcs	.+8      	; 0x2284 <__addsf3+0x18>
    227c:	31 f4       	brne	.+12     	; 0x228a <__addsf3+0x1e>
    227e:	9f 3f       	cpi	r25, 0xFF	; 255
    2280:	11 f4       	brne	.+4      	; 0x2286 <__addsf3+0x1a>
    2282:	1e f4       	brtc	.+6      	; 0x228a <__addsf3+0x1e>
    2284:	2a c1       	rjmp	.+596    	; 0x24da <__fp_nan>
    2286:	0e f4       	brtc	.+2      	; 0x228a <__addsf3+0x1e>
    2288:	e0 95       	com	r30
    228a:	e7 fb       	bst	r30, 7
    228c:	20 c1       	rjmp	.+576    	; 0x24ce <__fp_inf>

0000228e <__addsf3x>:
    228e:	e9 2f       	mov	r30, r25
    2290:	46 d1       	rcall	.+652    	; 0x251e <__fp_split3>
    2292:	80 f3       	brcs	.-32     	; 0x2274 <__addsf3+0x8>
    2294:	ba 17       	cp	r27, r26
    2296:	62 07       	cpc	r22, r18
    2298:	73 07       	cpc	r23, r19
    229a:	84 07       	cpc	r24, r20
    229c:	95 07       	cpc	r25, r21
    229e:	18 f0       	brcs	.+6      	; 0x22a6 <__addsf3x+0x18>
    22a0:	71 f4       	brne	.+28     	; 0x22be <__addsf3x+0x30>
    22a2:	9e f5       	brtc	.+102    	; 0x230a <__addsf3x+0x7c>
    22a4:	5e c1       	rjmp	.+700    	; 0x2562 <__fp_zero>
    22a6:	0e f4       	brtc	.+2      	; 0x22aa <__addsf3x+0x1c>
    22a8:	e0 95       	com	r30
    22aa:	0b 2e       	mov	r0, r27
    22ac:	ba 2f       	mov	r27, r26
    22ae:	a0 2d       	mov	r26, r0
    22b0:	0b 01       	movw	r0, r22
    22b2:	b9 01       	movw	r22, r18
    22b4:	90 01       	movw	r18, r0
    22b6:	0c 01       	movw	r0, r24
    22b8:	ca 01       	movw	r24, r20
    22ba:	a0 01       	movw	r20, r0
    22bc:	11 24       	eor	r1, r1
    22be:	ff 27       	eor	r31, r31
    22c0:	59 1b       	sub	r21, r25
    22c2:	99 f0       	breq	.+38     	; 0x22ea <__addsf3x+0x5c>
    22c4:	59 3f       	cpi	r21, 0xF9	; 249
    22c6:	50 f4       	brcc	.+20     	; 0x22dc <__addsf3x+0x4e>
    22c8:	50 3e       	cpi	r21, 0xE0	; 224
    22ca:	68 f1       	brcs	.+90     	; 0x2326 <__addsf3x+0x98>
    22cc:	1a 16       	cp	r1, r26
    22ce:	f0 40       	sbci	r31, 0x00	; 0
    22d0:	a2 2f       	mov	r26, r18
    22d2:	23 2f       	mov	r18, r19
    22d4:	34 2f       	mov	r19, r20
    22d6:	44 27       	eor	r20, r20
    22d8:	58 5f       	subi	r21, 0xF8	; 248
    22da:	f3 cf       	rjmp	.-26     	; 0x22c2 <__addsf3x+0x34>
    22dc:	46 95       	lsr	r20
    22de:	37 95       	ror	r19
    22e0:	27 95       	ror	r18
    22e2:	a7 95       	ror	r26
    22e4:	f0 40       	sbci	r31, 0x00	; 0
    22e6:	53 95       	inc	r21
    22e8:	c9 f7       	brne	.-14     	; 0x22dc <__addsf3x+0x4e>
    22ea:	7e f4       	brtc	.+30     	; 0x230a <__addsf3x+0x7c>
    22ec:	1f 16       	cp	r1, r31
    22ee:	ba 0b       	sbc	r27, r26
    22f0:	62 0b       	sbc	r22, r18
    22f2:	73 0b       	sbc	r23, r19
    22f4:	84 0b       	sbc	r24, r20
    22f6:	ba f0       	brmi	.+46     	; 0x2326 <__addsf3x+0x98>
    22f8:	91 50       	subi	r25, 0x01	; 1
    22fa:	a1 f0       	breq	.+40     	; 0x2324 <__addsf3x+0x96>
    22fc:	ff 0f       	add	r31, r31
    22fe:	bb 1f       	adc	r27, r27
    2300:	66 1f       	adc	r22, r22
    2302:	77 1f       	adc	r23, r23
    2304:	88 1f       	adc	r24, r24
    2306:	c2 f7       	brpl	.-16     	; 0x22f8 <__addsf3x+0x6a>
    2308:	0e c0       	rjmp	.+28     	; 0x2326 <__addsf3x+0x98>
    230a:	ba 0f       	add	r27, r26
    230c:	62 1f       	adc	r22, r18
    230e:	73 1f       	adc	r23, r19
    2310:	84 1f       	adc	r24, r20
    2312:	48 f4       	brcc	.+18     	; 0x2326 <__addsf3x+0x98>
    2314:	87 95       	ror	r24
    2316:	77 95       	ror	r23
    2318:	67 95       	ror	r22
    231a:	b7 95       	ror	r27
    231c:	f7 95       	ror	r31
    231e:	9e 3f       	cpi	r25, 0xFE	; 254
    2320:	08 f0       	brcs	.+2      	; 0x2324 <__addsf3x+0x96>
    2322:	b3 cf       	rjmp	.-154    	; 0x228a <__addsf3+0x1e>
    2324:	93 95       	inc	r25
    2326:	88 0f       	add	r24, r24
    2328:	08 f0       	brcs	.+2      	; 0x232c <__addsf3x+0x9e>
    232a:	99 27       	eor	r25, r25
    232c:	ee 0f       	add	r30, r30
    232e:	97 95       	ror	r25
    2330:	87 95       	ror	r24
    2332:	08 95       	ret

00002334 <__cmpsf2>:
    2334:	a8 d0       	rcall	.+336    	; 0x2486 <__fp_cmp>
    2336:	08 f4       	brcc	.+2      	; 0x233a <__cmpsf2+0x6>
    2338:	81 e0       	ldi	r24, 0x01	; 1
    233a:	08 95       	ret

0000233c <__divsf3>:
    233c:	0c d0       	rcall	.+24     	; 0x2356 <__divsf3x>
    233e:	de c0       	rjmp	.+444    	; 0x24fc <__fp_round>
    2340:	d6 d0       	rcall	.+428    	; 0x24ee <__fp_pscB>
    2342:	40 f0       	brcs	.+16     	; 0x2354 <__divsf3+0x18>
    2344:	cd d0       	rcall	.+410    	; 0x24e0 <__fp_pscA>
    2346:	30 f0       	brcs	.+12     	; 0x2354 <__divsf3+0x18>
    2348:	21 f4       	brne	.+8      	; 0x2352 <__divsf3+0x16>
    234a:	5f 3f       	cpi	r21, 0xFF	; 255
    234c:	19 f0       	breq	.+6      	; 0x2354 <__divsf3+0x18>
    234e:	bf c0       	rjmp	.+382    	; 0x24ce <__fp_inf>
    2350:	51 11       	cpse	r21, r1
    2352:	08 c1       	rjmp	.+528    	; 0x2564 <__fp_szero>
    2354:	c2 c0       	rjmp	.+388    	; 0x24da <__fp_nan>

00002356 <__divsf3x>:
    2356:	e3 d0       	rcall	.+454    	; 0x251e <__fp_split3>
    2358:	98 f3       	brcs	.-26     	; 0x2340 <__divsf3+0x4>

0000235a <__divsf3_pse>:
    235a:	99 23       	and	r25, r25
    235c:	c9 f3       	breq	.-14     	; 0x2350 <__divsf3+0x14>
    235e:	55 23       	and	r21, r21
    2360:	b1 f3       	breq	.-20     	; 0x234e <__divsf3+0x12>
    2362:	95 1b       	sub	r25, r21
    2364:	55 0b       	sbc	r21, r21
    2366:	bb 27       	eor	r27, r27
    2368:	aa 27       	eor	r26, r26
    236a:	62 17       	cp	r22, r18
    236c:	73 07       	cpc	r23, r19
    236e:	84 07       	cpc	r24, r20
    2370:	38 f0       	brcs	.+14     	; 0x2380 <__divsf3_pse+0x26>
    2372:	9f 5f       	subi	r25, 0xFF	; 255
    2374:	5f 4f       	sbci	r21, 0xFF	; 255
    2376:	22 0f       	add	r18, r18
    2378:	33 1f       	adc	r19, r19
    237a:	44 1f       	adc	r20, r20
    237c:	aa 1f       	adc	r26, r26
    237e:	a9 f3       	breq	.-22     	; 0x236a <__divsf3_pse+0x10>
    2380:	33 d0       	rcall	.+102    	; 0x23e8 <__divsf3_pse+0x8e>
    2382:	0e 2e       	mov	r0, r30
    2384:	3a f0       	brmi	.+14     	; 0x2394 <__divsf3_pse+0x3a>
    2386:	e0 e8       	ldi	r30, 0x80	; 128
    2388:	30 d0       	rcall	.+96     	; 0x23ea <__divsf3_pse+0x90>
    238a:	91 50       	subi	r25, 0x01	; 1
    238c:	50 40       	sbci	r21, 0x00	; 0
    238e:	e6 95       	lsr	r30
    2390:	00 1c       	adc	r0, r0
    2392:	ca f7       	brpl	.-14     	; 0x2386 <__divsf3_pse+0x2c>
    2394:	29 d0       	rcall	.+82     	; 0x23e8 <__divsf3_pse+0x8e>
    2396:	fe 2f       	mov	r31, r30
    2398:	27 d0       	rcall	.+78     	; 0x23e8 <__divsf3_pse+0x8e>
    239a:	66 0f       	add	r22, r22
    239c:	77 1f       	adc	r23, r23
    239e:	88 1f       	adc	r24, r24
    23a0:	bb 1f       	adc	r27, r27
    23a2:	26 17       	cp	r18, r22
    23a4:	37 07       	cpc	r19, r23
    23a6:	48 07       	cpc	r20, r24
    23a8:	ab 07       	cpc	r26, r27
    23aa:	b0 e8       	ldi	r27, 0x80	; 128
    23ac:	09 f0       	breq	.+2      	; 0x23b0 <__divsf3_pse+0x56>
    23ae:	bb 0b       	sbc	r27, r27
    23b0:	80 2d       	mov	r24, r0
    23b2:	bf 01       	movw	r22, r30
    23b4:	ff 27       	eor	r31, r31
    23b6:	93 58       	subi	r25, 0x83	; 131
    23b8:	5f 4f       	sbci	r21, 0xFF	; 255
    23ba:	2a f0       	brmi	.+10     	; 0x23c6 <__divsf3_pse+0x6c>
    23bc:	9e 3f       	cpi	r25, 0xFE	; 254
    23be:	51 05       	cpc	r21, r1
    23c0:	68 f0       	brcs	.+26     	; 0x23dc <__divsf3_pse+0x82>
    23c2:	85 c0       	rjmp	.+266    	; 0x24ce <__fp_inf>
    23c4:	cf c0       	rjmp	.+414    	; 0x2564 <__fp_szero>
    23c6:	5f 3f       	cpi	r21, 0xFF	; 255
    23c8:	ec f3       	brlt	.-6      	; 0x23c4 <__divsf3_pse+0x6a>
    23ca:	98 3e       	cpi	r25, 0xE8	; 232
    23cc:	dc f3       	brlt	.-10     	; 0x23c4 <__divsf3_pse+0x6a>
    23ce:	86 95       	lsr	r24
    23d0:	77 95       	ror	r23
    23d2:	67 95       	ror	r22
    23d4:	b7 95       	ror	r27
    23d6:	f7 95       	ror	r31
    23d8:	9f 5f       	subi	r25, 0xFF	; 255
    23da:	c9 f7       	brne	.-14     	; 0x23ce <__divsf3_pse+0x74>
    23dc:	88 0f       	add	r24, r24
    23de:	91 1d       	adc	r25, r1
    23e0:	96 95       	lsr	r25
    23e2:	87 95       	ror	r24
    23e4:	97 f9       	bld	r25, 7
    23e6:	08 95       	ret
    23e8:	e1 e0       	ldi	r30, 0x01	; 1
    23ea:	66 0f       	add	r22, r22
    23ec:	77 1f       	adc	r23, r23
    23ee:	88 1f       	adc	r24, r24
    23f0:	bb 1f       	adc	r27, r27
    23f2:	62 17       	cp	r22, r18
    23f4:	73 07       	cpc	r23, r19
    23f6:	84 07       	cpc	r24, r20
    23f8:	ba 07       	cpc	r27, r26
    23fa:	20 f0       	brcs	.+8      	; 0x2404 <__divsf3_pse+0xaa>
    23fc:	62 1b       	sub	r22, r18
    23fe:	73 0b       	sbc	r23, r19
    2400:	84 0b       	sbc	r24, r20
    2402:	ba 0b       	sbc	r27, r26
    2404:	ee 1f       	adc	r30, r30
    2406:	88 f7       	brcc	.-30     	; 0x23ea <__divsf3_pse+0x90>
    2408:	e0 95       	com	r30
    240a:	08 95       	ret

0000240c <__floatunsisf>:
    240c:	e8 94       	clt
    240e:	09 c0       	rjmp	.+18     	; 0x2422 <__floatsisf+0x12>

00002410 <__floatsisf>:
    2410:	97 fb       	bst	r25, 7
    2412:	3e f4       	brtc	.+14     	; 0x2422 <__floatsisf+0x12>
    2414:	90 95       	com	r25
    2416:	80 95       	com	r24
    2418:	70 95       	com	r23
    241a:	61 95       	neg	r22
    241c:	7f 4f       	sbci	r23, 0xFF	; 255
    241e:	8f 4f       	sbci	r24, 0xFF	; 255
    2420:	9f 4f       	sbci	r25, 0xFF	; 255
    2422:	99 23       	and	r25, r25
    2424:	a9 f0       	breq	.+42     	; 0x2450 <__floatsisf+0x40>
    2426:	f9 2f       	mov	r31, r25
    2428:	96 e9       	ldi	r25, 0x96	; 150
    242a:	bb 27       	eor	r27, r27
    242c:	93 95       	inc	r25
    242e:	f6 95       	lsr	r31
    2430:	87 95       	ror	r24
    2432:	77 95       	ror	r23
    2434:	67 95       	ror	r22
    2436:	b7 95       	ror	r27
    2438:	f1 11       	cpse	r31, r1
    243a:	f8 cf       	rjmp	.-16     	; 0x242c <__floatsisf+0x1c>
    243c:	fa f4       	brpl	.+62     	; 0x247c <__floatsisf+0x6c>
    243e:	bb 0f       	add	r27, r27
    2440:	11 f4       	brne	.+4      	; 0x2446 <__floatsisf+0x36>
    2442:	60 ff       	sbrs	r22, 0
    2444:	1b c0       	rjmp	.+54     	; 0x247c <__floatsisf+0x6c>
    2446:	6f 5f       	subi	r22, 0xFF	; 255
    2448:	7f 4f       	sbci	r23, 0xFF	; 255
    244a:	8f 4f       	sbci	r24, 0xFF	; 255
    244c:	9f 4f       	sbci	r25, 0xFF	; 255
    244e:	16 c0       	rjmp	.+44     	; 0x247c <__floatsisf+0x6c>
    2450:	88 23       	and	r24, r24
    2452:	11 f0       	breq	.+4      	; 0x2458 <__floatsisf+0x48>
    2454:	96 e9       	ldi	r25, 0x96	; 150
    2456:	11 c0       	rjmp	.+34     	; 0x247a <__floatsisf+0x6a>
    2458:	77 23       	and	r23, r23
    245a:	21 f0       	breq	.+8      	; 0x2464 <__floatsisf+0x54>
    245c:	9e e8       	ldi	r25, 0x8E	; 142
    245e:	87 2f       	mov	r24, r23
    2460:	76 2f       	mov	r23, r22
    2462:	05 c0       	rjmp	.+10     	; 0x246e <__floatsisf+0x5e>
    2464:	66 23       	and	r22, r22
    2466:	71 f0       	breq	.+28     	; 0x2484 <__floatsisf+0x74>
    2468:	96 e8       	ldi	r25, 0x86	; 134
    246a:	86 2f       	mov	r24, r22
    246c:	70 e0       	ldi	r23, 0x00	; 0
    246e:	60 e0       	ldi	r22, 0x00	; 0
    2470:	2a f0       	brmi	.+10     	; 0x247c <__floatsisf+0x6c>
    2472:	9a 95       	dec	r25
    2474:	66 0f       	add	r22, r22
    2476:	77 1f       	adc	r23, r23
    2478:	88 1f       	adc	r24, r24
    247a:	da f7       	brpl	.-10     	; 0x2472 <__floatsisf+0x62>
    247c:	88 0f       	add	r24, r24
    247e:	96 95       	lsr	r25
    2480:	87 95       	ror	r24
    2482:	97 f9       	bld	r25, 7
    2484:	08 95       	ret

00002486 <__fp_cmp>:
    2486:	99 0f       	add	r25, r25
    2488:	00 08       	sbc	r0, r0
    248a:	55 0f       	add	r21, r21
    248c:	aa 0b       	sbc	r26, r26
    248e:	e0 e8       	ldi	r30, 0x80	; 128
    2490:	fe ef       	ldi	r31, 0xFE	; 254
    2492:	16 16       	cp	r1, r22
    2494:	17 06       	cpc	r1, r23
    2496:	e8 07       	cpc	r30, r24
    2498:	f9 07       	cpc	r31, r25
    249a:	c0 f0       	brcs	.+48     	; 0x24cc <__fp_cmp+0x46>
    249c:	12 16       	cp	r1, r18
    249e:	13 06       	cpc	r1, r19
    24a0:	e4 07       	cpc	r30, r20
    24a2:	f5 07       	cpc	r31, r21
    24a4:	98 f0       	brcs	.+38     	; 0x24cc <__fp_cmp+0x46>
    24a6:	62 1b       	sub	r22, r18
    24a8:	73 0b       	sbc	r23, r19
    24aa:	84 0b       	sbc	r24, r20
    24ac:	95 0b       	sbc	r25, r21
    24ae:	39 f4       	brne	.+14     	; 0x24be <__fp_cmp+0x38>
    24b0:	0a 26       	eor	r0, r26
    24b2:	61 f0       	breq	.+24     	; 0x24cc <__fp_cmp+0x46>
    24b4:	23 2b       	or	r18, r19
    24b6:	24 2b       	or	r18, r20
    24b8:	25 2b       	or	r18, r21
    24ba:	21 f4       	brne	.+8      	; 0x24c4 <__fp_cmp+0x3e>
    24bc:	08 95       	ret
    24be:	0a 26       	eor	r0, r26
    24c0:	09 f4       	brne	.+2      	; 0x24c4 <__fp_cmp+0x3e>
    24c2:	a1 40       	sbci	r26, 0x01	; 1
    24c4:	a6 95       	lsr	r26
    24c6:	8f ef       	ldi	r24, 0xFF	; 255
    24c8:	81 1d       	adc	r24, r1
    24ca:	81 1d       	adc	r24, r1
    24cc:	08 95       	ret

000024ce <__fp_inf>:
    24ce:	97 f9       	bld	r25, 7
    24d0:	9f 67       	ori	r25, 0x7F	; 127
    24d2:	80 e8       	ldi	r24, 0x80	; 128
    24d4:	70 e0       	ldi	r23, 0x00	; 0
    24d6:	60 e0       	ldi	r22, 0x00	; 0
    24d8:	08 95       	ret

000024da <__fp_nan>:
    24da:	9f ef       	ldi	r25, 0xFF	; 255
    24dc:	80 ec       	ldi	r24, 0xC0	; 192
    24de:	08 95       	ret

000024e0 <__fp_pscA>:
    24e0:	00 24       	eor	r0, r0
    24e2:	0a 94       	dec	r0
    24e4:	16 16       	cp	r1, r22
    24e6:	17 06       	cpc	r1, r23
    24e8:	18 06       	cpc	r1, r24
    24ea:	09 06       	cpc	r0, r25
    24ec:	08 95       	ret

000024ee <__fp_pscB>:
    24ee:	00 24       	eor	r0, r0
    24f0:	0a 94       	dec	r0
    24f2:	12 16       	cp	r1, r18
    24f4:	13 06       	cpc	r1, r19
    24f6:	14 06       	cpc	r1, r20
    24f8:	05 06       	cpc	r0, r21
    24fa:	08 95       	ret

000024fc <__fp_round>:
    24fc:	09 2e       	mov	r0, r25
    24fe:	03 94       	inc	r0
    2500:	00 0c       	add	r0, r0
    2502:	11 f4       	brne	.+4      	; 0x2508 <__fp_round+0xc>
    2504:	88 23       	and	r24, r24
    2506:	52 f0       	brmi	.+20     	; 0x251c <__fp_round+0x20>
    2508:	bb 0f       	add	r27, r27
    250a:	40 f4       	brcc	.+16     	; 0x251c <__fp_round+0x20>
    250c:	bf 2b       	or	r27, r31
    250e:	11 f4       	brne	.+4      	; 0x2514 <__fp_round+0x18>
    2510:	60 ff       	sbrs	r22, 0
    2512:	04 c0       	rjmp	.+8      	; 0x251c <__fp_round+0x20>
    2514:	6f 5f       	subi	r22, 0xFF	; 255
    2516:	7f 4f       	sbci	r23, 0xFF	; 255
    2518:	8f 4f       	sbci	r24, 0xFF	; 255
    251a:	9f 4f       	sbci	r25, 0xFF	; 255
    251c:	08 95       	ret

0000251e <__fp_split3>:
    251e:	57 fd       	sbrc	r21, 7
    2520:	90 58       	subi	r25, 0x80	; 128
    2522:	44 0f       	add	r20, r20
    2524:	55 1f       	adc	r21, r21
    2526:	59 f0       	breq	.+22     	; 0x253e <__fp_splitA+0x10>
    2528:	5f 3f       	cpi	r21, 0xFF	; 255
    252a:	71 f0       	breq	.+28     	; 0x2548 <__fp_splitA+0x1a>
    252c:	47 95       	ror	r20

0000252e <__fp_splitA>:
    252e:	88 0f       	add	r24, r24
    2530:	97 fb       	bst	r25, 7
    2532:	99 1f       	adc	r25, r25
    2534:	61 f0       	breq	.+24     	; 0x254e <__fp_splitA+0x20>
    2536:	9f 3f       	cpi	r25, 0xFF	; 255
    2538:	79 f0       	breq	.+30     	; 0x2558 <__fp_splitA+0x2a>
    253a:	87 95       	ror	r24
    253c:	08 95       	ret
    253e:	12 16       	cp	r1, r18
    2540:	13 06       	cpc	r1, r19
    2542:	14 06       	cpc	r1, r20
    2544:	55 1f       	adc	r21, r21
    2546:	f2 cf       	rjmp	.-28     	; 0x252c <__fp_split3+0xe>
    2548:	46 95       	lsr	r20
    254a:	f1 df       	rcall	.-30     	; 0x252e <__fp_splitA>
    254c:	08 c0       	rjmp	.+16     	; 0x255e <__fp_splitA+0x30>
    254e:	16 16       	cp	r1, r22
    2550:	17 06       	cpc	r1, r23
    2552:	18 06       	cpc	r1, r24
    2554:	99 1f       	adc	r25, r25
    2556:	f1 cf       	rjmp	.-30     	; 0x253a <__fp_splitA+0xc>
    2558:	86 95       	lsr	r24
    255a:	71 05       	cpc	r23, r1
    255c:	61 05       	cpc	r22, r1
    255e:	08 94       	sec
    2560:	08 95       	ret

00002562 <__fp_zero>:
    2562:	e8 94       	clt

00002564 <__fp_szero>:
    2564:	bb 27       	eor	r27, r27
    2566:	66 27       	eor	r22, r22
    2568:	77 27       	eor	r23, r23
    256a:	cb 01       	movw	r24, r22
    256c:	97 f9       	bld	r25, 7
    256e:	08 95       	ret

00002570 <__gesf2>:
    2570:	8a df       	rcall	.-236    	; 0x2486 <__fp_cmp>
    2572:	08 f4       	brcc	.+2      	; 0x2576 <__gesf2+0x6>
    2574:	8f ef       	ldi	r24, 0xFF	; 255
    2576:	08 95       	ret

00002578 <__udivmodhi4>:
    2578:	aa 1b       	sub	r26, r26
    257a:	bb 1b       	sub	r27, r27
    257c:	51 e1       	ldi	r21, 0x11	; 17
    257e:	07 c0       	rjmp	.+14     	; 0x258e <__udivmodhi4_ep>

00002580 <__udivmodhi4_loop>:
    2580:	aa 1f       	adc	r26, r26
    2582:	bb 1f       	adc	r27, r27
    2584:	a6 17       	cp	r26, r22
    2586:	b7 07       	cpc	r27, r23
    2588:	10 f0       	brcs	.+4      	; 0x258e <__udivmodhi4_ep>
    258a:	a6 1b       	sub	r26, r22
    258c:	b7 0b       	sbc	r27, r23

0000258e <__udivmodhi4_ep>:
    258e:	88 1f       	adc	r24, r24
    2590:	99 1f       	adc	r25, r25
    2592:	5a 95       	dec	r21
    2594:	a9 f7       	brne	.-22     	; 0x2580 <__udivmodhi4_loop>
    2596:	80 95       	com	r24
    2598:	90 95       	com	r25
    259a:	bc 01       	movw	r22, r24
    259c:	cd 01       	movw	r24, r26
    259e:	08 95       	ret

000025a0 <__divmodhi4>:
    25a0:	97 fb       	bst	r25, 7
    25a2:	07 2e       	mov	r0, r23
    25a4:	16 f4       	brtc	.+4      	; 0x25aa <__divmodhi4+0xa>
    25a6:	00 94       	com	r0
    25a8:	07 d0       	rcall	.+14     	; 0x25b8 <__divmodhi4_neg1>
    25aa:	77 fd       	sbrc	r23, 7
    25ac:	09 d0       	rcall	.+18     	; 0x25c0 <__divmodhi4_neg2>
    25ae:	0e 94 bc 12 	call	0x2578	; 0x2578 <__udivmodhi4>
    25b2:	07 fc       	sbrc	r0, 7
    25b4:	05 d0       	rcall	.+10     	; 0x25c0 <__divmodhi4_neg2>
    25b6:	3e f4       	brtc	.+14     	; 0x25c6 <__divmodhi4_exit>

000025b8 <__divmodhi4_neg1>:
    25b8:	90 95       	com	r25
    25ba:	81 95       	neg	r24
    25bc:	9f 4f       	sbci	r25, 0xFF	; 255
    25be:	08 95       	ret

000025c0 <__divmodhi4_neg2>:
    25c0:	70 95       	com	r23
    25c2:	61 95       	neg	r22
    25c4:	7f 4f       	sbci	r23, 0xFF	; 255

000025c6 <__divmodhi4_exit>:
    25c6:	08 95       	ret

000025c8 <malloc>:
    25c8:	0f 93       	push	r16
    25ca:	1f 93       	push	r17
    25cc:	cf 93       	push	r28
    25ce:	df 93       	push	r29
    25d0:	82 30       	cpi	r24, 0x02	; 2
    25d2:	91 05       	cpc	r25, r1
    25d4:	10 f4       	brcc	.+4      	; 0x25da <malloc+0x12>
    25d6:	82 e0       	ldi	r24, 0x02	; 2
    25d8:	90 e0       	ldi	r25, 0x00	; 0
    25da:	e0 91 c2 10 	lds	r30, 0x10C2
    25de:	f0 91 c3 10 	lds	r31, 0x10C3
    25e2:	20 e0       	ldi	r18, 0x00	; 0
    25e4:	30 e0       	ldi	r19, 0x00	; 0
    25e6:	c0 e0       	ldi	r28, 0x00	; 0
    25e8:	d0 e0       	ldi	r29, 0x00	; 0
    25ea:	23 c0       	rjmp	.+70     	; 0x2632 <malloc+0x6a>
    25ec:	40 81       	ld	r20, Z
    25ee:	51 81       	ldd	r21, Z+1	; 0x01
    25f0:	48 17       	cp	r20, r24
    25f2:	59 07       	cpc	r21, r25
    25f4:	a8 f0       	brcs	.+42     	; 0x2620 <malloc+0x58>
    25f6:	48 17       	cp	r20, r24
    25f8:	59 07       	cpc	r21, r25
    25fa:	61 f4       	brne	.+24     	; 0x2614 <malloc+0x4c>
    25fc:	82 81       	ldd	r24, Z+2	; 0x02
    25fe:	93 81       	ldd	r25, Z+3	; 0x03
    2600:	20 97       	sbiw	r28, 0x00	; 0
    2602:	19 f0       	breq	.+6      	; 0x260a <malloc+0x42>
    2604:	9b 83       	std	Y+3, r25	; 0x03
    2606:	8a 83       	std	Y+2, r24	; 0x02
    2608:	2e c0       	rjmp	.+92     	; 0x2666 <malloc+0x9e>
    260a:	90 93 c3 10 	sts	0x10C3, r25
    260e:	80 93 c2 10 	sts	0x10C2, r24
    2612:	29 c0       	rjmp	.+82     	; 0x2666 <malloc+0x9e>
    2614:	21 15       	cp	r18, r1
    2616:	31 05       	cpc	r19, r1
    2618:	29 f0       	breq	.+10     	; 0x2624 <malloc+0x5c>
    261a:	42 17       	cp	r20, r18
    261c:	53 07       	cpc	r21, r19
    261e:	10 f0       	brcs	.+4      	; 0x2624 <malloc+0x5c>
    2620:	a9 01       	movw	r20, r18
    2622:	02 c0       	rjmp	.+4      	; 0x2628 <malloc+0x60>
    2624:	be 01       	movw	r22, r28
    2626:	df 01       	movw	r26, r30
    2628:	02 81       	ldd	r16, Z+2	; 0x02
    262a:	13 81       	ldd	r17, Z+3	; 0x03
    262c:	ef 01       	movw	r28, r30
    262e:	9a 01       	movw	r18, r20
    2630:	f8 01       	movw	r30, r16
    2632:	30 97       	sbiw	r30, 0x00	; 0
    2634:	d9 f6       	brne	.-74     	; 0x25ec <malloc+0x24>
    2636:	21 15       	cp	r18, r1
    2638:	31 05       	cpc	r19, r1
    263a:	09 f1       	breq	.+66     	; 0x267e <malloc+0xb6>
    263c:	28 1b       	sub	r18, r24
    263e:	39 0b       	sbc	r19, r25
    2640:	24 30       	cpi	r18, 0x04	; 4
    2642:	31 05       	cpc	r19, r1
    2644:	90 f4       	brcc	.+36     	; 0x266a <malloc+0xa2>
    2646:	12 96       	adiw	r26, 0x02	; 2
    2648:	8d 91       	ld	r24, X+
    264a:	9c 91       	ld	r25, X
    264c:	13 97       	sbiw	r26, 0x03	; 3
    264e:	61 15       	cp	r22, r1
    2650:	71 05       	cpc	r23, r1
    2652:	21 f0       	breq	.+8      	; 0x265c <malloc+0x94>
    2654:	fb 01       	movw	r30, r22
    2656:	93 83       	std	Z+3, r25	; 0x03
    2658:	82 83       	std	Z+2, r24	; 0x02
    265a:	04 c0       	rjmp	.+8      	; 0x2664 <malloc+0x9c>
    265c:	90 93 c3 10 	sts	0x10C3, r25
    2660:	80 93 c2 10 	sts	0x10C2, r24
    2664:	fd 01       	movw	r30, r26
    2666:	32 96       	adiw	r30, 0x02	; 2
    2668:	44 c0       	rjmp	.+136    	; 0x26f2 <malloc+0x12a>
    266a:	fd 01       	movw	r30, r26
    266c:	e2 0f       	add	r30, r18
    266e:	f3 1f       	adc	r31, r19
    2670:	81 93       	st	Z+, r24
    2672:	91 93       	st	Z+, r25
    2674:	22 50       	subi	r18, 0x02	; 2
    2676:	31 09       	sbc	r19, r1
    2678:	2d 93       	st	X+, r18
    267a:	3c 93       	st	X, r19
    267c:	3a c0       	rjmp	.+116    	; 0x26f2 <malloc+0x12a>
    267e:	20 91 c0 10 	lds	r18, 0x10C0
    2682:	30 91 c1 10 	lds	r19, 0x10C1
    2686:	23 2b       	or	r18, r19
    2688:	41 f4       	brne	.+16     	; 0x269a <malloc+0xd2>
    268a:	20 91 02 01 	lds	r18, 0x0102
    268e:	30 91 03 01 	lds	r19, 0x0103
    2692:	30 93 c1 10 	sts	0x10C1, r19
    2696:	20 93 c0 10 	sts	0x10C0, r18
    269a:	20 91 00 01 	lds	r18, 0x0100
    269e:	30 91 01 01 	lds	r19, 0x0101
    26a2:	21 15       	cp	r18, r1
    26a4:	31 05       	cpc	r19, r1
    26a6:	41 f4       	brne	.+16     	; 0x26b8 <malloc+0xf0>
    26a8:	2d b7       	in	r18, 0x3d	; 61
    26aa:	3e b7       	in	r19, 0x3e	; 62
    26ac:	40 91 04 01 	lds	r20, 0x0104
    26b0:	50 91 05 01 	lds	r21, 0x0105
    26b4:	24 1b       	sub	r18, r20
    26b6:	35 0b       	sbc	r19, r21
    26b8:	e0 91 c0 10 	lds	r30, 0x10C0
    26bc:	f0 91 c1 10 	lds	r31, 0x10C1
    26c0:	e2 17       	cp	r30, r18
    26c2:	f3 07       	cpc	r31, r19
    26c4:	a0 f4       	brcc	.+40     	; 0x26ee <malloc+0x126>
    26c6:	2e 1b       	sub	r18, r30
    26c8:	3f 0b       	sbc	r19, r31
    26ca:	28 17       	cp	r18, r24
    26cc:	39 07       	cpc	r19, r25
    26ce:	78 f0       	brcs	.+30     	; 0x26ee <malloc+0x126>
    26d0:	ac 01       	movw	r20, r24
    26d2:	4e 5f       	subi	r20, 0xFE	; 254
    26d4:	5f 4f       	sbci	r21, 0xFF	; 255
    26d6:	24 17       	cp	r18, r20
    26d8:	35 07       	cpc	r19, r21
    26da:	48 f0       	brcs	.+18     	; 0x26ee <malloc+0x126>
    26dc:	4e 0f       	add	r20, r30
    26de:	5f 1f       	adc	r21, r31
    26e0:	50 93 c1 10 	sts	0x10C1, r21
    26e4:	40 93 c0 10 	sts	0x10C0, r20
    26e8:	81 93       	st	Z+, r24
    26ea:	91 93       	st	Z+, r25
    26ec:	02 c0       	rjmp	.+4      	; 0x26f2 <malloc+0x12a>
    26ee:	e0 e0       	ldi	r30, 0x00	; 0
    26f0:	f0 e0       	ldi	r31, 0x00	; 0
    26f2:	cf 01       	movw	r24, r30
    26f4:	df 91       	pop	r29
    26f6:	cf 91       	pop	r28
    26f8:	1f 91       	pop	r17
    26fa:	0f 91       	pop	r16
    26fc:	08 95       	ret

000026fe <free>:
    26fe:	ef 92       	push	r14
    2700:	ff 92       	push	r15
    2702:	0f 93       	push	r16
    2704:	1f 93       	push	r17
    2706:	cf 93       	push	r28
    2708:	df 93       	push	r29
    270a:	00 97       	sbiw	r24, 0x00	; 0
    270c:	09 f4       	brne	.+2      	; 0x2710 <free+0x12>
    270e:	8f c0       	rjmp	.+286    	; 0x282e <free+0x130>
    2710:	dc 01       	movw	r26, r24
    2712:	12 97       	sbiw	r26, 0x02	; 2
    2714:	13 96       	adiw	r26, 0x03	; 3
    2716:	1c 92       	st	X, r1
    2718:	1e 92       	st	-X, r1
    271a:	12 97       	sbiw	r26, 0x02	; 2
    271c:	e0 90 c2 10 	lds	r14, 0x10C2
    2720:	f0 90 c3 10 	lds	r15, 0x10C3
    2724:	e1 14       	cp	r14, r1
    2726:	f1 04       	cpc	r15, r1
    2728:	89 f4       	brne	.+34     	; 0x274c <free+0x4e>
    272a:	2d 91       	ld	r18, X+
    272c:	3c 91       	ld	r19, X
    272e:	11 97       	sbiw	r26, 0x01	; 1
    2730:	28 0f       	add	r18, r24
    2732:	39 1f       	adc	r19, r25
    2734:	80 91 c0 10 	lds	r24, 0x10C0
    2738:	90 91 c1 10 	lds	r25, 0x10C1
    273c:	82 17       	cp	r24, r18
    273e:	93 07       	cpc	r25, r19
    2740:	89 f5       	brne	.+98     	; 0x27a4 <free+0xa6>
    2742:	b0 93 c1 10 	sts	0x10C1, r27
    2746:	a0 93 c0 10 	sts	0x10C0, r26
    274a:	71 c0       	rjmp	.+226    	; 0x282e <free+0x130>
    274c:	e7 01       	movw	r28, r14
    274e:	20 e0       	ldi	r18, 0x00	; 0
    2750:	30 e0       	ldi	r19, 0x00	; 0
    2752:	01 c0       	rjmp	.+2      	; 0x2756 <free+0x58>
    2754:	ea 01       	movw	r28, r20
    2756:	ca 17       	cp	r28, r26
    2758:	db 07       	cpc	r29, r27
    275a:	38 f4       	brcc	.+14     	; 0x276a <free+0x6c>
    275c:	4a 81       	ldd	r20, Y+2	; 0x02
    275e:	5b 81       	ldd	r21, Y+3	; 0x03
    2760:	9e 01       	movw	r18, r28
    2762:	41 15       	cp	r20, r1
    2764:	51 05       	cpc	r21, r1
    2766:	b1 f7       	brne	.-20     	; 0x2754 <free+0x56>
    2768:	22 c0       	rjmp	.+68     	; 0x27ae <free+0xb0>
    276a:	bc 01       	movw	r22, r24
    276c:	62 50       	subi	r22, 0x02	; 2
    276e:	71 09       	sbc	r23, r1
    2770:	fb 01       	movw	r30, r22
    2772:	d3 83       	std	Z+3, r29	; 0x03
    2774:	c2 83       	std	Z+2, r28	; 0x02
    2776:	00 81       	ld	r16, Z
    2778:	11 81       	ldd	r17, Z+1	; 0x01
    277a:	ac 01       	movw	r20, r24
    277c:	40 0f       	add	r20, r16
    277e:	51 1f       	adc	r21, r17
    2780:	4c 17       	cp	r20, r28
    2782:	5d 07       	cpc	r21, r29
    2784:	61 f4       	brne	.+24     	; 0x279e <free+0xa0>
    2786:	48 81       	ld	r20, Y
    2788:	59 81       	ldd	r21, Y+1	; 0x01
    278a:	40 0f       	add	r20, r16
    278c:	51 1f       	adc	r21, r17
    278e:	4e 5f       	subi	r20, 0xFE	; 254
    2790:	5f 4f       	sbci	r21, 0xFF	; 255
    2792:	51 83       	std	Z+1, r21	; 0x01
    2794:	40 83       	st	Z, r20
    2796:	4a 81       	ldd	r20, Y+2	; 0x02
    2798:	5b 81       	ldd	r21, Y+3	; 0x03
    279a:	53 83       	std	Z+3, r21	; 0x03
    279c:	42 83       	std	Z+2, r20	; 0x02
    279e:	21 15       	cp	r18, r1
    27a0:	31 05       	cpc	r19, r1
    27a2:	29 f4       	brne	.+10     	; 0x27ae <free+0xb0>
    27a4:	b0 93 c3 10 	sts	0x10C3, r27
    27a8:	a0 93 c2 10 	sts	0x10C2, r26
    27ac:	40 c0       	rjmp	.+128    	; 0x282e <free+0x130>
    27ae:	f9 01       	movw	r30, r18
    27b0:	b3 83       	std	Z+3, r27	; 0x03
    27b2:	a2 83       	std	Z+2, r26	; 0x02
    27b4:	e9 01       	movw	r28, r18
    27b6:	69 91       	ld	r22, Y+
    27b8:	79 91       	ld	r23, Y+
    27ba:	c6 0f       	add	r28, r22
    27bc:	d7 1f       	adc	r29, r23
    27be:	ac 17       	cp	r26, r28
    27c0:	bd 07       	cpc	r27, r29
    27c2:	79 f4       	brne	.+30     	; 0x27e2 <free+0xe4>
    27c4:	dc 01       	movw	r26, r24
    27c6:	5e 91       	ld	r21, -X
    27c8:	4e 91       	ld	r20, -X
    27ca:	46 0f       	add	r20, r22
    27cc:	57 1f       	adc	r21, r23
    27ce:	4e 5f       	subi	r20, 0xFE	; 254
    27d0:	5f 4f       	sbci	r21, 0xFF	; 255
    27d2:	51 83       	std	Z+1, r21	; 0x01
    27d4:	40 83       	st	Z, r20
    27d6:	12 96       	adiw	r26, 0x02	; 2
    27d8:	8d 91       	ld	r24, X+
    27da:	9c 91       	ld	r25, X
    27dc:	13 97       	sbiw	r26, 0x03	; 3
    27de:	93 83       	std	Z+3, r25	; 0x03
    27e0:	82 83       	std	Z+2, r24	; 0x02
    27e2:	a0 e0       	ldi	r26, 0x00	; 0
    27e4:	b0 e0       	ldi	r27, 0x00	; 0
    27e6:	02 c0       	rjmp	.+4      	; 0x27ec <free+0xee>
    27e8:	d7 01       	movw	r26, r14
    27ea:	7c 01       	movw	r14, r24
    27ec:	f7 01       	movw	r30, r14
    27ee:	82 81       	ldd	r24, Z+2	; 0x02
    27f0:	93 81       	ldd	r25, Z+3	; 0x03
    27f2:	00 97       	sbiw	r24, 0x00	; 0
    27f4:	c9 f7       	brne	.-14     	; 0x27e8 <free+0xea>
    27f6:	c7 01       	movw	r24, r14
    27f8:	02 96       	adiw	r24, 0x02	; 2
    27fa:	20 81       	ld	r18, Z
    27fc:	31 81       	ldd	r19, Z+1	; 0x01
    27fe:	82 0f       	add	r24, r18
    2800:	93 1f       	adc	r25, r19
    2802:	20 91 c0 10 	lds	r18, 0x10C0
    2806:	30 91 c1 10 	lds	r19, 0x10C1
    280a:	28 17       	cp	r18, r24
    280c:	39 07       	cpc	r19, r25
    280e:	79 f4       	brne	.+30     	; 0x282e <free+0x130>
    2810:	10 97       	sbiw	r26, 0x00	; 0
    2812:	29 f4       	brne	.+10     	; 0x281e <free+0x120>
    2814:	10 92 c3 10 	sts	0x10C3, r1
    2818:	10 92 c2 10 	sts	0x10C2, r1
    281c:	04 c0       	rjmp	.+8      	; 0x2826 <free+0x128>
    281e:	13 96       	adiw	r26, 0x03	; 3
    2820:	1c 92       	st	X, r1
    2822:	1e 92       	st	-X, r1
    2824:	12 97       	sbiw	r26, 0x02	; 2
    2826:	f0 92 c1 10 	sts	0x10C1, r15
    282a:	e0 92 c0 10 	sts	0x10C0, r14
    282e:	df 91       	pop	r29
    2830:	cf 91       	pop	r28
    2832:	1f 91       	pop	r17
    2834:	0f 91       	pop	r16
    2836:	ff 90       	pop	r15
    2838:	ef 90       	pop	r14
    283a:	08 95       	ret

0000283c <memcpy>:
    283c:	fb 01       	movw	r30, r22
    283e:	dc 01       	movw	r26, r24
    2840:	02 c0       	rjmp	.+4      	; 0x2846 <memcpy+0xa>
    2842:	01 90       	ld	r0, Z+
    2844:	0d 92       	st	X+, r0
    2846:	41 50       	subi	r20, 0x01	; 1
    2848:	50 40       	sbci	r21, 0x00	; 0
    284a:	d8 f7       	brcc	.-10     	; 0x2842 <memcpy+0x6>
    284c:	08 95       	ret

0000284e <_exit>:
    284e:	f8 94       	cli

00002850 <__stop_program>:
    2850:	ff cf       	rjmp	.-2      	; 0x2850 <__stop_program>
