
violet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000270  00800100  00002796  0000282a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002796  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c60  00800370  00800370  00002a9a  2**0
                  ALLOC
  3 .stab         00003ff0  00000000  00000000  00002a9c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000010d7  00000000  00000000  00006a8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00007b63  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000278  00000000  00000000  00007b92  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00004f82  00000000  00000000  00007e0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001104  00000000  00000000  0000cd8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001402  00000000  00000000  0000de90  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000096c  00000000  00000000  0000f294  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000abe  00000000  00000000  0000fc00  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002b6c  00000000  00000000  000106be  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000200  00000000  00000000  0001322a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
{
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
 * insert_str
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
{
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
		output[i] = input[i - start_index];

	return i;
}
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 3f 0b 	jmp	0x167e	; 0x167e <__vector_12>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 21 0b 	jmp	0x1642	; 0x1642 <__vector_15>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 5a 0c 	jmp	0x18b4	; 0x18b4 <__vector_18>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 31 0c 	jmp	0x1862	; 0x1862 <__vector_20>
      54:	0c 94 1c 0c 	jmp	0x1838	; 0x1838 <__vector_21>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 e7 0b 	jmp	0x17ce	; 0x17ce <__vector_30>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 be 0b 	jmp	0x177c	; 0x177c <__vector_32>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	13 e0       	ldi	r17, 0x03	; 3
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e6 e9       	ldi	r30, 0x96	; 150
      a0:	f7 e2       	ldi	r31, 0x27	; 39
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a0 37       	cpi	r26, 0x70	; 112
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	2f e0       	ldi	r18, 0x0F	; 15
      b4:	a0 e7       	ldi	r26, 0x70	; 112
      b6:	b3 e0       	ldi	r27, 0x03	; 3
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a0 3d       	cpi	r26, 0xD0	; 208
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 a5 06 	call	0xd4a	; 0xd4a <main>
      c6:	0c 94 c9 13 	jmp	0x2792	; 0x2792 <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <set_component>:
  else if (real < 11.2) {
	 real = 11.2;
  }
  
  //charging = 0xcc;
  if (charging == 0xdd) // change back to dd for tomorrow 
      ce:	8f 92       	push	r8
      d0:	af 92       	push	r10
      d2:	cf 92       	push	r12
      d4:	ef 92       	push	r14
      d6:	0f 93       	push	r16
      d8:	cf 93       	push	r28
      da:	df 93       	push	r29
      dc:	cd b7       	in	r28, 0x3d	; 61
      de:	de b7       	in	r29, 0x3e	; 62
      e0:	9a e1       	ldi	r25, 0x1A	; 26
  {
  	if (real > 12.43) 
      e2:	89 9f       	mul	r24, r25
      e4:	f0 01       	movw	r30, r0
      e6:	11 24       	eor	r1, r1
      e8:	e0 56       	subi	r30, 0x60	; 96
      ea:	fc 4f       	sbci	r31, 0xFC	; 252
      ec:	60 83       	st	Z, r22
      ee:	41 83       	std	Z+1, r20	; 0x01
      f0:	22 83       	std	Z+2, r18	; 0x02
      f2:	13 82       	std	Z+3, r1	; 0x03
      f4:	04 83       	std	Z+4, r16	; 0x04
      f6:	e5 82       	std	Z+5, r14	; 0x05
	{
      debug = 0x0A;
      f8:	c6 82       	std	Z+6, r12	; 0x06
      fa:	12 86       	std	Z+10, r1	; 0x0a
      fc:	13 86       	std	Z+11, r1	; 0x0b
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
      fe:	a4 86       	std	Z+12, r10	; 0x0c
     100:	85 86       	std	Z+13, r8	; 0x0d
     102:	8a 85       	ldd	r24, Y+10	; 0x0a
     104:	86 87       	std	Z+14, r24	; 0x0e
     106:	12 8a       	std	Z+18, r1	; 0x12
     108:	13 8a       	std	Z+19, r1	; 0x13
     10a:	8b 85       	ldd	r24, Y+11	; 0x0b
     10c:	84 8b       	std	Z+20, r24	; 0x14
     10e:	8c 85       	ldd	r24, Y+12	; 0x0c
     110:	85 8b       	std	Z+21, r24	; 0x15
     112:	11 8e       	std	Z+25, r1	; 0x19
     114:	df 91       	pop	r29
     116:	cf 91       	pop	r28
     118:	0f 91       	pop	r16
     11a:	ef 90       	pop	r14
     11c:	cf 90       	pop	r12
     11e:	af 90       	pop	r10
     120:	8f 90       	pop	r8
     122:	08 95       	ret

00000124 <initialize_svit>:
     124:	8f 92       	push	r8
     126:	af 92       	push	r10
     128:	cf 92       	push	r12
     12a:	ef 92       	push	r14
     12c:	ff 92       	push	r15
     12e:	0f 93       	push	r16
     130:	1f 93       	push	r17
     132:	cf 93       	push	r28
     134:	df 93       	push	r29
     136:	80 e6       	ldi	r24, 0x60	; 96
     138:	87 b9       	out	0x07, r24	; 7
     13a:	8f e8       	ldi	r24, 0x8F	; 143
     13c:	86 b9       	out	0x06, r24	; 6
     13e:	1f 92       	push	r1
     140:	d3 e0       	ldi	r29, 0x03	; 3
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     142:	df 93       	push	r29
     144:	c1 ee       	ldi	r28, 0xE1	; 225
     146:	cf 93       	push	r28
     148:	86 e0       	ldi	r24, 0x06	; 6
     14a:	88 2e       	mov	r8, r24
     14c:	a1 2c       	mov	r10, r1
     14e:	91 ee       	ldi	r25, 0xE1	; 225
     150:	c9 2e       	mov	r12, r25
     152:	2b e0       	ldi	r18, 0x0B	; 11
     154:	e2 2e       	mov	r14, r18
     156:	00 e0       	ldi	r16, 0x00	; 0
     158:	21 e0       	ldi	r18, 0x01	; 1
     15a:	47 e0       	ldi	r20, 0x07	; 7
     15c:	60 e0       	ldi	r22, 0x00	; 0
     15e:	80 e0       	ldi	r24, 0x00	; 0
     160:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     164:	87 e0       	ldi	r24, 0x07	; 7
     166:	8f 93       	push	r24
     168:	ff 24       	eor	r15, r15
     16a:	f3 94       	inc	r15
     16c:	ff 92       	push	r15
     16e:	cf 93       	push	r28
     170:	37 e0       	ldi	r19, 0x07	; 7
     172:	83 2e       	mov	r8, r19
     174:	47 e1       	ldi	r20, 0x17	; 23
     176:	e4 2e       	mov	r14, r20
     178:	21 e0       	ldi	r18, 0x01	; 1
     17a:	48 e0       	ldi	r20, 0x08	; 8
     17c:	61 e0       	ldi	r22, 0x01	; 1
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     17e:	81 e0       	ldi	r24, 0x01	; 1
     180:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     184:	1f 92       	push	r1
     186:	df 93       	push	r29
     188:	cf 93       	push	r28
     18a:	81 2c       	mov	r8, r1
     18c:	aa 24       	eor	r10, r10
     18e:	a3 94       	inc	r10
     190:	53 e1       	ldi	r21, 0x13	; 19
     192:	e5 2e       	mov	r14, r21
     194:	01 e0       	ldi	r16, 0x01	; 1
     196:	21 e0       	ldi	r18, 0x01	; 1
     198:	41 e0       	ldi	r20, 0x01	; 1
     19a:	62 e0       	ldi	r22, 0x02	; 2
     19c:	82 e0       	ldi	r24, 0x02	; 2
     19e:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1a2:	1f 92       	push	r1
     1a4:	df 93       	push	r29
     1a6:	cf 93       	push	r28
     1a8:	6e e0       	ldi	r22, 0x0E	; 14
     1aa:	86 2e       	mov	r8, r22
     1ac:	72 e0       	ldi	r23, 0x02	; 2
     1ae:	a7 2e       	mov	r10, r23
     1b0:	ed e0       	ldi	r30, 0x0D	; 13
     1b2:	ee 2e       	mov	r14, r30
     1b4:	02 e0       	ldi	r16, 0x02	; 2
     1b6:	21 e0       	ldi	r18, 0x01	; 1
     1b8:	41 e0       	ldi	r20, 0x01	; 1
     1ba:	63 e0       	ldi	r22, 0x03	; 3
     1bc:	83 e0       	ldi	r24, 0x03	; 3
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     1be:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1c2:	1f 92       	push	r1
     1c4:	df 93       	push	r29
     1c6:	cf 93       	push	r28
     1c8:	88 24       	eor	r8, r8
     1ca:	83 94       	inc	r8
     1cc:	aa 24       	eor	r10, r10
     1ce:	a3 94       	inc	r10
     1d0:	f5 e1       	ldi	r31, 0x15	; 21
     1d2:	ef 2e       	mov	r14, r31
     1d4:	01 e0       	ldi	r16, 0x01	; 1
     1d6:	21 e0       	ldi	r18, 0x01	; 1
     1d8:	42 e0       	ldi	r20, 0x02	; 2
     1da:	64 e0       	ldi	r22, 0x04	; 4
     1dc:	84 e0       	ldi	r24, 0x04	; 4
     1de:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1e2:	1f 92       	push	r1
     1e4:	df 93       	push	r29
     1e6:	cf 93       	push	r28
     1e8:	a2 e0       	ldi	r26, 0x02	; 2
     1ea:	8a 2e       	mov	r8, r26
     1ec:	ba e1       	ldi	r27, 0x1A	; 26
     1ee:	eb 2e       	mov	r14, r27
     1f0:	21 e0       	ldi	r18, 0x01	; 1
     1f2:	43 e0       	ldi	r20, 0x03	; 3
     1f4:	65 e0       	ldi	r22, 0x05	; 5
     1f6:	85 e0       	ldi	r24, 0x05	; 5
     1f8:	0e 94 67 00 	call	0xce	; 0xce <set_component>
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     1fc:	1f 92       	push	r1
     1fe:	df 93       	push	r29
     200:	cf 93       	push	r28
     202:	13 e0       	ldi	r17, 0x03	; 3
     204:	81 2e       	mov	r8, r17
     206:	8d e1       	ldi	r24, 0x1D	; 29
     208:	e8 2e       	mov	r14, r24
     20a:	21 e0       	ldi	r18, 0x01	; 1
     20c:	44 e0       	ldi	r20, 0x04	; 4
     20e:	66 e0       	ldi	r22, 0x06	; 6
     210:	86 e0       	ldi	r24, 0x06	; 6
     212:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     216:	1f 92       	push	r1
     218:	df 93       	push	r29
     21a:	cf 93       	push	r28
     21c:	9f e1       	ldi	r25, 0x1F	; 31
     21e:	89 2e       	mov	r8, r25
     220:	2e e0       	ldi	r18, 0x0E	; 14
     222:	e2 2e       	mov	r14, r18
     224:	21 e0       	ldi	r18, 0x01	; 1
     226:	45 e0       	ldi	r20, 0x05	; 5
     228:	67 e0       	ldi	r22, 0x07	; 7
     22a:	87 e0       	ldi	r24, 0x07	; 7
     22c:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     230:	1f 92       	push	r1
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     232:	df 93       	push	r29
     234:	cf 93       	push	r28
     236:	34 e0       	ldi	r19, 0x04	; 4
     238:	83 2e       	mov	r8, r19
     23a:	4b e1       	ldi	r20, 0x1B	; 27
     23c:	e4 2e       	mov	r14, r20
     23e:	21 e0       	ldi	r18, 0x01	; 1
     240:	46 e0       	ldi	r20, 0x06	; 6
     242:	68 e0       	ldi	r22, 0x08	; 8
     244:	88 e0       	ldi	r24, 0x08	; 8
     246:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     24a:	1f 92       	push	r1
     24c:	df 93       	push	r29
     24e:	cf 93       	push	r28
     250:	58 e0       	ldi	r21, 0x08	; 8
     252:	85 2e       	mov	r8, r21
     254:	6f e0       	ldi	r22, 0x0F	; 15
     256:	e6 2e       	mov	r14, r22
     258:	21 e0       	ldi	r18, 0x01	; 1
     25a:	49 e0       	ldi	r20, 0x09	; 9
     25c:	69 e0       	ldi	r22, 0x09	; 9
     25e:	89 e0       	ldi	r24, 0x09	; 9
     260:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     264:	1f 92       	push	r1
     266:	df 93       	push	r29
     268:	cf 93       	push	r28
     26a:	79 e0       	ldi	r23, 0x09	; 9
     26c:	87 2e       	mov	r8, r23
     26e:	e9 e1       	ldi	r30, 0x19	; 25
     270:	ee 2e       	mov	r14, r30
     272:	21 e0       	ldi	r18, 0x01	; 1
     274:	4a e0       	ldi	r20, 0x0A	; 10
     276:	6a e0       	ldi	r22, 0x0A	; 10
     278:	8a e0       	ldi	r24, 0x0A	; 10
     27a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     27e:	8d b7       	in	r24, 0x3d	; 61
     280:	9e b7       	in	r25, 0x3e	; 62
     282:	81 96       	adiw	r24, 0x21	; 33
     284:	0f b6       	in	r0, 0x3f	; 63
     286:	f8 94       	cli
     288:	9e bf       	out	0x3e, r25	; 62
     28a:	0f be       	out	0x3f, r0	; 63
     28c:	8d bf       	out	0x3d, r24	; 61
     28e:	1f 92       	push	r1
     290:	df 93       	push	r29
     292:	cf 93       	push	r28
     294:	fa e0       	ldi	r31, 0x0A	; 10
     296:	8f 2e       	mov	r8, r31
     298:	a8 e1       	ldi	r26, 0x18	; 24
     29a:	ea 2e       	mov	r14, r26
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	4b e0       	ldi	r20, 0x0B	; 11
     2a0:	6b e0       	ldi	r22, 0x0B	; 11
     2a2:	8b e0       	ldi	r24, 0x0B	; 11
     2a4:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2a8:	1f 92       	push	r1
     2aa:	df 93       	push	r29
     2ac:	cf 93       	push	r28
     2ae:	b0 e1       	ldi	r27, 0x10	; 16
     2b0:	8b 2e       	mov	r8, r27
     2b2:	11 e1       	ldi	r17, 0x11	; 17
     2b4:	e1 2e       	mov	r14, r17
     2b6:	20 e0       	ldi	r18, 0x00	; 0
     2b8:	4c e0       	ldi	r20, 0x0C	; 12
     2ba:	6c e0       	ldi	r22, 0x0C	; 12
     2bc:	8c e0       	ldi	r24, 0x0C	; 12
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2be:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	8f 93       	push	r24
     2c6:	12 e0       	ldi	r17, 0x02	; 2
     2c8:	1f 93       	push	r17
     2ca:	cf 93       	push	r28
     2cc:	8c e0       	ldi	r24, 0x0C	; 12
     2ce:	88 2e       	mov	r8, r24
     2d0:	96 e1       	ldi	r25, 0x16	; 22
     2d2:	e9 2e       	mov	r14, r25
     2d4:	21 e0       	ldi	r18, 0x01	; 1
     2d6:	4d e0       	ldi	r20, 0x0D	; 13
     2d8:	6d e0       	ldi	r22, 0x0D	; 13
     2da:	8d e0       	ldi	r24, 0x0D	; 13
     2dc:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2e0:	1f 92       	push	r1
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     2e2:	df 93       	push	r29
     2e4:	cf 93       	push	r28
     2e6:	26 e0       	ldi	r18, 0x06	; 6
     2e8:	82 2e       	mov	r8, r18
     2ea:	a1 2c       	mov	r10, r1
     2ec:	34 e0       	ldi	r19, 0x04	; 4
     2ee:	e3 2e       	mov	r14, r19
     2f0:	00 e0       	ldi	r16, 0x00	; 0
     2f2:	21 e0       	ldi	r18, 0x01	; 1
     2f4:	4e e0       	ldi	r20, 0x0E	; 14
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2f6:	6e e0       	ldi	r22, 0x0E	; 14
     2f8:	8e e0       	ldi	r24, 0x0E	; 14
     2fa:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2fe:	1f 92       	push	r1
     300:	df 93       	push	r29
     302:	cf 93       	push	r28
     304:	81 2c       	mov	r8, r1
     306:	43 e0       	ldi	r20, 0x03	; 3
     308:	a4 2e       	mov	r10, r20
     30a:	55 e1       	ldi	r21, 0x15	; 21
     30c:	e5 2e       	mov	r14, r21
     30e:	02 e0       	ldi	r16, 0x02	; 2
     310:	21 e0       	ldi	r18, 0x01	; 1
     312:	40 e1       	ldi	r20, 0x10	; 16
     314:	6f e0       	ldi	r22, 0x0F	; 15
     316:	8f e0       	ldi	r24, 0x0F	; 15
     318:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     31c:	1f 92       	push	r1
     31e:	df 93       	push	r29
     320:	cf 93       	push	r28
     322:	6d e0       	ldi	r22, 0x0D	; 13
     324:	86 2e       	mov	r8, r22
     326:	aa 24       	eor	r10, r10
     328:	a3 94       	inc	r10
     32a:	72 e1       	ldi	r23, 0x12	; 18
     32c:	e7 2e       	mov	r14, r23
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     32e:	01 e0       	ldi	r16, 0x01	; 1
     330:	21 e0       	ldi	r18, 0x01	; 1
     332:	4f e0       	ldi	r20, 0x0F	; 15
     334:	60 e1       	ldi	r22, 0x10	; 16
     336:	80 e1       	ldi	r24, 0x10	; 16
     338:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     33c:	1f 92       	push	r1
     33e:	df 93       	push	r29
     340:	cf 93       	push	r28
     342:	e5 e0       	ldi	r30, 0x05	; 5
     344:	8e 2e       	mov	r8, r30
     346:	fc e1       	ldi	r31, 0x1C	; 28
     348:	ef 2e       	mov	r14, r31
     34a:	20 e0       	ldi	r18, 0x00	; 0
     34c:	4f ef       	ldi	r20, 0xFF	; 255
     34e:	61 e1       	ldi	r22, 0x11	; 17
     350:	81 e1       	ldi	r24, 0x11	; 17
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     352:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     356:	1f 92       	push	r1
     358:	df 93       	push	r29
     35a:	cf 93       	push	r28
     35c:	a0 e1       	ldi	r26, 0x10	; 16
     35e:	8a 2e       	mov	r8, r26
     360:	b2 e0       	ldi	r27, 0x02	; 2
     362:	ab 2e       	mov	r10, r27
     364:	0f e0       	ldi	r16, 0x0F	; 15
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     366:	e0 2e       	mov	r14, r16
     368:	02 e0       	ldi	r16, 0x02	; 2
     36a:	20 e0       	ldi	r18, 0x00	; 0
     36c:	4f ef       	ldi	r20, 0xFF	; 255
     36e:	62 e1       	ldi	r22, 0x12	; 18
     370:	82 e1       	ldi	r24, 0x12	; 18
     372:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     376:	1f 92       	push	r1
     378:	df 93       	push	r29
     37a:	cf 93       	push	r28
     37c:	82 e1       	ldi	r24, 0x12	; 18
     37e:	88 2e       	mov	r8, r24
     380:	91 e1       	ldi	r25, 0x11	; 17
     382:	e9 2e       	mov	r14, r25
     384:	20 e0       	ldi	r18, 0x00	; 0
     386:	4f ef       	ldi	r20, 0xFF	; 255
     388:	63 e1       	ldi	r22, 0x13	; 19
     38a:	83 e1       	ldi	r24, 0x13	; 19
     38c:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     390:	89 e0       	ldi	r24, 0x09	; 9
     392:	8f 93       	push	r24
     394:	1f 93       	push	r17
     396:	cf 93       	push	r28
     398:	22 e0       	ldi	r18, 0x02	; 2
     39a:	82 2e       	mov	r8, r18
     39c:	a1 2c       	mov	r10, r1
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     39e:	ee 24       	eor	r14, r14
     3a0:	e3 94       	inc	r14
     3a2:	00 e0       	ldi	r16, 0x00	; 0
     3a4:	21 e0       	ldi	r18, 0x01	; 1
     3a6:	4f ef       	ldi	r20, 0xFF	; 255
     3a8:	64 e1       	ldi	r22, 0x14	; 20
     3aa:	84 e1       	ldi	r24, 0x14	; 20
     3ac:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     3b0:	8b e0       	ldi	r24, 0x0B	; 11
     3b2:	8f 93       	push	r24
     3b4:	1f 93       	push	r17
     3b6:	cf 93       	push	r28
     3b8:	3e e1       	ldi	r19, 0x1E	; 30
     3ba:	83 2e       	mov	r8, r19
     3bc:	42 e0       	ldi	r20, 0x02	; 2
     3be:	a4 2e       	mov	r10, r20
     3c0:	54 e1       	ldi	r21, 0x14	; 20
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     3c2:	e5 2e       	mov	r14, r21
     3c4:	02 e0       	ldi	r16, 0x02	; 2
     3c6:	21 e0       	ldi	r18, 0x01	; 1
     3c8:	4f ef       	ldi	r20, 0xFF	; 255
     3ca:	65 e1       	ldi	r22, 0x15	; 21
     3cc:	85 e1       	ldi	r24, 0x15	; 21
     3ce:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     3d2:	8d b7       	in	r24, 0x3d	; 61
     3d4:	9e b7       	in	r25, 0x3e	; 62
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     3d6:	81 96       	adiw	r24, 0x21	; 33
     3d8:	0f b6       	in	r0, 0x3f	; 63
     3da:	f8 94       	cli
     3dc:	9e bf       	out	0x3e, r25	; 62
     3de:	0f be       	out	0x3f, r0	; 63
     3e0:	8d bf       	out	0x3d, r24	; 61
     3e2:	1f 92       	push	r1
     3e4:	df 93       	push	r29
     3e6:	cf 93       	push	r28
     3e8:	63 e0       	ldi	r22, 0x03	; 3
     3ea:	86 2e       	mov	r8, r22
     3ec:	a1 2c       	mov	r10, r1
     3ee:	77 e0       	ldi	r23, 0x07	; 7
     3f0:	e7 2e       	mov	r14, r23
     3f2:	00 e0       	ldi	r16, 0x00	; 0
     3f4:	21 e0       	ldi	r18, 0x01	; 1
     3f6:	4f ef       	ldi	r20, 0xFF	; 255
     3f8:	66 e1       	ldi	r22, 0x16	; 22
     3fa:	86 e1       	ldi	r24, 0x16	; 22
     3fc:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     400:	1f 92       	push	r1
     402:	1f 93       	push	r17
     404:	cf 93       	push	r28
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     406:	e4 e1       	ldi	r30, 0x14	; 20
     408:	8e 2e       	mov	r8, r30
     40a:	f2 e1       	ldi	r31, 0x12	; 18
     40c:	ef 2e       	mov	r14, r31
     40e:	21 e0       	ldi	r18, 0x01	; 1
     410:	4f ef       	ldi	r20, 0xFF	; 255
     412:	67 e1       	ldi	r22, 0x17	; 23
     414:	87 e1       	ldi	r24, 0x17	; 23
     416:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     41a:	ff 92       	push	r15
     41c:	1f 93       	push	r17
     41e:	cf 93       	push	r28
     420:	a5 e1       	ldi	r26, 0x15	; 21
     422:	8a 2e       	mov	r8, r26
     424:	b3 e1       	ldi	r27, 0x13	; 19
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     426:	eb 2e       	mov	r14, r27
     428:	21 e0       	ldi	r18, 0x01	; 1
     42a:	4f ef       	ldi	r20, 0xFF	; 255
     42c:	68 e1       	ldi	r22, 0x18	; 24
     42e:	88 e1       	ldi	r24, 0x18	; 24
     430:	0e 94 67 00 	call	0xce	; 0xce <set_component>
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     434:	1f 93       	push	r17
     436:	1f 93       	push	r17
     438:	cf 93       	push	r28
     43a:	86 e1       	ldi	r24, 0x16	; 22
     43c:	88 2e       	mov	r8, r24
     43e:	9a e0       	ldi	r25, 0x0A	; 10
     440:	e9 2e       	mov	r14, r25
     442:	21 e0       	ldi	r18, 0x01	; 1
	}
    else 
	{
	  debug = 0x0B;
     444:	4f ef       	ldi	r20, 0xFF	; 255
     446:	69 e1       	ldi	r22, 0x19	; 25
     448:	89 e1       	ldi	r24, 0x19	; 25
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     44a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     44e:	df 93       	push	r29
     450:	1f 93       	push	r17
     452:	cf 93       	push	r28
     454:	27 e1       	ldi	r18, 0x17	; 23
     456:	82 2e       	mov	r8, r18
     458:	3f e0       	ldi	r19, 0x0F	; 15
     45a:	e3 2e       	mov	r14, r19
     45c:	21 e0       	ldi	r18, 0x01	; 1
     45e:	4f ef       	ldi	r20, 0xFF	; 255
     460:	6a e1       	ldi	r22, 0x1A	; 26
     462:	8a e1       	ldi	r24, 0x1A	; 26
     464:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     468:	84 e0       	ldi	r24, 0x04	; 4
     46a:	8f 93       	push	r24
     46c:	1f 93       	push	r17
     46e:	cf 93       	push	r28
     470:	48 e1       	ldi	r20, 0x18	; 24
     472:	84 2e       	mov	r8, r20
     474:	59 e0       	ldi	r21, 0x09	; 9
     476:	e5 2e       	mov	r14, r21
     478:	21 e0       	ldi	r18, 0x01	; 1
     47a:	4f ef       	ldi	r20, 0xFF	; 255
     47c:	6b e1       	ldi	r22, 0x1B	; 27
     47e:	8b e1       	ldi	r24, 0x1B	; 27
     480:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     484:	1f 92       	push	r1
     486:	df 93       	push	r29
     488:	cf 93       	push	r28
     48a:	69 e1       	ldi	r22, 0x19	; 25
     48c:	86 2e       	mov	r8, r22
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     48e:	7e e0       	ldi	r23, 0x0E	; 14
     490:	e7 2e       	mov	r14, r23
     492:	21 e0       	ldi	r18, 0x01	; 1
     494:	4f ef       	ldi	r20, 0xFF	; 255
     496:	6c e1       	ldi	r22, 0x1C	; 28
     498:	8c e1       	ldi	r24, 0x1C	; 28
     49a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     49e:	1f 92       	push	r1
     4a0:	df 93       	push	r29
     4a2:	cf 93       	push	r28
     4a4:	ea e1       	ldi	r30, 0x1A	; 26
     4a6:	8e 2e       	mov	r8, r30
     4a8:	f0 e1       	ldi	r31, 0x10	; 16
     4aa:	ef 2e       	mov	r14, r31
     4ac:	21 e0       	ldi	r18, 0x01	; 1
     4ae:	4f ef       	ldi	r20, 0xFF	; 255
     4b0:	6d e1       	ldi	r22, 0x1D	; 29
     4b2:	8d e1       	ldi	r24, 0x1D	; 29
     4b4:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4b8:	1f 92       	push	r1
     4ba:	df 93       	push	r29
     4bc:	cf 93       	push	r28
     4be:	ab e1       	ldi	r26, 0x1B	; 27
     4c0:	8a 2e       	mov	r8, r26
     4c2:	b8 e0       	ldi	r27, 0x08	; 8
     4c4:	eb 2e       	mov	r14, r27
     4c6:	21 e0       	ldi	r18, 0x01	; 1
     4c8:	4f ef       	ldi	r20, 0xFF	; 255
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     4ca:	6e e1       	ldi	r22, 0x1E	; 30
     4cc:	8e e1       	ldi	r24, 0x1E	; 30
     4ce:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4d2:	85 e0       	ldi	r24, 0x05	; 5
     4d4:	8f 93       	push	r24
     4d6:	1f 93       	push	r17
     4d8:	cf 93       	push	r28
     4da:	8c e1       	ldi	r24, 0x1C	; 28
     4dc:	88 2e       	mov	r8, r24
     4de:	9d e0       	ldi	r25, 0x0D	; 13
     4e0:	e9 2e       	mov	r14, r25
     4e2:	21 e0       	ldi	r18, 0x01	; 1
     4e4:	4f ef       	ldi	r20, 0xFF	; 255
     4e6:	6f e1       	ldi	r22, 0x1F	; 31
     4e8:	8f e1       	ldi	r24, 0x1F	; 31
     4ea:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4ee:	1f 92       	push	r1
     4f0:	df 93       	push	r29
     4f2:	cf 93       	push	r28
     4f4:	2d e1       	ldi	r18, 0x1D	; 29
     4f6:	82 2e       	mov	r8, r18
     4f8:	3c e0       	ldi	r19, 0x0C	; 12
     4fa:	e3 2e       	mov	r14, r19
     4fc:	21 e0       	ldi	r18, 0x01	; 1
     4fe:	4f ef       	ldi	r20, 0xFF	; 255
     500:	60 e2       	ldi	r22, 0x20	; 32
     502:	80 e2       	ldi	r24, 0x20	; 32
     504:	0e 94 67 00 	call	0xce	; 0xce <set_component>
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     508:	8d b7       	in	r24, 0x3d	; 61
     50a:	9e b7       	in	r25, 0x3e	; 62
     50c:	81 96       	adiw	r24, 0x21	; 33
     50e:	0f b6       	in	r0, 0x3f	; 63
     510:	f8 94       	cli
     512:	9e bf       	out	0x3e, r25	; 62
     514:	0f be       	out	0x3f, r0	; 63
     516:	8d bf       	out	0x3d, r24	; 61
     518:	1f 92       	push	r1
     51a:	df 93       	push	r29
     51c:	cf 93       	push	r28
     51e:	4e e1       	ldi	r20, 0x1E	; 30
     520:	84 2e       	mov	r8, r20
     522:	5b e0       	ldi	r21, 0x0B	; 11
     524:	e5 2e       	mov	r14, r21
     526:	21 e0       	ldi	r18, 0x01	; 1
     528:	4f ef       	ldi	r20, 0xFF	; 255
     52a:	61 e2       	ldi	r22, 0x21	; 33
     52c:	81 e2       	ldi	r24, 0x21	; 33
     52e:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     532:	1f 92       	push	r1
     534:	df 93       	push	r29
     536:	cf 93       	push	r28
     538:	6f e1       	ldi	r22, 0x1F	; 31
     53a:	86 2e       	mov	r8, r22
     53c:	71 e1       	ldi	r23, 0x11	; 17
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     53e:	e7 2e       	mov	r14, r23
     540:	21 e0       	ldi	r18, 0x01	; 1
     542:	4f ef       	ldi	r20, 0xFF	; 255
     544:	62 e2       	ldi	r22, 0x22	; 34
     546:	82 e2       	ldi	r24, 0x22	; 34
     548:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     54c:	86 e0       	ldi	r24, 0x06	; 6
     54e:	8f 93       	push	r24
     550:	1f 93       	push	r17
     552:	cf 93       	push	r28
     554:	81 2c       	mov	r8, r1
     556:	e5 e0       	ldi	r30, 0x05	; 5
     558:	ee 2e       	mov	r14, r30
     55a:	21 e0       	ldi	r18, 0x01	; 1
     55c:	4f ef       	ldi	r20, 0xFF	; 255
     55e:	63 e2       	ldi	r22, 0x23	; 35
     560:	83 e2       	ldi	r24, 0x23	; 35
     562:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     566:	8d b7       	in	r24, 0x3d	; 61
     568:	9e b7       	in	r25, 0x3e	; 62
     56a:	09 96       	adiw	r24, 0x09	; 9
     56c:	0f b6       	in	r0, 0x3f	; 63
     56e:	f8 94       	cli
     570:	9e bf       	out	0x3e, r25	; 62
     572:	0f be       	out	0x3f, r0	; 63
     574:	8d bf       	out	0x3d, r24	; 61
     576:	df 91       	pop	r29
     578:	cf 91       	pop	r28
     57a:	1f 91       	pop	r17
     57c:	0f 91       	pop	r16
     57e:	ff 90       	pop	r15
     580:	ef 90       	pop	r14
     582:	cf 90       	pop	r12
     584:	af 90       	pop	r10
     586:	8f 90       	pop	r8
     588:	08 95       	ret

0000058a <receive_message>:
     58a:	ff 92       	push	r15
     58c:	0f 93       	push	r16
     58e:	1f 93       	push	r17
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	f8 2e       	mov	r15, r24
     596:	fb 01       	movw	r30, r22
     598:	c1 81       	ldd	r28, Z+1	; 0x01
     59a:	90 81       	ld	r25, Z
     59c:	93 30       	cpi	r25, 0x03	; 3
     59e:	09 f4       	brne	.+2      	; 0x5a2 <receive_message+0x18>
     5a0:	5a c0       	rjmp	.+180    	; 0x656 <receive_message+0xcc>
     5a2:	30 f4       	brcc	.+12     	; 0x5b0 <receive_message+0x26>
     5a4:	0c 2f       	mov	r16, r28
     5a6:	10 e0       	ldi	r17, 0x00	; 0
     5a8:	91 30       	cpi	r25, 0x01	; 1
     5aa:	11 f1       	breq	.+68     	; 0x5f0 <receive_message+0x66>
     5ac:	90 f5       	brcc	.+100    	; 0x612 <receive_message+0x88>
     5ae:	0c c0       	rjmp	.+24     	; 0x5c8 <receive_message+0x3e>
     5b0:	95 30       	cpi	r25, 0x05	; 5
     5b2:	09 f4       	brne	.+2      	; 0x5b6 <receive_message+0x2c>
     5b4:	55 c0       	rjmp	.+170    	; 0x660 <receive_message+0xd6>
     5b6:	08 f4       	brcc	.+2      	; 0x5ba <receive_message+0x30>
     5b8:	50 c0       	rjmp	.+160    	; 0x65a <receive_message+0xd0>
     5ba:	96 30       	cpi	r25, 0x06	; 6
     5bc:	09 f4       	brne	.+2      	; 0x5c0 <receive_message+0x36>
     5be:	60 c0       	rjmp	.+192    	; 0x680 <receive_message+0xf6>
     5c0:	97 30       	cpi	r25, 0x07	; 7
     5c2:	09 f0       	breq	.+2      	; 0x5c6 <receive_message+0x3c>
     5c4:	7b c0       	rjmp	.+246    	; 0x6bc <receive_message+0x132>
     5c6:	6b c0       	rjmp	.+214    	; 0x69e <receive_message+0x114>
     5c8:	8c e2       	ldi	r24, 0x2C	; 44
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     5ca:	80 93 bb 0d 	sts	0x0DBB, r24
     5ce:	8a e1       	ldi	r24, 0x1A	; 26
     5d0:	80 9f       	mul	r24, r16
     5d2:	e0 01       	movw	r28, r0
     5d4:	81 9f       	mul	r24, r17
     5d6:	d0 0d       	add	r29, r0
     5d8:	11 24       	eor	r1, r1
     5da:	c0 56       	subi	r28, 0x60	; 96
     5dc:	dc 4f       	sbci	r29, 0xFC	; 252
     5de:	89 81       	ldd	r24, Y+1	; 0x01
     5e0:	8f 3f       	cpi	r24, 0xFF	; 255
     5e2:	21 f0       	breq	.+8      	; 0x5ec <receive_message+0x62>
     5e4:	0e 94 b4 07 	call	0xf68	; 0xf68 <switch_on>
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	8a 83       	std	Y+2, r24	; 0x02
     5ec:	40 e0       	ldi	r20, 0x00	; 0
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     5ee:	0f c0       	rjmp	.+30     	; 0x60e <receive_message+0x84>
     5f0:	8a e1       	ldi	r24, 0x1A	; 26
     5f2:	80 9f       	mul	r24, r16
     5f4:	e0 01       	movw	r28, r0
     5f6:	81 9f       	mul	r24, r17
     5f8:	d0 0d       	add	r29, r0
     5fa:	11 24       	eor	r1, r1
     5fc:	c0 56       	subi	r28, 0x60	; 96
     5fe:	dc 4f       	sbci	r29, 0xFC	; 252
     600:	89 81       	ldd	r24, Y+1	; 0x01
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     602:	8f 3f       	cpi	r24, 0xFF	; 255
     604:	19 f0       	breq	.+6      	; 0x60c <receive_message+0x82>
     606:	0e 94 f7 07 	call	0xfee	; 0xfee <switch_off>
     60a:	1a 82       	std	Y+2, r1	; 0x02
     60c:	41 e0       	ldi	r20, 0x01	; 1
     60e:	62 e0       	ldi	r22, 0x02	; 2
     610:	57 c0       	rjmp	.+174    	; 0x6c0 <receive_message+0x136>
     612:	8a e1       	ldi	r24, 0x1A	; 26
     614:	80 9f       	mul	r24, r16
     616:	e0 01       	movw	r28, r0
     618:	81 9f       	mul	r24, r17
     61a:	d0 0d       	add	r29, r0
     61c:	11 24       	eor	r1, r1
     61e:	c0 56       	subi	r28, 0x60	; 96
     620:	dc 4f       	sbci	r29, 0xFC	; 252
     622:	89 81       	ldd	r24, Y+1	; 0x01
     624:	8f 3f       	cpi	r24, 0xFF	; 255
     626:	19 f0       	breq	.+6      	; 0x62e <receive_message+0xa4>
     628:	0e 94 f7 07 	call	0xfee	; 0xfee <switch_off>
     62c:	1a 82       	std	Y+2, r1	; 0x02
     62e:	85 e0       	ldi	r24, 0x05	; 5
     630:	8a 95       	dec	r24
     632:	f1 f7       	brne	.-4      	; 0x630 <receive_message+0xa6>
     634:	8a e1       	ldi	r24, 0x1A	; 26
     636:	80 9f       	mul	r24, r16
     638:	e0 01       	movw	r28, r0
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     63a:	81 9f       	mul	r24, r17
     63c:	d0 0d       	add	r29, r0
     63e:	11 24       	eor	r1, r1
     640:	c0 56       	subi	r28, 0x60	; 96
     642:	dc 4f       	sbci	r29, 0xFC	; 252
     644:	89 81       	ldd	r24, Y+1	; 0x01
     646:	8f 3f       	cpi	r24, 0xFF	; 255
     648:	21 f0       	breq	.+8      	; 0x652 <receive_message+0xc8>
     64a:	0e 94 b4 07 	call	0xf68	; 0xf68 <switch_on>
     64e:	81 e0       	ldi	r24, 0x01	; 1
     650:	8a 83       	std	Y+2, r24	; 0x02
     652:	42 e0       	ldi	r20, 0x02	; 2
     654:	dc cf       	rjmp	.-72     	; 0x60e <receive_message+0x84>
     656:	43 e0       	ldi	r20, 0x03	; 3
     658:	da cf       	rjmp	.-76     	; 0x60e <receive_message+0x84>
     65a:	40 e0       	ldi	r20, 0x00	; 0
     65c:	60 e0       	ldi	r22, 0x00	; 0
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     65e:	30 c0       	rjmp	.+96     	; 0x6c0 <receive_message+0x136>
     660:	8a e1       	ldi	r24, 0x1A	; 26
     662:	c8 9f       	mul	r28, r24
     664:	e0 01       	movw	r28, r0
     666:	11 24       	eor	r1, r1
     668:	c0 56       	subi	r28, 0x60	; 96
     66a:	dc 4f       	sbci	r29, 0xFC	; 252
     66c:	89 81       	ldd	r24, Y+1	; 0x01
     66e:	8f 3f       	cpi	r24, 0xFF	; 255
     670:	29 f0       	breq	.+10     	; 0x67c <receive_message+0xf2>
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     672:	0e 94 b4 07 	call	0xf68	; 0xf68 <switch_on>
     676:	81 e0       	ldi	r24, 0x01	; 1
     678:	8a 83       	std	Y+2, r24	; 0x02
     67a:	8b 83       	std	Y+3, r24	; 0x03
     67c:	45 e0       	ldi	r20, 0x05	; 5
     67e:	c7 cf       	rjmp	.-114    	; 0x60e <receive_message+0x84>
     680:	8a e1       	ldi	r24, 0x1A	; 26
     682:	c8 9f       	mul	r28, r24
     684:	e0 01       	movw	r28, r0
     686:	11 24       	eor	r1, r1
     688:	c0 56       	subi	r28, 0x60	; 96
     68a:	dc 4f       	sbci	r29, 0xFC	; 252
     68c:	89 81       	ldd	r24, Y+1	; 0x01
     68e:	8f 3f       	cpi	r24, 0xFF	; 255
     690:	f9 f0       	breq	.+62     	; 0x6d0 <receive_message+0x146>
     692:	82 81       	ldd	r24, Z+2	; 0x02
     694:	8e 83       	std	Y+6, r24	; 0x06
     696:	82 81       	ldd	r24, Z+2	; 0x02
     698:	80 93 9f 0b 	sts	0x0B9F, r24
     69c:	19 c0       	rjmp	.+50     	; 0x6d0 <receive_message+0x146>
     69e:	8a e1       	ldi	r24, 0x1A	; 26
     6a0:	c8 9f       	mul	r28, r24
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6a2:	e0 01       	movw	r28, r0
     6a4:	11 24       	eor	r1, r1
     6a6:	c0 56       	subi	r28, 0x60	; 96
     6a8:	dc 4f       	sbci	r29, 0xFC	; 252
     6aa:	89 81       	ldd	r24, Y+1	; 0x01
     6ac:	8f 3f       	cpi	r24, 0xFF	; 255
     6ae:	81 f0       	breq	.+32     	; 0x6d0 <receive_message+0x146>
     6b0:	82 81       	ldd	r24, Z+2	; 0x02
     6b2:	8e 87       	std	Y+14, r24	; 0x0e
     6b4:	82 81       	ldd	r24, Z+2	; 0x02
     6b6:	80 93 9a 0b 	sts	0x0B9A, r24
     6ba:	0a c0       	rjmp	.+20     	; 0x6d0 <receive_message+0x146>
     6bc:	40 e0       	ldi	r20, 0x00	; 0
     6be:	61 e0       	ldi	r22, 0x01	; 1
     6c0:	8f 2d       	mov	r24, r15
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     6c2:	df 91       	pop	r29
     6c4:	cf 91       	pop	r28
     6c6:	1f 91       	pop	r17
     6c8:	0f 91       	pop	r16
     6ca:	ff 90       	pop	r15
     6cc:	0c 94 2a 10 	jmp	0x2054	; 0x2054 <transmit_packet>
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	1f 91       	pop	r17
     6d6:	0f 91       	pop	r16
     6d8:	ff 90       	pop	r15
     6da:	08 95       	ret

000006dc <StateofCharge>:
     6dc:	80 91 8f 09 	lds	r24, 0x098F
     6e0:	8f 3f       	cpi	r24, 0xFF	; 255
     6e2:	09 f4       	brne	.+2      	; 0x6e6 <StateofCharge+0xa>
     6e4:	6a c0       	rjmp	.+212    	; 0x7ba <StateofCharge+0xde>
     6e6:	90 91 79 09 	lds	r25, 0x0979
     6ea:	99 23       	and	r25, r25
     6ec:	09 f4       	brne	.+2      	; 0x6f0 <StateofCharge+0x14>
     6ee:	65 c0       	rjmp	.+202    	; 0x7ba <StateofCharge+0xde>
     6f0:	90 91 90 09 	lds	r25, 0x0990
     6f4:	99 23       	and	r25, r25
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     6f6:	21 f0       	breq	.+8      	; 0x700 <StateofCharge+0x24>
     6f8:	91 e0       	ldi	r25, 0x01	; 1
     6fa:	90 93 c6 0d 	sts	0x0DC6, r25
     6fe:	02 c0       	rjmp	.+4      	; 0x704 <StateofCharge+0x28>
     700:	10 92 c6 0d 	sts	0x0DC6, r1
     704:	98 2f       	mov	r25, r24
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
	}
  	percent = 100*(1 - batt_time/discharge_max_time);
     706:	95 56       	subi	r25, 0x65	; 101
     708:	9a 31       	cpi	r25, 0x1A	; 26
     70a:	08 f0       	brcs	.+2      	; 0x70e <StateofCharge+0x32>
     70c:	43 c0       	rjmp	.+134    	; 0x794 <StateofCharge+0xb8>
     70e:	90 91 70 03 	lds	r25, 0x0370
     712:	9f 5f       	subi	r25, 0xFF	; 255
     714:	90 93 70 03 	sts	0x0370, r25
     718:	20 91 c6 0d 	lds	r18, 0x0DC6
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	22 23       	and	r18, r18
     720:	a1 f0       	breq	.+40     	; 0x74a <StateofCharge+0x6e>
     722:	fc 01       	movw	r30, r24
     724:	ee 0f       	add	r30, r30
     726:	ff 1f       	adc	r31, r31
     728:	e4 5c       	subi	r30, 0xC4	; 196
     72a:	fd 4f       	sbci	r31, 0xFD	; 253
     72c:	60 81       	ld	r22, Z
     72e:	71 81       	ldd	r23, Z+1	; 0x01
     730:	6b 50       	subi	r22, 0x0B	; 11
     732:	71 09       	sbc	r23, r1
     734:	80 e0       	ldi	r24, 0x00	; 0
     736:	90 e0       	ldi	r25, 0x00	; 0
     738:	0e 94 a8 11 	call	0x2350	; 0x2350 <__floatunsisf>
  }
  else 
  {
    float temp_real = 0;
    if (real < 13.35)
     73c:	28 eb       	ldi	r18, 0xB8	; 184
     73e:	3e e1       	ldi	r19, 0x1E	; 30
     740:	49 e2       	ldi	r20, 0x29	; 41
     742:	51 e4       	ldi	r21, 0x41	; 65
     744:	0e 94 40 11 	call	0x2280	; 0x2280 <__divsf3>
     748:	1c c0       	rjmp	.+56     	; 0x782 <StateofCharge+0xa6>
     74a:	e7 e7       	ldi	r30, 0x77	; 119
     74c:	f0 e0       	ldi	r31, 0x00	; 0
     74e:	e8 1b       	sub	r30, r24
	{
	  debug = 0x0C;
     750:	f9 0b       	sbc	r31, r25
     752:	ee 0f       	add	r30, r30
     754:	ff 1f       	adc	r31, r31
	  // voltage is normalized by mean 13.13 and std 0.1754 (real - 13.13)/0.1754
	  temp_real = (real - 13.13)*5.701254;
     756:	e2 5c       	subi	r30, 0xC2	; 194
     758:	fc 4f       	sbci	r31, 0xFC	; 252
     75a:	60 81       	ld	r22, Z
     75c:	71 81       	ldd	r23, Z+1	; 0x01
     75e:	80 e0       	ldi	r24, 0x00	; 0
     760:	90 e0       	ldi	r25, 0x00	; 0
     762:	0e 94 a8 11 	call	0x2350	; 0x2350 <__floatunsisf>
     766:	28 eb       	ldi	r18, 0xB8	; 184
     768:	3e e1       	ldi	r19, 0x1E	; 30
     76a:	41 e2       	ldi	r20, 0x21	; 33
     76c:	51 e4       	ldi	r21, 0x41	; 65
     76e:	0e 94 40 11 	call	0x2280	; 0x2280 <__divsf3>
     772:	9b 01       	movw	r18, r22
     774:	ac 01       	movw	r20, r24
	  batt_time = p1*pow(temp_real,3) + p2*pow(temp_real,2) + p3*temp_real + p4;
     776:	60 e0       	ldi	r22, 0x00	; 0
     778:	70 e0       	ldi	r23, 0x00	; 0
     77a:	88 ec       	ldi	r24, 0xC8	; 200
     77c:	92 e4       	ldi	r25, 0x42	; 66
     77e:	0e 94 d7 10 	call	0x21ae	; 0x21ae <__subsf3>
     782:	60 93 4f 07 	sts	0x074F, r22
     786:	70 93 50 07 	sts	0x0750, r23
     78a:	80 93 51 07 	sts	0x0751, r24
     78e:	90 93 52 07 	sts	0x0752, r25
     792:	13 c0       	rjmp	.+38     	; 0x7ba <StateofCharge+0xde>
     794:	85 36       	cpi	r24, 0x65	; 101
     796:	28 f4       	brcc	.+10     	; 0x7a2 <StateofCharge+0xc6>
     798:	80 e0       	ldi	r24, 0x00	; 0
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	a0 e8       	ldi	r26, 0x80	; 128
     79e:	bf eb       	ldi	r27, 0xBF	; 191
     7a0:	04 c0       	rjmp	.+8      	; 0x7aa <StateofCharge+0xce>
     7a2:	80 e0       	ldi	r24, 0x00	; 0
     7a4:	90 e0       	ldi	r25, 0x00	; 0
     7a6:	a8 ed       	ldi	r26, 0xD8	; 216
     7a8:	b2 e4       	ldi	r27, 0x42	; 66
     7aa:	80 93 4f 07 	sts	0x074F, r24
     7ae:	90 93 50 07 	sts	0x0750, r25
     7b2:	a0 93 51 07 	sts	0x0751, r26
     7b6:	b0 93 52 07 	sts	0x0752, r27
     7ba:	80 91 90 09 	lds	r24, 0x0990
     7be:	81 50       	subi	r24, 0x01	; 1
     7c0:	8e 3f       	cpi	r24, 0xFE	; 254
     7c2:	28 f4       	brcc	.+10     	; 0x7ce <StateofCharge+0xf2>
     7c4:	80 91 70 03 	lds	r24, 0x0370
     7c8:	8f 5f       	subi	r24, 0xFF	; 255
     7ca:	80 93 70 03 	sts	0x0370, r24
     7ce:	08 95       	ret

000007d0 <assign_charge_fit>:
     7d0:	80 e0       	ldi	r24, 0x00	; 0
     7d2:	90 e3       	ldi	r25, 0x30	; 48
     7d4:	af e1       	ldi	r26, 0x1F	; 31
     7d6:	b6 e4       	ldi	r27, 0x46	; 70
     7d8:	80 93 96 09 	sts	0x0996, r24
     7dc:	90 93 97 09 	sts	0x0997, r25
     7e0:	a0 93 98 09 	sts	0x0998, r26
     7e4:	b0 93 99 09 	sts	0x0999, r27
     7e8:	8c e5       	ldi	r24, 0x5C	; 92
     7ea:	9f e8       	ldi	r25, 0x8F	; 143
     7ec:	a4 e9       	ldi	r26, 0x94	; 148
     7ee:	b1 e4       	ldi	r27, 0x41	; 65
     7f0:	80 93 68 09 	sts	0x0968, r24
     7f4:	90 93 69 09 	sts	0x0969, r25
     7f8:	a0 93 6a 09 	sts	0x096A, r26
     7fc:	b0 93 6b 09 	sts	0x096B, r27
     800:	8d ec       	ldi	r24, 0xCD	; 205
     802:	9c ec       	ldi	r25, 0xCC	; 204
     804:	a8 e3       	ldi	r26, 0x38	; 56
     806:	b3 e4       	ldi	r27, 0x43	; 67
     808:	80 93 8d 03 	sts	0x038D, r24
     80c:	90 93 8e 03 	sts	0x038E, r25
	}
	else 
	{
	  debug = 0x0D;
     810:	a0 93 8f 03 	sts	0x038F, r26
     814:	b0 93 90 03 	sts	0x0390, r27
	  // voltage is normalized by mean 13.7 and std 0.1558 (real - 13.7)/0.1558;
	  temp_real = (real - 13.7)*6.418485;
     818:	86 e6       	ldi	r24, 0x66	; 102
     81a:	96 ee       	ldi	r25, 0xE6	; 230
     81c:	a5 e2       	ldi	r26, 0x25	; 37
     81e:	b4 e4       	ldi	r27, 0x44	; 68
     820:	80 93 ae 0d 	sts	0x0DAE, r24
     824:	90 93 af 0d 	sts	0x0DAF, r25
     828:	a0 93 b0 0d 	sts	0x0DB0, r26
     82c:	b0 93 b1 0d 	sts	0x0DB1, r27
     830:	86 e6       	ldi	r24, 0x66	; 102
     832:	96 ea       	ldi	r25, 0xA6	; 166
     834:	a1 e5       	ldi	r26, 0x51	; 81
      batt_time = q1*pow(temp_real,3) + q2*pow(temp_real,2) + q3*temp_real + q4;
     836:	b4 e4       	ldi	r27, 0x44	; 68
     838:	80 93 c9 0d 	sts	0x0DC9, r24
     83c:	90 93 ca 0d 	sts	0x0DCA, r25
     840:	a0 93 cb 0d 	sts	0x0DCB, r26
     844:	b0 93 cc 0d 	sts	0x0DCC, r27
     848:	81 ee       	ldi	r24, 0xE1	; 225
     84a:	9a ef       	ldi	r25, 0xFA	; 250
     84c:	ac e9       	ldi	r26, 0x9C	; 156
     84e:	b2 e4       	ldi	r27, 0x42	; 66
     850:	80 93 8a 09 	sts	0x098A, r24
     854:	90 93 8b 09 	sts	0x098B, r25
     858:	a0 93 8c 09 	sts	0x098C, r26
     85c:	b0 93 8d 09 	sts	0x098D, r27
     860:	86 e6       	ldi	r24, 0x66	; 102
     862:	96 ec       	ldi	r25, 0xC6	; 198
     864:	a7 e0       	ldi	r26, 0x07	; 7
     866:	b4 e4       	ldi	r27, 0x44	; 68
     868:	80 93 48 07 	sts	0x0748, r24
     86c:	90 93 49 07 	sts	0x0749, r25
     870:	a0 93 4a 07 	sts	0x074A, r26
     874:	b0 93 4b 07 	sts	0x074B, r27
     878:	80 e0       	ldi	r24, 0x00	; 0
     87a:	90 eb       	ldi	r25, 0xB0	; 176
     87c:	a7 e1       	ldi	r26, 0x17	; 23
     87e:	b5 e4       	ldi	r27, 0x45	; 69
     880:	80 93 86 09 	sts	0x0986, r24
     884:	90 93 87 09 	sts	0x0987, r25
     888:	a0 93 88 09 	sts	0x0988, r26
     88c:	b0 93 89 09 	sts	0x0989, r27
     890:	80 e0       	ldi	r24, 0x00	; 0
     892:	98 e9       	ldi	r25, 0x98	; 152
     894:	ae ea       	ldi	r26, 0xAE	; 174
     896:	b5 e4       	ldi	r27, 0x45	; 69
     898:	80 93 be 0d 	sts	0x0DBE, r24
     89c:	90 93 bf 0d 	sts	0x0DBF, r25
     8a0:	a0 93 c0 0d 	sts	0x0DC0, r26
     8a4:	b0 93 c1 0d 	sts	0x0DC1, r27
     8a8:	08 95       	ret

000008aa <assign_discharge_fit>:
     8aa:	80 e0       	ldi	r24, 0x00	; 0
     8ac:	96 e1       	ldi	r25, 0x16	; 22
     8ae:	a9 e8       	ldi	r26, 0x89	; 137
     8b0:	b6 e4       	ldi	r27, 0x46	; 70
     8b2:	80 93 5d 07 	sts	0x075D, r24
     8b6:	90 93 5e 07 	sts	0x075E, r25
     8ba:	a0 93 5f 07 	sts	0x075F, r26
     8be:	b0 93 60 07 	sts	0x0760, r27
     8c2:	88 eb       	ldi	r24, 0xB8	; 184
     8c4:	93 ec       	ldi	r25, 0xC3	; 195
     8c6:	90 93 ab 0d 	sts	0x0DAB, r25
     8ca:	80 93 aa 0d 	sts	0x0DAA, r24
     8ce:	8a ee       	ldi	r24, 0xEA	; 234
     8d0:	98 eb       	ldi	r25, 0xB8	; 184
     8d2:	90 93 b5 0d 	sts	0x0DB5, r25
     8d6:	80 93 b4 0d 	sts	0x0DB4, r24
     8da:	8f e6       	ldi	r24, 0x6F	; 111
     8dc:	9c e9       	ldi	r25, 0x9C	; 156
     8de:	90 93 4d 07 	sts	0x074D, r25
	}
  	percent = 100*(batt_time/charge_max_time);
     8e2:	80 93 4c 07 	sts	0x074C, r24
     8e6:	85 e9       	ldi	r24, 0x95	; 149
     8e8:	9c e2       	ldi	r25, 0x2C	; 44
     8ea:	90 93 7f 09 	sts	0x097F, r25
     8ee:	80 93 7e 09 	sts	0x097E, r24
     8f2:	81 e7       	ldi	r24, 0x71	; 113
     8f4:	9a ea       	ldi	r25, 0xAA	; 170
     8f6:	90 93 8b 03 	sts	0x038B, r25
     8fa:	80 93 8a 03 	sts	0x038A, r24
     8fe:	8a ec       	ldi	r24, 0xCA	; 202
     900:	98 e3       	ldi	r25, 0x38	; 56
     902:	90 93 73 09 	sts	0x0973, r25
     906:	80 93 72 09 	sts	0x0972, r24
     90a:	82 e0       	ldi	r24, 0x02	; 2
     90c:	93 e0       	ldi	r25, 0x03	; 3
     90e:	90 93 ad 0d 	sts	0x0DAD, r25
     912:	80 93 ac 0d 	sts	0x0DAC, r24
     916:	8d ea       	ldi	r24, 0xAD	; 173
     918:	97 e0       	ldi	r25, 0x07	; 7
     91a:	90 93 b3 0d 	sts	0x0DB3, r25
     91e:	80 93 b2 0d 	sts	0x0DB2, r24
  }
  
  // Percent limiting for periodic function
  if (percent < 1) 
     922:	80 e8       	ldi	r24, 0x80	; 128
     924:	95 e1       	ldi	r25, 0x15	; 21
     926:	90 93 67 07 	sts	0x0767, r25
     92a:	80 93 66 07 	sts	0x0766, r24
     92e:	8e e4       	ldi	r24, 0x4E	; 78
     930:	9c ef       	ldi	r25, 0xFC	; 252
     932:	90 93 65 07 	sts	0x0765, r25
     936:	80 93 64 07 	sts	0x0764, r24
     93a:	8b e3       	ldi	r24, 0x3B	; 59
     93c:	93 e0       	ldi	r25, 0x03	; 3
     93e:	90 93 a9 0d 	sts	0x0DA9, r25
     942:	80 93 a8 0d 	sts	0x0DA8, r24
  { 
  	debug2 = 0xA0;
     946:	8c ed       	ldi	r24, 0xDC	; 220
     948:	9b e6       	ldi	r25, 0x6B	; 107
     94a:	ae e2       	ldi	r26, 0x2E	; 46
  	soc = 0; 
     94c:	b0 e4       	ldi	r27, 0x40	; 64
     94e:	80 93 53 07 	sts	0x0753, r24
  }
  else if (percent > 99) 
     952:	90 93 54 07 	sts	0x0754, r25
     956:	a0 93 55 07 	sts	0x0755, r26
     95a:	b0 93 56 07 	sts	0x0756, r27
     95e:	80 e8       	ldi	r24, 0x80	; 128
     960:	95 e5       	ldi	r25, 0x55	; 85
     962:	a2 ec       	ldi	r26, 0xC2	; 194
     964:	b1 e1       	ldi	r27, 0x11	; 17
  { 
  	debug2 = 0xB0;
     966:	80 93 7a 09 	sts	0x097A, r24
     96a:	90 93 7b 09 	sts	0x097B, r25
  	soc = 255;
     96e:	a0 93 7c 09 	sts	0x097C, r26
     972:	b0 93 7d 09 	sts	0x097D, r27
  }
  else { 
  	debug2 = 0xC0;
     976:	80 ea       	ldi	r24, 0xA0	; 160
     978:	9c e3       	ldi	r25, 0x3C	; 60
  	soc = (char)floor((int)(percent)); 
     97a:	a3 e7       	ldi	r26, 0x73	; 115
     97c:	bc e0       	ldi	r27, 0x0C	; 12
     97e:	80 93 95 03 	sts	0x0395, r24
     982:	90 93 96 03 	sts	0x0396, r25
     986:	a0 93 97 03 	sts	0x0397, r26
     98a:	b0 93 98 03 	sts	0x0398, r27
     98e:	80 ea       	ldi	r24, 0xA0	; 160
     990:	96 e6       	ldi	r25, 0x66	; 102
     992:	ac ef       	ldi	r26, 0xFC	; 252
     994:	b9 e1       	ldi	r27, 0x19	; 25
     996:	80 93 9a 03 	sts	0x039A, r24
  }
}
     99a:	90 93 9b 03 	sts	0x039B, r25
     99e:	a0 93 9c 03 	sts	0x039C, r26
     9a2:	b0 93 9d 03 	sts	0x039D, r27
     9a6:	80 e2       	ldi	r24, 0x20	; 32
     9a8:	95 eb       	ldi	r25, 0xB5	; 181
     9aa:	a4 ea       	ldi	r26, 0xA4	; 164
     9ac:	b6 ef       	ldi	r27, 0xF6	; 246
     9ae:	80 93 75 09 	sts	0x0975, r24
     9b2:	90 93 76 09 	sts	0x0976, r25
     9b6:	a0 93 77 09 	sts	0x0977, r26
     9ba:	b0 93 78 09 	sts	0x0978, r27
     9be:	80 e9       	ldi	r24, 0x90	; 144
     9c0:	92 ec       	ldi	r25, 0xC2	; 194
     9c2:	ad eb       	ldi	r26, 0xBD	; 189
  
  h0 = 2.979485572689352E8;
  h1 = 2.088787459098652E8;
  g1 = 4.359717315569648E8;
  h2 =  -1.569778955752849E8;
  g2 =  1.969854815603661E8;
     9c4:	bb e0       	ldi	r27, 0x0B	; 11
     9c6:	80 93 6d 09 	sts	0x096D, r24
     9ca:	90 93 6e 09 	sts	0x096E, r25
     9ce:	a0 93 6f 09 	sts	0x096F, r26
     9d2:	b0 93 70 09 	sts	0x0970, r27
  h3 =  -7.513816845838763E7;
     9d6:	88 e8       	ldi	r24, 0x88	; 136
     9d8:	9b e7       	ldi	r25, 0x7B	; 123
     9da:	a5 e8       	ldi	r26, 0x85	; 133
     9dc:	bb ef       	ldi	r27, 0xFB	; 251
     9de:	80 93 b6 0d 	sts	0x0DB6, r24
     9e2:	90 93 b7 0d 	sts	0x0DB7, r25
     9e6:	a0 93 b8 0d 	sts	0x0DB8, r26
     9ea:	b0 93 b9 0d 	sts	0x0DB9, r27
  g3 =  -1.633385950799686E7;
     9ee:	8c ed       	ldi	r24, 0xDC	; 220
     9f0:	93 ec       	ldi	r25, 0xC3	; 195
     9f2:	a6 e0       	ldi	r26, 0x06	; 6
     9f4:	bf ef       	ldi	r27, 0xFF	; 255
     9f6:	80 93 86 03 	sts	0x0386, r24
     9fa:	90 93 87 03 	sts	0x0387, r25
     9fe:	a0 93 88 03 	sts	0x0388, r26
     a02:	b0 93 89 03 	sts	0x0389, r27
  h4 =   -2.642581886559125E6;
     a06:	8a e6       	ldi	r24, 0x6A	; 106
     a08:	9d ea       	ldi	r25, 0xAD	; 173
     a0a:	a7 ed       	ldi	r26, 0xD7	; 215
     a0c:	bf ef       	ldi	r27, 0xFF	; 255
     a0e:	80 93 9f 0d 	sts	0x0D9F, r24
     a12:	90 93 a0 0d 	sts	0x0DA0, r25
     a16:	a0 93 a1 0d 	sts	0x0DA1, r26
     a1a:	b0 93 a2 0d 	sts	0x0DA2, r27
  g4 =   -1.016608352073227E7;
     a1e:	8c eb       	ldi	r24, 0xBC	; 188
     a20:	90 ee       	ldi	r25, 0xE0	; 224
     a22:	a4 e6       	ldi	r26, 0x64	; 100
     a24:	bf ef       	ldi	r27, 0xFF	; 255
     a26:	80 93 71 03 	sts	0x0371, r24
     a2a:	90 93 72 03 	sts	0x0372, r25
     a2e:	a0 93 73 03 	sts	0x0373, r26
     a32:	b0 93 74 03 	sts	0x0374, r27
  w2 =  0.364797662747743;
     a36:	82 ec       	ldi	r24, 0xC2	; 194
     a38:	96 ec       	ldi	r25, 0xC6	; 198
     a3a:	aa eb       	ldi	r26, 0xBA	; 186
     a3c:	be e3       	ldi	r27, 0x3E	; 62
     a3e:	80 93 9b 0b 	sts	0x0B9B, r24
     a42:	90 93 9c 0b 	sts	0x0B9C, r25
     a46:	a0 93 9d 0b 	sts	0x0B9D, r26
     a4a:	b0 93 9e 0b 	sts	0x0B9E, r27
     a4e:	08 95       	ret

00000a50 <initialize>:
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE,    MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE,    MUX2    ,       6     );  // Fake Data
}

void initialize( void )
{
     a50:	ef 92       	push	r14
     a52:	ff 92       	push	r15
     a54:	0f 93       	push	r16
     a56:	1f 93       	push	r17
     a58:	cf 93       	push	r28
     a5a:	df 93       	push	r29
   // pin initialization
  DDRA  = 0b11111111;
     a5c:	1f ef       	ldi	r17, 0xFF	; 255
     a5e:	1a bb       	out	0x1a, r17	; 26
  PORTA = 0b00000111;
     a60:	87 e0       	ldi	r24, 0x07	; 7
     a62:	8b bb       	out	0x1b, r24	; 27

  DDRB  = 0b11111111;
     a64:	17 bb       	out	0x17, r17	; 23
  PORTB = 0b11100000;
     a66:	80 ee       	ldi	r24, 0xE0	; 224
     a68:	88 bb       	out	0x18, r24	; 24

  DDRC  = 0b11111111;
     a6a:	14 bb       	out	0x14, r17	; 20
  PORTC = 0b11111111;
     a6c:	15 bb       	out	0x15, r17	; 21

  DDRD  = 0b11111011;
     a6e:	8b ef       	ldi	r24, 0xFB	; 251
     a70:	81 bb       	out	0x11, r24	; 17
  PORTD = 0b11110000;
     a72:	80 ef       	ldi	r24, 0xF0	; 240
     a74:	82 bb       	out	0x12, r24	; 18

  DDRE  = 0b11111110;
     a76:	9e ef       	ldi	r25, 0xFE	; 254
     a78:	92 b9       	out	0x02, r25	; 2
  PORTE = 0b00000000;
     a7a:	13 b8       	out	0x03, r1	; 3

  DDRF  = 0b11110000;
     a7c:	80 93 61 00 	sts	0x0061, r24
  //0b11111111;	//testing
  PORTF = 0b00000000;
     a80:	10 92 62 00 	sts	0x0062, r1

  DDRG  = 0b00011111;
     a84:	8f e1       	ldi	r24, 0x1F	; 31
     a86:	80 93 64 00 	sts	0x0064, r24
  PORTG = 0b00000100;
     a8a:	04 e0       	ldi	r16, 0x04	; 4
     a8c:	00 93 65 00 	sts	0x0065, r16
  // compare value = 124
  // compare match interrupt freq = (14.7456 MHz / 1024 / 100) = 144 Hz
  // use timer0_counter to get 144 / 144 = 1 Hz

  // enable clear on match interrupt
  TIMSK = ( 1 << OCIE0 );
     a90:	82 e0       	ldi	r24, 0x02	; 2
     a92:	87 bf       	out	0x37, r24	; 55
  OCR0 = 71;
     a94:	87 e4       	ldi	r24, 0x47	; 71
     a96:	81 bf       	out	0x31, r24	; 49

  // enable clear on match mode, set prescalar to 1024
  TCCR0 = ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );
     a98:	8f e0       	ldi	r24, 0x0F	; 15
     a9a:	83 bf       	out	0x33, r24	; 51

  timer0_counter[0] = 99;
     a9c:	83 e6       	ldi	r24, 0x63	; 99
     a9e:	80 93 98 0b 	sts	0x0B98, r24
  timer0_counter[1] = 199;
     aa2:	87 ec       	ldi	r24, 0xC7	; 199
     aa4:	80 93 99 0b 	sts	0x0B99, r24
  period of interrupts = 28800 / 14400 Hz = 2 s/interrupt
  use timer1_counter to get a total period of 2*65535 =  s (24 hours is 86400 seconds)
  */
  
  // Enable clear on match interrupt for the 16 bit timer/counter 1, register A
  OCR1A = 28800;		//28800 corresponds to 2 seconds
     aa8:	80 e8       	ldi	r24, 0x80	; 128
     aaa:	90 e7       	ldi	r25, 0x70	; 112
     aac:	9b bd       	out	0x2b, r25	; 43
     aae:	8a bd       	out	0x2a, r24	; 42

  // Enable clear on match mode, set prescalar to 1024.
  // CS[2:0] = 101 (1024 prescalar)
  // WGM[3:0] = 0100 (Clear Timer on Compare (CTC) when timer matches OCR1A)
  
  TCCR1B = ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS10 );
     ab0:	8d e0       	ldi	r24, 0x0D	; 13
     ab2:	8e bd       	out	0x2e, r24	; 46
  // Explicit Default Defs
  // TCCR1A |= 0;
  // TCNT1 = 0;
  timer1_counter[0] = CYCLE_COUNTER;	//CYCLE_COUNTER   = 900 for 2 seconds interrupt handler = 1800 secs (30 minutes)
     ab4:	84 e8       	ldi	r24, 0x84	; 132
     ab6:	80 93 ba 0d 	sts	0x0DBA, r24
  timer1_counter[1] = CYCLE_COUNTER_2;	//CYCLE_COUNTER_2 = 300 for 2 seconds interrupt handler = 600 secs  (10 minutes)
     aba:	8c e2       	ldi	r24, 0x2C	; 44
     abc:	80 93 bb 0d 	sts	0x0DBB, r24
  //---------------------------------------------------------------------  
  // End of timer 1 Setup
  //--------------------------------------------------------------------- 
  
  // communication
  uart_init();
     ac0:	0e 94 8d 09 	call	0x131a	; 0x131a <uart_init>

  // for use in debugging
  // stdout = stdin = stderr = &uart_str;

  tel_packet_size[0] = 0;
     ac4:	10 92 92 03 	sts	0x0392, r1
     ac8:	10 92 91 03 	sts	0x0391, r1
  tel_packet_size[1] = 0;
     acc:	10 92 94 03 	sts	0x0394, r1
     ad0:	10 92 93 03 	sts	0x0393, r1
  tel_packet_index[0] = 0;
     ad4:	10 92 61 07 	sts	0x0761, r1
  tel_packet_index[1] = 0;
     ad8:	10 92 62 07 	sts	0x0762, r1
  uart_vcp_buff[0] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     adc:	8a e0       	ldi	r24, 0x0A	; 10
     ade:	90 e0       	ldi	r25, 0x00	; 0
     ae0:	0e 94 86 12 	call	0x250c	; 0x250c <malloc>
     ae4:	7c 01       	movw	r14, r24
     ae6:	e2 ec       	ldi	r30, 0xC2	; 194
     ae8:	fd e0       	ldi	r31, 0x0D	; 13
     aea:	80 83       	st	Z, r24
     aec:	f1 82       	std	Z+1, r15	; 0x01
  uart_vcp_buff[1] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     aee:	8a e0       	ldi	r24, 0x0A	; 10
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	0e 94 86 12 	call	0x250c	; 0x250c <malloc>
     af6:	c4 ec       	ldi	r28, 0xC4	; 196
     af8:	dd e0       	ldi	r29, 0x0D	; 13
     afa:	88 83       	st	Y, r24
     afc:	99 83       	std	Y+1, r25	; 0x01
  vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     afe:	4f ef       	ldi	r20, 0xFF	; 255
     b00:	50 e0       	ldi	r21, 0x00	; 0
     b02:	61 ea       	ldi	r22, 0xA1	; 161
     b04:	7b e0       	ldi	r23, 0x0B	; 11
     b06:	c7 01       	movw	r24, r14
     b08:	0e 94 b3 09 	call	0x1366	; 0x1366 <vcpptr_init>
  vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     b0c:	4f ef       	ldi	r20, 0xFF	; 255
     b0e:	50 e0       	ldi	r21, 0x00	; 0
     b10:	60 ea       	ldi	r22, 0xA0	; 160
     b12:	7c e0       	ldi	r23, 0x0C	; 12
     b14:	88 81       	ld	r24, Y
     b16:	99 81       	ldd	r25, Y+1	; 0x01
     b18:	0e 94 b3 09 	call	0x1366	; 0x1366 <vcpptr_init>

  rx_flag[0] = 0;
     b1c:	10 92 c7 0d 	sts	0x0DC7, r1
  rx_flag[1] = 0;
     b20:	10 92 c8 0d 	sts	0x0DC8, r1

  // svit
  initialize_svit();
     b24:	0e 94 92 00 	call	0x124	; 0x124 <initialize_svit>

  // rev up those interrupts
  sei();
     b28:	78 94       	sei

  //ADC conversions
  adc_flag = 1;
     b2a:	c1 e0       	ldi	r28, 0x01	; 1
     b2c:	c0 93 67 09 	sts	0x0967, r28
	adc_component = 0;
     b30:	10 92 9f 03 	sts	0x039F, r1
	adc_sensor_type = ADC_INIT;//get default case on first interation as to not enter switch
     b34:	00 93 74 09 	sts	0x0974, r16
  ADC_high = 0;
     b38:	10 92 85 09 	sts	0x0985, r1

  V_upper_val_change = 0;
     b3c:	10 92 9f 0b 	sts	0x0B9F, r1
  I_upper_val_change = 0;
     b40:	10 92 9a 0b 	sts	0x0B9A, r1

  //---------------------------------------------------------------------  
  // SOC Initializations
  //--------------------------------------------------------------------- 
  // and shunt and safe transmit flags
  safe_mode = 0;
     b44:	10 92 71 09 	sts	0x0971, r1
  transmit_safe = 0;
     b48:	10 92 6c 09 	sts	0x096C, r1
  transmit_shunt = 0;
     b4c:	10 92 a7 0d 	sts	0x0DA7, r1
  been_to_safe = 0;
     b50:	10 92 99 03 	sts	0x0399, r1
  been_to_shunt = 0;
     b54:	10 92 91 09 	sts	0x0991, r1
  assign_charge_fit();
     b58:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <assign_charge_fit>
  assign_discharge_fit();
     b5c:	0e 94 55 04 	call	0x8aa	; 0x8aa <assign_discharge_fit>
  
  // First get battery voltage so that the SoC can
  // accurately determine whether batteries are charging or discharging
  batt1_voltage = 0xff;
     b60:	10 93 8f 09 	sts	0x098F, r17
  batt2_voltage = 0xff;
     b64:	10 93 a0 0b 	sts	0x0BA0, r17
  charging = 0xff;
     b68:	10 93 58 07 	sts	0x0758, r17
  chargeforward = 0;
     b6c:	10 92 bd 0d 	sts	0x0DBD, r1
  chargebackward = 0;
     b70:	10 92 9e 03 	sts	0x039E, r1
  debug = 0;
     b74:	10 92 57 07 	sts	0x0757, r1
  debug2 = 0;
     b78:	10 92 63 07 	sts	0x0763, r1
  percent = 0;
     b7c:	10 92 4f 07 	sts	0x074F, r1
     b80:	10 92 50 07 	sts	0x0750, r1
     b84:	10 92 51 07 	sts	0x0751, r1
     b88:	10 92 52 07 	sts	0x0752, r1
  soc = 0;
     b8c:	10 92 cb 0f 	sts	0x0FCB, r1
  high = 0;
     b90:	10 92 80 09 	sts	0x0980, r1
  low = 0;
     b94:	10 92 8e 09 	sts	0x098E, r1
  limit_check_overriden = 0; // Initially limit checking is NOT OVERRIDEN
     b98:	10 92 4e 07 	sts	0x074E, r1
  isCharging = 0;
     b9c:	10 92 c6 0d 	sts	0x0DC6, r1
  hasCheckedCurr = 0;
     ba0:	10 92 79 09 	sts	0x0979, r1
  //--------------------------------------------------------------------- 

  //---------------------------------------------------------------------  
  // Timer Initializations
  //---------------------------------------------------------------------
  cdh_heartbeat_flag = 0;	//Default: do not have flag to restart components on
     ba4:	10 92 8c 03 	sts	0x038C, r1
  rad_torq_flag = 1;		//Indicates need to delay radio/torquer on signals later
     ba8:	c0 93 75 03 	sts	0x0375, r28
  SVIT_t *component; 	// Initialize Radios to be OFF
  component = &svit[components[RADIO_1]];
     bac:	a0 91 81 03 	lds	r26, 0x0381
     bb0:	ca e1       	ldi	r28, 0x1A	; 26
     bb2:	ca 9f       	mul	r28, r26
     bb4:	d0 01       	movw	r26, r0
     bb6:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     bb8:	a0 56       	subi	r26, 0x60	; 96
     bba:	bc 4f       	sbci	r27, 0xFC	; 252
     bbc:	11 96       	adiw	r26, 0x01	; 1
     bbe:	8c 91       	ld	r24, X
     bc0:	0e 94 f7 07 	call	0xfee	; 0xfee <switch_off>
  component = &svit[components[RADIO_2]];
     bc4:	e0 91 82 03 	lds	r30, 0x0382
     bc8:	ce 9f       	mul	r28, r30
     bca:	f0 01       	movw	r30, r0
     bcc:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     bce:	e0 56       	subi	r30, 0x60	; 96
     bd0:	fc 4f       	sbci	r31, 0xFC	; 252
     bd2:	81 81       	ldd	r24, Z+1	; 0x01
     bd4:	0e 94 f7 07 	call	0xfee	; 0xfee <switch_off>
  component = &svit[TORQUER_1];	// Initialize Torque Coils to be OFF
  component->switch_state = SW_OFF;
     bd8:	10 92 5c 05 	sts	0x055C, r1
  component = &svit[TORQUER_2];
  component->switch_state = SW_OFF;
     bdc:	10 92 76 05 	sts	0x0576, r1
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
     be0:	10 92 90 05 	sts	0x0590, r1
  torquer_off(TORQUER_1);
     be4:	81 e1       	ldi	r24, 0x11	; 17
     be6:	0e 94 7d 07 	call	0xefa	; 0xefa <torquer_off>
  torquer_off(TORQUER_2);
     bea:	82 e1       	ldi	r24, 0x12	; 18
     bec:	0e 94 7d 07 	call	0xefa	; 0xefa <torquer_off>
  torquer_off(TORQUER_3);
     bf0:	83 e1       	ldi	r24, 0x13	; 19
  //---------------------------------------------------------------------  
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	1f 91       	pop	r17
     bf8:	0f 91       	pop	r16
     bfa:	ff 90       	pop	r15
     bfc:	ef 90       	pop	r14
  component->switch_state = SW_OFF;
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
  torquer_off(TORQUER_1);
  torquer_off(TORQUER_2);
  torquer_off(TORQUER_3);
     bfe:	0c 94 7d 07 	jmp	0xefa	; 0xefa <torquer_off>

00000c02 <compareVoltage>:
void compareVoltage( void ) {
  SVIT_t *component;
  //component = &svit[BATTERY_1_b];
  //chargebackward = average_samples( component->I_samples );
  component = &svit[BATTERY_1];
  chargeforward= average_samples( component->I_samples );
     c02:	87 eb       	ldi	r24, 0xB7	; 183
     c04:	95 e0       	ldi	r25, 0x05	; 5
     c06:	0e 94 3a 08 	call	0x1074	; 0x1074 <average_samples>
     c0a:	80 93 bd 0d 	sts	0x0DBD, r24
  if (chargeforward > 2){
     c0e:	83 30       	cpi	r24, 0x03	; 3
     c10:	10 f0       	brcs	.+4      	; 0xc16 <compareVoltage+0x14>
    charging = 0xdd;//discharging
     c12:	8d ed       	ldi	r24, 0xDD	; 221
     c14:	01 c0       	rjmp	.+2      	; 0xc18 <compareVoltage+0x16>
    }
  else{
    charging = 0xcc;
     c16:	8c ec       	ldi	r24, 0xCC	; 204
     c18:	80 93 58 07 	sts	0x0758, r24
     c1c:	08 95       	ret

00000c1e <limit_check>:
we should at least get the framework set up for limit checking on arbitrary values.
The power board should have upper and lower limits for vsense and csense data, 
and turn off components if their voltage/current is too high. ONLY CHECKS
BATTERY 1 VOLTAGE LINE RIGHT NOW.
*/
void limit_check( void ) {
     c1e:	cf 92       	push	r12
     c20:	df 92       	push	r13
     c22:	ef 92       	push	r14
     c24:	ff 92       	push	r15
     c26:	0f 93       	push	r16
     c28:	1f 93       	push	r17
     c2a:	cf 93       	push	r28
     c2c:	df 93       	push	r29
	unsigned char sw;
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
     c2e:	c0 90 4f 07 	lds	r12, 0x074F
     c32:	d0 90 50 07 	lds	r13, 0x0750
     c36:	e0 90 51 07 	lds	r14, 0x0751
     c3a:	f0 90 52 07 	lds	r15, 0x0752
     c3e:	20 e0       	ldi	r18, 0x00	; 0
     c40:	30 e0       	ldi	r19, 0x00	; 0
     c42:	a9 01       	movw	r20, r18
     c44:	c7 01       	movw	r24, r14
     c46:	b6 01       	movw	r22, r12
     c48:	0e 94 3c 11 	call	0x2278	; 0x2278 <__cmpsf2>
     c4c:	87 ff       	sbrs	r24, 7
     c4e:	4c c0       	rjmp	.+152    	; 0xce8 <limit_check+0xca>
     c50:	29 e2       	ldi	r18, 0x29	; 41
     c52:	3c e5       	ldi	r19, 0x5C	; 92
     c54:	4f e0       	ldi	r20, 0x0F	; 15
     c56:	5f eb       	ldi	r21, 0xBF	; 191
     c58:	c7 01       	movw	r24, r14
     c5a:	b6 01       	movw	r22, r12
     c5c:	0e 94 3c 11 	call	0x2278	; 0x2278 <__cmpsf2>
     c60:	87 ff       	sbrs	r24, 7
     c62:	0a c0       	rjmp	.+20     	; 0xc78 <limit_check+0x5a>
     c64:	25 e8       	ldi	r18, 0x85	; 133
     c66:	3b ee       	ldi	r19, 0xEB	; 235
     c68:	41 e1       	ldi	r20, 0x11	; 17
     c6a:	5f eb       	ldi	r21, 0xBF	; 191
     c6c:	c7 01       	movw	r24, r14
     c6e:	b6 01       	movw	r22, r12
     c70:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <__gesf2>
     c74:	18 16       	cp	r1, r24
     c76:	c4 f1       	brlt	.+112    	; 0xce8 <limit_check+0xca>
		safe_mode = 1;
     c78:	81 e0       	ldi	r24, 0x01	; 1
     c7a:	80 93 71 09 	sts	0x0971, r24
     c7e:	06 e7       	ldi	r16, 0x76	; 118
     c80:	13 e0       	ldi	r17, 0x03	; 3
		for (sw = 0; sw < sizeof(components); sw++) {
			component = &svit[components[sw]];
     c82:	ca e1       	ldi	r28, 0x1A	; 26
     c84:	fc 2e       	mov	r15, r28
     c86:	f8 01       	movw	r30, r16
     c88:	c1 91       	ld	r28, Z+
     c8a:	8f 01       	movw	r16, r30
     c8c:	fc 9e       	mul	r15, r28
     c8e:	e0 01       	movw	r28, r0
     c90:	11 24       	eor	r1, r1
     c92:	c0 56       	subi	r28, 0x60	; 96
     c94:	dc 4f       	sbci	r29, 0xFC	; 252
			switch_off( component->switch_num );
     c96:	89 81       	ldd	r24, Y+1	; 0x01
     c98:	0e 94 f7 07 	call	0xfee	; 0xfee <switch_off>
			component->switch_state = SW_OFF;
     c9c:	1a 82       	std	Y+2, r1	; 0x02
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
		safe_mode = 1;
		for (sw = 0; sw < sizeof(components); sw++) {
     c9e:	f3 e0       	ldi	r31, 0x03	; 3
     ca0:	06 38       	cpi	r16, 0x86	; 134
     ca2:	1f 07       	cpc	r17, r31
     ca4:	81 f7       	brne	.-32     	; 0xc86 <limit_check+0x68>
			component = &svit[components[sw]];
			switch_off( component->switch_num );
			component->switch_state = SW_OFF;
		}
		component = &svit[TORQUER_1];
		component->switch_state = SW_OFF;
     ca6:	10 92 5c 05 	sts	0x055C, r1
		component = &svit[TORQUER_2];
		component->switch_state = SW_OFF;
     caa:	10 92 76 05 	sts	0x0576, r1
		component = &svit[TORQUER_3];
		component->switch_state = SW_OFF;
     cae:	10 92 90 05 	sts	0x0590, r1
		torquer_off(TORQUER_1);
     cb2:	81 e1       	ldi	r24, 0x11	; 17
     cb4:	0e 94 7d 07 	call	0xefa	; 0xefa <torquer_off>
		torquer_off(TORQUER_2);
     cb8:	82 e1       	ldi	r24, 0x12	; 18
     cba:	0e 94 7d 07 	call	0xefa	; 0xefa <torquer_off>
		torquer_off(TORQUER_3);
     cbe:	83 e1       	ldi	r24, 0x13	; 19
     cc0:	0e 94 7d 07 	call	0xefa	; 0xefa <torquer_off>
		// Only transmit once
		if (!transmit_safe && !been_to_safe) { 
     cc4:	80 91 6c 09 	lds	r24, 0x096C
     cc8:	81 11       	cpse	r24, r1
     cca:	08 c0       	rjmp	.+16     	; 0xcdc <limit_check+0xbe>
     ccc:	80 91 99 03 	lds	r24, 0x0399
     cd0:	81 11       	cpse	r24, r1
     cd2:	04 c0       	rjmp	.+8      	; 0xcdc <limit_check+0xbe>
			transmit_packet( 0, VCP_ACK, SAFE_MODE);
     cd4:	40 e0       	ldi	r20, 0x00	; 0
     cd6:	62 e0       	ldi	r22, 0x02	; 2
     cd8:	0e 94 2a 10 	call	0x2054	; 0x2054 <transmit_packet>
			transmit_safe = 1;
		}
		else {}
		been_to_safe = 1;
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	80 93 99 03 	sts	0x0399, r24
		transmit_safe = 1;
     ce2:	80 93 6c 09 	sts	0x096C, r24
     ce6:	28 c0       	rjmp	.+80     	; 0xd38 <limit_check+0x11a>
	}
	else if (percent > SHUNT_MODE  && isCharging) {
     ce8:	20 e0       	ldi	r18, 0x00	; 0
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	48 ec       	ldi	r20, 0xC8	; 200
     cee:	52 e4       	ldi	r21, 0x42	; 66
     cf0:	c7 01       	movw	r24, r14
     cf2:	b6 01       	movw	r22, r12
     cf4:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <__gesf2>
     cf8:	18 16       	cp	r1, r24
     cfa:	f4 f4       	brge	.+60     	; 0xd38 <limit_check+0x11a>
     cfc:	80 91 c6 0d 	lds	r24, 0x0DC6
     d00:	88 23       	and	r24, r24
     d02:	d1 f0       	breq	.+52     	; 0xd38 <limit_check+0x11a>
	    safe_mode = 0;
     d04:	10 92 71 09 	sts	0x0971, r1
		// turn on the maestro and send ack_command w/ value of SHUNT_MODE
		component = &svit[MAESTRO];
		switch_on( component->switch_num );
     d08:	80 91 f3 04 	lds	r24, 0x04F3
     d0c:	0e 94 b4 07 	call	0xf68	; 0xf68 <switch_on>
		component->switch_state = SW_ON;
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	80 93 f4 04 	sts	0x04F4, r24
		// Only transmit once
		if (!transmit_shunt && !been_to_shunt) {
     d16:	80 91 a7 0d 	lds	r24, 0x0DA7
     d1a:	81 11       	cpse	r24, r1
     d1c:	08 c0       	rjmp	.+16     	; 0xd2e <limit_check+0x110>
     d1e:	80 91 91 09 	lds	r24, 0x0991
     d22:	81 11       	cpse	r24, r1
     d24:	04 c0       	rjmp	.+8      	; 0xd2e <limit_check+0x110>
			transmit_packet( 0, VCP_ACK, SHUNT_MODE);
     d26:	44 e6       	ldi	r20, 0x64	; 100
     d28:	62 e0       	ldi	r22, 0x02	; 2
     d2a:	0e 94 2a 10 	call	0x2054	; 0x2054 <transmit_packet>
		}
		else {}	
		been_to_shunt = 1;
     d2e:	81 e0       	ldi	r24, 0x01	; 1
     d30:	80 93 91 09 	sts	0x0991, r24
		transmit_shunt = 1;	
     d34:	80 93 a7 0d 	sts	0x0DA7, r24
	}
	else {} // To avoid annoying compile warning 
}
     d38:	df 91       	pop	r29
     d3a:	cf 91       	pop	r28
     d3c:	1f 91       	pop	r17
     d3e:	0f 91       	pop	r16
     d40:	ff 90       	pop	r15
     d42:	ef 90       	pop	r14
     d44:	df 90       	pop	r13
     d46:	cf 90       	pop	r12
     d48:	08 95       	ret

00000d4a <main>:


// MAIN
int main( void ) 
{  
  initialize();
     d4a:	0e 94 28 05 	call	0xa50	; 0xa50 <initialize>
  //fprintf( stdout, "uart initialized\n" );
	
  //Testing
  cntr = 0;
     d4e:	10 92 66 09 	sts	0x0966, r1

  while(1)
  {
	cntr = 1 - cntr; //Testing
     d52:	11 e0       	ldi	r17, 0x01	; 1
	
    if ( timer0_counter[1] == 0 )
    {
        timer0_counter[1] = 199;
     d54:	c7 ec       	ldi	r28, 0xC7	; 199
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     d56:	dc e2       	ldi	r29, 0x2C	; 44
  //Testing
  cntr = 0;

  while(1)
  {
	cntr = 1 - cntr; //Testing
     d58:	80 91 66 09 	lds	r24, 0x0966
     d5c:	91 2f       	mov	r25, r17
     d5e:	98 1b       	sub	r25, r24
     d60:	90 93 66 09 	sts	0x0966, r25
	
    if ( timer0_counter[1] == 0 )
     d64:	80 91 99 0b 	lds	r24, 0x0B99
     d68:	81 11       	cpse	r24, r1
     d6a:	07 c0       	rjmp	.+14     	; 0xd7a <main+0x30>
    {
        timer0_counter[1] = 199;
     d6c:	c0 93 99 0b 	sts	0x0B99, r28
        transmit_packet( 1, VCP_POWER_TELEMETRY, 0);
     d70:	40 e0       	ldi	r20, 0x00	; 0
     d72:	60 e0       	ldi	r22, 0x00	; 0
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	0e 94 2a 10 	call	0x2054	; 0x2054 <transmit_packet>
    }
	  if ( timer0_counter[0] == 0 )
     d7a:	80 91 98 0b 	lds	r24, 0x0B98
     d7e:	81 11       	cpse	r24, r1
     d80:	06 c0       	rjmp	.+12     	; 0xd8e <main+0x44>
    {
        timer0_counter[0] = 199;
     d82:	c0 93 98 0b 	sts	0x0B98, r28
        transmit_packet( 0, VCP_POWER_TELEMETRY, 0);
     d86:	40 e0       	ldi	r20, 0x00	; 0
     d88:	60 e0       	ldi	r22, 0x00	; 0
     d8a:	0e 94 2a 10 	call	0x2054	; 0x2054 <transmit_packet>
    }
	  if ( rx_flag[0] > 0 )
     d8e:	80 91 c7 0d 	lds	r24, 0x0DC7
     d92:	88 23       	and	r24, r24
     d94:	c9 f0       	breq	.+50     	; 0xdc8 <main+0x7e>
    {
        rx_flag[0]--;
     d96:	80 91 c7 0d 	lds	r24, 0x0DC7
     d9a:	81 50       	subi	r24, 0x01	; 1
     d9c:	80 93 c7 0d 	sts	0x0DC7, r24
        receive_message( 0, uart_vcp_buff[0]->message, uart_vcp_buff[0]->index );
     da0:	e0 91 c2 0d 	lds	r30, 0x0DC2
     da4:	f0 91 c3 0d 	lds	r31, 0x0DC3
     da8:	61 81       	ldd	r22, Z+1	; 0x01
     daa:	72 81       	ldd	r23, Z+2	; 0x02
     dac:	47 81       	ldd	r20, Z+7	; 0x07
     dae:	80 e0       	ldi	r24, 0x00	; 0
     db0:	0e 94 c5 02 	call	0x58a	; 0x58a <receive_message>
        vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     db4:	4f ef       	ldi	r20, 0xFF	; 255
     db6:	50 e0       	ldi	r21, 0x00	; 0
     db8:	61 ea       	ldi	r22, 0xA1	; 161
     dba:	7b e0       	ldi	r23, 0x0B	; 11
     dbc:	80 91 c2 0d 	lds	r24, 0x0DC2
     dc0:	90 91 c3 0d 	lds	r25, 0x0DC3
     dc4:	0e 94 b3 09 	call	0x1366	; 0x1366 <vcpptr_init>
    }
	  if ( rx_flag[1] > 0 )
     dc8:	80 91 c8 0d 	lds	r24, 0x0DC8
     dcc:	88 23       	and	r24, r24
     dce:	c9 f0       	breq	.+50     	; 0xe02 <main+0xb8>
    {
        rx_flag[1]--;
     dd0:	80 91 c8 0d 	lds	r24, 0x0DC8
     dd4:	81 50       	subi	r24, 0x01	; 1
     dd6:	80 93 c8 0d 	sts	0x0DC8, r24
        receive_message( 1, uart_vcp_buff[1]->message, uart_vcp_buff[1]->index );
     dda:	e0 91 c4 0d 	lds	r30, 0x0DC4
     dde:	f0 91 c5 0d 	lds	r31, 0x0DC5
     de2:	61 81       	ldd	r22, Z+1	; 0x01
     de4:	72 81       	ldd	r23, Z+2	; 0x02
     de6:	47 81       	ldd	r20, Z+7	; 0x07
     de8:	81 e0       	ldi	r24, 0x01	; 1
     dea:	0e 94 c5 02 	call	0x58a	; 0x58a <receive_message>
        vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     dee:	4f ef       	ldi	r20, 0xFF	; 255
     df0:	50 e0       	ldi	r21, 0x00	; 0
     df2:	60 ea       	ldi	r22, 0xA0	; 160
     df4:	7c e0       	ldi	r23, 0x0C	; 12
     df6:	80 91 c4 0d 	lds	r24, 0x0DC4
     dfa:	90 91 c5 0d 	lds	r25, 0x0DC5
     dfe:	0e 94 b3 09 	call	0x1366	; 0x1366 <vcpptr_init>
    }
    if (adc_flag == 1)
     e02:	80 91 67 09 	lds	r24, 0x0967
     e06:	81 30       	cpi	r24, 0x01	; 1
     e08:	91 f4       	brne	.+36     	; 0xe2e <main+0xe4>
    {
        adc_flag = 0;
     e0a:	10 92 67 09 	sts	0x0967, r1
        read_VIT();
     e0e:	0e 94 71 08 	call	0x10e2	; 0x10e2 <read_VIT>
		//calcSOC();
		StateofCharge();
     e12:	0e 94 6e 03 	call	0x6dc	; 0x6dc <StateofCharge>

		/*
		Manual Override on Limit Checking: The power board must be able to receive a 
		command to disable and/or change the limits in the limit checking code
		*/
		if (!limit_check_overriden) {
     e16:	80 91 4e 07 	lds	r24, 0x074E
     e1a:	81 11       	cpse	r24, r1
     e1c:	02 c0       	rjmp	.+4      	; 0xe22 <main+0xd8>
			limit_check(); // First determine if voltage is within valid range, then switch
     e1e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <limit_check>
		}

		if ( adc_component == 23 ) 
     e22:	80 91 9f 03 	lds	r24, 0x039F
     e26:	87 31       	cpi	r24, 0x17	; 23
     e28:	11 f4       	brne	.+4      	; 0xe2e <main+0xe4>
      	{ //23ish anything after battery values are calculated
  			  compareVoltage();
     e2a:	0e 94 01 06 	call	0xc02	; 0xc02 <compareVoltage>
	   	}
    }	
	
	//Restart all board components if CDH-IB heartbeat timeout
	if (cdh_heartbeat_flag == 1){
     e2e:	80 91 8c 03 	lds	r24, 0x038C
     e32:	81 30       	cpi	r24, 0x01	; 1
     e34:	09 f0       	breq	.+2      	; 0xe38 <main+0xee>
     e36:	90 cf       	rjmp	.-224    	; 0xd58 <main+0xe>
		//Restart all components
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
     e38:	10 92 8c 03 	sts	0x038C, r1
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     e3c:	d0 93 bb 0d 	sts	0x0DBB, r29
     e40:	8b cf       	rjmp	.-234    	; 0xd58 <main+0xe>

00000e42 <torquer_off.part.0>:
void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
  {
    case TORQUER_1:
      CLR( PORTC, 0 );
     e42:	a8 98       	cbi	0x15, 0	; 21
	  CLR( PORTG, 1 );
     e44:	e5 e6       	ldi	r30, 0x65	; 101
     e46:	f0 e0       	ldi	r31, 0x00	; 0
     e48:	80 81       	ld	r24, Z
     e4a:	8d 7f       	andi	r24, 0xFD	; 253
     e4c:	80 83       	st	Z, r24
     e4e:	08 95       	ret

00000e50 <set_mux_sel>:
#include "mcupwr-Defs.h"


void set_mux_sel( uint8_t mux_num, uint8_t mux_sel )
{
  switch( mux_num )
     e50:	81 30       	cpi	r24, 0x01	; 1
     e52:	f9 f0       	breq	.+62     	; 0xe92 <set_mux_sel+0x42>
     e54:	20 f0       	brcs	.+8      	; 0xe5e <set_mux_sel+0xe>
     e56:	82 30       	cpi	r24, 0x02	; 2
     e58:	09 f0       	breq	.+2      	; 0xe5c <set_mux_sel+0xc>
     e5a:	4e c0       	rjmp	.+156    	; 0xef8 <set_mux_sel+0xa8>
     e5c:	34 c0       	rjmp	.+104    	; 0xec6 <set_mux_sel+0x76>
  {
    case MUX0:
      READ( mux_sel, 4 ) ? SET( PORTA, 7 ) : CLR( PORTA, 7 );
     e5e:	64 ff       	sbrs	r22, 4
     e60:	02 c0       	rjmp	.+4      	; 0xe66 <set_mux_sel+0x16>
     e62:	df 9a       	sbi	0x1b, 7	; 27
     e64:	01 c0       	rjmp	.+2      	; 0xe68 <set_mux_sel+0x18>
     e66:	df 98       	cbi	0x1b, 7	; 27
      READ( mux_sel, 3 ) ? SET( PORTA, 6 ) : CLR( PORTA, 6 );
     e68:	63 ff       	sbrs	r22, 3
     e6a:	02 c0       	rjmp	.+4      	; 0xe70 <set_mux_sel+0x20>
     e6c:	de 9a       	sbi	0x1b, 6	; 27
     e6e:	01 c0       	rjmp	.+2      	; 0xe72 <set_mux_sel+0x22>
     e70:	de 98       	cbi	0x1b, 6	; 27
      READ( mux_sel, 2 ) ? SET( PORTA, 5 ) : CLR( PORTA, 5 );
     e72:	62 ff       	sbrs	r22, 2
     e74:	02 c0       	rjmp	.+4      	; 0xe7a <set_mux_sel+0x2a>
     e76:	dd 9a       	sbi	0x1b, 5	; 27
     e78:	01 c0       	rjmp	.+2      	; 0xe7c <set_mux_sel+0x2c>
     e7a:	dd 98       	cbi	0x1b, 5	; 27
      READ( mux_sel, 1 ) ? SET( PORTA, 4 ) : CLR( PORTA, 4 );
     e7c:	61 ff       	sbrs	r22, 1
     e7e:	02 c0       	rjmp	.+4      	; 0xe84 <set_mux_sel+0x34>
     e80:	dc 9a       	sbi	0x1b, 4	; 27
     e82:	01 c0       	rjmp	.+2      	; 0xe86 <set_mux_sel+0x36>
     e84:	dc 98       	cbi	0x1b, 4	; 27
      READ( mux_sel, 0 ) ? SET( PORTA, 3 ) : CLR( PORTA, 3 );
     e86:	60 ff       	sbrs	r22, 0
     e88:	02 c0       	rjmp	.+4      	; 0xe8e <set_mux_sel+0x3e>
     e8a:	db 9a       	sbi	0x1b, 3	; 27
     e8c:	08 95       	ret
     e8e:	db 98       	cbi	0x1b, 3	; 27
     e90:	08 95       	ret

      break;

    case MUX1:
      READ( mux_sel, 4 ) ? SET( PORTB, 0 ) : CLR( PORTB, 0 );
     e92:	64 ff       	sbrs	r22, 4
     e94:	02 c0       	rjmp	.+4      	; 0xe9a <set_mux_sel+0x4a>
     e96:	c0 9a       	sbi	0x18, 0	; 24
     e98:	01 c0       	rjmp	.+2      	; 0xe9c <set_mux_sel+0x4c>
     e9a:	c0 98       	cbi	0x18, 0	; 24
      READ( mux_sel, 3 ) ? SET( PORTB, 1 ) : CLR( PORTB, 1 );
     e9c:	63 ff       	sbrs	r22, 3
     e9e:	02 c0       	rjmp	.+4      	; 0xea4 <set_mux_sel+0x54>
     ea0:	c1 9a       	sbi	0x18, 1	; 24
     ea2:	01 c0       	rjmp	.+2      	; 0xea6 <set_mux_sel+0x56>
     ea4:	c1 98       	cbi	0x18, 1	; 24
      READ( mux_sel, 2 ) ? SET( PORTB, 2 ) : CLR( PORTB, 2 );
     ea6:	62 ff       	sbrs	r22, 2
     ea8:	02 c0       	rjmp	.+4      	; 0xeae <set_mux_sel+0x5e>
     eaa:	c2 9a       	sbi	0x18, 2	; 24
     eac:	01 c0       	rjmp	.+2      	; 0xeb0 <set_mux_sel+0x60>
     eae:	c2 98       	cbi	0x18, 2	; 24
      READ( mux_sel, 1 ) ? SET( PORTB, 3 ) : CLR( PORTB, 3 );
     eb0:	61 ff       	sbrs	r22, 1
     eb2:	02 c0       	rjmp	.+4      	; 0xeb8 <set_mux_sel+0x68>
     eb4:	c3 9a       	sbi	0x18, 3	; 24
     eb6:	01 c0       	rjmp	.+2      	; 0xeba <set_mux_sel+0x6a>
     eb8:	c3 98       	cbi	0x18, 3	; 24
      READ( mux_sel, 0 ) ? SET( PORTB, 4 ) : CLR( PORTB, 4 );
     eba:	60 ff       	sbrs	r22, 0
     ebc:	02 c0       	rjmp	.+4      	; 0xec2 <set_mux_sel+0x72>
     ebe:	c4 9a       	sbi	0x18, 4	; 24
     ec0:	08 95       	ret
     ec2:	c4 98       	cbi	0x18, 4	; 24
     ec4:	08 95       	ret

      break;

    case MUX2:
      READ( mux_sel, 4 ) ? SET( PORTE, 3 ) : CLR( PORTE, 3 );
     ec6:	64 ff       	sbrs	r22, 4
     ec8:	02 c0       	rjmp	.+4      	; 0xece <set_mux_sel+0x7e>
     eca:	1b 9a       	sbi	0x03, 3	; 3
     ecc:	01 c0       	rjmp	.+2      	; 0xed0 <set_mux_sel+0x80>
     ece:	1b 98       	cbi	0x03, 3	; 3
      READ( mux_sel, 3 ) ? SET( PORTE, 4 ) : CLR( PORTE, 4 );
     ed0:	63 ff       	sbrs	r22, 3
     ed2:	02 c0       	rjmp	.+4      	; 0xed8 <set_mux_sel+0x88>
     ed4:	1c 9a       	sbi	0x03, 4	; 3
     ed6:	01 c0       	rjmp	.+2      	; 0xeda <set_mux_sel+0x8a>
     ed8:	1c 98       	cbi	0x03, 4	; 3
      READ( mux_sel, 2 ) ? SET( PORTE, 5 ) : CLR( PORTE, 5 );
     eda:	62 ff       	sbrs	r22, 2
     edc:	02 c0       	rjmp	.+4      	; 0xee2 <set_mux_sel+0x92>
     ede:	1d 9a       	sbi	0x03, 5	; 3
     ee0:	01 c0       	rjmp	.+2      	; 0xee4 <set_mux_sel+0x94>
     ee2:	1d 98       	cbi	0x03, 5	; 3
      READ( mux_sel, 1 ) ? SET( PORTE, 6 ) : CLR( PORTE, 6 );
     ee4:	61 ff       	sbrs	r22, 1
     ee6:	02 c0       	rjmp	.+4      	; 0xeec <set_mux_sel+0x9c>
     ee8:	1e 9a       	sbi	0x03, 6	; 3
     eea:	01 c0       	rjmp	.+2      	; 0xeee <set_mux_sel+0x9e>
     eec:	1e 98       	cbi	0x03, 6	; 3
      READ( mux_sel, 0 ) ? SET( PORTE, 7 ) : CLR( PORTE, 7 );
     eee:	60 ff       	sbrs	r22, 0
     ef0:	02 c0       	rjmp	.+4      	; 0xef6 <set_mux_sel+0xa6>
     ef2:	1f 9a       	sbi	0x03, 7	; 3
     ef4:	08 95       	ret
     ef6:	1f 98       	cbi	0x03, 7	; 3
     ef8:	08 95       	ret

00000efa <torquer_off>:
  }
}

void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
     efa:	82 31       	cpi	r24, 0x12	; 18
     efc:	31 f0       	breq	.+12     	; 0xf0a <torquer_off+0x10>
     efe:	83 31       	cpi	r24, 0x13	; 19
     f00:	59 f0       	breq	.+22     	; 0xf18 <torquer_off+0x1e>
     f02:	81 31       	cpi	r24, 0x11	; 17
     f04:	99 f4       	brne	.+38     	; 0xf2c <torquer_off+0x32>
     f06:	0c 94 21 07 	jmp	0xe42	; 0xe42 <torquer_off.part.0>
      CLR( PORTC, 0 );
	  CLR( PORTG, 1 );
      break;

    case TORQUER_2:
      CLR( PORTG, 0 );
     f0a:	80 91 65 00 	lds	r24, 0x0065
     f0e:	8e 7f       	andi	r24, 0xFE	; 254
     f10:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTD, 0 );
     f14:	90 98       	cbi	0x12, 0	; 18
      break;
     f16:	08 95       	ret

    case TORQUER_3:
      CLR( PORTG, 3 );
     f18:	80 91 65 00 	lds	r24, 0x0065
     f1c:	87 7f       	andi	r24, 0xF7	; 247
     f1e:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTG, 4 );
     f22:	80 91 65 00 	lds	r24, 0x0065
     f26:	8f 7e       	andi	r24, 0xEF	; 239
     f28:	80 93 65 00 	sts	0x0065, r24
     f2c:	08 95       	ret

00000f2e <torquer_on>:
  }  
}

void torquer_on( uint8_t torquer_num )
{
  switch( torquer_num )
     f2e:	82 31       	cpi	r24, 0x12	; 18
     f30:	49 f0       	breq	.+18     	; 0xf44 <torquer_on+0x16>
     f32:	83 31       	cpi	r24, 0x13	; 19
     f34:	71 f0       	breq	.+28     	; 0xf52 <torquer_on+0x24>
     f36:	81 31       	cpi	r24, 0x11	; 17
     f38:	b1 f4       	brne	.+44     	; 0xf66 <torquer_on+0x38>
  {
    case TORQUER_1:
      SET( PORTC, 0 );
     f3a:	a8 9a       	sbi	0x15, 0	; 21
	  SET( PORTG, 1 );
     f3c:	80 91 65 00 	lds	r24, 0x0065
     f40:	82 60       	ori	r24, 0x02	; 2
     f42:	0f c0       	rjmp	.+30     	; 0xf62 <torquer_on+0x34>
      break;

    case TORQUER_2:
      SET( PORTG, 0 );
     f44:	80 91 65 00 	lds	r24, 0x0065
     f48:	81 60       	ori	r24, 0x01	; 1
     f4a:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTD, 0 );
     f4e:	90 9a       	sbi	0x12, 0	; 18
      break;
     f50:	08 95       	ret

    case TORQUER_3:
      SET( PORTG, 3 );
     f52:	80 91 65 00 	lds	r24, 0x0065
     f56:	88 60       	ori	r24, 0x08	; 8
     f58:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTG, 4 );
     f5c:	80 91 65 00 	lds	r24, 0x0065
     f60:	80 61       	ori	r24, 0x10	; 16
     f62:	80 93 65 00 	sts	0x0065, r24
     f66:	08 95       	ret

00000f68 <switch_on>:
  }
}

void switch_on( uint8_t switch_num )
{
  switch ( switch_num )
     f68:	88 30       	cpi	r24, 0x08	; 8
     f6a:	59 f1       	breq	.+86     	; 0xfc2 <switch_on+0x5a>
     f6c:	68 f4       	brcc	.+26     	; 0xf88 <switch_on+0x20>
     f6e:	84 30       	cpi	r24, 0x04	; 4
     f70:	01 f1       	breq	.+64     	; 0xfb2 <switch_on+0x4a>
     f72:	30 f4       	brcc	.+12     	; 0xf80 <switch_on+0x18>
     f74:	82 30       	cpi	r24, 0x02	; 2
     f76:	c9 f0       	breq	.+50     	; 0xfaa <switch_on+0x42>
     f78:	d0 f4       	brcc	.+52     	; 0xfae <switch_on+0x46>
     f7a:	81 30       	cpi	r24, 0x01	; 1
     f7c:	b9 f5       	brne	.+110    	; 0xfec <switch_on+0x84>
     f7e:	13 c0       	rjmp	.+38     	; 0xfa6 <switch_on+0x3e>
     f80:	86 30       	cpi	r24, 0x06	; 6
     f82:	d9 f0       	breq	.+54     	; 0xfba <switch_on+0x52>
     f84:	e0 f4       	brcc	.+56     	; 0xfbe <switch_on+0x56>
     f86:	17 c0       	rjmp	.+46     	; 0xfb6 <switch_on+0x4e>
     f88:	8c 30       	cpi	r24, 0x0C	; 12
     f8a:	39 f1       	breq	.+78     	; 0xfda <switch_on+0x72>
     f8c:	20 f4       	brcc	.+8      	; 0xf96 <switch_on+0x2e>
     f8e:	8a 30       	cpi	r24, 0x0A	; 10
     f90:	01 f1       	breq	.+64     	; 0xfd2 <switch_on+0x6a>
     f92:	08 f5       	brcc	.+66     	; 0xfd6 <switch_on+0x6e>
     f94:	18 c0       	rjmp	.+48     	; 0xfc6 <switch_on+0x5e>
     f96:	8e 30       	cpi	r24, 0x0E	; 14
     f98:	21 f1       	breq	.+72     	; 0xfe2 <switch_on+0x7a>
     f9a:	08 f1       	brcs	.+66     	; 0xfde <switch_on+0x76>
     f9c:	8f 30       	cpi	r24, 0x0F	; 15
     f9e:	19 f1       	breq	.+70     	; 0xfe6 <switch_on+0x7e>
     fa0:	80 31       	cpi	r24, 0x10	; 16
     fa2:	21 f5       	brne	.+72     	; 0xfec <switch_on+0x84>
     fa4:	22 c0       	rjmp	.+68     	; 0xfea <switch_on+0x82>
  {
    case 1:
      SET( PORTA, 0 );
     fa6:	d8 9a       	sbi	0x1b, 0	; 27
      break;
     fa8:	08 95       	ret

    case 2:
      SET( PORTA, 1 );
     faa:	d9 9a       	sbi	0x1b, 1	; 27
      break;
     fac:	08 95       	ret

    case 3:
      SET( PORTA, 2 );
     fae:	da 9a       	sbi	0x1b, 2	; 27
      break;
     fb0:	08 95       	ret

    case 4:
      SET( PORTB, 5 );
     fb2:	c5 9a       	sbi	0x18, 5	; 24
      break;
     fb4:	08 95       	ret

    case 5:
      SET( PORTB, 6 );
     fb6:	c6 9a       	sbi	0x18, 6	; 24
      break;
     fb8:	08 95       	ret

    case 6:
      SET( PORTB, 7 );
     fba:	c7 9a       	sbi	0x18, 7	; 24
      break;
     fbc:	08 95       	ret

    case 7:
      SET( PORTD, 4 );
     fbe:	94 9a       	sbi	0x12, 4	; 18
      break;
     fc0:	08 95       	ret

    case 8:
      SET( PORTD, 5 );
     fc2:	95 9a       	sbi	0x12, 5	; 18
      break;
     fc4:	08 95       	ret

    case 9:
      SET( PORTG, 2 );
     fc6:	80 91 65 00 	lds	r24, 0x0065
     fca:	84 60       	ori	r24, 0x04	; 4
     fcc:	80 93 65 00 	sts	0x0065, r24
      break;
     fd0:	08 95       	ret

    case 10: 
      SET( PORTC, 7 );
     fd2:	af 9a       	sbi	0x15, 7	; 21
      break;
     fd4:	08 95       	ret

    case 11:
      SET( PORTC, 6 );
     fd6:	ae 9a       	sbi	0x15, 6	; 21
      break;
     fd8:	08 95       	ret

    case 12:
      SET( PORTC, 5 );
     fda:	ad 9a       	sbi	0x15, 5	; 21
      break;
     fdc:	08 95       	ret

    case 13:
      SET( PORTC, 4 );
     fde:	ac 9a       	sbi	0x15, 4	; 21
      break;
     fe0:	08 95       	ret

    case 14:
      SET( PORTC, 3 );
     fe2:	ab 9a       	sbi	0x15, 3	; 21
      break;
     fe4:	08 95       	ret

    case 15:
      SET( PORTC, 2 );
     fe6:	aa 9a       	sbi	0x15, 2	; 21
      break;
     fe8:	08 95       	ret

    case 16:
      SET( PORTC, 1 );
     fea:	a9 9a       	sbi	0x15, 1	; 21
     fec:	08 95       	ret

00000fee <switch_off>:
  }
}

void switch_off( uint8_t switch_num )
{
  switch ( switch_num )
     fee:	88 30       	cpi	r24, 0x08	; 8
     ff0:	59 f1       	breq	.+86     	; 0x1048 <switch_off+0x5a>
     ff2:	68 f4       	brcc	.+26     	; 0x100e <switch_off+0x20>
     ff4:	84 30       	cpi	r24, 0x04	; 4
     ff6:	01 f1       	breq	.+64     	; 0x1038 <switch_off+0x4a>
     ff8:	30 f4       	brcc	.+12     	; 0x1006 <switch_off+0x18>
     ffa:	82 30       	cpi	r24, 0x02	; 2
     ffc:	c9 f0       	breq	.+50     	; 0x1030 <switch_off+0x42>
     ffe:	d0 f4       	brcc	.+52     	; 0x1034 <switch_off+0x46>
    1000:	81 30       	cpi	r24, 0x01	; 1
    1002:	b9 f5       	brne	.+110    	; 0x1072 <switch_off+0x84>
    1004:	13 c0       	rjmp	.+38     	; 0x102c <switch_off+0x3e>
    1006:	86 30       	cpi	r24, 0x06	; 6
    1008:	d9 f0       	breq	.+54     	; 0x1040 <switch_off+0x52>
    100a:	e0 f4       	brcc	.+56     	; 0x1044 <switch_off+0x56>
    100c:	17 c0       	rjmp	.+46     	; 0x103c <switch_off+0x4e>
    100e:	8c 30       	cpi	r24, 0x0C	; 12
    1010:	39 f1       	breq	.+78     	; 0x1060 <switch_off+0x72>
    1012:	20 f4       	brcc	.+8      	; 0x101c <switch_off+0x2e>
    1014:	8a 30       	cpi	r24, 0x0A	; 10
    1016:	01 f1       	breq	.+64     	; 0x1058 <switch_off+0x6a>
    1018:	08 f5       	brcc	.+66     	; 0x105c <switch_off+0x6e>
    101a:	18 c0       	rjmp	.+48     	; 0x104c <switch_off+0x5e>
    101c:	8e 30       	cpi	r24, 0x0E	; 14
    101e:	21 f1       	breq	.+72     	; 0x1068 <switch_off+0x7a>
    1020:	08 f1       	brcs	.+66     	; 0x1064 <switch_off+0x76>
    1022:	8f 30       	cpi	r24, 0x0F	; 15
    1024:	19 f1       	breq	.+70     	; 0x106c <switch_off+0x7e>
    1026:	80 31       	cpi	r24, 0x10	; 16
    1028:	21 f5       	brne	.+72     	; 0x1072 <switch_off+0x84>
    102a:	22 c0       	rjmp	.+68     	; 0x1070 <switch_off+0x82>
  {
    case 1:
      CLR( PORTA, 0 );
    102c:	d8 98       	cbi	0x1b, 0	; 27
      break;
    102e:	08 95       	ret

    case 2:
      CLR( PORTA, 1 );
    1030:	d9 98       	cbi	0x1b, 1	; 27
      break;
    1032:	08 95       	ret

    case 3:
      CLR( PORTA, 2 );
    1034:	da 98       	cbi	0x1b, 2	; 27
      break;
    1036:	08 95       	ret

    case 4:
      CLR( PORTB, 5 );
    1038:	c5 98       	cbi	0x18, 5	; 24
      break;
    103a:	08 95       	ret

    case 5:
      CLR( PORTB, 6 );
    103c:	c6 98       	cbi	0x18, 6	; 24
      break;
    103e:	08 95       	ret

    case 6:
      CLR( PORTB, 7 );
    1040:	c7 98       	cbi	0x18, 7	; 24
      break;
    1042:	08 95       	ret

    case 7:
      CLR( PORTD, 4 );
    1044:	94 98       	cbi	0x12, 4	; 18
      break;
    1046:	08 95       	ret

    case 8:
      CLR( PORTD, 5 );
    1048:	95 98       	cbi	0x12, 5	; 18
      break;
    104a:	08 95       	ret

    case 9:
      CLR( PORTG, 2 );
    104c:	80 91 65 00 	lds	r24, 0x0065
    1050:	8b 7f       	andi	r24, 0xFB	; 251
    1052:	80 93 65 00 	sts	0x0065, r24
      break;
    1056:	08 95       	ret

    case 10: 
      CLR( PORTC, 7 );
    1058:	af 98       	cbi	0x15, 7	; 21
      break;
    105a:	08 95       	ret

    case 11:
      CLR( PORTC, 6 );
    105c:	ae 98       	cbi	0x15, 6	; 21
      break;
    105e:	08 95       	ret

    case 12:
      CLR( PORTC, 5 );
    1060:	ad 98       	cbi	0x15, 5	; 21
      break;
    1062:	08 95       	ret

    case 13:
      CLR( PORTC, 4 );
    1064:	ac 98       	cbi	0x15, 4	; 21
      break;
    1066:	08 95       	ret

    case 14:
      CLR( PORTC, 3 );
    1068:	ab 98       	cbi	0x15, 3	; 21
      break;
    106a:	08 95       	ret

    case 15:
      CLR( PORTC, 2 );
    106c:	aa 98       	cbi	0x15, 2	; 21
      break;
    106e:	08 95       	ret

    case 16:
      CLR( PORTC, 1 );
    1070:	a9 98       	cbi	0x15, 1	; 21
    1072:	08 95       	ret

00001074 <average_samples>:
    return  average_samples( component->I_samples );
  }
}

uint8_t average_samples( uint8_t samples[NUM_SAMPLES] )
{
    1074:	fc 01       	movw	r30, r24
  uint8_t average = 0;
  uint16_t sum = 0;

  for(uint8_t avg_index = 0; avg_index < NUM_SAMPLES; avg_index++)
    sum += samples[avg_index];
    1076:	21 81       	ldd	r18, Z+1	; 0x01
    1078:	80 81       	ld	r24, Z
    107a:	90 e0       	ldi	r25, 0x00	; 0
    107c:	82 0f       	add	r24, r18
    107e:	91 1d       	adc	r25, r1
    1080:	22 81       	ldd	r18, Z+2	; 0x02
    1082:	82 0f       	add	r24, r18
    1084:	91 1d       	adc	r25, r1

  average = sum / NUM_SAMPLES;
    1086:	63 e0       	ldi	r22, 0x03	; 3
    1088:	70 e0       	ldi	r23, 0x00	; 0
    108a:	0e 94 5e 12 	call	0x24bc	; 0x24bc <__udivmodhi4>
    108e:	86 2f       	mov	r24, r22

  return average;
}
    1090:	08 95       	ret

00001092 <SVIT_check_I_critical>:
}

uint8_t SVIT_check_I_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1092:	9a e1       	ldi	r25, 0x1A	; 26
    1094:	89 9f       	mul	r24, r25
    1096:	f0 01       	movw	r30, r0
    1098:	11 24       	eor	r1, r1
    109a:	e0 56       	subi	r30, 0x60	; 96
    109c:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->I_critical_value != 0 )
    109e:	83 89       	ldd	r24, Z+19	; 0x13
    10a0:	88 23       	and	r24, r24
    10a2:	11 f0       	breq	.+4      	; 0x10a8 <SVIT_check_I_critical+0x16>
  {
    temp= component->I_critical_value;
    component->I_critical_value = 0;
    10a4:	13 8a       	std	Z+19, r1	; 0x13
    10a6:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->I_samples );
    10a8:	cf 01       	movw	r24, r30
    10aa:	0f 96       	adiw	r24, 0x0f	; 15
    10ac:	0c 94 3a 08 	jmp	0x1074	; 0x1074 <average_samples>

000010b0 <SVIT_check_V_critical>:
}

uint8_t SVIT_check_V_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    10b0:	9a e1       	ldi	r25, 0x1A	; 26
    10b2:	89 9f       	mul	r24, r25
    10b4:	f0 01       	movw	r30, r0
    10b6:	11 24       	eor	r1, r1
    10b8:	e0 56       	subi	r30, 0x60	; 96
    10ba:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->V_critical_value != 0 )
    10bc:	83 85       	ldd	r24, Z+11	; 0x0b
    10be:	88 23       	and	r24, r24
    10c0:	11 f0       	breq	.+4      	; 0x10c6 <SVIT_check_V_critical+0x16>
  {
    temp= component->V_critical_value;
    component->V_critical_value = 0;
    10c2:	13 86       	std	Z+11, r1	; 0x0b
    10c4:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->V_samples );
    10c6:	cf 01       	movw	r24, r30
    10c8:	07 96       	adiw	r24, 0x07	; 7
    10ca:	0c 94 3a 08 	jmp	0x1074	; 0x1074 <average_samples>

000010ce <perform_ADC>:
}

void perform_ADC( uint8_t mux_num )
{
  // set Vref to AVCC and set the ADC channel to the correct pin ( mux_num )
  ADMUX = (1 << ADLAR) | ( 1 << REFS0 );
    10ce:	90 e6       	ldi	r25, 0x60	; 96
    10d0:	97 b9       	out	0x07, r25	; 7
  ADMUX &= ~0x3;
    10d2:	97 b1       	in	r25, 0x07	; 7
    10d4:	9c 7f       	andi	r25, 0xFC	; 252
    10d6:	97 b9       	out	0x07, r25	; 7
  ADMUX |= mux_num;
    10d8:	97 b1       	in	r25, 0x07	; 7
    10da:	98 2b       	or	r25, r24
    10dc:	97 b9       	out	0x07, r25	; 7

  // signal ADC to start a new conversion
  ADCSRA |= ( 1 << ADSC );
    10de:	36 9a       	sbi	0x06, 6	; 6
    10e0:	08 95       	ret

000010e2 <read_VIT>:

  // when the conversion finishes, the result is stored in ADCL and ADCH
}

void read_VIT( void )
{
    10e2:	1f 93       	push	r17
    10e4:	cf 93       	push	r28
    10e6:	df 93       	push	r29
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type )
    10e8:	80 91 74 09 	lds	r24, 0x0974
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    10ec:	c0 91 9f 03 	lds	r28, 0x039F
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type )
    10f0:	82 30       	cpi	r24, 0x02	; 2
    10f2:	09 f4       	brne	.+2      	; 0x10f6 <read_VIT+0x14>
    10f4:	5d c0       	rjmp	.+186    	; 0x11b0 <__stack+0xb1>
    10f6:	20 f4       	brcc	.+8      	; 0x1100 <__stack+0x1>
    10f8:	81 30       	cpi	r24, 0x01	; 1
    10fa:	09 f0       	breq	.+2      	; 0x10fe <read_VIT+0x1c>
    10fc:	f4 c0       	rjmp	.+488    	; 0x12e6 <__stack+0x1e7>
    10fe:	07 c0       	rjmp	.+14     	; 0x110e <__stack+0xf>
    1100:	83 30       	cpi	r24, 0x03	; 3
    1102:	09 f4       	brne	.+2      	; 0x1106 <__stack+0x7>
    1104:	b4 c0       	rjmp	.+360    	; 0x126e <__stack+0x16f>
    1106:	84 30       	cpi	r24, 0x04	; 4
    1108:	09 f0       	breq	.+2      	; 0x110c <__stack+0xd>
    110a:	ed c0       	rjmp	.+474    	; 0x12e6 <__stack+0x1e7>
    110c:	d8 c0       	rjmp	.+432    	; 0x12be <__stack+0x1bf>
  {
		case ADC_VOLTAGE:
			component = &svit[adc_component];
    110e:	8a e1       	ldi	r24, 0x1A	; 26
    1110:	c8 9f       	mul	r28, r24
    1112:	e0 01       	movw	r28, r0
    1114:	11 24       	eor	r1, r1
    1116:	c0 56       	subi	r28, 0x60	; 96
    1118:	dc 4f       	sbci	r29, 0xFC	; 252
			sample_index = component->V_sample_index;
			component->V_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    111a:	2a 85       	ldd	r18, Y+10	; 0x0a
    111c:	30 e0       	ldi	r19, 0x00	; 0
    111e:	c9 01       	movw	r24, r18
    1120:	01 96       	adiw	r24, 0x01	; 1
    1122:	63 e0       	ldi	r22, 0x03	; 3
    1124:	70 e0       	ldi	r23, 0x00	; 0
    1126:	0e 94 72 12 	call	0x24e4	; 0x24e4 <__divmodhi4>
    112a:	8a 87       	std	Y+10, r24	; 0x0a

			// SoC: If component is a battery, store in different global variable
			if (component->name == BATTERY_1) {
    112c:	98 81       	ld	r25, Y
    112e:	94 31       	cpi	r25, 0x14	; 20
    1130:	69 f4       	brne	.+26     	; 0x114c <__stack+0x4d>
				batt1_voltage = ADC_high;
    1132:	80 91 85 09 	lds	r24, 0x0985
    1136:	80 93 8f 09 	sts	0x098F, r24
				high = ADC_high;
    113a:	80 91 85 09 	lds	r24, 0x0985
    113e:	80 93 80 09 	sts	0x0980, r24
				low = ADC_low;
    1142:	80 91 bc 0d 	lds	r24, 0x0DBC
    1146:	80 93 8e 09 	sts	0x098E, r24
    114a:	06 c0       	rjmp	.+12     	; 0x1158 <__stack+0x59>
				//debug = adc_component;
			}
			else if (component->name == BATTERY_2) {
    114c:	95 31       	cpi	r25, 0x15	; 21
    114e:	21 f4       	brne	.+8      	; 0x1158 <__stack+0x59>
				batt2_voltage = ADC_high;
    1150:	80 91 85 09 	lds	r24, 0x0985
    1154:	80 93 a0 0b 	sts	0x0BA0, r24
			}
			component->V_samples[sample_index] = ADC_high;
    1158:	80 91 85 09 	lds	r24, 0x0985
    115c:	fe 01       	movw	r30, r28
    115e:	e2 0f       	add	r30, r18
    1160:	f3 1f       	adc	r31, r19
    1162:	87 83       	std	Z+7, r24	; 0x07
      
	  	if ( ( ADC_high > component->V_upper_limit ) && ( component->force_on != 1 ) )
    1164:	20 91 85 09 	lds	r18, 0x0985
    1168:	8e 81       	ldd	r24, Y+6	; 0x06
    116a:	82 17       	cp	r24, r18
    116c:	d8 f4       	brcc	.+54     	; 0x11a4 <__stack+0xa5>
    116e:	8b 81       	ldd	r24, Y+3	; 0x03
    1170:	81 30       	cpi	r24, 0x01	; 1
    1172:	c1 f0       	breq	.+48     	; 0x11a4 <__stack+0xa5>
			{
				if ( component->switch_num != SW_NULL )
    1174:	89 81       	ldd	r24, Y+1	; 0x01
    1176:	8f 3f       	cpi	r24, 0xFF	; 255
    1178:	19 f0       	breq	.+6      	; 0x1180 <__stack+0x81>
				{
			  	switch_off( component->switch_num );
    117a:	0e 94 f7 07 	call	0xfee	; 0xfee <switch_off>
    117e:	0e c0       	rjmp	.+28     	; 0x119c <__stack+0x9d>
				}
		  	else
				{
			  	switch ( component->name )
    1180:	92 31       	cpi	r25, 0x12	; 18
    1182:	39 f0       	breq	.+14     	; 0x1192 <__stack+0x93>
    1184:	93 31       	cpi	r25, 0x13	; 19
    1186:	39 f0       	breq	.+14     	; 0x1196 <__stack+0x97>
    1188:	91 31       	cpi	r25, 0x11	; 17
    118a:	41 f4       	brne	.+16     	; 0x119c <__stack+0x9d>
    118c:	0e 94 21 07 	call	0xe42	; 0xe42 <torquer_off.part.0>
    1190:	05 c0       	rjmp	.+10     	; 0x119c <__stack+0x9d>
			  	{
						case TORQUER_1:
				  		torquer_off( TORQUER_1 );
				  		break;
					  case TORQUER_2:
	  			  	torquer_off( TORQUER_2 );
    1192:	82 e1       	ldi	r24, 0x12	; 18
    1194:	01 c0       	rjmp	.+2      	; 0x1198 <__stack+0x99>
		  		  	break;
			  		case TORQUER_3:
				    	torquer_off( TORQUER_3 );
    1196:	83 e1       	ldi	r24, 0x13	; 19
    1198:	0e 94 7d 07 	call	0xefa	; 0xefa <torquer_off>
				    	break;
					  default:
				  	  break;
			    }
  			}
        component->switch_state = SW_OFF;
    119c:	1a 82       	std	Y+2, r1	; 0x02
        component->V_critical_value = ADC_high;
    119e:	80 91 85 09 	lds	r24, 0x0985
    11a2:	8b 87       	std	Y+11, r24	; 0x0b
		  }
		  adc_sensor_type = ADC_CURRENT;
    11a4:	82 e0       	ldi	r24, 0x02	; 2
    11a6:	80 93 74 09 	sts	0x0974, r24

      //perform next ADC conversion
      mux_num = component->I_mux_num;
    11aa:	1c 85       	ldd	r17, Y+12	; 0x0c
      mux_sel = component->I_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    11ac:	6d 85       	ldd	r22, Y+13	; 0x0d
    11ae:	92 c0       	rjmp	.+292    	; 0x12d4 <__stack+0x1d5>
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    11b0:	9a e1       	ldi	r25, 0x1A	; 26
    11b2:	c9 9f       	mul	r28, r25
    11b4:	e0 01       	movw	r28, r0
    11b6:	11 24       	eor	r1, r1
    11b8:	c0 56       	subi	r28, 0x60	; 96
    11ba:	dc 4f       	sbci	r29, 0xFC	; 252
	  	sample_index = component->I_sample_index;
	  	component->I_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    11bc:	2a 89       	ldd	r18, Y+18	; 0x12
    11be:	30 e0       	ldi	r19, 0x00	; 0
    11c0:	c9 01       	movw	r24, r18
    11c2:	01 96       	adiw	r24, 0x01	; 1
    11c4:	63 e0       	ldi	r22, 0x03	; 3
    11c6:	70 e0       	ldi	r23, 0x00	; 0
    11c8:	0e 94 72 12 	call	0x24e4	; 0x24e4 <__divmodhi4>
    11cc:	8a 8b       	std	Y+18, r24	; 0x12
		// SoC hardcode backward current
//		if (adc_component == BATTERY_1_b) {
			//debug = 5;
		//}
		
		if(component->name == SOLAR_1){
    11ce:	98 81       	ld	r25, Y
    11d0:	97 31       	cpi	r25, 0x17	; 23
    11d2:	39 f4       	brne	.+14     	; 0x11e2 <__stack+0xe3>
			solar1_current = ADC_high;
    11d4:	80 91 85 09 	lds	r24, 0x0985
    11d8:	80 93 90 09 	sts	0x0990, r24
			hasCheckedCurr = 1;
    11dc:	81 e0       	ldi	r24, 0x01	; 1
    11de:	80 93 79 09 	sts	0x0979, r24
		}

	  	component->I_samples[sample_index] = ADC_high;
    11e2:	80 91 85 09 	lds	r24, 0x0985
    11e6:	fe 01       	movw	r30, r28
    11e8:	e2 0f       	add	r30, r18
    11ea:	f3 1f       	adc	r31, r19
    11ec:	87 87       	std	Z+15, r24	; 0x0f
    
	    if ( ( ADC_high > component->I_upper_limit ) && ( component->force_on != 1 ) )
    11ee:	20 91 85 09 	lds	r18, 0x0985
    11f2:	8e 85       	ldd	r24, Y+14	; 0x0e
    11f4:	82 17       	cp	r24, r18
    11f6:	d8 f4       	brcc	.+54     	; 0x122e <__stack+0x12f>
    11f8:	8b 81       	ldd	r24, Y+3	; 0x03
    11fa:	81 30       	cpi	r24, 0x01	; 1
    11fc:	c1 f0       	breq	.+48     	; 0x122e <__stack+0x12f>
	  	{
	  		if ( component->switch_num != SW_NULL )
    11fe:	89 81       	ldd	r24, Y+1	; 0x01
    1200:	8f 3f       	cpi	r24, 0xFF	; 255
    1202:	19 f0       	breq	.+6      	; 0x120a <__stack+0x10b>
	  		{
	  		  switch_off( component->switch_num );
    1204:	0e 94 f7 07 	call	0xfee	; 0xfee <switch_off>
    1208:	0e c0       	rjmp	.+28     	; 0x1226 <__stack+0x127>
	  		}
	  		else
	  		{
	  		  switch ( component->name )
    120a:	92 31       	cpi	r25, 0x12	; 18
    120c:	39 f0       	breq	.+14     	; 0x121c <__stack+0x11d>
    120e:	93 31       	cpi	r25, 0x13	; 19
    1210:	39 f0       	breq	.+14     	; 0x1220 <__stack+0x121>
    1212:	91 31       	cpi	r25, 0x11	; 17
    1214:	41 f4       	brne	.+16     	; 0x1226 <__stack+0x127>
    1216:	0e 94 21 07 	call	0xe42	; 0xe42 <torquer_off.part.0>
    121a:	05 c0       	rjmp	.+10     	; 0x1226 <__stack+0x127>
		  	  {
  		  		case TORQUER_1:
	  	  		  torquer_off( TORQUER_1 );
		    		  break;
			    	case TORQUER_2:
			  	    torquer_off( TORQUER_2 );
    121c:	82 e1       	ldi	r24, 0x12	; 18
    121e:	01 c0       	rjmp	.+2      	; 0x1222 <__stack+0x123>
			  	    break;
  		  		case TORQUER_3:
	  	  		  torquer_off( TORQUER_3 );
    1220:	83 e1       	ldi	r24, 0x13	; 19
    1222:	0e 94 7d 07 	call	0xefa	; 0xefa <torquer_off>
		    		  break;
			     	default:
				      break;
			    }
			  }
			  component->switch_state = 0;
    1226:	1a 82       	std	Y+2, r1	; 0x02
        component->I_critical_value = ADC_high;
    1228:	80 91 85 09 	lds	r24, 0x0985
    122c:	8b 8b       	std	Y+19, r24	; 0x13
		  }
      //perform next ADC conversion
      mux_num = component->T_mux_num;
    122e:	1c 89       	ldd	r17, Y+20	; 0x14
      if( mux_num != MUX_NULL )
    1230:	13 30       	cpi	r17, 0x03	; 3
    1232:	29 f0       	breq	.+10     	; 0x123e <__stack+0x13f>
      {
		    adc_sensor_type = ADC_TEMPERATURE;
    1234:	83 e0       	ldi	r24, 0x03	; 3
    1236:	80 93 74 09 	sts	0x0974, r24
        mux_sel = component->T_mux_sel;        
    123a:	6d 89       	ldd	r22, Y+21	; 0x15
    123c:	4b c0       	rjmp	.+150    	; 0x12d4 <__stack+0x1d5>
		  }
      else
      {
        adc_sensor_type = ADC_VOLTAGE;
    123e:	81 e0       	ldi	r24, 0x01	; 1
    1240:	80 93 74 09 	sts	0x0974, r24
		    adc_component = ( adc_component + 1 ) % SVIT_SZ;
    1244:	80 91 9f 03 	lds	r24, 0x039F
    1248:	90 e0       	ldi	r25, 0x00	; 0
    124a:	01 96       	adiw	r24, 0x01	; 1
    124c:	64 e2       	ldi	r22, 0x24	; 36
    124e:	70 e0       	ldi	r23, 0x00	; 0
    1250:	0e 94 72 12 	call	0x24e4	; 0x24e4 <__divmodhi4>
    1254:	80 93 9f 03 	sts	0x039F, r24
        component = &svit[adc_component];
    1258:	2a e1       	ldi	r18, 0x1A	; 26
    125a:	28 9f       	mul	r18, r24
    125c:	f0 01       	movw	r30, r0
    125e:	29 9f       	mul	r18, r25
    1260:	f0 0d       	add	r31, r0
    1262:	11 24       	eor	r1, r1
    1264:	e0 56       	subi	r30, 0x60	; 96
    1266:	fc 4f       	sbci	r31, 0xFC	; 252
        mux_num = component->V_mux_num;
    1268:	14 81       	ldd	r17, Z+4	; 0x04
        mux_sel = component->V_mux_sel;
    126a:	65 81       	ldd	r22, Z+5	; 0x05
    126c:	33 c0       	rjmp	.+102    	; 0x12d4 <__stack+0x1d5>
      break;
    //-------------------------------------------------------------------
    // Measure temperature
    //-------------------------------------------------------------------
	  case ADC_TEMPERATURE:
		  component = &svit[adc_component];
    126e:	d0 e0       	ldi	r29, 0x00	; 0
    1270:	4a e1       	ldi	r20, 0x1A	; 26
    1272:	4c 9f       	mul	r20, r28
    1274:	f0 01       	movw	r30, r0
    1276:	4d 9f       	mul	r20, r29
    1278:	f0 0d       	add	r31, r0
    127a:	11 24       	eor	r1, r1
    127c:	e0 56       	subi	r30, 0x60	; 96
    127e:	fc 4f       	sbci	r31, 0xFC	; 252
		  sample_index = component->T_sample_index;
		  component->T_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    1280:	21 8d       	ldd	r18, Z+25	; 0x19
    1282:	30 e0       	ldi	r19, 0x00	; 0
    1284:	c9 01       	movw	r24, r18
    1286:	01 96       	adiw	r24, 0x01	; 1
    1288:	63 e0       	ldi	r22, 0x03	; 3
    128a:	70 e0       	ldi	r23, 0x00	; 0
    128c:	0e 94 72 12 	call	0x24e4	; 0x24e4 <__divmodhi4>
    1290:	81 8f       	std	Z+25, r24	; 0x19
		  component->T_samples[sample_index] = ADC_high;
    1292:	80 91 85 09 	lds	r24, 0x0985
    1296:	e2 0f       	add	r30, r18
    1298:	f3 1f       	adc	r31, r19
    129a:	86 8b       	std	Z+22, r24	; 0x16
      //perform next ADC conversion
  	  adc_sensor_type = ADC_VOLTAGE;
    129c:	81 e0       	ldi	r24, 0x01	; 1
    129e:	80 93 74 09 	sts	0x0974, r24
		  adc_component = ( adc_component + 1 ) % SVIT_SZ;
    12a2:	ce 01       	movw	r24, r28
    12a4:	01 96       	adiw	r24, 0x01	; 1
    12a6:	64 e2       	ldi	r22, 0x24	; 36
    12a8:	70 e0       	ldi	r23, 0x00	; 0
    12aa:	0e 94 72 12 	call	0x24e4	; 0x24e4 <__divmodhi4>
    12ae:	80 93 9f 03 	sts	0x039F, r24
      component = &svit[adc_component];
    12b2:	48 9f       	mul	r20, r24
    12b4:	f0 01       	movw	r30, r0
    12b6:	49 9f       	mul	r20, r25
    12b8:	f0 0d       	add	r31, r0
    12ba:	11 24       	eor	r1, r1
    12bc:	1d c0       	rjmp	.+58     	; 0x12f8 <__stack+0x1f9>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
		  break;
    case ADC_INIT:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    12be:	81 e0       	ldi	r24, 0x01	; 1
    12c0:	80 93 74 09 	sts	0x0974, r24
      component = &svit[adc_component];
    12c4:	9a e1       	ldi	r25, 0x1A	; 26
    12c6:	c9 9f       	mul	r28, r25
    12c8:	e0 01       	movw	r28, r0
    12ca:	11 24       	eor	r1, r1
    12cc:	c0 56       	subi	r28, 0x60	; 96
    12ce:	dc 4f       	sbci	r29, 0xFC	; 252
      mux_num = component->V_mux_num;
    12d0:	1c 81       	ldd	r17, Y+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    12d2:	6d 81       	ldd	r22, Y+5	; 0x05
    12d4:	81 2f       	mov	r24, r17
    12d6:	0e 94 28 07 	call	0xe50	; 0xe50 <set_mux_sel>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    12da:	83 e3       	ldi	r24, 0x33	; 51
    12dc:	93 e7       	ldi	r25, 0x73	; 115
    12de:	01 97       	sbiw	r24, 0x01	; 1
    12e0:	f1 f7       	brne	.-4      	; 0x12de <__stack+0x1df>
      //_delay_us(1);
	  //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
    12e2:	81 2f       	mov	r24, r17
    12e4:	15 c0       	rjmp	.+42     	; 0x1310 <__stack+0x211>
      break;
	  default:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    12e6:	81 e0       	ldi	r24, 0x01	; 1
    12e8:	80 93 74 09 	sts	0x0974, r24
      component = &svit[adc_component];
    12ec:	e0 91 9f 03 	lds	r30, 0x039F
    12f0:	9a e1       	ldi	r25, 0x1A	; 26
    12f2:	e9 9f       	mul	r30, r25
    12f4:	f0 01       	movw	r30, r0
    12f6:	11 24       	eor	r1, r1
    12f8:	e0 56       	subi	r30, 0x60	; 96
    12fa:	fc 4f       	sbci	r31, 0xFC	; 252
      mux_num = component->V_mux_num;
    12fc:	c4 81       	ldd	r28, Z+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    12fe:	65 81       	ldd	r22, Z+5	; 0x05
    1300:	8c 2f       	mov	r24, r28
    1302:	0e 94 28 07 	call	0xe50	; 0xe50 <set_mux_sel>
    1306:	83 e3       	ldi	r24, 0x33	; 51
    1308:	93 e7       	ldi	r25, 0x73	; 115
    130a:	01 97       	sbiw	r24, 0x01	; 1
    130c:	f1 f7       	brne	.-4      	; 0x130a <__stack+0x20b>
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    130e:	8c 2f       	mov	r24, r28
      break;
  } 
}
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	1f 91       	pop	r17
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    1316:	0c 94 67 08 	jmp	0x10ce	; 0x10ce <perform_ADC>

0000131a <uart_init>:
{
  #if F_CPU < 2000000UL && defined(U2X)
  UCSR0A = UCSR1A = _BV(U2X); /* improve baud rate error by using 2x clk */
  UBRR0L = UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  #else
  UBRR0L = UBRR1L = 7;//(F_CPU / (16UL * UART_BAUD)) - 1;//7;
    131a:	87 e0       	ldi	r24, 0x07	; 7
    131c:	80 93 99 00 	sts	0x0099, r24
    1320:	89 b9       	out	0x09, r24	; 9
  #endif
  UCSR0B = _BV(TXEN0) | _BV(RXEN0); /* tx/rx enable */
    1322:	88 e1       	ldi	r24, 0x18	; 24
    1324:	8a b9       	out	0x0a, r24	; 10
  UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
    1326:	ea e9       	ldi	r30, 0x9A	; 154
    1328:	f0 e0       	ldi	r31, 0x00	; 0
    132a:	80 83       	st	Z, r24


  UCSR1B = UCSR1B | _BV(TXCIE1);
    132c:	80 81       	ld	r24, Z
    132e:	80 64       	ori	r24, 0x40	; 64
    1330:	80 83       	st	Z, r24
  UCSR1B = UCSR1B | _BV(RXCIE1);
    1332:	80 81       	ld	r24, Z
    1334:	80 68       	ori	r24, 0x80	; 128
    1336:	80 83       	st	Z, r24
  UCSR0B = UCSR0B | _BV(TXCIE0);
    1338:	56 9a       	sbi	0x0a, 6	; 10
  UCSR0B = UCSR0B | _BV(RXCIE0);
    133a:	57 9a       	sbi	0x0a, 7	; 10
    133c:	08 95       	ret

0000133e <append_crc16>:
 * Adds a byte of data into the crc calculation using
 * the table above.
 */
void append_crc16(uint8 byte, uint16ptr crc)
{
	*crc = ((*crc) >> 8) ^ ccitt_crc16[((*crc) ^ (byte)) & 0xff];
    133e:	fb 01       	movw	r30, r22
    1340:	20 81       	ld	r18, Z
    1342:	31 81       	ldd	r19, Z+1	; 0x01
    1344:	f9 01       	movw	r30, r18
    1346:	e8 27       	eor	r30, r24
    1348:	ff 27       	eor	r31, r31
    134a:	ee 0f       	add	r30, r30
    134c:	ff 1f       	adc	r31, r31
    134e:	ea 5f       	subi	r30, 0xFA	; 250
    1350:	fe 4f       	sbci	r31, 0xFE	; 254
    1352:	23 2f       	mov	r18, r19
    1354:	33 27       	eor	r19, r19
    1356:	80 81       	ld	r24, Z
    1358:	91 81       	ldd	r25, Z+1	; 0x01
    135a:	82 27       	eor	r24, r18
    135c:	93 27       	eor	r25, r19
    135e:	fb 01       	movw	r30, r22
    1360:	91 83       	std	Z+1, r25	; 0x01
    1362:	80 83       	st	Z, r24
    1364:	08 95       	ret

00001366 <vcpptr_init>:
// Parameters: 
// vcp_ptrbuffer	*buff -					Pointer to the vcp buffer structure
// uint8			*message_buffer -		Pointer to the allocated data buffer
// uint16			message_buffer_size -	Size of the allocated data buffer
void vcpptr_init(vcp_ptrbuffer *buff, uint8 *message_buffer, uint16 message_buffer_size)
{
    1366:	fc 01       	movw	r30, r24
	buff->address =	0;
    1368:	10 82       	st	Z, r1
	buff->message =	message_buffer;
    136a:	72 83       	std	Z+2, r23	; 0x02
    136c:	61 83       	std	Z+1, r22	; 0x01
	buff->size =	message_buffer_size;
    136e:	56 83       	std	Z+6, r21	; 0x06
    1370:	45 83       	std	Z+5, r20	; 0x05
	buff->index	=	0;
    1372:	10 86       	std	Z+8, r1	; 0x08
    1374:	17 82       	std	Z+7, r1	; 0x07
	buff->crc =		CRC16_INIT_VALUE;
    1376:	14 82       	std	Z+4, r1	; 0x04
    1378:	13 82       	std	Z+3, r1	; 0x03
	buff->status =	VCP_IDLE;
    137a:	11 86       	std	Z+9, r1	; 0x09
    137c:	08 95       	ret

0000137e <Create_VCP_frame>:
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
    137e:	4f 92       	push	r4
    1380:	5f 92       	push	r5
    1382:	6f 92       	push	r6
    1384:	7f 92       	push	r7
    1386:	8f 92       	push	r8
    1388:	9f 92       	push	r9
    138a:	af 92       	push	r10
    138c:	bf 92       	push	r11
    138e:	cf 92       	push	r12
    1390:	df 92       	push	r13
    1392:	ef 92       	push	r14
    1394:	ff 92       	push	r15
    1396:	0f 93       	push	r16
    1398:	1f 93       	push	r17
    139a:	cf 93       	push	r28
    139c:	df 93       	push	r29
    139e:	00 d0       	rcall	.+0      	; 0x13a0 <Create_VCP_frame+0x22>
    13a0:	1f 92       	push	r1
    13a2:	cd b7       	in	r28, 0x3d	; 61
    13a4:	de b7       	in	r29, 0x3e	; 62
    13a6:	6c 01       	movw	r12, r24
    13a8:	5b 01       	movw	r10, r22
    13aa:	79 01       	movw	r14, r18
	uint16_t crc = CRC16_INIT_VALUE;
    13ac:	1a 82       	std	Y+2, r1	; 0x02
    13ae:	19 82       	std	Y+1, r1	; 0x01
	uint16_t src_index = 0;
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
    13b0:	00 97       	sbiw	r24, 0x00	; 0
    13b2:	09 f4       	brne	.+2      	; 0x13b6 <Create_VCP_frame+0x38>
    13b4:	58 c0       	rjmp	.+176    	; 0x1466 <Create_VCP_frame+0xe8>
    13b6:	21 15       	cp	r18, r1
    13b8:	31 05       	cpc	r19, r1
    13ba:	09 f4       	brne	.+2      	; 0x13be <Create_VCP_frame+0x40>
    13bc:	54 c0       	rjmp	.+168    	; 0x1466 <Create_VCP_frame+0xe8>
		return VCP_NULL_ERR;

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
    13be:	4c 30       	cpi	r20, 0x0C	; 12
    13c0:	18 f0       	brcs	.+6      	; 0x13c8 <Create_VCP_frame+0x4a>
    13c2:	48 33       	cpi	r20, 0x38	; 56
    13c4:	09 f0       	breq	.+2      	; 0x13c8 <Create_VCP_frame+0x4a>
    13c6:	51 c0       	rjmp	.+162    	; 0x146a <Create_VCP_frame+0xec>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    13c8:	44 24       	eor	r4, r4
    13ca:	43 94       	inc	r4
    13cc:	51 2c       	mov	r5, r1
    13ce:	4c 0e       	add	r4, r28
    13d0:	5d 1e       	adc	r5, r29
    13d2:	b2 01       	movw	r22, r4
    13d4:	84 2f       	mov	r24, r20
    13d6:	4b 83       	std	Y+3, r20	; 0x03
    13d8:	0e 94 9f 09 	call	0x133e	; 0x133e <append_crc16>
// uint8ptr		dst -		Pointer to the destination buffer
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
    13dc:	37 01       	movw	r6, r14
    13de:	60 0e       	add	r6, r16
    13e0:	71 1e       	adc	r7, r17
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    13e2:	47 01       	movw	r8, r14
    13e4:	07 c0       	rjmp	.+14     	; 0x13f4 <Create_VCP_frame+0x76>
	  append_crc16(src[src_index], &crc);
    13e6:	b2 01       	movw	r22, r4
    13e8:	f4 01       	movw	r30, r8
    13ea:	81 91       	ld	r24, Z+
    13ec:	4f 01       	movw	r8, r30
    13ee:	4b 83       	std	Y+3, r20	; 0x03
    13f0:	0e 94 9f 09 	call	0x133e	; 0x133e <append_crc16>
    13f4:	4b 81       	ldd	r20, Y+3	; 0x03
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    13f6:	86 14       	cp	r8, r6
    13f8:	97 04       	cpc	r9, r7
    13fa:	a9 f7       	brne	.-22     	; 0x13e6 <Create_VCP_frame+0x68>
	  append_crc16(src[src_index], &crc);
	
	// Add CRC to the end of the source buffer
	src[src_index++] = ((crc >> 8) & 0xFF);
    13fc:	89 81       	ldd	r24, Y+1	; 0x01
    13fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1400:	f7 01       	movw	r30, r14
    1402:	e0 0f       	add	r30, r16
    1404:	f1 1f       	adc	r31, r17
    1406:	90 83       	st	Z, r25
	src[src_index++] = (crc & 0xFF);
    1408:	81 83       	std	Z+1, r24	; 0x01
    140a:	0e 5f       	subi	r16, 0xFE	; 254
    140c:	1f 4f       	sbci	r17, 0xFF	; 255
	payload_size = src_index;
	
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
    140e:	80 ec       	ldi	r24, 0xC0	; 192
    1410:	f6 01       	movw	r30, r12
    1412:	80 83       	st	Z, r24
	// then insert VCP address
	dst[dst_index++] =					addr;
    1414:	41 83       	std	Z+1, r20	; 0x01
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1416:	d7 01       	movw	r26, r14
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
    1418:	42 e0       	ldi	r20, 0x02	; 2
    141a:	50 e0       	ldi	r21, 0x00	; 0
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    141c:	2d ed       	ldi	r18, 0xDD	; 221
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
    141e:	3b ed       	ldi	r19, 0xDB	; 219
			dst[dst_index++] =			TFEND;
    1420:	6c ed       	ldi	r22, 0xDC	; 220
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1422:	0f c0       	rjmp	.+30     	; 0x1442 <Create_VCP_frame+0xc4>
	{
		if (src[src_index] == FEND)
    1424:	8d 91       	ld	r24, X+
    1426:	80 3c       	cpi	r24, 0xC0	; 192
    1428:	19 f4       	brne	.+6      	; 0x1430 <Create_VCP_frame+0xb2>
		{
			dst[dst_index++] =			FESC;
    142a:	30 83       	st	Z, r19
			dst[dst_index++] =			TFEND;
    142c:	61 83       	std	Z+1, r22	; 0x01
    142e:	04 c0       	rjmp	.+8      	; 0x1438 <Create_VCP_frame+0xba>
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
    1430:	80 83       	st	Z, r24
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
    1432:	8b 3d       	cpi	r24, 0xDB	; 219
    1434:	21 f4       	brne	.+8      	; 0x143e <Create_VCP_frame+0xc0>
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    1436:	21 83       	std	Z+1, r18	; 0x01
    1438:	4e 5f       	subi	r20, 0xFE	; 254
    143a:	5f 4f       	sbci	r21, 0xFF	; 255
    143c:	02 c0       	rjmp	.+4      	; 0x1442 <Create_VCP_frame+0xc4>
		}
		else
		{
			dst[dst_index++] =			src[src_index];
    143e:	4f 5f       	subi	r20, 0xFF	; 255
    1440:	5f 4f       	sbci	r21, 0xFF	; 255
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1442:	cd 01       	movw	r24, r26
    1444:	8e 19       	sub	r24, r14
    1446:	9f 09       	sbc	r25, r15
    1448:	f6 01       	movw	r30, r12
    144a:	e4 0f       	add	r30, r20
    144c:	f5 1f       	adc	r31, r21
    144e:	80 17       	cp	r24, r16
    1450:	91 07       	cpc	r25, r17
    1452:	40 f3       	brcs	.-48     	; 0x1424 <Create_VCP_frame+0xa6>
		//if (dst_index >= *dst_size - 1)
			//return VCP_OVR_ERR;
	}
	
	// End the frame with FEND
	dst[dst_index++] =					FEND;
    1454:	80 ec       	ldi	r24, 0xC0	; 192
    1456:	80 83       	st	Z, r24
    1458:	4f 5f       	subi	r20, 0xFF	; 255
    145a:	5f 4f       	sbci	r21, 0xFF	; 255
	
	// Save the frame size
	*dst_size = dst_index;
    145c:	f5 01       	movw	r30, r10
    145e:	51 83       	std	Z+1, r21	; 0x01
    1460:	40 83       	st	Z, r20
	
	// All good
	return VCP_TERM;
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	03 c0       	rjmp	.+6      	; 0x146c <Create_VCP_frame+0xee>
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
		return VCP_NULL_ERR;
    1466:	85 e0       	ldi	r24, 0x05	; 5
    1468:	01 c0       	rjmp	.+2      	; 0x146c <Create_VCP_frame+0xee>

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
		return VCP_ADDR_ERR;
    146a:	86 e0       	ldi	r24, 0x06	; 6
	// Save the frame size
	*dst_size = dst_index;
	
	// All good
	return VCP_TERM;
}
    146c:	0f 90       	pop	r0
    146e:	0f 90       	pop	r0
    1470:	0f 90       	pop	r0
    1472:	df 91       	pop	r29
    1474:	cf 91       	pop	r28
    1476:	1f 91       	pop	r17
    1478:	0f 91       	pop	r16
    147a:	ff 90       	pop	r15
    147c:	ef 90       	pop	r14
    147e:	df 90       	pop	r13
    1480:	cf 90       	pop	r12
    1482:	bf 90       	pop	r11
    1484:	af 90       	pop	r10
    1486:	9f 90       	pop	r9
    1488:	8f 90       	pop	r8
    148a:	7f 90       	pop	r7
    148c:	6f 90       	pop	r6
    148e:	5f 90       	pop	r5
    1490:	4f 90       	pop	r4
    1492:	08 95       	ret

00001494 <Receive_VCP_byte>:
// and return VCP status.
// Parameters:
// vcp_ptrbuffer	*buff -	Pointer to the vcp buffer structure
// uint8			byte -	received byte
uint8_t Receive_VCP_byte(vcp_ptrbuffer *buff, uint8 byte)
{
    1494:	cf 92       	push	r12
    1496:	df 92       	push	r13
    1498:	ef 92       	push	r14
    149a:	ff 92       	push	r15
    149c:	0f 93       	push	r16
    149e:	1f 93       	push	r17
    14a0:	cf 93       	push	r28
    14a2:	df 93       	push	r29
    14a4:	ec 01       	movw	r28, r24
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
    14a6:	29 81       	ldd	r18, Y+1	; 0x01
    14a8:	3a 81       	ldd	r19, Y+2	; 0x02
    14aa:	21 15       	cp	r18, r1
    14ac:	31 05       	cpc	r19, r1
    14ae:	09 f4       	brne	.+2      	; 0x14b2 <Receive_VCP_byte+0x1e>
    14b0:	84 c0       	rjmp	.+264    	; 0x15ba <Receive_VCP_byte+0x126>
		return VCP_NULL_ERR;
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
    14b2:	8f 81       	ldd	r24, Y+7	; 0x07
    14b4:	98 85       	ldd	r25, Y+8	; 0x08
    14b6:	4d 81       	ldd	r20, Y+5	; 0x05
    14b8:	5e 81       	ldd	r21, Y+6	; 0x06
    14ba:	41 50       	subi	r20, 0x01	; 1
    14bc:	51 09       	sbc	r21, r1
    14be:	84 17       	cp	r24, r20
    14c0:	95 07       	cpc	r25, r21
    14c2:	08 f0       	brcs	.+2      	; 0x14c6 <Receive_VCP_byte+0x32>
    14c4:	7c c0       	rjmp	.+248    	; 0x15be <Receive_VCP_byte+0x12a>
		return VCP_OVR_ERR;
	
	// State Machine
	switch (buff->status)
    14c6:	49 85       	ldd	r20, Y+9	; 0x09
    14c8:	42 30       	cpi	r20, 0x02	; 2
    14ca:	39 f1       	breq	.+78     	; 0x151a <Receive_VCP_byte+0x86>
    14cc:	18 f4       	brcc	.+6      	; 0x14d4 <Receive_VCP_byte+0x40>
    14ce:	44 23       	and	r20, r20
    14d0:	31 f0       	breq	.+12     	; 0x14de <Receive_VCP_byte+0x4a>
    14d2:	38 c0       	rjmp	.+112    	; 0x1544 <Receive_VCP_byte+0xb0>
    14d4:	40 31       	cpi	r20, 0x10	; 16
    14d6:	31 f0       	breq	.+12     	; 0x14e4 <Receive_VCP_byte+0x50>
    14d8:	40 32       	cpi	r20, 0x20	; 32
    14da:	a1 f5       	brne	.+104    	; 0x1544 <Receive_VCP_byte+0xb0>
    14dc:	0a c0       	rjmp	.+20     	; 0x14f2 <Receive_VCP_byte+0x5e>
	{
		case VCP_IDLE:										
			if (byte == FEND)
    14de:	60 3c       	cpi	r22, 0xC0	; 192
    14e0:	91 f5       	brne	.+100    	; 0x1546 <Receive_VCP_byte+0xb2>
    14e2:	0d c0       	rjmp	.+26     	; 0x14fe <Receive_VCP_byte+0x6a>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
    14e4:	6c 30       	cpi	r22, 0x0C	; 12
    14e6:	18 f0       	brcs	.+6      	; 0x14ee <Receive_VCP_byte+0x5a>
    14e8:	68 33       	cpi	r22, 0x38	; 56
    14ea:	09 f0       	breq	.+2      	; 0x14ee <Receive_VCP_byte+0x5a>
    14ec:	6a c0       	rjmp	.+212    	; 0x15c2 <Receive_VCP_byte+0x12e>
				return VCP_ADDR_ERR;
			else
			{
				buff->address = byte;
    14ee:	68 83       	st	Y, r22
    14f0:	26 c0       	rjmp	.+76     	; 0x153e <Receive_VCP_byte+0xaa>
				buff->status = VCP_RECEIVING;
			}	
			break;
		case VCP_RECEIVING:
			if (byte == FEND)
    14f2:	60 3c       	cpi	r22, 0xC0	; 192
    14f4:	31 f4       	brne	.+12     	; 0x1502 <Receive_VCP_byte+0x6e>
			{
				if (buff->index > 0)
    14f6:	89 2b       	or	r24, r25
    14f8:	11 f0       	breq	.+4      	; 0x14fe <Receive_VCP_byte+0x6a>
					// Done
					buff->status = VCP_TERM;
    14fa:	81 e0       	ldi	r24, 0x01	; 1
    14fc:	21 c0       	rjmp	.+66     	; 0x1540 <Receive_VCP_byte+0xac>
				else
					// No data between FENDs - assume lost sync and start over
					buff->status = VCP_ADDRESS;
    14fe:	80 e1       	ldi	r24, 0x10	; 16
    1500:	1f c0       	rjmp	.+62     	; 0x1540 <Receive_VCP_byte+0xac>
			}
			else if (byte == FESC)
    1502:	6b 3d       	cpi	r22, 0xDB	; 219
    1504:	11 f4       	brne	.+4      	; 0x150a <Receive_VCP_byte+0x76>
				buff->status = VCP_ESC;
    1506:	82 e0       	ldi	r24, 0x02	; 2
    1508:	1b c0       	rjmp	.+54     	; 0x1540 <Receive_VCP_byte+0xac>
			else
			{
				buff->message[(buff->index)++] = byte;	
    150a:	f9 01       	movw	r30, r18
    150c:	e8 0f       	add	r30, r24
    150e:	f9 1f       	adc	r31, r25
    1510:	60 83       	st	Z, r22
    1512:	01 96       	adiw	r24, 0x01	; 1
    1514:	98 87       	std	Y+8, r25	; 0x08
    1516:	8f 83       	std	Y+7, r24	; 0x07
    1518:	16 c0       	rjmp	.+44     	; 0x1546 <Receive_VCP_byte+0xb2>
			}						
			break;
		case VCP_ESC:
			if (byte == TFEND)
    151a:	6c 3d       	cpi	r22, 0xDC	; 220
    151c:	29 f4       	brne	.+10     	; 0x1528 <Receive_VCP_byte+0x94>
			{
				buff->message[(buff->index)++] = FEND;
    151e:	f9 01       	movw	r30, r18
    1520:	e8 0f       	add	r30, r24
    1522:	f9 1f       	adc	r31, r25
    1524:	40 ec       	ldi	r20, 0xC0	; 192
    1526:	07 c0       	rjmp	.+14     	; 0x1536 <Receive_VCP_byte+0xa2>
				buff->status = VCP_RECEIVING;
			}
			else if (byte == TFESC)
    1528:	6d 3d       	cpi	r22, 0xDD	; 221
    152a:	09 f0       	breq	.+2      	; 0x152e <Receive_VCP_byte+0x9a>
    152c:	4c c0       	rjmp	.+152    	; 0x15c6 <Receive_VCP_byte+0x132>
			{
				buff->message[(buff->index)++] = FESC;
    152e:	f9 01       	movw	r30, r18
    1530:	e8 0f       	add	r30, r24
    1532:	f9 1f       	adc	r31, r25
    1534:	4b ed       	ldi	r20, 0xDB	; 219
    1536:	40 83       	st	Z, r20
    1538:	01 96       	adiw	r24, 0x01	; 1
    153a:	98 87       	std	Y+8, r25	; 0x08
    153c:	8f 83       	std	Y+7, r24	; 0x07
				buff->status = VCP_RECEIVING;
    153e:	80 e2       	ldi	r24, 0x20	; 32
    1540:	89 87       	std	Y+9, r24	; 0x09
    1542:	01 c0       	rjmp	.+2      	; 0x1546 <Receive_VCP_byte+0xb2>
			}
			else
				return VCP_ESC_ERR;	
			break;
		default:
			buff->status = VCP_IDLE;
    1544:	19 86       	std	Y+9, r1	; 0x09
			break; 
	}
	
	// End of frame
	if (buff->status == VCP_TERM)
    1546:	89 85       	ldd	r24, Y+9	; 0x09
    1548:	81 30       	cpi	r24, 0x01	; 1
    154a:	11 f0       	breq	.+4      	; 0x1550 <Receive_VCP_byte+0xbc>
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
    154c:	89 85       	ldd	r24, Y+9	; 0x09
    154e:	3c c0       	rjmp	.+120    	; 0x15c8 <Receive_VCP_byte+0x134>
	
	// End of frame
	if (buff->status == VCP_TERM)
	{
		// Message CRC is last 2 bytes 
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
    1550:	89 81       	ldd	r24, Y+1	; 0x01
    1552:	9a 81       	ldd	r25, Y+2	; 0x02
    1554:	4f 81       	ldd	r20, Y+7	; 0x07
    1556:	58 85       	ldd	r21, Y+8	; 0x08
    1558:	84 0f       	add	r24, r20
    155a:	95 1f       	adc	r25, r21
    155c:	fc 01       	movw	r30, r24
    155e:	32 97       	sbiw	r30, 0x02	; 2
    1560:	30 81       	ld	r19, Z
    1562:	20 e0       	ldi	r18, 0x00	; 0
    1564:	fc 01       	movw	r30, r24
    1566:	31 97       	sbiw	r30, 0x01	; 1
    1568:	80 81       	ld	r24, Z
    156a:	69 01       	movw	r12, r18
    156c:	c8 0e       	add	r12, r24
    156e:	d1 1c       	adc	r13, r1
		// Remove CRC bytes from the message
		buff->index -= 2;
    1570:	42 50       	subi	r20, 0x02	; 2
    1572:	51 09       	sbc	r21, r1
    1574:	58 87       	std	Y+8, r21	; 0x08
    1576:	4f 83       	std	Y+7, r20	; 0x07
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
    1578:	7e 01       	movw	r14, r28
    157a:	83 e0       	ldi	r24, 0x03	; 3
    157c:	e8 0e       	add	r14, r24
    157e:	f1 1c       	adc	r15, r1
    1580:	b7 01       	movw	r22, r14
    1582:	88 81       	ld	r24, Y
    1584:	0e 94 9f 09 	call	0x133e	; 0x133e <append_crc16>
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    1588:	00 e0       	ldi	r16, 0x00	; 0
    158a:	10 e0       	ldi	r17, 0x00	; 0
    158c:	0a c0       	rjmp	.+20     	; 0x15a2 <Receive_VCP_byte+0x10e>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
    158e:	e9 81       	ldd	r30, Y+1	; 0x01
    1590:	fa 81       	ldd	r31, Y+2	; 0x02
    1592:	e0 0f       	add	r30, r16
    1594:	f1 1f       	adc	r31, r17
    1596:	b7 01       	movw	r22, r14
    1598:	80 81       	ld	r24, Z
    159a:	0e 94 9f 09 	call	0x133e	; 0x133e <append_crc16>
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
		// Remove CRC bytes from the message
		buff->index -= 2;
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    159e:	0f 5f       	subi	r16, 0xFF	; 255
    15a0:	1f 4f       	sbci	r17, 0xFF	; 255
    15a2:	8f 81       	ldd	r24, Y+7	; 0x07
    15a4:	98 85       	ldd	r25, Y+8	; 0x08
    15a6:	08 17       	cp	r16, r24
    15a8:	19 07       	cpc	r17, r25
    15aa:	88 f3       	brcs	.-30     	; 0x158e <Receive_VCP_byte+0xfa>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
		}
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
    15ac:	8b 81       	ldd	r24, Y+3	; 0x03
    15ae:	9c 81       	ldd	r25, Y+4	; 0x04
    15b0:	8c 15       	cp	r24, r12
    15b2:	9d 05       	cpc	r25, r13
    15b4:	59 f2       	breq	.-106    	; 0x154c <Receive_VCP_byte+0xb8>
			return VCP_CRC_ERR;
    15b6:	84 e0       	ldi	r24, 0x04	; 4
    15b8:	07 c0       	rjmp	.+14     	; 0x15c8 <Receive_VCP_byte+0x134>
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
		return VCP_NULL_ERR;
    15ba:	85 e0       	ldi	r24, 0x05	; 5
    15bc:	05 c0       	rjmp	.+10     	; 0x15c8 <Receive_VCP_byte+0x134>
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
		return VCP_OVR_ERR;
    15be:	83 e0       	ldi	r24, 0x03	; 3
    15c0:	03 c0       	rjmp	.+6      	; 0x15c8 <Receive_VCP_byte+0x134>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
				return VCP_ADDR_ERR;
    15c2:	86 e0       	ldi	r24, 0x06	; 6
    15c4:	01 c0       	rjmp	.+2      	; 0x15c8 <Receive_VCP_byte+0x134>
			{
				buff->message[(buff->index)++] = FESC;
				buff->status = VCP_RECEIVING;
			}
			else
				return VCP_ESC_ERR;	
    15c6:	87 e0       	ldi	r24, 0x07	; 7
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
}
    15c8:	df 91       	pop	r29
    15ca:	cf 91       	pop	r28
    15cc:	1f 91       	pop	r17
    15ce:	0f 91       	pop	r16
    15d0:	ff 90       	pop	r15
    15d2:	ef 90       	pop	r14
    15d4:	df 90       	pop	r13
    15d6:	cf 90       	pop	r12
    15d8:	08 95       	ret

000015da <tx_put_byte.part.0>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    return;
  if( tel_packet_index[uart] < tel_packet_size[uart] )
    15da:	28 2f       	mov	r18, r24
    15dc:	30 e0       	ldi	r19, 0x00	; 0
    15de:	f9 01       	movw	r30, r18
    15e0:	ef 59       	subi	r30, 0x9F	; 159
    15e2:	f8 4f       	sbci	r31, 0xF8	; 248
    15e4:	60 81       	ld	r22, Z
    15e6:	d9 01       	movw	r26, r18
    15e8:	aa 0f       	add	r26, r26
    15ea:	bb 1f       	adc	r27, r27
    15ec:	af 56       	subi	r26, 0x6F	; 111
    15ee:	bc 4f       	sbci	r27, 0xFC	; 252
    15f0:	4d 91       	ld	r20, X+
    15f2:	5c 91       	ld	r21, X
    15f4:	70 e0       	ldi	r23, 0x00	; 0
    15f6:	64 17       	cp	r22, r20
    15f8:	75 07       	cpc	r23, r21
    15fa:	10 f5       	brcc	.+68     	; 0x1640 <tx_put_byte.part.0+0x66>
  {
      if ( uart == 0 )
    15fc:	81 11       	cpse	r24, r1
    15fe:	0e c0       	rjmp	.+28     	; 0x161c <tx_put_byte.part.0+0x42>
      UDR0 = tel_packet[uart][tel_packet_index[uart]++];
    1600:	80 81       	ld	r24, Z
    1602:	9f ef       	ldi	r25, 0xFF	; 255
    1604:	92 9f       	mul	r25, r18
    1606:	d0 01       	movw	r26, r0
    1608:	93 9f       	mul	r25, r19
    160a:	b0 0d       	add	r27, r0
    160c:	11 24       	eor	r1, r1
    160e:	a8 0f       	add	r26, r24
    1610:	b1 1d       	adc	r27, r1
    1612:	a8 59       	subi	r26, 0x98	; 152
    1614:	b8 4f       	sbci	r27, 0xF8	; 248
    1616:	9c 91       	ld	r25, X
    1618:	9c b9       	out	0x0c, r25	; 12
    161a:	10 c0       	rjmp	.+32     	; 0x163c <tx_put_byte.part.0+0x62>
    else if ( uart == 1 )
    161c:	81 30       	cpi	r24, 0x01	; 1
    161e:	81 f4       	brne	.+32     	; 0x1640 <tx_put_byte.part.0+0x66>
      UDR1 = tel_packet[uart][tel_packet_index[uart]++];
    1620:	80 81       	ld	r24, Z
    1622:	9f ef       	ldi	r25, 0xFF	; 255
    1624:	92 9f       	mul	r25, r18
    1626:	d0 01       	movw	r26, r0
    1628:	93 9f       	mul	r25, r19
    162a:	b0 0d       	add	r27, r0
    162c:	11 24       	eor	r1, r1
    162e:	a8 0f       	add	r26, r24
    1630:	b1 1d       	adc	r27, r1
    1632:	a8 59       	subi	r26, 0x98	; 152
    1634:	b8 4f       	sbci	r27, 0xF8	; 248
    1636:	9c 91       	ld	r25, X
    1638:	90 93 9c 00 	sts	0x009C, r25
    163c:	8f 5f       	subi	r24, 0xFF	; 255
    163e:	80 83       	st	Z, r24
    1640:	08 95       	ret

00001642 <__vector_15>:
#include "vcp_library.h"
#include "crclib.h"
#include "uart.h"

ISR(TIMER0_COMP_vect)
{
    1642:	1f 92       	push	r1
    1644:	0f 92       	push	r0
    1646:	0f b6       	in	r0, 0x3f	; 63
    1648:	0f 92       	push	r0
    164a:	11 24       	eor	r1, r1
    164c:	8f 93       	push	r24
  if ( timer0_counter[0] > 0 )
    164e:	80 91 98 0b 	lds	r24, 0x0B98
    1652:	88 23       	and	r24, r24
    1654:	29 f0       	breq	.+10     	; 0x1660 <__vector_15+0x1e>
    --timer0_counter[0];
    1656:	80 91 98 0b 	lds	r24, 0x0B98
    165a:	81 50       	subi	r24, 0x01	; 1
    165c:	80 93 98 0b 	sts	0x0B98, r24
  if ( timer0_counter[1] > 0 )
    1660:	80 91 99 0b 	lds	r24, 0x0B99
    1664:	88 23       	and	r24, r24
    1666:	29 f0       	breq	.+10     	; 0x1672 <__vector_15+0x30>
    --timer0_counter[1];
    1668:	80 91 99 0b 	lds	r24, 0x0B99
    166c:	81 50       	subi	r24, 0x01	; 1
    166e:	80 93 99 0b 	sts	0x0B99, r24
	//if (cntr == 0)
	//	PORTC |= 0x01;
	//else
	//	PORTC &= 0xFE;
	//_delay_ms(500);
}
    1672:	8f 91       	pop	r24
    1674:	0f 90       	pop	r0
    1676:	0f be       	out	0x3f, r0	; 63
    1678:	0f 90       	pop	r0
    167a:	1f 90       	pop	r1
    167c:	18 95       	reti

0000167e <__vector_12>:

/* Timer 1(A) routine */
ISR(TIMER1_COMPA_vect)		//Handle Radio & Torquer 30 min delays here; handle 10 min CDH-IB no heartbeat restart
{
    167e:	1f 92       	push	r1
    1680:	0f 92       	push	r0
    1682:	0f b6       	in	r0, 0x3f	; 63
    1684:	0f 92       	push	r0
    1686:	11 24       	eor	r1, r1
    1688:	0b b6       	in	r0, 0x3b	; 59
    168a:	0f 92       	push	r0
    168c:	2f 93       	push	r18
    168e:	3f 93       	push	r19
    1690:	4f 93       	push	r20
    1692:	5f 93       	push	r21
    1694:	6f 93       	push	r22
    1696:	7f 93       	push	r23
    1698:	8f 93       	push	r24
    169a:	9f 93       	push	r25
    169c:	af 93       	push	r26
    169e:	bf 93       	push	r27
    16a0:	cf 93       	push	r28
    16a2:	ef 93       	push	r30
    16a4:	ff 93       	push	r31
	SVIT_t *component;
	
	//Testing
	//PORTC ^= 0xFF;
		
	if (timer1_counter[0] <= 0	  &&     rad_torq_flag){	//provides 30 minute delay			
    16a6:	80 91 ba 0d 	lds	r24, 0x0DBA
    16aa:	81 11       	cpse	r24, r1
    16ac:	31 c0       	rjmp	.+98     	; 0x1710 <__vector_12+0x92>
    16ae:	80 91 75 03 	lds	r24, 0x0375
    16b2:	88 23       	and	r24, r24
    16b4:	69 f1       	breq	.+90     	; 0x1710 <__vector_12+0x92>
	//if ( receive_flag == 1){		//If message is received, reset timer1_counter[0] to CYCLE_COUNTER
	    timer1_counter[0] = CYCLE_COUNTER;
    16b6:	84 e8       	ldi	r24, 0x84	; 132
    16b8:	80 93 ba 0d 	sts	0x0DBA, r24
		
		//CHECK: Should the ISR do this code or not?
		
		//Turn on radios
		component = &svit[RADIO_1];
		switch_on( component->switch_num );
    16bc:	80 91 bf 04 	lds	r24, 0x04BF
    16c0:	0e 94 b4 07 	call	0xf68	; 0xf68 <switch_on>
		component->switch_state = SW_ON;
    16c4:	c1 e0       	ldi	r28, 0x01	; 1
    16c6:	c0 93 c0 04 	sts	0x04C0, r28
		component = &svit[RADIO_2];
		switch_on( component->switch_num );
    16ca:	80 91 d9 04 	lds	r24, 0x04D9
    16ce:	0e 94 b4 07 	call	0xf68	; 0xf68 <switch_on>
		component->switch_state = SW_ON;
    16d2:	c0 93 da 04 	sts	0x04DA, r28
		
		//Turn on torque coils			
		component = &svit[TORQUER_1];
		switch_on( component->switch_num );
    16d6:	80 91 5b 05 	lds	r24, 0x055B
    16da:	0e 94 b4 07 	call	0xf68	; 0xf68 <switch_on>
		component->switch_state = SW_ON;
    16de:	c0 93 5c 05 	sts	0x055C, r28
		component = &svit[TORQUER_2];
		switch_on( component->switch_num );
    16e2:	80 91 75 05 	lds	r24, 0x0575
    16e6:	0e 94 b4 07 	call	0xf68	; 0xf68 <switch_on>
		component->switch_state = SW_ON;
    16ea:	c0 93 76 05 	sts	0x0576, r28
		component = &svit[TORQUER_3];
		switch_on( component->switch_num );
    16ee:	80 91 8f 05 	lds	r24, 0x058F
    16f2:	0e 94 b4 07 	call	0xf68	; 0xf68 <switch_on>
		component->switch_state = SW_ON;
    16f6:	c0 93 90 05 	sts	0x0590, r28
		torquer_on(TORQUER_1);
    16fa:	81 e1       	ldi	r24, 0x11	; 17
    16fc:	0e 94 97 07 	call	0xf2e	; 0xf2e <torquer_on>
		torquer_on(TORQUER_2);
    1700:	82 e1       	ldi	r24, 0x12	; 18
    1702:	0e 94 97 07 	call	0xf2e	; 0xf2e <torquer_on>
		torquer_on(TORQUER_3);
    1706:	83 e1       	ldi	r24, 0x13	; 19
    1708:	0e 94 97 07 	call	0xf2e	; 0xf2e <torquer_on>
		
		//PORTC ^= 0x02;	//LED for STK testing
		//PORTC ^= 0x01;
		
		//Don't reexecute this code
		rad_torq_flag = 0;
    170c:	10 92 75 03 	sts	0x0375, r1
	}
	
	if (timer1_counter[1] <= 0   &&   !cdh_heartbeat_flag){		//If heartbeat timer 1 has expired AND we haven't already ordered a restart
    1710:	80 91 bb 0d 	lds	r24, 0x0DBB
    1714:	81 11       	cpse	r24, r1
    1716:	07 c0       	rjmp	.+14     	; 0x1726 <__vector_12+0xa8>
    1718:	80 91 8c 03 	lds	r24, 0x038C
    171c:	81 11       	cpse	r24, r1
    171e:	03 c0       	rjmp	.+6      	; 0x1726 <__vector_12+0xa8>
		//Order full component restart
		cdh_heartbeat_flag = 1;
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	80 93 8c 03 	sts	0x038C, r24
		
	}
	
	//else{
		PORTC ^= 0x01;		//LED for STK testing at PORTC0
    1726:	85 b3       	in	r24, 0x15	; 21
    1728:	91 e0       	ldi	r25, 0x01	; 1
    172a:	89 27       	eor	r24, r25
    172c:	85 bb       	out	0x15, r24	; 21
    172e:	2f ef       	ldi	r18, 0xFF	; 255
    1730:	8f e7       	ldi	r24, 0x7F	; 127
    1732:	96 e1       	ldi	r25, 0x16	; 22
    1734:	21 50       	subi	r18, 0x01	; 1
    1736:	80 40       	sbci	r24, 0x00	; 0
    1738:	90 40       	sbci	r25, 0x00	; 0
    173a:	e1 f7       	brne	.-8      	; 0x1734 <__vector_12+0xb6>
    173c:	00 c0       	rjmp	.+0      	; 0x173e <__vector_12+0xc0>
    173e:	00 00       	nop
		_delay_ms(500);
		--timer1_counter[0];
    1740:	80 91 ba 0d 	lds	r24, 0x0DBA
    1744:	81 50       	subi	r24, 0x01	; 1
    1746:	80 93 ba 0d 	sts	0x0DBA, r24
		--timer1_counter[1];
    174a:	80 91 bb 0d 	lds	r24, 0x0DBB
    174e:	81 50       	subi	r24, 0x01	; 1
    1750:	80 93 bb 0d 	sts	0x0DBB, r24
	//}
}
    1754:	ff 91       	pop	r31
    1756:	ef 91       	pop	r30
    1758:	cf 91       	pop	r28
    175a:	bf 91       	pop	r27
    175c:	af 91       	pop	r26
    175e:	9f 91       	pop	r25
    1760:	8f 91       	pop	r24
    1762:	7f 91       	pop	r23
    1764:	6f 91       	pop	r22
    1766:	5f 91       	pop	r21
    1768:	4f 91       	pop	r20
    176a:	3f 91       	pop	r19
    176c:	2f 91       	pop	r18
    176e:	0f 90       	pop	r0
    1770:	0b be       	out	0x3b, r0	; 59
    1772:	0f 90       	pop	r0
    1774:	0f be       	out	0x3f, r0	; 63
    1776:	0f 90       	pop	r0
    1778:	1f 90       	pop	r1
    177a:	18 95       	reti

0000177c <__vector_32>:

ISR(USART1_TX_vect)
{
    177c:	1f 92       	push	r1
    177e:	0f 92       	push	r0
    1780:	0f b6       	in	r0, 0x3f	; 63
    1782:	0f 92       	push	r0
    1784:	11 24       	eor	r1, r1
    1786:	0b b6       	in	r0, 0x3b	; 59
    1788:	0f 92       	push	r0
    178a:	2f 93       	push	r18
    178c:	3f 93       	push	r19
    178e:	4f 93       	push	r20
    1790:	5f 93       	push	r21
    1792:	6f 93       	push	r22
    1794:	7f 93       	push	r23
    1796:	8f 93       	push	r24
    1798:	9f 93       	push	r25
    179a:	af 93       	push	r26
    179c:	bf 93       	push	r27
    179e:	ef 93       	push	r30
    17a0:	ff 93       	push	r31
    17a2:	81 e0       	ldi	r24, 0x01	; 1
    17a4:	0e 94 ed 0a 	call	0x15da	; 0x15da <tx_put_byte.part.0>
  tx_put_byte( 1 );
}
    17a8:	ff 91       	pop	r31
    17aa:	ef 91       	pop	r30
    17ac:	bf 91       	pop	r27
    17ae:	af 91       	pop	r26
    17b0:	9f 91       	pop	r25
    17b2:	8f 91       	pop	r24
    17b4:	7f 91       	pop	r23
    17b6:	6f 91       	pop	r22
    17b8:	5f 91       	pop	r21
    17ba:	4f 91       	pop	r20
    17bc:	3f 91       	pop	r19
    17be:	2f 91       	pop	r18
    17c0:	0f 90       	pop	r0
    17c2:	0b be       	out	0x3b, r0	; 59
    17c4:	0f 90       	pop	r0
    17c6:	0f be       	out	0x3f, r0	; 63
    17c8:	0f 90       	pop	r0
    17ca:	1f 90       	pop	r1
    17cc:	18 95       	reti

000017ce <__vector_30>:

ISR(USART1_RX_vect)
{
    17ce:	1f 92       	push	r1
    17d0:	0f 92       	push	r0
    17d2:	0f b6       	in	r0, 0x3f	; 63
    17d4:	0f 92       	push	r0
    17d6:	11 24       	eor	r1, r1
    17d8:	0b b6       	in	r0, 0x3b	; 59
    17da:	0f 92       	push	r0
    17dc:	2f 93       	push	r18
    17de:	3f 93       	push	r19
    17e0:	4f 93       	push	r20
    17e2:	5f 93       	push	r21
    17e4:	6f 93       	push	r22
    17e6:	7f 93       	push	r23
    17e8:	8f 93       	push	r24
    17ea:	9f 93       	push	r25
    17ec:	af 93       	push	r26
    17ee:	bf 93       	push	r27
    17f0:	ef 93       	push	r30
    17f2:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[1], UDR1 ) == VCP_TERM )
    17f4:	60 91 9c 00 	lds	r22, 0x009C
    17f8:	80 91 c4 0d 	lds	r24, 0x0DC4
    17fc:	90 91 c5 0d 	lds	r25, 0x0DC5
    1800:	0e 94 4a 0a 	call	0x1494	; 0x1494 <Receive_VCP_byte>
    1804:	81 30       	cpi	r24, 0x01	; 1
    1806:	29 f4       	brne	.+10     	; 0x1812 <__vector_30+0x44>
  {
    rx_flag[1]++;
    1808:	80 91 c8 0d 	lds	r24, 0x0DC8
    180c:	8f 5f       	subi	r24, 0xFF	; 255
    180e:	80 93 c8 0d 	sts	0x0DC8, r24
  }
}
    1812:	ff 91       	pop	r31
    1814:	ef 91       	pop	r30
    1816:	bf 91       	pop	r27
    1818:	af 91       	pop	r26
    181a:	9f 91       	pop	r25
    181c:	8f 91       	pop	r24
    181e:	7f 91       	pop	r23
    1820:	6f 91       	pop	r22
    1822:	5f 91       	pop	r21
    1824:	4f 91       	pop	r20
    1826:	3f 91       	pop	r19
    1828:	2f 91       	pop	r18
    182a:	0f 90       	pop	r0
    182c:	0b be       	out	0x3b, r0	; 59
    182e:	0f 90       	pop	r0
    1830:	0f be       	out	0x3f, r0	; 63
    1832:	0f 90       	pop	r0
    1834:	1f 90       	pop	r1
    1836:	18 95       	reti

00001838 <__vector_21>:

ISR ( ADC_vect )
{
    1838:	1f 92       	push	r1
    183a:	0f 92       	push	r0
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	0f 92       	push	r0
    1840:	11 24       	eor	r1, r1
    1842:	8f 93       	push	r24
  ADC_low = ADCL;	// Left adjusted; read 2 LSB then 8 MSB
    1844:	84 b1       	in	r24, 0x04	; 4
    1846:	80 93 bc 0d 	sts	0x0DBC, r24
  ADC_high = ADCH;
    184a:	85 b1       	in	r24, 0x05	; 5
    184c:	80 93 85 09 	sts	0x0985, r24
  adc_flag = 1;
    1850:	81 e0       	ldi	r24, 0x01	; 1
    1852:	80 93 67 09 	sts	0x0967, r24
}
    1856:	8f 91       	pop	r24
    1858:	0f 90       	pop	r0
    185a:	0f be       	out	0x3f, r0	; 63
    185c:	0f 90       	pop	r0
    185e:	1f 90       	pop	r1
    1860:	18 95       	reti

00001862 <__vector_20>:

ISR( USART0_TX_vect )
{
    1862:	1f 92       	push	r1
    1864:	0f 92       	push	r0
    1866:	0f b6       	in	r0, 0x3f	; 63
    1868:	0f 92       	push	r0
    186a:	11 24       	eor	r1, r1
    186c:	0b b6       	in	r0, 0x3b	; 59
    186e:	0f 92       	push	r0
    1870:	2f 93       	push	r18
    1872:	3f 93       	push	r19
    1874:	4f 93       	push	r20
    1876:	5f 93       	push	r21
    1878:	6f 93       	push	r22
    187a:	7f 93       	push	r23
    187c:	8f 93       	push	r24
    187e:	9f 93       	push	r25
    1880:	af 93       	push	r26
    1882:	bf 93       	push	r27
    1884:	ef 93       	push	r30
    1886:	ff 93       	push	r31
    1888:	80 e0       	ldi	r24, 0x00	; 0
    188a:	0e 94 ed 0a 	call	0x15da	; 0x15da <tx_put_byte.part.0>
  tx_put_byte( 0 );
}
    188e:	ff 91       	pop	r31
    1890:	ef 91       	pop	r30
    1892:	bf 91       	pop	r27
    1894:	af 91       	pop	r26
    1896:	9f 91       	pop	r25
    1898:	8f 91       	pop	r24
    189a:	7f 91       	pop	r23
    189c:	6f 91       	pop	r22
    189e:	5f 91       	pop	r21
    18a0:	4f 91       	pop	r20
    18a2:	3f 91       	pop	r19
    18a4:	2f 91       	pop	r18
    18a6:	0f 90       	pop	r0
    18a8:	0b be       	out	0x3b, r0	; 59
    18aa:	0f 90       	pop	r0
    18ac:	0f be       	out	0x3f, r0	; 63
    18ae:	0f 90       	pop	r0
    18b0:	1f 90       	pop	r1
    18b2:	18 95       	reti

000018b4 <__vector_18>:

ISR( USART0_RX_vect )
{
    18b4:	1f 92       	push	r1
    18b6:	0f 92       	push	r0
    18b8:	0f b6       	in	r0, 0x3f	; 63
    18ba:	0f 92       	push	r0
    18bc:	11 24       	eor	r1, r1
    18be:	0b b6       	in	r0, 0x3b	; 59
    18c0:	0f 92       	push	r0
    18c2:	2f 93       	push	r18
    18c4:	3f 93       	push	r19
    18c6:	4f 93       	push	r20
    18c8:	5f 93       	push	r21
    18ca:	6f 93       	push	r22
    18cc:	7f 93       	push	r23
    18ce:	8f 93       	push	r24
    18d0:	9f 93       	push	r25
    18d2:	af 93       	push	r26
    18d4:	bf 93       	push	r27
    18d6:	ef 93       	push	r30
    18d8:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[0], UDR0 ) == VCP_TERM )
    18da:	6c b1       	in	r22, 0x0c	; 12
    18dc:	80 91 c2 0d 	lds	r24, 0x0DC2
    18e0:	90 91 c3 0d 	lds	r25, 0x0DC3
    18e4:	0e 94 4a 0a 	call	0x1494	; 0x1494 <Receive_VCP_byte>
    18e8:	81 30       	cpi	r24, 0x01	; 1
    18ea:	29 f4       	brne	.+10     	; 0x18f6 <__vector_18+0x42>
  {
    rx_flag[0]++;
    18ec:	80 91 c7 0d 	lds	r24, 0x0DC7
    18f0:	8f 5f       	subi	r24, 0xFF	; 255
    18f2:	80 93 c7 0d 	sts	0x0DC7, r24
  }
}
    18f6:	ff 91       	pop	r31
    18f8:	ef 91       	pop	r30
    18fa:	bf 91       	pop	r27
    18fc:	af 91       	pop	r26
    18fe:	9f 91       	pop	r25
    1900:	8f 91       	pop	r24
    1902:	7f 91       	pop	r23
    1904:	6f 91       	pop	r22
    1906:	5f 91       	pop	r21
    1908:	4f 91       	pop	r20
    190a:	3f 91       	pop	r19
    190c:	2f 91       	pop	r18
    190e:	0f 90       	pop	r0
    1910:	0b be       	out	0x3b, r0	; 59
    1912:	0f 90       	pop	r0
    1914:	0f be       	out	0x3f, r0	; 63
    1916:	0f 90       	pop	r0
    1918:	1f 90       	pop	r1
    191a:	18 95       	reti

0000191c <tx_put_byte>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    191c:	82 30       	cpi	r24, 0x02	; 2
    191e:	10 f4       	brcc	.+4      	; 0x1924 <tx_put_byte+0x8>
    1920:	0c 94 ed 0a 	jmp	0x15da	; 0x15da <tx_put_byte.part.0>
    1924:	08 95       	ret

00001926 <construct_telemetry_packet>:
  }
}


void construct_telemetry_packet( uint8_t* packet_payload )
{
    1926:	2f 92       	push	r2
    1928:	3f 92       	push	r3
    192a:	4f 92       	push	r4
    192c:	5f 92       	push	r5
    192e:	6f 92       	push	r6
    1930:	7f 92       	push	r7
    1932:	8f 92       	push	r8
    1934:	9f 92       	push	r9
    1936:	af 92       	push	r10
    1938:	bf 92       	push	r11
    193a:	cf 92       	push	r12
    193c:	df 92       	push	r13
    193e:	ef 92       	push	r14
    1940:	ff 92       	push	r15
    1942:	0f 93       	push	r16
    1944:	1f 93       	push	r17
    1946:	cf 93       	push	r28
    1948:	df 93       	push	r29
    194a:	cd b7       	in	r28, 0x3d	; 61
    194c:	de b7       	in	r29, 0x3e	; 62
    194e:	28 97       	sbiw	r28, 0x08	; 8
    1950:	0f b6       	in	r0, 0x3f	; 63
    1952:	f8 94       	cli
    1954:	de bf       	out	0x3e, r29	; 62
    1956:	0f be       	out	0x3f, r0	; 63
    1958:	cd bf       	out	0x3d, r28	; 61
    195a:	98 87       	std	Y+8, r25	; 0x08
    195c:	8f 83       	std	Y+7, r24	; 0x07
  packet_payload[0] = VCP_POWER_TELEMETRY;
    195e:	dc 01       	movw	r26, r24
    1960:	1c 92       	st	X, r1
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
    1962:	30 91 a6 04 	lds	r19, 0x04A6
    1966:	33 0f       	add	r19, r19
                  ( svit[RADIO_1].switch_state << 2 )    |
    1968:	80 91 c0 04 	lds	r24, 0x04C0
    196c:	b4 e0       	ldi	r27, 0x04	; 4
    196e:	8b 9f       	mul	r24, r27
    1970:	c0 01       	movw	r24, r0
    1972:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1974:	38 2b       	or	r19, r24
    1976:	80 91 8c 04 	lds	r24, 0x048C
    197a:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
    197c:	80 91 da 04 	lds	r24, 0x04DA
    1980:	e8 e0       	ldi	r30, 0x08	; 8
    1982:	8e 9f       	mul	r24, r30
    1984:	c0 01       	movw	r24, r0
    1986:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1988:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
    198a:	80 91 28 05 	lds	r24, 0x0528
    198e:	f0 e1       	ldi	r31, 0x10	; 16
    1990:	8f 9f       	mul	r24, r31
    1992:	c0 01       	movw	r24, r0
    1994:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1996:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;
    1998:	80 91 42 05 	lds	r24, 0x0542
    199c:	20 e2       	ldi	r18, 0x20	; 32
    199e:	82 9f       	mul	r24, r18
    19a0:	c0 01       	movw	r24, r0
    19a2:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    19a4:	38 2b       	or	r19, r24
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
    19a6:	40 91 76 05 	lds	r20, 0x0576
    19aa:	44 0f       	add	r20, r20
                  ( svit[TORQUER_3].switch_state << 2 ) |
    19ac:	80 91 90 05 	lds	r24, 0x0590
    19b0:	54 e0       	ldi	r21, 0x04	; 4
    19b2:	85 9f       	mul	r24, r21
    19b4:	c0 01       	movw	r24, r0
    19b6:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    19b8:	48 2b       	or	r20, r24
    19ba:	80 91 5c 05 	lds	r24, 0x055C
    19be:	48 2b       	or	r20, r24
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );
    19c0:	e4 ef       	ldi	r30, 0xF4	; 244
    19c2:	f4 e0       	ldi	r31, 0x04	; 4
    19c4:	80 81       	ld	r24, Z
    19c6:	a8 e0       	ldi	r26, 0x08	; 8
    19c8:	8a 9f       	mul	r24, r26
    19ca:	c0 01       	movw	r24, r0
    19cc:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    19ce:	48 2b       	or	r20, r24
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
    19d0:	20 91 bc 03 	lds	r18, 0x03BC
    19d4:	22 0f       	add	r18, r18
                  ( svit[FC_5V].switch_state << 2 )        |
    19d6:	80 91 d6 03 	lds	r24, 0x03D6
    19da:	b4 e0       	ldi	r27, 0x04	; 4
    19dc:	8b 9f       	mul	r24, r27
    19de:	c0 01       	movw	r24, r0
    19e0:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    19e2:	28 2b       	or	r18, r24
    19e4:	80 91 a2 03 	lds	r24, 0x03A2
    19e8:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
    19ea:	80 91 0a 04 	lds	r24, 0x040A
    19ee:	58 e0       	ldi	r21, 0x08	; 8
    19f0:	85 9f       	mul	r24, r21
    19f2:	c0 01       	movw	r24, r0
    19f4:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    19f6:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
    19f8:	80 91 24 04 	lds	r24, 0x0424
    19fc:	a0 e1       	ldi	r26, 0x10	; 16
    19fe:	8a 9f       	mul	r24, r26
    1a00:	c0 01       	movw	r24, r0
    1a02:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a04:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
    1a06:	80 91 3e 04 	lds	r24, 0x043E
    1a0a:	b0 e2       	ldi	r27, 0x20	; 32
    1a0c:	8b 9f       	mul	r24, r27
    1a0e:	c0 01       	movw	r24, r0
    1a10:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a12:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
    1a14:	80 91 58 04 	lds	r24, 0x0458
    1a18:	50 e4       	ldi	r21, 0x40	; 64
    1a1a:	85 9f       	mul	r24, r21
    1a1c:	c0 01       	movw	r24, r0
    1a1e:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a20:	28 2b       	or	r18, r24
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;
    1a22:	80 91 72 04 	lds	r24, 0x0472
    1a26:	a0 e8       	ldi	r26, 0x80	; 128
    1a28:	8a 9f       	mul	r24, r26
    1a2a:	c0 01       	movw	r24, r0
    1a2c:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a2e:	28 2b       	or	r18, r24
  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );

  packet_payload[1] = on_off_state0;
    1a30:	af 81       	ldd	r26, Y+7	; 0x07
    1a32:	b8 85       	ldd	r27, Y+8	; 0x08
    1a34:	11 96       	adiw	r26, 0x01	; 1
    1a36:	2c 93       	st	X, r18
    1a38:	11 97       	sbiw	r26, 0x01	; 1
  packet_payload[2] = on_off_state1;
    1a3a:	12 96       	adiw	r26, 0x02	; 2
    1a3c:	3c 93       	st	X, r19
    1a3e:	12 97       	sbiw	r26, 0x02	; 2
  packet_payload[3] = on_off_state2;
    1a40:	13 96       	adiw	r26, 0x03	; 3
    1a42:	4c 93       	st	X, r20
    1a44:	13 97       	sbiw	r26, 0x03	; 3
  packet_payload[4] = 0x99;
    1a46:	89 e9       	ldi	r24, 0x99	; 153
    1a48:	14 96       	adiw	r26, 0x04	; 4
    1a4a:	8c 93       	st	X, r24
    1a4c:	14 97       	sbiw	r26, 0x04	; 4
  packet_payload[5] = svit[MAESTRO].switch_state;
    1a4e:	80 81       	ld	r24, Z
    1a50:	15 96       	adiw	r26, 0x05	; 5
    1a52:	8c 93       	st	X, r24

  // voltage values (raw ADC output)
  packet_payload[6]  = SVIT_check_V_critical( svit[SPECTROMETER].name );
    1a54:	20 ea       	ldi	r18, 0xA0	; 160
    1a56:	62 2e       	mov	r6, r18
    1a58:	23 e0       	ldi	r18, 0x03	; 3
    1a5a:	72 2e       	mov	r7, r18
    1a5c:	f3 01       	movw	r30, r6
    1a5e:	80 81       	ld	r24, Z
    1a60:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1a64:	af 81       	ldd	r26, Y+7	; 0x07
    1a66:	b8 85       	ldd	r27, Y+8	; 0x08
    1a68:	16 96       	adiw	r26, 0x06	; 6
    1a6a:	8c 93       	st	X, r24
  packet_payload[7]  = SVIT_check_V_critical( svit[STAR_TRACKER].name );
    1a6c:	3a eb       	ldi	r19, 0xBA	; 186
    1a6e:	83 2e       	mov	r8, r19
    1a70:	33 e0       	ldi	r19, 0x03	; 3
    1a72:	93 2e       	mov	r9, r19
    1a74:	f4 01       	movw	r30, r8
    1a76:	80 81       	ld	r24, Z
    1a78:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1a7c:	af 81       	ldd	r26, Y+7	; 0x07
    1a7e:	b8 85       	ldd	r27, Y+8	; 0x08
    1a80:	17 96       	adiw	r26, 0x07	; 7
    1a82:	8c 93       	st	X, r24
  packet_payload[8]  = SVIT_check_V_critical( svit[FC_5V].name );
    1a84:	44 ed       	ldi	r20, 0xD4	; 212
    1a86:	a4 2e       	mov	r10, r20
    1a88:	43 e0       	ldi	r20, 0x03	; 3
    1a8a:	b4 2e       	mov	r11, r20
    1a8c:	f5 01       	movw	r30, r10
    1a8e:	80 81       	ld	r24, Z
    1a90:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1a94:	af 81       	ldd	r26, Y+7	; 0x07
    1a96:	b8 85       	ldd	r27, Y+8	; 0x08
    1a98:	18 96       	adiw	r26, 0x08	; 8
    1a9a:	8c 93       	st	X, r24
  packet_payload[9]  = SVIT_check_V_critical( svit[FC_3_3V].name );
    1a9c:	5e ee       	ldi	r21, 0xEE	; 238
    1a9e:	c5 2e       	mov	r12, r21
    1aa0:	53 e0       	ldi	r21, 0x03	; 3
    1aa2:	d5 2e       	mov	r13, r21
    1aa4:	f6 01       	movw	r30, r12
    1aa6:	80 81       	ld	r24, Z
    1aa8:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1aac:	af 81       	ldd	r26, Y+7	; 0x07
    1aae:	b8 85       	ldd	r27, Y+8	; 0x08
    1ab0:	19 96       	adiw	r26, 0x09	; 9
    1ab2:	8c 93       	st	X, r24
  packet_payload[10] = SVIT_check_V_critical( svit[GPS_1].name );
    1ab4:	68 e0       	ldi	r22, 0x08	; 8
    1ab6:	e6 2e       	mov	r14, r22
    1ab8:	64 e0       	ldi	r22, 0x04	; 4
    1aba:	f6 2e       	mov	r15, r22
    1abc:	f7 01       	movw	r30, r14
    1abe:	80 81       	ld	r24, Z
    1ac0:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1ac4:	af 81       	ldd	r26, Y+7	; 0x07
    1ac6:	b8 85       	ldd	r27, Y+8	; 0x08
    1ac8:	1a 96       	adiw	r26, 0x0a	; 10
    1aca:	8c 93       	st	X, r24
  packet_payload[11] = SVIT_check_V_critical( svit[CDH_IB].name );
    1acc:	0c e3       	ldi	r16, 0x3C	; 60
    1ace:	14 e0       	ldi	r17, 0x04	; 4
    1ad0:	f8 01       	movw	r30, r16
    1ad2:	80 81       	ld	r24, Z
    1ad4:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1ad8:	af 81       	ldd	r26, Y+7	; 0x07
    1ada:	b8 85       	ldd	r27, Y+8	; 0x08
    1adc:	1b 96       	adiw	r26, 0x0b	; 11
    1ade:	8c 93       	st	X, r24
  packet_payload[12] = SVIT_check_V_critical( svit[HEATER_1].name );
    1ae0:	e6 e5       	ldi	r30, 0x56	; 86
    1ae2:	f4 e0       	ldi	r31, 0x04	; 4
    1ae4:	80 81       	ld	r24, Z
    1ae6:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1aea:	af 81       	ldd	r26, Y+7	; 0x07
    1aec:	b8 85       	ldd	r27, Y+8	; 0x08
    1aee:	1c 96       	adiw	r26, 0x0c	; 12
    1af0:	8c 93       	st	X, r24
  packet_payload[13] = SVIT_check_V_critical( svit[HEATER_2].name );
    1af2:	70 e7       	ldi	r23, 0x70	; 112
    1af4:	47 2e       	mov	r4, r23
    1af6:	74 e0       	ldi	r23, 0x04	; 4
    1af8:	57 2e       	mov	r5, r23
    1afa:	f2 01       	movw	r30, r4
    1afc:	80 81       	ld	r24, Z
    1afe:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1b02:	af 81       	ldd	r26, Y+7	; 0x07
    1b04:	b8 85       	ldd	r27, Y+8	; 0x08
    1b06:	1d 96       	adiw	r26, 0x0d	; 13
    1b08:	8c 93       	st	X, r24
  packet_payload[14] = SVIT_check_V_critical( svit[CMG].name );
    1b0a:	ea e8       	ldi	r30, 0x8A	; 138
    1b0c:	2e 2e       	mov	r2, r30
    1b0e:	e4 e0       	ldi	r30, 0x04	; 4
    1b10:	3e 2e       	mov	r3, r30
    1b12:	f1 01       	movw	r30, r2
    1b14:	80 81       	ld	r24, Z
    1b16:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1b1a:	af 81       	ldd	r26, Y+7	; 0x07
    1b1c:	b8 85       	ldd	r27, Y+8	; 0x08
    1b1e:	1e 96       	adiw	r26, 0x0e	; 14
    1b20:	8c 93       	st	X, r24
  packet_payload[15] = SVIT_check_V_critical( svit[SUN_SENSOR].name );
    1b22:	24 ea       	ldi	r18, 0xA4	; 164
    1b24:	34 e0       	ldi	r19, 0x04	; 4
    1b26:	f9 01       	movw	r30, r18
    1b28:	80 81       	ld	r24, Z
    1b2a:	29 83       	std	Y+1, r18	; 0x01
    1b2c:	3a 83       	std	Y+2, r19	; 0x02
    1b2e:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1b32:	af 81       	ldd	r26, Y+7	; 0x07
    1b34:	b8 85       	ldd	r27, Y+8	; 0x08
    1b36:	1f 96       	adiw	r26, 0x0f	; 15
    1b38:	8c 93       	st	X, r24
  packet_payload[16] = SVIT_check_V_critical( svit[RADIO_1].name );
    1b3a:	4e eb       	ldi	r20, 0xBE	; 190
    1b3c:	54 e0       	ldi	r21, 0x04	; 4
    1b3e:	fa 01       	movw	r30, r20
    1b40:	80 81       	ld	r24, Z
    1b42:	4b 83       	std	Y+3, r20	; 0x03
    1b44:	5c 83       	std	Y+4, r21	; 0x04
    1b46:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1b4a:	af 81       	ldd	r26, Y+7	; 0x07
    1b4c:	b8 85       	ldd	r27, Y+8	; 0x08
    1b4e:	50 96       	adiw	r26, 0x10	; 16
    1b50:	8c 93       	st	X, r24
  packet_payload[17] = SVIT_check_V_critical( svit[RADIO_2].name );
    1b52:	68 ed       	ldi	r22, 0xD8	; 216
    1b54:	74 e0       	ldi	r23, 0x04	; 4
    1b56:	fb 01       	movw	r30, r22
    1b58:	80 81       	ld	r24, Z
    1b5a:	6d 83       	std	Y+5, r22	; 0x05
    1b5c:	7e 83       	std	Y+6, r23	; 0x06
    1b5e:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1b62:	af 81       	ldd	r26, Y+7	; 0x07
    1b64:	b8 85       	ldd	r27, Y+8	; 0x08
    1b66:	51 96       	adiw	r26, 0x11	; 17
    1b68:	8c 93       	st	X, r24
  packet_payload[18] = SVIT_check_V_critical( svit[FOG_15V].name );
    1b6a:	e6 e2       	ldi	r30, 0x26	; 38
    1b6c:	f5 e0       	ldi	r31, 0x05	; 5
    1b6e:	80 81       	ld	r24, Z
    1b70:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1b74:	af 81       	ldd	r26, Y+7	; 0x07
    1b76:	b8 85       	ldd	r27, Y+8	; 0x08
    1b78:	52 96       	adiw	r26, 0x12	; 18
    1b7a:	8c 93       	st	X, r24
  packet_payload[19] = SVIT_check_V_critical( svit[FOG_5V].name );
    1b7c:	e0 e4       	ldi	r30, 0x40	; 64
    1b7e:	f5 e0       	ldi	r31, 0x05	; 5
    1b80:	80 81       	ld	r24, Z
    1b82:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1b86:	af 81       	ldd	r26, Y+7	; 0x07
    1b88:	b8 85       	ldd	r27, Y+8	; 0x08
    1b8a:	53 96       	adiw	r26, 0x13	; 19
    1b8c:	8c 93       	st	X, r24
  packet_payload[20] = SVIT_check_V_critical( svit[TORQUER_1].name );
    1b8e:	ea e5       	ldi	r30, 0x5A	; 90
    1b90:	f5 e0       	ldi	r31, 0x05	; 5
    1b92:	80 81       	ld	r24, Z
    1b94:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1b98:	af 81       	ldd	r26, Y+7	; 0x07
    1b9a:	b8 85       	ldd	r27, Y+8	; 0x08
    1b9c:	54 96       	adiw	r26, 0x14	; 20
    1b9e:	8c 93       	st	X, r24
  packet_payload[21] = SVIT_check_V_critical( svit[TORQUER_2].name );
    1ba0:	e4 e7       	ldi	r30, 0x74	; 116
    1ba2:	f5 e0       	ldi	r31, 0x05	; 5
    1ba4:	80 81       	ld	r24, Z
    1ba6:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1baa:	af 81       	ldd	r26, Y+7	; 0x07
    1bac:	b8 85       	ldd	r27, Y+8	; 0x08
    1bae:	55 96       	adiw	r26, 0x15	; 21
    1bb0:	8c 93       	st	X, r24
  packet_payload[22] = SVIT_check_V_critical( svit[TORQUER_3].name );
    1bb2:	ee e8       	ldi	r30, 0x8E	; 142
    1bb4:	f5 e0       	ldi	r31, 0x05	; 5
    1bb6:	80 81       	ld	r24, Z
    1bb8:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1bbc:	af 81       	ldd	r26, Y+7	; 0x07
    1bbe:	b8 85       	ldd	r27, Y+8	; 0x08
    1bc0:	56 96       	adiw	r26, 0x16	; 22
    1bc2:	8c 93       	st	X, r24
  packet_payload[23] = SVIT_check_V_critical( svit[BATTERY_1].name );
    1bc4:	e8 ea       	ldi	r30, 0xA8	; 168
    1bc6:	f5 e0       	ldi	r31, 0x05	; 5
    1bc8:	80 81       	ld	r24, Z
    1bca:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1bce:	af 81       	ldd	r26, Y+7	; 0x07
    1bd0:	b8 85       	ldd	r27, Y+8	; 0x08
    1bd2:	57 96       	adiw	r26, 0x17	; 23
    1bd4:	8c 93       	st	X, r24
  packet_payload[24] = SVIT_check_V_critical( svit[BATTERY_2].name );
    1bd6:	e2 ec       	ldi	r30, 0xC2	; 194
    1bd8:	f5 e0       	ldi	r31, 0x05	; 5
    1bda:	80 81       	ld	r24, Z
    1bdc:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1be0:	af 81       	ldd	r26, Y+7	; 0x07
    1be2:	b8 85       	ldd	r27, Y+8	; 0x08
    1be4:	58 96       	adiw	r26, 0x18	; 24
    1be6:	8c 93       	st	X, r24
  packet_payload[25] = SVIT_check_V_critical( svit[SOLAR_FULL].name );
    1be8:	ec ed       	ldi	r30, 0xDC	; 220
    1bea:	f5 e0       	ldi	r31, 0x05	; 5
    1bec:	80 81       	ld	r24, Z
    1bee:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1bf2:	af 81       	ldd	r26, Y+7	; 0x07
    1bf4:	b8 85       	ldd	r27, Y+8	; 0x08
    1bf6:	59 96       	adiw	r26, 0x19	; 25
    1bf8:	8c 93       	st	X, r24
  packet_payload[26] = SVIT_check_V_critical( svit[SOLAR_1].name );
    1bfa:	e6 ef       	ldi	r30, 0xF6	; 246
    1bfc:	f5 e0       	ldi	r31, 0x05	; 5
    1bfe:	80 81       	ld	r24, Z
    1c00:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1c04:	af 81       	ldd	r26, Y+7	; 0x07
    1c06:	b8 85       	ldd	r27, Y+8	; 0x08
    1c08:	5a 96       	adiw	r26, 0x1a	; 26
    1c0a:	8c 93       	st	X, r24
  packet_payload[27] = SVIT_check_V_critical( svit[SOLAR_2].name );
    1c0c:	e0 e1       	ldi	r30, 0x10	; 16
    1c0e:	f6 e0       	ldi	r31, 0x06	; 6
    1c10:	80 81       	ld	r24, Z
    1c12:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1c16:	af 81       	ldd	r26, Y+7	; 0x07
    1c18:	b8 85       	ldd	r27, Y+8	; 0x08
    1c1a:	5b 96       	adiw	r26, 0x1b	; 27
    1c1c:	8c 93       	st	X, r24
  packet_payload[28] = SVIT_check_V_critical( svit[SOLAR_3].name );
    1c1e:	ea e2       	ldi	r30, 0x2A	; 42
    1c20:	f6 e0       	ldi	r31, 0x06	; 6
    1c22:	80 81       	ld	r24, Z
    1c24:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1c28:	af 81       	ldd	r26, Y+7	; 0x07
    1c2a:	b8 85       	ldd	r27, Y+8	; 0x08
    1c2c:	5c 96       	adiw	r26, 0x1c	; 28
    1c2e:	8c 93       	st	X, r24
  packet_payload[29] = SVIT_check_V_critical( svit[SOLAR_4].name );
    1c30:	e4 e4       	ldi	r30, 0x44	; 68
    1c32:	f6 e0       	ldi	r31, 0x06	; 6
    1c34:	80 81       	ld	r24, Z
    1c36:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1c3a:	af 81       	ldd	r26, Y+7	; 0x07
    1c3c:	b8 85       	ldd	r27, Y+8	; 0x08
    1c3e:	5d 96       	adiw	r26, 0x1d	; 29
    1c40:	8c 93       	st	X, r24
  packet_payload[30] = SVIT_check_V_critical( svit[SOLAR_5].name );
    1c42:	ee e5       	ldi	r30, 0x5E	; 94
    1c44:	f6 e0       	ldi	r31, 0x06	; 6
    1c46:	80 81       	ld	r24, Z
    1c48:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1c4c:	af 81       	ldd	r26, Y+7	; 0x07
    1c4e:	b8 85       	ldd	r27, Y+8	; 0x08
    1c50:	5e 96       	adiw	r26, 0x1e	; 30
    1c52:	8c 93       	st	X, r24
  packet_payload[31] = SVIT_check_V_critical( svit[SOLAR_6].name );
    1c54:	e8 e7       	ldi	r30, 0x78	; 120
    1c56:	f6 e0       	ldi	r31, 0x06	; 6
    1c58:	80 81       	ld	r24, Z
    1c5a:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1c5e:	af 81       	ldd	r26, Y+7	; 0x07
    1c60:	b8 85       	ldd	r27, Y+8	; 0x08
    1c62:	5f 96       	adiw	r26, 0x1f	; 31
    1c64:	8c 93       	st	X, r24
  packet_payload[32] = SVIT_check_V_critical( svit[SOLAR_7].name );
    1c66:	e2 e9       	ldi	r30, 0x92	; 146
    1c68:	f6 e0       	ldi	r31, 0x06	; 6
    1c6a:	80 81       	ld	r24, Z
    1c6c:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1c70:	af 81       	ldd	r26, Y+7	; 0x07
    1c72:	b8 85       	ldd	r27, Y+8	; 0x08
    1c74:	90 96       	adiw	r26, 0x20	; 32
    1c76:	8c 93       	st	X, r24
  packet_payload[33] = SVIT_check_V_critical( svit[SOLAR_8].name );
    1c78:	ec ea       	ldi	r30, 0xAC	; 172
    1c7a:	f6 e0       	ldi	r31, 0x06	; 6
    1c7c:	80 81       	ld	r24, Z
    1c7e:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1c82:	af 81       	ldd	r26, Y+7	; 0x07
    1c84:	b8 85       	ldd	r27, Y+8	; 0x08
    1c86:	91 96       	adiw	r26, 0x21	; 33
    1c88:	8c 93       	st	X, r24
  packet_payload[34] = SVIT_check_V_critical( svit[SOLAR_9].name );
    1c8a:	e6 ec       	ldi	r30, 0xC6	; 198
    1c8c:	f6 e0       	ldi	r31, 0x06	; 6
    1c8e:	80 81       	ld	r24, Z
    1c90:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1c94:	af 81       	ldd	r26, Y+7	; 0x07
    1c96:	b8 85       	ldd	r27, Y+8	; 0x08
    1c98:	92 96       	adiw	r26, 0x22	; 34
    1c9a:	8c 93       	st	X, r24
  packet_payload[35] = SVIT_check_V_critical( svit[SOLAR_10].name );
    1c9c:	e0 ee       	ldi	r30, 0xE0	; 224
    1c9e:	f6 e0       	ldi	r31, 0x06	; 6
    1ca0:	80 81       	ld	r24, Z
    1ca2:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1ca6:	af 81       	ldd	r26, Y+7	; 0x07
    1ca8:	b8 85       	ldd	r27, Y+8	; 0x08
    1caa:	93 96       	adiw	r26, 0x23	; 35
    1cac:	8c 93       	st	X, r24
  packet_payload[36] = SVIT_check_V_critical( svit[SOLAR_11].name );
    1cae:	ea ef       	ldi	r30, 0xFA	; 250
    1cb0:	f6 e0       	ldi	r31, 0x06	; 6
    1cb2:	80 81       	ld	r24, Z
    1cb4:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1cb8:	af 81       	ldd	r26, Y+7	; 0x07
    1cba:	b8 85       	ldd	r27, Y+8	; 0x08
    1cbc:	94 96       	adiw	r26, 0x24	; 36
    1cbe:	8c 93       	st	X, r24
  packet_payload[37] = SVIT_check_V_critical( svit[SOLAR_12].name );
    1cc0:	e4 e1       	ldi	r30, 0x14	; 20
    1cc2:	f7 e0       	ldi	r31, 0x07	; 7
    1cc4:	80 81       	ld	r24, Z
    1cc6:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1cca:	af 81       	ldd	r26, Y+7	; 0x07
    1ccc:	b8 85       	ldd	r27, Y+8	; 0x08
    1cce:	95 96       	adiw	r26, 0x25	; 37
    1cd0:	8c 93       	st	X, r24
  packet_payload[38] = SVIT_check_V_critical( svit[POWER_BOARD].name );
    1cd2:	80 91 2e 07 	lds	r24, 0x072E
    1cd6:	0e 94 58 08 	call	0x10b0	; 0x10b0 <SVIT_check_V_critical>
    1cda:	ef 81       	ldd	r30, Y+7	; 0x07
    1cdc:	f8 85       	ldd	r31, Y+8	; 0x08
    1cde:	86 a3       	std	Z+38, r24	; 0x26
  //uint8_t voltage_error1;
  //uint8_t voltage_error2;
  //uint8_t voltage_error3;
  //uint8_t voltage_error4;
 
  packet_payload[39] = 0;
    1ce0:	17 a2       	std	Z+39, r1	; 0x27
  packet_payload[40] = 0;
    1ce2:	10 a6       	std	Z+40, r1	; 0x28
  packet_payload[41] = 0;
    1ce4:	11 a6       	std	Z+41, r1	; 0x29
  packet_payload[42] = 0;
    1ce6:	12 a6       	std	Z+42, r1	; 0x2a
  packet_payload[43] = 0;
    1ce8:	13 a6       	std	Z+43, r1	; 0x2b

  // current values (raw ADC output)
  packet_payload[44] = SVIT_check_I_critical( svit[SPECTROMETER].name );
    1cea:	d3 01       	movw	r26, r6
    1cec:	8c 91       	ld	r24, X
    1cee:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1cf2:	ef 81       	ldd	r30, Y+7	; 0x07
    1cf4:	f8 85       	ldd	r31, Y+8	; 0x08
    1cf6:	84 a7       	std	Z+44, r24	; 0x2c
  packet_payload[45] = SVIT_check_I_critical( svit[STAR_TRACKER].name );
    1cf8:	d4 01       	movw	r26, r8
    1cfa:	8c 91       	ld	r24, X
    1cfc:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d00:	ef 81       	ldd	r30, Y+7	; 0x07
    1d02:	f8 85       	ldd	r31, Y+8	; 0x08
    1d04:	85 a7       	std	Z+45, r24	; 0x2d
  packet_payload[46] = SVIT_check_I_critical( svit[FC_5V].name );
    1d06:	d5 01       	movw	r26, r10
    1d08:	8c 91       	ld	r24, X
    1d0a:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d0e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d10:	f8 85       	ldd	r31, Y+8	; 0x08
    1d12:	86 a7       	std	Z+46, r24	; 0x2e
  packet_payload[47] = SVIT_check_I_critical( svit[FC_3_3V].name );
    1d14:	d6 01       	movw	r26, r12
    1d16:	8c 91       	ld	r24, X
    1d18:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d1c:	ef 81       	ldd	r30, Y+7	; 0x07
    1d1e:	f8 85       	ldd	r31, Y+8	; 0x08
    1d20:	87 a7       	std	Z+47, r24	; 0x2f
  packet_payload[48] = SVIT_check_I_critical( svit[GPS_1].name );
    1d22:	d7 01       	movw	r26, r14
    1d24:	8c 91       	ld	r24, X
    1d26:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d2a:	ef 81       	ldd	r30, Y+7	; 0x07
    1d2c:	f8 85       	ldd	r31, Y+8	; 0x08
    1d2e:	80 ab       	std	Z+48, r24	; 0x30
  packet_payload[49] = SVIT_check_I_critical( svit[CDH_IB].name );
    1d30:	d8 01       	movw	r26, r16
    1d32:	8c 91       	ld	r24, X
    1d34:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d38:	ef 81       	ldd	r30, Y+7	; 0x07
    1d3a:	f8 85       	ldd	r31, Y+8	; 0x08
    1d3c:	81 ab       	std	Z+49, r24	; 0x31
  packet_payload[50] = SVIT_check_I_critical( svit[HEATER_1].name );
    1d3e:	a6 e5       	ldi	r26, 0x56	; 86
    1d40:	b4 e0       	ldi	r27, 0x04	; 4
    1d42:	8c 91       	ld	r24, X
    1d44:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d48:	ef 81       	ldd	r30, Y+7	; 0x07
    1d4a:	f8 85       	ldd	r31, Y+8	; 0x08
    1d4c:	82 ab       	std	Z+50, r24	; 0x32
  packet_payload[51] = SVIT_check_I_critical( svit[HEATER_2].name );
    1d4e:	d2 01       	movw	r26, r4
    1d50:	8c 91       	ld	r24, X
    1d52:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d56:	ef 81       	ldd	r30, Y+7	; 0x07
    1d58:	f8 85       	ldd	r31, Y+8	; 0x08
    1d5a:	83 ab       	std	Z+51, r24	; 0x33
  packet_payload[52] = SVIT_check_I_critical( svit[CMG].name );
    1d5c:	d1 01       	movw	r26, r2
    1d5e:	8c 91       	ld	r24, X
    1d60:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d64:	ef 81       	ldd	r30, Y+7	; 0x07
    1d66:	f8 85       	ldd	r31, Y+8	; 0x08
    1d68:	84 ab       	std	Z+52, r24	; 0x34
  packet_payload[53] = SVIT_check_I_critical( svit[SUN_SENSOR].name );
    1d6a:	29 81       	ldd	r18, Y+1	; 0x01
    1d6c:	3a 81       	ldd	r19, Y+2	; 0x02
    1d6e:	d9 01       	movw	r26, r18
    1d70:	8c 91       	ld	r24, X
    1d72:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d76:	ef 81       	ldd	r30, Y+7	; 0x07
    1d78:	f8 85       	ldd	r31, Y+8	; 0x08
    1d7a:	85 ab       	std	Z+53, r24	; 0x35
  packet_payload[54] = SVIT_check_I_critical( svit[RADIO_1].name );
    1d7c:	4b 81       	ldd	r20, Y+3	; 0x03
    1d7e:	5c 81       	ldd	r21, Y+4	; 0x04
    1d80:	da 01       	movw	r26, r20
    1d82:	8c 91       	ld	r24, X
    1d84:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d88:	ef 81       	ldd	r30, Y+7	; 0x07
    1d8a:	f8 85       	ldd	r31, Y+8	; 0x08
    1d8c:	86 ab       	std	Z+54, r24	; 0x36
  packet_payload[55] = SVIT_check_I_critical( svit[RADIO_2].name );
    1d8e:	6d 81       	ldd	r22, Y+5	; 0x05
    1d90:	7e 81       	ldd	r23, Y+6	; 0x06
    1d92:	db 01       	movw	r26, r22
    1d94:	8c 91       	ld	r24, X
    1d96:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1d9a:	ef 81       	ldd	r30, Y+7	; 0x07
    1d9c:	f8 85       	ldd	r31, Y+8	; 0x08
    1d9e:	87 ab       	std	Z+55, r24	; 0x37
  packet_payload[56] = SVIT_check_I_critical( svit[FOG_15V].name );
    1da0:	a6 e2       	ldi	r26, 0x26	; 38
    1da2:	b5 e0       	ldi	r27, 0x05	; 5
    1da4:	8c 91       	ld	r24, X
    1da6:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1daa:	ef 81       	ldd	r30, Y+7	; 0x07
    1dac:	f8 85       	ldd	r31, Y+8	; 0x08
    1dae:	80 af       	std	Z+56, r24	; 0x38
  packet_payload[57] = SVIT_check_I_critical( svit[FOG_5V].name );
    1db0:	a0 e4       	ldi	r26, 0x40	; 64
    1db2:	b5 e0       	ldi	r27, 0x05	; 5
    1db4:	8c 91       	ld	r24, X
    1db6:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1dba:	ef 81       	ldd	r30, Y+7	; 0x07
    1dbc:	f8 85       	ldd	r31, Y+8	; 0x08
    1dbe:	81 af       	std	Z+57, r24	; 0x39
  packet_payload[58] = SVIT_check_I_critical( svit[TORQUER_1].name );
    1dc0:	aa e5       	ldi	r26, 0x5A	; 90
    1dc2:	b5 e0       	ldi	r27, 0x05	; 5
    1dc4:	8c 91       	ld	r24, X
    1dc6:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1dca:	ef 81       	ldd	r30, Y+7	; 0x07
    1dcc:	f8 85       	ldd	r31, Y+8	; 0x08
    1dce:	82 af       	std	Z+58, r24	; 0x3a
  packet_payload[59] = SVIT_check_I_critical( svit[TORQUER_2].name );
    1dd0:	a4 e7       	ldi	r26, 0x74	; 116
    1dd2:	b5 e0       	ldi	r27, 0x05	; 5
    1dd4:	8c 91       	ld	r24, X
    1dd6:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1dda:	ef 81       	ldd	r30, Y+7	; 0x07
    1ddc:	f8 85       	ldd	r31, Y+8	; 0x08
    1dde:	83 af       	std	Z+59, r24	; 0x3b
  packet_payload[60] = SVIT_check_I_critical( svit[TORQUER_3].name );
    1de0:	ae e8       	ldi	r26, 0x8E	; 142
    1de2:	b5 e0       	ldi	r27, 0x05	; 5
    1de4:	8c 91       	ld	r24, X
    1de6:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1dea:	ef 81       	ldd	r30, Y+7	; 0x07
    1dec:	f8 85       	ldd	r31, Y+8	; 0x08
    1dee:	84 af       	std	Z+60, r24	; 0x3c
  packet_payload[61] = SVIT_check_I_critical( svit[BATTERY_1].name );
    1df0:	a8 ea       	ldi	r26, 0xA8	; 168
    1df2:	b5 e0       	ldi	r27, 0x05	; 5
    1df4:	8c 91       	ld	r24, X
    1df6:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1dfa:	ef 81       	ldd	r30, Y+7	; 0x07
    1dfc:	f8 85       	ldd	r31, Y+8	; 0x08
    1dfe:	85 af       	std	Z+61, r24	; 0x3d
  packet_payload[62] = SVIT_check_I_critical( svit[BATTERY_2].name );
    1e00:	a2 ec       	ldi	r26, 0xC2	; 194
    1e02:	b5 e0       	ldi	r27, 0x05	; 5
    1e04:	8c 91       	ld	r24, X
    1e06:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1e0a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e0c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e0e:	86 af       	std	Z+62, r24	; 0x3e
  packet_payload[63] = SVIT_check_I_critical( svit[SOLAR_FULL].name );
    1e10:	ac ed       	ldi	r26, 0xDC	; 220
    1e12:	b5 e0       	ldi	r27, 0x05	; 5
    1e14:	8c 91       	ld	r24, X
    1e16:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1e1a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e1c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e1e:	87 af       	std	Z+63, r24	; 0x3f
  packet_payload[64] = SVIT_check_I_critical( svit[SOLAR_1].name );
    1e20:	a6 ef       	ldi	r26, 0xF6	; 246
    1e22:	b5 e0       	ldi	r27, 0x05	; 5
    1e24:	8c 91       	ld	r24, X
    1e26:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1e2a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e2c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e2e:	e0 5c       	subi	r30, 0xC0	; 192
    1e30:	ff 4f       	sbci	r31, 0xFF	; 255
    1e32:	80 83       	st	Z, r24
  packet_payload[65] = SVIT_check_I_critical( svit[SOLAR_2].name );
    1e34:	e0 e1       	ldi	r30, 0x10	; 16
    1e36:	f6 e0       	ldi	r31, 0x06	; 6
    1e38:	80 81       	ld	r24, Z
    1e3a:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1e3e:	ef 81       	ldd	r30, Y+7	; 0x07
    1e40:	f8 85       	ldd	r31, Y+8	; 0x08
    1e42:	ef 5b       	subi	r30, 0xBF	; 191
    1e44:	ff 4f       	sbci	r31, 0xFF	; 255
    1e46:	80 83       	st	Z, r24
  packet_payload[66] = SVIT_check_I_critical( svit[SOLAR_3].name );
    1e48:	aa e2       	ldi	r26, 0x2A	; 42
    1e4a:	b6 e0       	ldi	r27, 0x06	; 6
    1e4c:	8c 91       	ld	r24, X
    1e4e:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1e52:	ef 81       	ldd	r30, Y+7	; 0x07
    1e54:	f8 85       	ldd	r31, Y+8	; 0x08
    1e56:	ee 5b       	subi	r30, 0xBE	; 190
    1e58:	ff 4f       	sbci	r31, 0xFF	; 255
    1e5a:	80 83       	st	Z, r24
  packet_payload[67] = SVIT_check_I_critical( svit[SOLAR_4].name );
    1e5c:	e4 e4       	ldi	r30, 0x44	; 68
    1e5e:	f6 e0       	ldi	r31, 0x06	; 6
    1e60:	80 81       	ld	r24, Z
    1e62:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1e66:	ef 81       	ldd	r30, Y+7	; 0x07
    1e68:	f8 85       	ldd	r31, Y+8	; 0x08
    1e6a:	ed 5b       	subi	r30, 0xBD	; 189
    1e6c:	ff 4f       	sbci	r31, 0xFF	; 255
    1e6e:	80 83       	st	Z, r24
  packet_payload[68] = SVIT_check_I_critical( svit[SOLAR_5].name );
    1e70:	ae e5       	ldi	r26, 0x5E	; 94
    1e72:	b6 e0       	ldi	r27, 0x06	; 6
    1e74:	8c 91       	ld	r24, X
    1e76:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1e7a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e7c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e7e:	ec 5b       	subi	r30, 0xBC	; 188
    1e80:	ff 4f       	sbci	r31, 0xFF	; 255
    1e82:	80 83       	st	Z, r24
  packet_payload[69] = SVIT_check_I_critical( svit[SOLAR_6].name );
    1e84:	e8 e7       	ldi	r30, 0x78	; 120
    1e86:	f6 e0       	ldi	r31, 0x06	; 6
    1e88:	80 81       	ld	r24, Z
    1e8a:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1e8e:	ef 81       	ldd	r30, Y+7	; 0x07
    1e90:	f8 85       	ldd	r31, Y+8	; 0x08
    1e92:	eb 5b       	subi	r30, 0xBB	; 187
    1e94:	ff 4f       	sbci	r31, 0xFF	; 255
    1e96:	80 83       	st	Z, r24
  packet_payload[70] = SVIT_check_I_critical( svit[SOLAR_7].name );
    1e98:	a2 e9       	ldi	r26, 0x92	; 146
    1e9a:	b6 e0       	ldi	r27, 0x06	; 6
    1e9c:	8c 91       	ld	r24, X
    1e9e:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1ea2:	ef 81       	ldd	r30, Y+7	; 0x07
    1ea4:	f8 85       	ldd	r31, Y+8	; 0x08
    1ea6:	ea 5b       	subi	r30, 0xBA	; 186
    1ea8:	ff 4f       	sbci	r31, 0xFF	; 255
    1eaa:	80 83       	st	Z, r24
  packet_payload[71] = SVIT_check_I_critical( svit[SOLAR_8].name );
    1eac:	ec ea       	ldi	r30, 0xAC	; 172
    1eae:	f6 e0       	ldi	r31, 0x06	; 6
    1eb0:	80 81       	ld	r24, Z
    1eb2:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1eb6:	ef 81       	ldd	r30, Y+7	; 0x07
    1eb8:	f8 85       	ldd	r31, Y+8	; 0x08
    1eba:	e9 5b       	subi	r30, 0xB9	; 185
    1ebc:	ff 4f       	sbci	r31, 0xFF	; 255
    1ebe:	80 83       	st	Z, r24
  packet_payload[72] = SVIT_check_I_critical( svit[SOLAR_9].name );
    1ec0:	a6 ec       	ldi	r26, 0xC6	; 198
    1ec2:	b6 e0       	ldi	r27, 0x06	; 6
    1ec4:	8c 91       	ld	r24, X
    1ec6:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1eca:	ef 81       	ldd	r30, Y+7	; 0x07
    1ecc:	f8 85       	ldd	r31, Y+8	; 0x08
    1ece:	e8 5b       	subi	r30, 0xB8	; 184
    1ed0:	ff 4f       	sbci	r31, 0xFF	; 255
    1ed2:	80 83       	st	Z, r24
  packet_payload[73] = SVIT_check_I_critical( svit[SOLAR_10].name );
    1ed4:	e0 ee       	ldi	r30, 0xE0	; 224
    1ed6:	f6 e0       	ldi	r31, 0x06	; 6
    1ed8:	80 81       	ld	r24, Z
    1eda:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1ede:	ef 81       	ldd	r30, Y+7	; 0x07
    1ee0:	f8 85       	ldd	r31, Y+8	; 0x08
    1ee2:	e7 5b       	subi	r30, 0xB7	; 183
    1ee4:	ff 4f       	sbci	r31, 0xFF	; 255
    1ee6:	80 83       	st	Z, r24
  packet_payload[74] = SVIT_check_I_critical( svit[SOLAR_11].name );
    1ee8:	aa ef       	ldi	r26, 0xFA	; 250
    1eea:	b6 e0       	ldi	r27, 0x06	; 6
    1eec:	8c 91       	ld	r24, X
    1eee:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1ef2:	ef 81       	ldd	r30, Y+7	; 0x07
    1ef4:	f8 85       	ldd	r31, Y+8	; 0x08
    1ef6:	e6 5b       	subi	r30, 0xB6	; 182
    1ef8:	ff 4f       	sbci	r31, 0xFF	; 255
    1efa:	80 83       	st	Z, r24
  packet_payload[75] = SVIT_check_I_critical( svit[SOLAR_12].name );
    1efc:	e4 e1       	ldi	r30, 0x14	; 20
    1efe:	f7 e0       	ldi	r31, 0x07	; 7
    1f00:	80 81       	ld	r24, Z
    1f02:	0e 94 49 08 	call	0x1092	; 0x1092 <SVIT_check_I_critical>
    1f06:	ef 81       	ldd	r30, Y+7	; 0x07
    1f08:	f8 85       	ldd	r31, Y+8	; 0x08
    1f0a:	e5 5b       	subi	r30, 0xB5	; 181
    1f0c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f0e:	80 83       	st	Z, r24
  packet_payload[76] = 0xFF;//SVIT_check_I_critical( svit[POWER_BOARD].name );
    1f10:	ef 81       	ldd	r30, Y+7	; 0x07
    1f12:	f8 85       	ldd	r31, Y+8	; 0x08
    1f14:	e4 5b       	subi	r30, 0xB4	; 180
    1f16:	ff 4f       	sbci	r31, 0xFF	; 255
    1f18:	8f ef       	ldi	r24, 0xFF	; 255
    1f1a:	80 83       	st	Z, r24
  //uint8_t current_error1;
  //uint8_t current_error2;
  //uint8_t current_error3;
  //uint8_t current_error4;

  packet_payload[77] = batt1_voltage;//V_ack_change();
    1f1c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f1e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f20:	e3 5b       	subi	r30, 0xB3	; 179
    1f22:	ff 4f       	sbci	r31, 0xFF	; 255
    1f24:	90 91 8f 09 	lds	r25, 0x098F
    1f28:	90 83       	st	Z, r25
  packet_payload[78] = soc;//soc;// I_ack_change();
    1f2a:	ef 81       	ldd	r30, Y+7	; 0x07
    1f2c:	f8 85       	ldd	r31, Y+8	; 0x08
    1f2e:	e2 5b       	subi	r30, 0xB2	; 178
    1f30:	ff 4f       	sbci	r31, 0xFF	; 255
    1f32:	90 91 cb 0f 	lds	r25, 0x0FCB
    1f36:	90 83       	st	Z, r25
  packet_payload[79] = 0x00;//low >> 6;//safe_mode;
    1f38:	ef 81       	ldd	r30, Y+7	; 0x07
    1f3a:	f8 85       	ldd	r31, Y+8	; 0x08
    1f3c:	e1 5b       	subi	r30, 0xB1	; 177
    1f3e:	ff 4f       	sbci	r31, 0xFF	; 255
    1f40:	10 82       	st	Z, r1
  packet_payload[80] = 0x00;//charging;
    1f42:	ef 81       	ldd	r30, Y+7	; 0x07
    1f44:	f8 85       	ldd	r31, Y+8	; 0x08
    1f46:	e0 5b       	subi	r30, 0xB0	; 176
    1f48:	ff 4f       	sbci	r31, 0xFF	; 255
    1f4a:	10 82       	st	Z, r1
  packet_payload[81] = 0x00;//chargeforward;
    1f4c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f4e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f50:	ef 5a       	subi	r30, 0xAF	; 175
    1f52:	ff 4f       	sbci	r31, 0xFF	; 255
    1f54:	10 82       	st	Z, r1

  // temperature values (raw ADC output)
  packet_payload[82] = debug;//average_samples( svit[STAR_TRACKER].T_samples );
    1f56:	ef 81       	ldd	r30, Y+7	; 0x07
    1f58:	f8 85       	ldd	r31, Y+8	; 0x08
    1f5a:	ee 5a       	subi	r30, 0xAE	; 174
    1f5c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f5e:	90 91 57 07 	lds	r25, 0x0757
    1f62:	90 83       	st	Z, r25
  packet_payload[83] = 0xFF;//average_samples( svit[BATTERY_1].T_samples );
    1f64:	ef 81       	ldd	r30, Y+7	; 0x07
    1f66:	f8 85       	ldd	r31, Y+8	; 0x08
    1f68:	ed 5a       	subi	r30, 0xAD	; 173
    1f6a:	ff 4f       	sbci	r31, 0xFF	; 255
    1f6c:	80 83       	st	Z, r24
  packet_payload[84] = average_samples( svit[BATTERY_2].T_samples );
    1f6e:	88 ed       	ldi	r24, 0xD8	; 216
    1f70:	95 e0       	ldi	r25, 0x05	; 5
    1f72:	0e 94 3a 08 	call	0x1074	; 0x1074 <average_samples>
    1f76:	ef 81       	ldd	r30, Y+7	; 0x07
    1f78:	f8 85       	ldd	r31, Y+8	; 0x08
    1f7a:	ec 5a       	subi	r30, 0xAC	; 172
    1f7c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f7e:	80 83       	st	Z, r24
  packet_payload[85] = average_samples( svit[SOLAR_1].T_samples );
    1f80:	8c e0       	ldi	r24, 0x0C	; 12
    1f82:	96 e0       	ldi	r25, 0x06	; 6
    1f84:	0e 94 3a 08 	call	0x1074	; 0x1074 <average_samples>
    1f88:	ef 81       	ldd	r30, Y+7	; 0x07
    1f8a:	f8 85       	ldd	r31, Y+8	; 0x08
    1f8c:	eb 5a       	subi	r30, 0xAB	; 171
    1f8e:	ff 4f       	sbci	r31, 0xFF	; 255
    1f90:	80 83       	st	Z, r24
  packet_payload[86] = average_samples( svit[SOLAR_2].T_samples );
    1f92:	86 e2       	ldi	r24, 0x26	; 38
    1f94:	96 e0       	ldi	r25, 0x06	; 6
    1f96:	0e 94 3a 08 	call	0x1074	; 0x1074 <average_samples>
    1f9a:	ef 81       	ldd	r30, Y+7	; 0x07
    1f9c:	f8 85       	ldd	r31, Y+8	; 0x08
    1f9e:	ea 5a       	subi	r30, 0xAA	; 170
    1fa0:	ff 4f       	sbci	r31, 0xFF	; 255
    1fa2:	80 83       	st	Z, r24
  packet_payload[87] = average_samples( svit[SOLAR_3].T_samples );
    1fa4:	80 e4       	ldi	r24, 0x40	; 64
    1fa6:	96 e0       	ldi	r25, 0x06	; 6
    1fa8:	0e 94 3a 08 	call	0x1074	; 0x1074 <average_samples>
    1fac:	ef 81       	ldd	r30, Y+7	; 0x07
    1fae:	f8 85       	ldd	r31, Y+8	; 0x08
    1fb0:	e9 5a       	subi	r30, 0xA9	; 169
    1fb2:	ff 4f       	sbci	r31, 0xFF	; 255
    1fb4:	80 83       	st	Z, r24
  packet_payload[88] = average_samples( svit[SOLAR_4].T_samples );
    1fb6:	8a e5       	ldi	r24, 0x5A	; 90
    1fb8:	96 e0       	ldi	r25, 0x06	; 6
    1fba:	0e 94 3a 08 	call	0x1074	; 0x1074 <average_samples>
    1fbe:	ef 81       	ldd	r30, Y+7	; 0x07
    1fc0:	f8 85       	ldd	r31, Y+8	; 0x08
    1fc2:	e8 5a       	subi	r30, 0xA8	; 168
    1fc4:	ff 4f       	sbci	r31, 0xFF	; 255
    1fc6:	80 83       	st	Z, r24
  packet_payload[89] = average_samples( svit[SOLAR_5].T_samples );
    1fc8:	84 e7       	ldi	r24, 0x74	; 116
    1fca:	96 e0       	ldi	r25, 0x06	; 6
    1fcc:	0e 94 3a 08 	call	0x1074	; 0x1074 <average_samples>
    1fd0:	ef 81       	ldd	r30, Y+7	; 0x07
    1fd2:	f8 85       	ldd	r31, Y+8	; 0x08
    1fd4:	e7 5a       	subi	r30, 0xA7	; 167
    1fd6:	ff 4f       	sbci	r31, 0xFF	; 255
    1fd8:	80 83       	st	Z, r24
  packet_payload[90] = average_samples( svit[SOLAR_9].T_samples );
    1fda:	8c ed       	ldi	r24, 0xDC	; 220
    1fdc:	96 e0       	ldi	r25, 0x06	; 6
    1fde:	0e 94 3a 08 	call	0x1074	; 0x1074 <average_samples>
    1fe2:	ef 81       	ldd	r30, Y+7	; 0x07
    1fe4:	f8 85       	ldd	r31, Y+8	; 0x08
    1fe6:	e6 5a       	subi	r30, 0xA6	; 166
    1fe8:	ff 4f       	sbci	r31, 0xFF	; 255
    1fea:	80 83       	st	Z, r24
  packet_payload[91] = average_samples( svit[POWER_BOARD].T_samples );
    1fec:	84 e4       	ldi	r24, 0x44	; 68
    1fee:	97 e0       	ldi	r25, 0x07	; 7
    1ff0:	0e 94 3a 08 	call	0x1074	; 0x1074 <average_samples>
    1ff4:	ef 81       	ldd	r30, Y+7	; 0x07
    1ff6:	f8 85       	ldd	r31, Y+8	; 0x08
    1ff8:	e5 5a       	subi	r30, 0xA5	; 165
    1ffa:	ff 4f       	sbci	r31, 0xFF	; 255
    1ffc:	80 83       	st	Z, r24

uint8_t V_ack_change( void )
{
  uint8_t temp;

  temp = V_upper_val_change;
    1ffe:	80 91 9f 0b 	lds	r24, 0x0B9F
  V_upper_val_change = 0;
    2002:	10 92 9f 0b 	sts	0x0B9F, r1
  //uint8_t temperature_error1;
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
    2006:	ef 81       	ldd	r30, Y+7	; 0x07
    2008:	f8 85       	ldd	r31, Y+8	; 0x08
    200a:	e4 5a       	subi	r30, 0xA4	; 164
    200c:	ff 4f       	sbci	r31, 0xFF	; 255
    200e:	80 83       	st	Z, r24

uint8_t I_ack_change( void )
{
  uint8_t temp;

  temp = I_upper_val_change;
    2010:	80 91 9a 0b 	lds	r24, 0x0B9A
  I_upper_val_change = 0;
    2014:	10 92 9a 0b 	sts	0x0B9A, r1
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
  packet_payload[93] = I_ack_change();
    2018:	ef 81       	ldd	r30, Y+7	; 0x07
    201a:	f8 85       	ldd	r31, Y+8	; 0x08
    201c:	e3 5a       	subi	r30, 0xA3	; 163
    201e:	ff 4f       	sbci	r31, 0xFF	; 255
    2020:	80 83       	st	Z, r24
}
    2022:	28 96       	adiw	r28, 0x08	; 8
    2024:	0f b6       	in	r0, 0x3f	; 63
    2026:	f8 94       	cli
    2028:	de bf       	out	0x3e, r29	; 62
    202a:	0f be       	out	0x3f, r0	; 63
    202c:	cd bf       	out	0x3d, r28	; 61
    202e:	df 91       	pop	r29
    2030:	cf 91       	pop	r28
    2032:	1f 91       	pop	r17
    2034:	0f 91       	pop	r16
    2036:	ff 90       	pop	r15
    2038:	ef 90       	pop	r14
    203a:	df 90       	pop	r13
    203c:	cf 90       	pop	r12
    203e:	bf 90       	pop	r11
    2040:	af 90       	pop	r10
    2042:	9f 90       	pop	r9
    2044:	8f 90       	pop	r8
    2046:	7f 90       	pop	r7
    2048:	6f 90       	pop	r6
    204a:	5f 90       	pop	r5
    204c:	4f 90       	pop	r4
    204e:	3f 90       	pop	r3
    2050:	2f 90       	pop	r2
    2052:	08 95       	ret

00002054 <transmit_packet>:

void transmit_packet( uint8_t uart, uint8_t packet_type, uint8_t ack_command )
{
    2054:	6f 92       	push	r6
    2056:	7f 92       	push	r7
    2058:	8f 92       	push	r8
    205a:	9f 92       	push	r9
    205c:	bf 92       	push	r11
    205e:	cf 92       	push	r12
    2060:	df 92       	push	r13
    2062:	ef 92       	push	r14
    2064:	ff 92       	push	r15
    2066:	0f 93       	push	r16
    2068:	1f 93       	push	r17
    206a:	cf 93       	push	r28
    206c:	df 93       	push	r29
    206e:	b8 2e       	mov	r11, r24
  uint8_t VCP_tx_status;

  switch( packet_type )
    2070:	61 30       	cpi	r22, 0x01	; 1
    2072:	b9 f0       	breq	.+46     	; 0x20a2 <transmit_packet+0x4e>
    2074:	20 f0       	brcs	.+8      	; 0x207e <transmit_packet+0x2a>
    2076:	62 30       	cpi	r22, 0x02	; 2
    2078:	09 f0       	breq	.+2      	; 0x207c <transmit_packet+0x28>
    207a:	8b c0       	rjmp	.+278    	; 0x2192 <transmit_packet+0x13e>
    207c:	22 c0       	rjmp	.+68     	; 0x20c2 <transmit_packet+0x6e>
  {
    case VCP_POWER_TELEMETRY:
      construct_telemetry_packet( tel_packet_payload[uart] );
    207e:	c8 2f       	mov	r28, r24
    2080:	d0 e0       	ldi	r29, 0x00	; 0
    2082:	2f ef       	ldi	r18, 0xFF	; 255
    2084:	82 9f       	mul	r24, r18
    2086:	c0 01       	movw	r24, r0
    2088:	11 24       	eor	r1, r1
    208a:	83 53       	subi	r24, 0x33	; 51
    208c:	92 4f       	sbci	r25, 0xF2	; 242
    208e:	0e 94 93 0c 	call	0x1926	; 0x1926 <construct_telemetry_packet>
      tel_packet_payload_size[uart] = 96;
    2092:	fe 01       	movw	r30, r28
    2094:	ee 0f       	add	r30, r30
    2096:	ff 1f       	adc	r31, r31
    2098:	e7 5a       	subi	r30, 0xA7	; 167
    209a:	f8 4f       	sbci	r31, 0xF8	; 248
    209c:	80 e6       	ldi	r24, 0x60	; 96
    209e:	90 e0       	ldi	r25, 0x00	; 0
    20a0:	21 c0       	rjmp	.+66     	; 0x20e4 <transmit_packet+0x90>
      break;
    case VCP_INVALID_COMMAND:
      tel_packet_payload[uart][0] = VCP_INVALID_COMMAND;
    20a2:	e8 2f       	mov	r30, r24
    20a4:	f0 e0       	ldi	r31, 0x00	; 0
    20a6:	8f ef       	ldi	r24, 0xFF	; 255
    20a8:	b8 9e       	mul	r11, r24
    20aa:	d0 01       	movw	r26, r0
    20ac:	11 24       	eor	r1, r1
    20ae:	a3 53       	subi	r26, 0x33	; 51
    20b0:	b2 4f       	sbci	r27, 0xF2	; 242
    20b2:	6c 93       	st	X, r22
      tel_packet_payload_size[uart] = 1;
    20b4:	ee 0f       	add	r30, r30
    20b6:	ff 1f       	adc	r31, r31
    20b8:	e7 5a       	subi	r30, 0xA7	; 167
    20ba:	f8 4f       	sbci	r31, 0xF8	; 248
    20bc:	81 e0       	ldi	r24, 0x01	; 1
    20be:	90 e0       	ldi	r25, 0x00	; 0
    20c0:	11 c0       	rjmp	.+34     	; 0x20e4 <transmit_packet+0x90>
      break;
    case VCP_ACK:
      tel_packet_payload[uart][0] = VCP_ACK;
    20c2:	e8 2f       	mov	r30, r24
    20c4:	f0 e0       	ldi	r31, 0x00	; 0
    20c6:	2f ef       	ldi	r18, 0xFF	; 255
    20c8:	82 9f       	mul	r24, r18
    20ca:	d0 01       	movw	r26, r0
    20cc:	11 24       	eor	r1, r1
    20ce:	a3 53       	subi	r26, 0x33	; 51
    20d0:	b2 4f       	sbci	r27, 0xF2	; 242
    20d2:	6c 93       	st	X, r22
      tel_packet_payload[uart][1] = ack_command;
    20d4:	11 96       	adiw	r26, 0x01	; 1
    20d6:	4c 93       	st	X, r20
      tel_packet_payload_size[uart] = 2;
    20d8:	ee 0f       	add	r30, r30
    20da:	ff 1f       	adc	r31, r31
    20dc:	e7 5a       	subi	r30, 0xA7	; 167
    20de:	f8 4f       	sbci	r31, 0xF8	; 248
    20e0:	82 e0       	ldi	r24, 0x02	; 2
    20e2:	90 e0       	ldi	r25, 0x00	; 0
    20e4:	91 83       	std	Z+1, r25	; 0x01
    20e6:	80 83       	st	Z, r24
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    20e8:	8b 2c       	mov	r8, r11
    20ea:	91 2c       	mov	r9, r1
    20ec:	8f ef       	ldi	r24, 0xFF	; 255
    20ee:	b8 9e       	mul	r11, r24
    20f0:	70 01       	movw	r14, r0
    20f2:	11 24       	eor	r1, r1
    20f4:	e7 01       	movw	r28, r14
    20f6:	c6 56       	subi	r28, 0x66	; 102
    20f8:	d6 4f       	sbci	r29, 0xF6	; 246
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
    20fa:	64 01       	movw	r12, r8
    20fc:	cc 0c       	add	r12, r12
    20fe:	dd 1c       	adc	r13, r13
    2100:	f6 01       	movw	r30, r12
    2102:	e7 5a       	subi	r30, 0xA7	; 167
    2104:	f8 4f       	sbci	r31, 0xF8	; 248
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2106:	00 81       	ld	r16, Z
    2108:	11 81       	ldd	r17, Z+1	; 0x01
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
    210a:	97 01       	movw	r18, r14
    210c:	23 53       	subi	r18, 0x33	; 51
    210e:	32 4f       	sbci	r19, 0xF2	; 242
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2110:	a3 ea       	ldi	r26, 0xA3	; 163
    2112:	6a 2e       	mov	r6, r26
    2114:	ad e0       	ldi	r26, 0x0D	; 13
    2116:	7a 2e       	mov	r7, r26
    2118:	6c 0c       	add	r6, r12
    211a:	7d 1c       	adc	r7, r13
    211c:	41 e0       	ldi	r20, 0x01	; 1
    211e:	b3 01       	movw	r22, r6
    2120:	ce 01       	movw	r24, r28
    2122:	0e 94 bf 09 	call	0x137e	; 0x137e <Create_VCP_frame>
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
                  );

  // VCP frame creation was successful
  if ( VCP_tx_status == VCP_TERM )
    2126:	81 30       	cpi	r24, 0x01	; 1
    2128:	a1 f5       	brne	.+104    	; 0x2192 <transmit_packet+0x13e>
  {
    tel_packet_size[uart] = dest_size[uart];
    212a:	f3 01       	movw	r30, r6
    212c:	80 81       	ld	r24, Z
    212e:	91 81       	ldd	r25, Z+1	; 0x01
    2130:	f6 01       	movw	r30, r12
    2132:	ef 56       	subi	r30, 0x6F	; 111
    2134:	fc 4f       	sbci	r31, 0xFC	; 252
    2136:	91 83       	std	Z+1, r25	; 0x01
    2138:	80 83       	st	Z, r24
    memcpy( tel_packet[uart], dest_data[uart], tel_packet_size[uart] );
    213a:	80 81       	ld	r24, Z
    213c:	91 81       	ldd	r25, Z+1	; 0x01
    213e:	97 01       	movw	r18, r14
    2140:	28 59       	subi	r18, 0x98	; 152
    2142:	38 4f       	sbci	r19, 0xF8	; 248
    2144:	ac 01       	movw	r20, r24
    2146:	be 01       	movw	r22, r28
    2148:	c9 01       	movw	r24, r18
    214a:	0e 94 c0 13 	call	0x2780	; 0x2780 <memcpy>
    tel_packet_index[uart] = 0;
    214e:	f4 01       	movw	r30, r8
    2150:	ef 59       	subi	r30, 0x9F	; 159
    2152:	f8 4f       	sbci	r31, 0xF8	; 248
    2154:	10 82       	st	Z, r1
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
    2156:	f1 e0       	ldi	r31, 0x01	; 1
    2158:	bf 12       	cpse	r11, r31
    215a:	06 c0       	rjmp	.+12     	; 0x2168 <transmit_packet+0x114>
    215c:	80 91 9b 00 	lds	r24, 0x009B
    2160:	88 23       	and	r24, r24
    2162:	b9 f0       	breq	.+46     	; 0x2192 <transmit_packet+0x13e>
      tx_put_byte( uart );
    2164:	81 e0       	ldi	r24, 0x01	; 1
    2166:	06 c0       	rjmp	.+12     	; 0x2174 <transmit_packet+0x120>
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
    2168:	b1 10       	cpse	r11, r1
    216a:	13 c0       	rjmp	.+38     	; 0x2192 <transmit_packet+0x13e>
    216c:	8b b1       	in	r24, 0x0b	; 11
    216e:	88 23       	and	r24, r24
    2170:	81 f0       	breq	.+32     	; 0x2192 <transmit_packet+0x13e>
      tx_put_byte( uart );
    2172:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    2174:	df 91       	pop	r29
    2176:	cf 91       	pop	r28
    2178:	1f 91       	pop	r17
    217a:	0f 91       	pop	r16
    217c:	ff 90       	pop	r15
    217e:	ef 90       	pop	r14
    2180:	df 90       	pop	r13
    2182:	cf 90       	pop	r12
    2184:	bf 90       	pop	r11
    2186:	9f 90       	pop	r9
    2188:	8f 90       	pop	r8
    218a:	7f 90       	pop	r7
    218c:	6f 90       	pop	r6
    tel_packet_index[uart] = 0;
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    218e:	0c 94 8e 0c 	jmp	0x191c	; 0x191c <tx_put_byte>
  }
}
    2192:	df 91       	pop	r29
    2194:	cf 91       	pop	r28
    2196:	1f 91       	pop	r17
    2198:	0f 91       	pop	r16
    219a:	ff 90       	pop	r15
    219c:	ef 90       	pop	r14
    219e:	df 90       	pop	r13
    21a0:	cf 90       	pop	r12
    21a2:	bf 90       	pop	r11
    21a4:	9f 90       	pop	r9
    21a6:	8f 90       	pop	r8
    21a8:	7f 90       	pop	r7
    21aa:	6f 90       	pop	r6
    21ac:	08 95       	ret

000021ae <__subsf3>:
    21ae:	50 58       	subi	r21, 0x80	; 128

000021b0 <__addsf3>:
    21b0:	bb 27       	eor	r27, r27
    21b2:	aa 27       	eor	r26, r26
    21b4:	0e d0       	rcall	.+28     	; 0x21d2 <__addsf3x>
    21b6:	44 c1       	rjmp	.+648    	; 0x2440 <__fp_round>
    21b8:	35 d1       	rcall	.+618    	; 0x2424 <__fp_pscA>
    21ba:	30 f0       	brcs	.+12     	; 0x21c8 <__addsf3+0x18>
    21bc:	3a d1       	rcall	.+628    	; 0x2432 <__fp_pscB>
    21be:	20 f0       	brcs	.+8      	; 0x21c8 <__addsf3+0x18>
    21c0:	31 f4       	brne	.+12     	; 0x21ce <__addsf3+0x1e>
    21c2:	9f 3f       	cpi	r25, 0xFF	; 255
    21c4:	11 f4       	brne	.+4      	; 0x21ca <__addsf3+0x1a>
    21c6:	1e f4       	brtc	.+6      	; 0x21ce <__addsf3+0x1e>
    21c8:	2a c1       	rjmp	.+596    	; 0x241e <__fp_nan>
    21ca:	0e f4       	brtc	.+2      	; 0x21ce <__addsf3+0x1e>
    21cc:	e0 95       	com	r30
    21ce:	e7 fb       	bst	r30, 7
    21d0:	20 c1       	rjmp	.+576    	; 0x2412 <__fp_inf>

000021d2 <__addsf3x>:
    21d2:	e9 2f       	mov	r30, r25
    21d4:	46 d1       	rcall	.+652    	; 0x2462 <__fp_split3>
    21d6:	80 f3       	brcs	.-32     	; 0x21b8 <__addsf3+0x8>
    21d8:	ba 17       	cp	r27, r26
    21da:	62 07       	cpc	r22, r18
    21dc:	73 07       	cpc	r23, r19
    21de:	84 07       	cpc	r24, r20
    21e0:	95 07       	cpc	r25, r21
    21e2:	18 f0       	brcs	.+6      	; 0x21ea <__addsf3x+0x18>
    21e4:	71 f4       	brne	.+28     	; 0x2202 <__addsf3x+0x30>
    21e6:	9e f5       	brtc	.+102    	; 0x224e <__addsf3x+0x7c>
    21e8:	5e c1       	rjmp	.+700    	; 0x24a6 <__fp_zero>
    21ea:	0e f4       	brtc	.+2      	; 0x21ee <__addsf3x+0x1c>
    21ec:	e0 95       	com	r30
    21ee:	0b 2e       	mov	r0, r27
    21f0:	ba 2f       	mov	r27, r26
    21f2:	a0 2d       	mov	r26, r0
    21f4:	0b 01       	movw	r0, r22
    21f6:	b9 01       	movw	r22, r18
    21f8:	90 01       	movw	r18, r0
    21fa:	0c 01       	movw	r0, r24
    21fc:	ca 01       	movw	r24, r20
    21fe:	a0 01       	movw	r20, r0
    2200:	11 24       	eor	r1, r1
    2202:	ff 27       	eor	r31, r31
    2204:	59 1b       	sub	r21, r25
    2206:	99 f0       	breq	.+38     	; 0x222e <__addsf3x+0x5c>
    2208:	59 3f       	cpi	r21, 0xF9	; 249
    220a:	50 f4       	brcc	.+20     	; 0x2220 <__addsf3x+0x4e>
    220c:	50 3e       	cpi	r21, 0xE0	; 224
    220e:	68 f1       	brcs	.+90     	; 0x226a <__addsf3x+0x98>
    2210:	1a 16       	cp	r1, r26
    2212:	f0 40       	sbci	r31, 0x00	; 0
    2214:	a2 2f       	mov	r26, r18
    2216:	23 2f       	mov	r18, r19
    2218:	34 2f       	mov	r19, r20
    221a:	44 27       	eor	r20, r20
    221c:	58 5f       	subi	r21, 0xF8	; 248
    221e:	f3 cf       	rjmp	.-26     	; 0x2206 <__addsf3x+0x34>
    2220:	46 95       	lsr	r20
    2222:	37 95       	ror	r19
    2224:	27 95       	ror	r18
    2226:	a7 95       	ror	r26
    2228:	f0 40       	sbci	r31, 0x00	; 0
    222a:	53 95       	inc	r21
    222c:	c9 f7       	brne	.-14     	; 0x2220 <__addsf3x+0x4e>
    222e:	7e f4       	brtc	.+30     	; 0x224e <__addsf3x+0x7c>
    2230:	1f 16       	cp	r1, r31
    2232:	ba 0b       	sbc	r27, r26
    2234:	62 0b       	sbc	r22, r18
    2236:	73 0b       	sbc	r23, r19
    2238:	84 0b       	sbc	r24, r20
    223a:	ba f0       	brmi	.+46     	; 0x226a <__addsf3x+0x98>
    223c:	91 50       	subi	r25, 0x01	; 1
    223e:	a1 f0       	breq	.+40     	; 0x2268 <__addsf3x+0x96>
    2240:	ff 0f       	add	r31, r31
    2242:	bb 1f       	adc	r27, r27
    2244:	66 1f       	adc	r22, r22
    2246:	77 1f       	adc	r23, r23
    2248:	88 1f       	adc	r24, r24
    224a:	c2 f7       	brpl	.-16     	; 0x223c <__addsf3x+0x6a>
    224c:	0e c0       	rjmp	.+28     	; 0x226a <__addsf3x+0x98>
    224e:	ba 0f       	add	r27, r26
    2250:	62 1f       	adc	r22, r18
    2252:	73 1f       	adc	r23, r19
    2254:	84 1f       	adc	r24, r20
    2256:	48 f4       	brcc	.+18     	; 0x226a <__addsf3x+0x98>
    2258:	87 95       	ror	r24
    225a:	77 95       	ror	r23
    225c:	67 95       	ror	r22
    225e:	b7 95       	ror	r27
    2260:	f7 95       	ror	r31
    2262:	9e 3f       	cpi	r25, 0xFE	; 254
    2264:	08 f0       	brcs	.+2      	; 0x2268 <__addsf3x+0x96>
    2266:	b3 cf       	rjmp	.-154    	; 0x21ce <__addsf3+0x1e>
    2268:	93 95       	inc	r25
    226a:	88 0f       	add	r24, r24
    226c:	08 f0       	brcs	.+2      	; 0x2270 <__addsf3x+0x9e>
    226e:	99 27       	eor	r25, r25
    2270:	ee 0f       	add	r30, r30
    2272:	97 95       	ror	r25
    2274:	87 95       	ror	r24
    2276:	08 95       	ret

00002278 <__cmpsf2>:
    2278:	a8 d0       	rcall	.+336    	; 0x23ca <__fp_cmp>
    227a:	08 f4       	brcc	.+2      	; 0x227e <__cmpsf2+0x6>
    227c:	81 e0       	ldi	r24, 0x01	; 1
    227e:	08 95       	ret

00002280 <__divsf3>:
    2280:	0c d0       	rcall	.+24     	; 0x229a <__divsf3x>
    2282:	de c0       	rjmp	.+444    	; 0x2440 <__fp_round>
    2284:	d6 d0       	rcall	.+428    	; 0x2432 <__fp_pscB>
    2286:	40 f0       	brcs	.+16     	; 0x2298 <__divsf3+0x18>
    2288:	cd d0       	rcall	.+410    	; 0x2424 <__fp_pscA>
    228a:	30 f0       	brcs	.+12     	; 0x2298 <__divsf3+0x18>
    228c:	21 f4       	brne	.+8      	; 0x2296 <__divsf3+0x16>
    228e:	5f 3f       	cpi	r21, 0xFF	; 255
    2290:	19 f0       	breq	.+6      	; 0x2298 <__divsf3+0x18>
    2292:	bf c0       	rjmp	.+382    	; 0x2412 <__fp_inf>
    2294:	51 11       	cpse	r21, r1
    2296:	08 c1       	rjmp	.+528    	; 0x24a8 <__fp_szero>
    2298:	c2 c0       	rjmp	.+388    	; 0x241e <__fp_nan>

0000229a <__divsf3x>:
    229a:	e3 d0       	rcall	.+454    	; 0x2462 <__fp_split3>
    229c:	98 f3       	brcs	.-26     	; 0x2284 <__divsf3+0x4>

0000229e <__divsf3_pse>:
    229e:	99 23       	and	r25, r25
    22a0:	c9 f3       	breq	.-14     	; 0x2294 <__divsf3+0x14>
    22a2:	55 23       	and	r21, r21
    22a4:	b1 f3       	breq	.-20     	; 0x2292 <__divsf3+0x12>
    22a6:	95 1b       	sub	r25, r21
    22a8:	55 0b       	sbc	r21, r21
    22aa:	bb 27       	eor	r27, r27
    22ac:	aa 27       	eor	r26, r26
    22ae:	62 17       	cp	r22, r18
    22b0:	73 07       	cpc	r23, r19
    22b2:	84 07       	cpc	r24, r20
    22b4:	38 f0       	brcs	.+14     	; 0x22c4 <__divsf3_pse+0x26>
    22b6:	9f 5f       	subi	r25, 0xFF	; 255
    22b8:	5f 4f       	sbci	r21, 0xFF	; 255
    22ba:	22 0f       	add	r18, r18
    22bc:	33 1f       	adc	r19, r19
    22be:	44 1f       	adc	r20, r20
    22c0:	aa 1f       	adc	r26, r26
    22c2:	a9 f3       	breq	.-22     	; 0x22ae <__divsf3_pse+0x10>
    22c4:	33 d0       	rcall	.+102    	; 0x232c <__divsf3_pse+0x8e>
    22c6:	0e 2e       	mov	r0, r30
    22c8:	3a f0       	brmi	.+14     	; 0x22d8 <__divsf3_pse+0x3a>
    22ca:	e0 e8       	ldi	r30, 0x80	; 128
    22cc:	30 d0       	rcall	.+96     	; 0x232e <__divsf3_pse+0x90>
    22ce:	91 50       	subi	r25, 0x01	; 1
    22d0:	50 40       	sbci	r21, 0x00	; 0
    22d2:	e6 95       	lsr	r30
    22d4:	00 1c       	adc	r0, r0
    22d6:	ca f7       	brpl	.-14     	; 0x22ca <__divsf3_pse+0x2c>
    22d8:	29 d0       	rcall	.+82     	; 0x232c <__divsf3_pse+0x8e>
    22da:	fe 2f       	mov	r31, r30
    22dc:	27 d0       	rcall	.+78     	; 0x232c <__divsf3_pse+0x8e>
    22de:	66 0f       	add	r22, r22
    22e0:	77 1f       	adc	r23, r23
    22e2:	88 1f       	adc	r24, r24
    22e4:	bb 1f       	adc	r27, r27
    22e6:	26 17       	cp	r18, r22
    22e8:	37 07       	cpc	r19, r23
    22ea:	48 07       	cpc	r20, r24
    22ec:	ab 07       	cpc	r26, r27
    22ee:	b0 e8       	ldi	r27, 0x80	; 128
    22f0:	09 f0       	breq	.+2      	; 0x22f4 <__divsf3_pse+0x56>
    22f2:	bb 0b       	sbc	r27, r27
    22f4:	80 2d       	mov	r24, r0
    22f6:	bf 01       	movw	r22, r30
    22f8:	ff 27       	eor	r31, r31
    22fa:	93 58       	subi	r25, 0x83	; 131
    22fc:	5f 4f       	sbci	r21, 0xFF	; 255
    22fe:	2a f0       	brmi	.+10     	; 0x230a <__divsf3_pse+0x6c>
    2300:	9e 3f       	cpi	r25, 0xFE	; 254
    2302:	51 05       	cpc	r21, r1
    2304:	68 f0       	brcs	.+26     	; 0x2320 <__divsf3_pse+0x82>
    2306:	85 c0       	rjmp	.+266    	; 0x2412 <__fp_inf>
    2308:	cf c0       	rjmp	.+414    	; 0x24a8 <__fp_szero>
    230a:	5f 3f       	cpi	r21, 0xFF	; 255
    230c:	ec f3       	brlt	.-6      	; 0x2308 <__divsf3_pse+0x6a>
    230e:	98 3e       	cpi	r25, 0xE8	; 232
    2310:	dc f3       	brlt	.-10     	; 0x2308 <__divsf3_pse+0x6a>
    2312:	86 95       	lsr	r24
    2314:	77 95       	ror	r23
    2316:	67 95       	ror	r22
    2318:	b7 95       	ror	r27
    231a:	f7 95       	ror	r31
    231c:	9f 5f       	subi	r25, 0xFF	; 255
    231e:	c9 f7       	brne	.-14     	; 0x2312 <__divsf3_pse+0x74>
    2320:	88 0f       	add	r24, r24
    2322:	91 1d       	adc	r25, r1
    2324:	96 95       	lsr	r25
    2326:	87 95       	ror	r24
    2328:	97 f9       	bld	r25, 7
    232a:	08 95       	ret
    232c:	e1 e0       	ldi	r30, 0x01	; 1
    232e:	66 0f       	add	r22, r22
    2330:	77 1f       	adc	r23, r23
    2332:	88 1f       	adc	r24, r24
    2334:	bb 1f       	adc	r27, r27
    2336:	62 17       	cp	r22, r18
    2338:	73 07       	cpc	r23, r19
    233a:	84 07       	cpc	r24, r20
    233c:	ba 07       	cpc	r27, r26
    233e:	20 f0       	brcs	.+8      	; 0x2348 <__divsf3_pse+0xaa>
    2340:	62 1b       	sub	r22, r18
    2342:	73 0b       	sbc	r23, r19
    2344:	84 0b       	sbc	r24, r20
    2346:	ba 0b       	sbc	r27, r26
    2348:	ee 1f       	adc	r30, r30
    234a:	88 f7       	brcc	.-30     	; 0x232e <__divsf3_pse+0x90>
    234c:	e0 95       	com	r30
    234e:	08 95       	ret

00002350 <__floatunsisf>:
    2350:	e8 94       	clt
    2352:	09 c0       	rjmp	.+18     	; 0x2366 <__floatsisf+0x12>

00002354 <__floatsisf>:
    2354:	97 fb       	bst	r25, 7
    2356:	3e f4       	brtc	.+14     	; 0x2366 <__floatsisf+0x12>
    2358:	90 95       	com	r25
    235a:	80 95       	com	r24
    235c:	70 95       	com	r23
    235e:	61 95       	neg	r22
    2360:	7f 4f       	sbci	r23, 0xFF	; 255
    2362:	8f 4f       	sbci	r24, 0xFF	; 255
    2364:	9f 4f       	sbci	r25, 0xFF	; 255
    2366:	99 23       	and	r25, r25
    2368:	a9 f0       	breq	.+42     	; 0x2394 <__floatsisf+0x40>
    236a:	f9 2f       	mov	r31, r25
    236c:	96 e9       	ldi	r25, 0x96	; 150
    236e:	bb 27       	eor	r27, r27
    2370:	93 95       	inc	r25
    2372:	f6 95       	lsr	r31
    2374:	87 95       	ror	r24
    2376:	77 95       	ror	r23
    2378:	67 95       	ror	r22
    237a:	b7 95       	ror	r27
    237c:	f1 11       	cpse	r31, r1
    237e:	f8 cf       	rjmp	.-16     	; 0x2370 <__floatsisf+0x1c>
    2380:	fa f4       	brpl	.+62     	; 0x23c0 <__floatsisf+0x6c>
    2382:	bb 0f       	add	r27, r27
    2384:	11 f4       	brne	.+4      	; 0x238a <__floatsisf+0x36>
    2386:	60 ff       	sbrs	r22, 0
    2388:	1b c0       	rjmp	.+54     	; 0x23c0 <__floatsisf+0x6c>
    238a:	6f 5f       	subi	r22, 0xFF	; 255
    238c:	7f 4f       	sbci	r23, 0xFF	; 255
    238e:	8f 4f       	sbci	r24, 0xFF	; 255
    2390:	9f 4f       	sbci	r25, 0xFF	; 255
    2392:	16 c0       	rjmp	.+44     	; 0x23c0 <__floatsisf+0x6c>
    2394:	88 23       	and	r24, r24
    2396:	11 f0       	breq	.+4      	; 0x239c <__floatsisf+0x48>
    2398:	96 e9       	ldi	r25, 0x96	; 150
    239a:	11 c0       	rjmp	.+34     	; 0x23be <__floatsisf+0x6a>
    239c:	77 23       	and	r23, r23
    239e:	21 f0       	breq	.+8      	; 0x23a8 <__floatsisf+0x54>
    23a0:	9e e8       	ldi	r25, 0x8E	; 142
    23a2:	87 2f       	mov	r24, r23
    23a4:	76 2f       	mov	r23, r22
    23a6:	05 c0       	rjmp	.+10     	; 0x23b2 <__floatsisf+0x5e>
    23a8:	66 23       	and	r22, r22
    23aa:	71 f0       	breq	.+28     	; 0x23c8 <__floatsisf+0x74>
    23ac:	96 e8       	ldi	r25, 0x86	; 134
    23ae:	86 2f       	mov	r24, r22
    23b0:	70 e0       	ldi	r23, 0x00	; 0
    23b2:	60 e0       	ldi	r22, 0x00	; 0
    23b4:	2a f0       	brmi	.+10     	; 0x23c0 <__floatsisf+0x6c>
    23b6:	9a 95       	dec	r25
    23b8:	66 0f       	add	r22, r22
    23ba:	77 1f       	adc	r23, r23
    23bc:	88 1f       	adc	r24, r24
    23be:	da f7       	brpl	.-10     	; 0x23b6 <__floatsisf+0x62>
    23c0:	88 0f       	add	r24, r24
    23c2:	96 95       	lsr	r25
    23c4:	87 95       	ror	r24
    23c6:	97 f9       	bld	r25, 7
    23c8:	08 95       	ret

000023ca <__fp_cmp>:
    23ca:	99 0f       	add	r25, r25
    23cc:	00 08       	sbc	r0, r0
    23ce:	55 0f       	add	r21, r21
    23d0:	aa 0b       	sbc	r26, r26
    23d2:	e0 e8       	ldi	r30, 0x80	; 128
    23d4:	fe ef       	ldi	r31, 0xFE	; 254
    23d6:	16 16       	cp	r1, r22
    23d8:	17 06       	cpc	r1, r23
    23da:	e8 07       	cpc	r30, r24
    23dc:	f9 07       	cpc	r31, r25
    23de:	c0 f0       	brcs	.+48     	; 0x2410 <__fp_cmp+0x46>
    23e0:	12 16       	cp	r1, r18
    23e2:	13 06       	cpc	r1, r19
    23e4:	e4 07       	cpc	r30, r20
    23e6:	f5 07       	cpc	r31, r21
    23e8:	98 f0       	brcs	.+38     	; 0x2410 <__fp_cmp+0x46>
    23ea:	62 1b       	sub	r22, r18
    23ec:	73 0b       	sbc	r23, r19
    23ee:	84 0b       	sbc	r24, r20
    23f0:	95 0b       	sbc	r25, r21
    23f2:	39 f4       	brne	.+14     	; 0x2402 <__fp_cmp+0x38>
    23f4:	0a 26       	eor	r0, r26
    23f6:	61 f0       	breq	.+24     	; 0x2410 <__fp_cmp+0x46>
    23f8:	23 2b       	or	r18, r19
    23fa:	24 2b       	or	r18, r20
    23fc:	25 2b       	or	r18, r21
    23fe:	21 f4       	brne	.+8      	; 0x2408 <__fp_cmp+0x3e>
    2400:	08 95       	ret
    2402:	0a 26       	eor	r0, r26
    2404:	09 f4       	brne	.+2      	; 0x2408 <__fp_cmp+0x3e>
    2406:	a1 40       	sbci	r26, 0x01	; 1
    2408:	a6 95       	lsr	r26
    240a:	8f ef       	ldi	r24, 0xFF	; 255
    240c:	81 1d       	adc	r24, r1
    240e:	81 1d       	adc	r24, r1
    2410:	08 95       	ret

00002412 <__fp_inf>:
    2412:	97 f9       	bld	r25, 7
    2414:	9f 67       	ori	r25, 0x7F	; 127
    2416:	80 e8       	ldi	r24, 0x80	; 128
    2418:	70 e0       	ldi	r23, 0x00	; 0
    241a:	60 e0       	ldi	r22, 0x00	; 0
    241c:	08 95       	ret

0000241e <__fp_nan>:
    241e:	9f ef       	ldi	r25, 0xFF	; 255
    2420:	80 ec       	ldi	r24, 0xC0	; 192
    2422:	08 95       	ret

00002424 <__fp_pscA>:
    2424:	00 24       	eor	r0, r0
    2426:	0a 94       	dec	r0
    2428:	16 16       	cp	r1, r22
    242a:	17 06       	cpc	r1, r23
    242c:	18 06       	cpc	r1, r24
    242e:	09 06       	cpc	r0, r25
    2430:	08 95       	ret

00002432 <__fp_pscB>:
    2432:	00 24       	eor	r0, r0
    2434:	0a 94       	dec	r0
    2436:	12 16       	cp	r1, r18
    2438:	13 06       	cpc	r1, r19
    243a:	14 06       	cpc	r1, r20
    243c:	05 06       	cpc	r0, r21
    243e:	08 95       	ret

00002440 <__fp_round>:
    2440:	09 2e       	mov	r0, r25
    2442:	03 94       	inc	r0
    2444:	00 0c       	add	r0, r0
    2446:	11 f4       	brne	.+4      	; 0x244c <__fp_round+0xc>
    2448:	88 23       	and	r24, r24
    244a:	52 f0       	brmi	.+20     	; 0x2460 <__fp_round+0x20>
    244c:	bb 0f       	add	r27, r27
    244e:	40 f4       	brcc	.+16     	; 0x2460 <__fp_round+0x20>
    2450:	bf 2b       	or	r27, r31
    2452:	11 f4       	brne	.+4      	; 0x2458 <__fp_round+0x18>
    2454:	60 ff       	sbrs	r22, 0
    2456:	04 c0       	rjmp	.+8      	; 0x2460 <__fp_round+0x20>
    2458:	6f 5f       	subi	r22, 0xFF	; 255
    245a:	7f 4f       	sbci	r23, 0xFF	; 255
    245c:	8f 4f       	sbci	r24, 0xFF	; 255
    245e:	9f 4f       	sbci	r25, 0xFF	; 255
    2460:	08 95       	ret

00002462 <__fp_split3>:
    2462:	57 fd       	sbrc	r21, 7
    2464:	90 58       	subi	r25, 0x80	; 128
    2466:	44 0f       	add	r20, r20
    2468:	55 1f       	adc	r21, r21
    246a:	59 f0       	breq	.+22     	; 0x2482 <__fp_splitA+0x10>
    246c:	5f 3f       	cpi	r21, 0xFF	; 255
    246e:	71 f0       	breq	.+28     	; 0x248c <__fp_splitA+0x1a>
    2470:	47 95       	ror	r20

00002472 <__fp_splitA>:
    2472:	88 0f       	add	r24, r24
    2474:	97 fb       	bst	r25, 7
    2476:	99 1f       	adc	r25, r25
    2478:	61 f0       	breq	.+24     	; 0x2492 <__fp_splitA+0x20>
    247a:	9f 3f       	cpi	r25, 0xFF	; 255
    247c:	79 f0       	breq	.+30     	; 0x249c <__fp_splitA+0x2a>
    247e:	87 95       	ror	r24
    2480:	08 95       	ret
    2482:	12 16       	cp	r1, r18
    2484:	13 06       	cpc	r1, r19
    2486:	14 06       	cpc	r1, r20
    2488:	55 1f       	adc	r21, r21
    248a:	f2 cf       	rjmp	.-28     	; 0x2470 <__fp_split3+0xe>
    248c:	46 95       	lsr	r20
    248e:	f1 df       	rcall	.-30     	; 0x2472 <__fp_splitA>
    2490:	08 c0       	rjmp	.+16     	; 0x24a2 <__fp_splitA+0x30>
    2492:	16 16       	cp	r1, r22
    2494:	17 06       	cpc	r1, r23
    2496:	18 06       	cpc	r1, r24
    2498:	99 1f       	adc	r25, r25
    249a:	f1 cf       	rjmp	.-30     	; 0x247e <__fp_splitA+0xc>
    249c:	86 95       	lsr	r24
    249e:	71 05       	cpc	r23, r1
    24a0:	61 05       	cpc	r22, r1
    24a2:	08 94       	sec
    24a4:	08 95       	ret

000024a6 <__fp_zero>:
    24a6:	e8 94       	clt

000024a8 <__fp_szero>:
    24a8:	bb 27       	eor	r27, r27
    24aa:	66 27       	eor	r22, r22
    24ac:	77 27       	eor	r23, r23
    24ae:	cb 01       	movw	r24, r22
    24b0:	97 f9       	bld	r25, 7
    24b2:	08 95       	ret

000024b4 <__gesf2>:
    24b4:	8a df       	rcall	.-236    	; 0x23ca <__fp_cmp>
    24b6:	08 f4       	brcc	.+2      	; 0x24ba <__gesf2+0x6>
    24b8:	8f ef       	ldi	r24, 0xFF	; 255
    24ba:	08 95       	ret

000024bc <__udivmodhi4>:
    24bc:	aa 1b       	sub	r26, r26
    24be:	bb 1b       	sub	r27, r27
    24c0:	51 e1       	ldi	r21, 0x11	; 17
    24c2:	07 c0       	rjmp	.+14     	; 0x24d2 <__udivmodhi4_ep>

000024c4 <__udivmodhi4_loop>:
    24c4:	aa 1f       	adc	r26, r26
    24c6:	bb 1f       	adc	r27, r27
    24c8:	a6 17       	cp	r26, r22
    24ca:	b7 07       	cpc	r27, r23
    24cc:	10 f0       	brcs	.+4      	; 0x24d2 <__udivmodhi4_ep>
    24ce:	a6 1b       	sub	r26, r22
    24d0:	b7 0b       	sbc	r27, r23

000024d2 <__udivmodhi4_ep>:
    24d2:	88 1f       	adc	r24, r24
    24d4:	99 1f       	adc	r25, r25
    24d6:	5a 95       	dec	r21
    24d8:	a9 f7       	brne	.-22     	; 0x24c4 <__udivmodhi4_loop>
    24da:	80 95       	com	r24
    24dc:	90 95       	com	r25
    24de:	bc 01       	movw	r22, r24
    24e0:	cd 01       	movw	r24, r26
    24e2:	08 95       	ret

000024e4 <__divmodhi4>:
    24e4:	97 fb       	bst	r25, 7
    24e6:	07 2e       	mov	r0, r23
    24e8:	16 f4       	brtc	.+4      	; 0x24ee <__divmodhi4+0xa>
    24ea:	00 94       	com	r0
    24ec:	07 d0       	rcall	.+14     	; 0x24fc <__divmodhi4_neg1>
    24ee:	77 fd       	sbrc	r23, 7
    24f0:	09 d0       	rcall	.+18     	; 0x2504 <__divmodhi4_neg2>
    24f2:	0e 94 5e 12 	call	0x24bc	; 0x24bc <__udivmodhi4>
    24f6:	07 fc       	sbrc	r0, 7
    24f8:	05 d0       	rcall	.+10     	; 0x2504 <__divmodhi4_neg2>
    24fa:	3e f4       	brtc	.+14     	; 0x250a <__divmodhi4_exit>

000024fc <__divmodhi4_neg1>:
    24fc:	90 95       	com	r25
    24fe:	81 95       	neg	r24
    2500:	9f 4f       	sbci	r25, 0xFF	; 255
    2502:	08 95       	ret

00002504 <__divmodhi4_neg2>:
    2504:	70 95       	com	r23
    2506:	61 95       	neg	r22
    2508:	7f 4f       	sbci	r23, 0xFF	; 255

0000250a <__divmodhi4_exit>:
    250a:	08 95       	ret

0000250c <malloc>:
    250c:	0f 93       	push	r16
    250e:	1f 93       	push	r17
    2510:	cf 93       	push	r28
    2512:	df 93       	push	r29
    2514:	82 30       	cpi	r24, 0x02	; 2
    2516:	91 05       	cpc	r25, r1
    2518:	10 f4       	brcc	.+4      	; 0x251e <malloc+0x12>
    251a:	82 e0       	ldi	r24, 0x02	; 2
    251c:	90 e0       	ldi	r25, 0x00	; 0
    251e:	e0 91 ce 0f 	lds	r30, 0x0FCE
    2522:	f0 91 cf 0f 	lds	r31, 0x0FCF
    2526:	20 e0       	ldi	r18, 0x00	; 0
    2528:	30 e0       	ldi	r19, 0x00	; 0
    252a:	c0 e0       	ldi	r28, 0x00	; 0
    252c:	d0 e0       	ldi	r29, 0x00	; 0
    252e:	23 c0       	rjmp	.+70     	; 0x2576 <malloc+0x6a>
    2530:	40 81       	ld	r20, Z
    2532:	51 81       	ldd	r21, Z+1	; 0x01
    2534:	48 17       	cp	r20, r24
    2536:	59 07       	cpc	r21, r25
    2538:	a8 f0       	brcs	.+42     	; 0x2564 <malloc+0x58>
    253a:	48 17       	cp	r20, r24
    253c:	59 07       	cpc	r21, r25
    253e:	61 f4       	brne	.+24     	; 0x2558 <malloc+0x4c>
    2540:	82 81       	ldd	r24, Z+2	; 0x02
    2542:	93 81       	ldd	r25, Z+3	; 0x03
    2544:	20 97       	sbiw	r28, 0x00	; 0
    2546:	19 f0       	breq	.+6      	; 0x254e <malloc+0x42>
    2548:	9b 83       	std	Y+3, r25	; 0x03
    254a:	8a 83       	std	Y+2, r24	; 0x02
    254c:	2e c0       	rjmp	.+92     	; 0x25aa <malloc+0x9e>
    254e:	90 93 cf 0f 	sts	0x0FCF, r25
    2552:	80 93 ce 0f 	sts	0x0FCE, r24
    2556:	29 c0       	rjmp	.+82     	; 0x25aa <malloc+0x9e>
    2558:	21 15       	cp	r18, r1
    255a:	31 05       	cpc	r19, r1
    255c:	29 f0       	breq	.+10     	; 0x2568 <malloc+0x5c>
    255e:	42 17       	cp	r20, r18
    2560:	53 07       	cpc	r21, r19
    2562:	10 f0       	brcs	.+4      	; 0x2568 <malloc+0x5c>
    2564:	a9 01       	movw	r20, r18
    2566:	02 c0       	rjmp	.+4      	; 0x256c <malloc+0x60>
    2568:	be 01       	movw	r22, r28
    256a:	df 01       	movw	r26, r30
    256c:	02 81       	ldd	r16, Z+2	; 0x02
    256e:	13 81       	ldd	r17, Z+3	; 0x03
    2570:	ef 01       	movw	r28, r30
    2572:	9a 01       	movw	r18, r20
    2574:	f8 01       	movw	r30, r16
    2576:	30 97       	sbiw	r30, 0x00	; 0
    2578:	d9 f6       	brne	.-74     	; 0x2530 <malloc+0x24>
    257a:	21 15       	cp	r18, r1
    257c:	31 05       	cpc	r19, r1
    257e:	09 f1       	breq	.+66     	; 0x25c2 <malloc+0xb6>
    2580:	28 1b       	sub	r18, r24
    2582:	39 0b       	sbc	r19, r25
    2584:	24 30       	cpi	r18, 0x04	; 4
    2586:	31 05       	cpc	r19, r1
    2588:	90 f4       	brcc	.+36     	; 0x25ae <malloc+0xa2>
    258a:	12 96       	adiw	r26, 0x02	; 2
    258c:	8d 91       	ld	r24, X+
    258e:	9c 91       	ld	r25, X
    2590:	13 97       	sbiw	r26, 0x03	; 3
    2592:	61 15       	cp	r22, r1
    2594:	71 05       	cpc	r23, r1
    2596:	21 f0       	breq	.+8      	; 0x25a0 <malloc+0x94>
    2598:	fb 01       	movw	r30, r22
    259a:	93 83       	std	Z+3, r25	; 0x03
    259c:	82 83       	std	Z+2, r24	; 0x02
    259e:	04 c0       	rjmp	.+8      	; 0x25a8 <malloc+0x9c>
    25a0:	90 93 cf 0f 	sts	0x0FCF, r25
    25a4:	80 93 ce 0f 	sts	0x0FCE, r24
    25a8:	fd 01       	movw	r30, r26
    25aa:	32 96       	adiw	r30, 0x02	; 2
    25ac:	44 c0       	rjmp	.+136    	; 0x2636 <malloc+0x12a>
    25ae:	fd 01       	movw	r30, r26
    25b0:	e2 0f       	add	r30, r18
    25b2:	f3 1f       	adc	r31, r19
    25b4:	81 93       	st	Z+, r24
    25b6:	91 93       	st	Z+, r25
    25b8:	22 50       	subi	r18, 0x02	; 2
    25ba:	31 09       	sbc	r19, r1
    25bc:	2d 93       	st	X+, r18
    25be:	3c 93       	st	X, r19
    25c0:	3a c0       	rjmp	.+116    	; 0x2636 <malloc+0x12a>
    25c2:	20 91 cc 0f 	lds	r18, 0x0FCC
    25c6:	30 91 cd 0f 	lds	r19, 0x0FCD
    25ca:	23 2b       	or	r18, r19
    25cc:	41 f4       	brne	.+16     	; 0x25de <malloc+0xd2>
    25ce:	20 91 02 01 	lds	r18, 0x0102
    25d2:	30 91 03 01 	lds	r19, 0x0103
    25d6:	30 93 cd 0f 	sts	0x0FCD, r19
    25da:	20 93 cc 0f 	sts	0x0FCC, r18
    25de:	20 91 00 01 	lds	r18, 0x0100
    25e2:	30 91 01 01 	lds	r19, 0x0101
    25e6:	21 15       	cp	r18, r1
    25e8:	31 05       	cpc	r19, r1
    25ea:	41 f4       	brne	.+16     	; 0x25fc <malloc+0xf0>
    25ec:	2d b7       	in	r18, 0x3d	; 61
    25ee:	3e b7       	in	r19, 0x3e	; 62
    25f0:	40 91 04 01 	lds	r20, 0x0104
    25f4:	50 91 05 01 	lds	r21, 0x0105
    25f8:	24 1b       	sub	r18, r20
    25fa:	35 0b       	sbc	r19, r21
    25fc:	e0 91 cc 0f 	lds	r30, 0x0FCC
    2600:	f0 91 cd 0f 	lds	r31, 0x0FCD
    2604:	e2 17       	cp	r30, r18
    2606:	f3 07       	cpc	r31, r19
    2608:	a0 f4       	brcc	.+40     	; 0x2632 <malloc+0x126>
    260a:	2e 1b       	sub	r18, r30
    260c:	3f 0b       	sbc	r19, r31
    260e:	28 17       	cp	r18, r24
    2610:	39 07       	cpc	r19, r25
    2612:	78 f0       	brcs	.+30     	; 0x2632 <malloc+0x126>
    2614:	ac 01       	movw	r20, r24
    2616:	4e 5f       	subi	r20, 0xFE	; 254
    2618:	5f 4f       	sbci	r21, 0xFF	; 255
    261a:	24 17       	cp	r18, r20
    261c:	35 07       	cpc	r19, r21
    261e:	48 f0       	brcs	.+18     	; 0x2632 <malloc+0x126>
    2620:	4e 0f       	add	r20, r30
    2622:	5f 1f       	adc	r21, r31
    2624:	50 93 cd 0f 	sts	0x0FCD, r21
    2628:	40 93 cc 0f 	sts	0x0FCC, r20
    262c:	81 93       	st	Z+, r24
    262e:	91 93       	st	Z+, r25
    2630:	02 c0       	rjmp	.+4      	; 0x2636 <malloc+0x12a>
    2632:	e0 e0       	ldi	r30, 0x00	; 0
    2634:	f0 e0       	ldi	r31, 0x00	; 0
    2636:	cf 01       	movw	r24, r30
    2638:	df 91       	pop	r29
    263a:	cf 91       	pop	r28
    263c:	1f 91       	pop	r17
    263e:	0f 91       	pop	r16
    2640:	08 95       	ret

00002642 <free>:
    2642:	ef 92       	push	r14
    2644:	ff 92       	push	r15
    2646:	0f 93       	push	r16
    2648:	1f 93       	push	r17
    264a:	cf 93       	push	r28
    264c:	df 93       	push	r29
    264e:	00 97       	sbiw	r24, 0x00	; 0
    2650:	09 f4       	brne	.+2      	; 0x2654 <free+0x12>
    2652:	8f c0       	rjmp	.+286    	; 0x2772 <free+0x130>
    2654:	dc 01       	movw	r26, r24
    2656:	12 97       	sbiw	r26, 0x02	; 2
    2658:	13 96       	adiw	r26, 0x03	; 3
    265a:	1c 92       	st	X, r1
    265c:	1e 92       	st	-X, r1
    265e:	12 97       	sbiw	r26, 0x02	; 2
    2660:	e0 90 ce 0f 	lds	r14, 0x0FCE
    2664:	f0 90 cf 0f 	lds	r15, 0x0FCF
    2668:	e1 14       	cp	r14, r1
    266a:	f1 04       	cpc	r15, r1
    266c:	89 f4       	brne	.+34     	; 0x2690 <free+0x4e>
    266e:	2d 91       	ld	r18, X+
    2670:	3c 91       	ld	r19, X
    2672:	11 97       	sbiw	r26, 0x01	; 1
    2674:	28 0f       	add	r18, r24
    2676:	39 1f       	adc	r19, r25
    2678:	80 91 cc 0f 	lds	r24, 0x0FCC
    267c:	90 91 cd 0f 	lds	r25, 0x0FCD
    2680:	82 17       	cp	r24, r18
    2682:	93 07       	cpc	r25, r19
    2684:	89 f5       	brne	.+98     	; 0x26e8 <free+0xa6>
    2686:	b0 93 cd 0f 	sts	0x0FCD, r27
    268a:	a0 93 cc 0f 	sts	0x0FCC, r26
    268e:	71 c0       	rjmp	.+226    	; 0x2772 <free+0x130>
    2690:	e7 01       	movw	r28, r14
    2692:	20 e0       	ldi	r18, 0x00	; 0
    2694:	30 e0       	ldi	r19, 0x00	; 0
    2696:	01 c0       	rjmp	.+2      	; 0x269a <free+0x58>
    2698:	ea 01       	movw	r28, r20
    269a:	ca 17       	cp	r28, r26
    269c:	db 07       	cpc	r29, r27
    269e:	38 f4       	brcc	.+14     	; 0x26ae <free+0x6c>
    26a0:	4a 81       	ldd	r20, Y+2	; 0x02
    26a2:	5b 81       	ldd	r21, Y+3	; 0x03
    26a4:	9e 01       	movw	r18, r28
    26a6:	41 15       	cp	r20, r1
    26a8:	51 05       	cpc	r21, r1
    26aa:	b1 f7       	brne	.-20     	; 0x2698 <free+0x56>
    26ac:	22 c0       	rjmp	.+68     	; 0x26f2 <free+0xb0>
    26ae:	bc 01       	movw	r22, r24
    26b0:	62 50       	subi	r22, 0x02	; 2
    26b2:	71 09       	sbc	r23, r1
    26b4:	fb 01       	movw	r30, r22
    26b6:	d3 83       	std	Z+3, r29	; 0x03
    26b8:	c2 83       	std	Z+2, r28	; 0x02
    26ba:	00 81       	ld	r16, Z
    26bc:	11 81       	ldd	r17, Z+1	; 0x01
    26be:	ac 01       	movw	r20, r24
    26c0:	40 0f       	add	r20, r16
    26c2:	51 1f       	adc	r21, r17
    26c4:	4c 17       	cp	r20, r28
    26c6:	5d 07       	cpc	r21, r29
    26c8:	61 f4       	brne	.+24     	; 0x26e2 <free+0xa0>
    26ca:	48 81       	ld	r20, Y
    26cc:	59 81       	ldd	r21, Y+1	; 0x01
    26ce:	40 0f       	add	r20, r16
    26d0:	51 1f       	adc	r21, r17
    26d2:	4e 5f       	subi	r20, 0xFE	; 254
    26d4:	5f 4f       	sbci	r21, 0xFF	; 255
    26d6:	51 83       	std	Z+1, r21	; 0x01
    26d8:	40 83       	st	Z, r20
    26da:	4a 81       	ldd	r20, Y+2	; 0x02
    26dc:	5b 81       	ldd	r21, Y+3	; 0x03
    26de:	53 83       	std	Z+3, r21	; 0x03
    26e0:	42 83       	std	Z+2, r20	; 0x02
    26e2:	21 15       	cp	r18, r1
    26e4:	31 05       	cpc	r19, r1
    26e6:	29 f4       	brne	.+10     	; 0x26f2 <free+0xb0>
    26e8:	b0 93 cf 0f 	sts	0x0FCF, r27
    26ec:	a0 93 ce 0f 	sts	0x0FCE, r26
    26f0:	40 c0       	rjmp	.+128    	; 0x2772 <free+0x130>
    26f2:	f9 01       	movw	r30, r18
    26f4:	b3 83       	std	Z+3, r27	; 0x03
    26f6:	a2 83       	std	Z+2, r26	; 0x02
    26f8:	e9 01       	movw	r28, r18
    26fa:	69 91       	ld	r22, Y+
    26fc:	79 91       	ld	r23, Y+
    26fe:	c6 0f       	add	r28, r22
    2700:	d7 1f       	adc	r29, r23
    2702:	ac 17       	cp	r26, r28
    2704:	bd 07       	cpc	r27, r29
    2706:	79 f4       	brne	.+30     	; 0x2726 <free+0xe4>
    2708:	dc 01       	movw	r26, r24
    270a:	5e 91       	ld	r21, -X
    270c:	4e 91       	ld	r20, -X
    270e:	46 0f       	add	r20, r22
    2710:	57 1f       	adc	r21, r23
    2712:	4e 5f       	subi	r20, 0xFE	; 254
    2714:	5f 4f       	sbci	r21, 0xFF	; 255
    2716:	51 83       	std	Z+1, r21	; 0x01
    2718:	40 83       	st	Z, r20
    271a:	12 96       	adiw	r26, 0x02	; 2
    271c:	8d 91       	ld	r24, X+
    271e:	9c 91       	ld	r25, X
    2720:	13 97       	sbiw	r26, 0x03	; 3
    2722:	93 83       	std	Z+3, r25	; 0x03
    2724:	82 83       	std	Z+2, r24	; 0x02
    2726:	a0 e0       	ldi	r26, 0x00	; 0
    2728:	b0 e0       	ldi	r27, 0x00	; 0
    272a:	02 c0       	rjmp	.+4      	; 0x2730 <free+0xee>
    272c:	d7 01       	movw	r26, r14
    272e:	7c 01       	movw	r14, r24
    2730:	f7 01       	movw	r30, r14
    2732:	82 81       	ldd	r24, Z+2	; 0x02
    2734:	93 81       	ldd	r25, Z+3	; 0x03
    2736:	00 97       	sbiw	r24, 0x00	; 0
    2738:	c9 f7       	brne	.-14     	; 0x272c <free+0xea>
    273a:	c7 01       	movw	r24, r14
    273c:	02 96       	adiw	r24, 0x02	; 2
    273e:	20 81       	ld	r18, Z
    2740:	31 81       	ldd	r19, Z+1	; 0x01
    2742:	82 0f       	add	r24, r18
    2744:	93 1f       	adc	r25, r19
    2746:	20 91 cc 0f 	lds	r18, 0x0FCC
    274a:	30 91 cd 0f 	lds	r19, 0x0FCD
    274e:	28 17       	cp	r18, r24
    2750:	39 07       	cpc	r19, r25
    2752:	79 f4       	brne	.+30     	; 0x2772 <free+0x130>
    2754:	10 97       	sbiw	r26, 0x00	; 0
    2756:	29 f4       	brne	.+10     	; 0x2762 <free+0x120>
    2758:	10 92 cf 0f 	sts	0x0FCF, r1
    275c:	10 92 ce 0f 	sts	0x0FCE, r1
    2760:	04 c0       	rjmp	.+8      	; 0x276a <free+0x128>
    2762:	13 96       	adiw	r26, 0x03	; 3
    2764:	1c 92       	st	X, r1
    2766:	1e 92       	st	-X, r1
    2768:	12 97       	sbiw	r26, 0x02	; 2
    276a:	f0 92 cd 0f 	sts	0x0FCD, r15
    276e:	e0 92 cc 0f 	sts	0x0FCC, r14
    2772:	df 91       	pop	r29
    2774:	cf 91       	pop	r28
    2776:	1f 91       	pop	r17
    2778:	0f 91       	pop	r16
    277a:	ff 90       	pop	r15
    277c:	ef 90       	pop	r14
    277e:	08 95       	ret

00002780 <memcpy>:
    2780:	fb 01       	movw	r30, r22
    2782:	dc 01       	movw	r26, r24
    2784:	02 c0       	rjmp	.+4      	; 0x278a <memcpy+0xa>
    2786:	01 90       	ld	r0, Z+
    2788:	0d 92       	st	X+, r0
    278a:	41 50       	subi	r20, 0x01	; 1
    278c:	50 40       	sbci	r21, 0x00	; 0
    278e:	d8 f7       	brcc	.-10     	; 0x2786 <memcpy+0x6>
    2790:	08 95       	ret

00002792 <_exit>:
    2792:	f8 94       	cli

00002794 <__stop_program>:
    2794:	ff cf       	rjmp	.-2      	; 0x2794 <__stop_program>
