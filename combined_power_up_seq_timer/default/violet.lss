
violet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000206  00800100  00002a38  00002acc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002a38  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000caa  00800306  00800306  00002cd2  2**0
                  ALLOC
  3 .stab         00003ff0  00000000  00000000  00002cd4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000010d7  00000000  00000000  00006cc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00007d9b  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000278  00000000  00000000  00007dca  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000050b8  00000000  00000000  00008042  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001104  00000000  00000000  0000d0fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001456  00000000  00000000  0000e1fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a70  00000000  00000000  0000f654  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000af4  00000000  00000000  000100c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002f9d  00000000  00000000  00010bb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000200  00000000  00000000  00013b55  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
{
       0:	0c 94 f4 00 	jmp	0x1e8	; 0x1e8 <__ctors_end>
       4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
       8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
       c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      10:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 * insert_str
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
      14:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      18:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
{
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
      1c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      20:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      24:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      28:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
		output[i] = input[i - start_index];

	return i;
}
      2c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      30:	0c 94 90 0c 	jmp	0x1920	; 0x1920 <__vector_12>
      34:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      38:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      3c:	0c 94 72 0c 	jmp	0x18e4	; 0x18e4 <__vector_15>
      40:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      44:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      48:	0c 94 ab 0d 	jmp	0x1b56	; 0x1b56 <__vector_18>
      4c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      50:	0c 94 82 0d 	jmp	0x1b04	; 0x1b04 <__vector_20>
      54:	0c 94 6d 0d 	jmp	0x1ada	; 0x1ada <__vector_21>
      58:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      5c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      60:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      64:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      68:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      6c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      70:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      74:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      78:	0c 94 38 0d 	jmp	0x1a70	; 0x1a70 <__vector_30>
      7c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      80:	0c 94 0f 0d 	jmp	0x1a1e	; 0x1a1e <__vector_32>
      84:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      88:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>

0000008c <charge20Pc>:
      8c:	08 00 09 00 09 00 0a 00 0b 00 0c 00 0d 00 0d 00     ................
      9c:	0e 00 0f 00 10 00 11 00 12 00 13 00 14 00 15 00     ................
      ac:	16 00 17 00 19 00 1a 00 1b 00 1d 00 1e 00 1f 00     ................
      bc:	21 00 22 00 24 00 25 00 27 00 28 00 2b 00 2c 00     !.".$.%.'.(.+.,.
      cc:	2e 00 30 00 32 00 34 00 36 00 38 00 3b 00 3e 00     ..0.2.4.6.8.;.>.
      dc:	3f 00 42 00 45 00 48 00 4c 00 50 00 59 00 6b 00     ?.B.E.H.L.P.Y.k.
      ec:	7f 00 8a 00 9c 00 a8 00 b3 00 c1 00 ce 00 dd 00     ................
      fc:	ea 00 f9 00 0d 01 1f 01 2b 01 3f 01 7e 01 a9 01     ........+.?.~...
     10c:	b7 01 e1 01 ff 01 18 02 28 02 3d 02 4d 02 62 02     ........(.=.M.b.
     11c:	7d 02 90 02 b8 02 c5 02 d6 02 e9 02 fa 02 08 03     }...............
     12c:	16 03 25 03 32 03 40 03 4d 03 60 03 6f 03 77 03     ..%.2.@.M.`.o.w.
     13c:	83 03 95 03 9f 03 aa 03 b4 03 c0 03 c9 03 d5 03     ................
     14c:	df 03 eb 03 f5 03 00 04 05 04 12 04 19 04 22 04     ..............".
     15c:	2c 04 34 04 37 04 40 04 74 04 7e 04                 ,.4.7.@.t.~.

00000168 <discharge20Pc>:
     168:	00 00 03 00 03 00 03 00 03 00 03 00 03 00 03 00     ................
     178:	03 00 03 00 03 00 03 00 03 00 03 00 03 00 03 00     ................
     188:	03 00 04 00 04 00 04 00 04 00 18 00 18 00 18 00     ................
     198:	18 00 40 00 40 00 40 00 40 00 68 00 68 00 68 00     ..@.@.@.@.h.h.h.
     1a8:	68 00 99 00 99 00 99 00 99 00 cd 00 cd 00 cd 00     h...............
     1b8:	cd 00 ff 00 ff 00 ff 00 ff 00 39 01 39 01 39 01     ..........9.9.9.
     1c8:	39 01 97 01 97 01 97 01 97 01 26 02 a9 02 40 03     9.........&...@.
     1d8:	91 03 ef 03 18 04 2a 04 34 04 3e 04 45 04 4d 04     ......*.4.>.E.M.

000001e8 <__ctors_end>:
     1e8:	11 24       	eor	r1, r1
     1ea:	1f be       	out	0x3f, r1	; 63
     1ec:	cf ef       	ldi	r28, 0xFF	; 255
     1ee:	d0 e1       	ldi	r29, 0x10	; 16
     1f0:	de bf       	out	0x3e, r29	; 62
     1f2:	cd bf       	out	0x3d, r28	; 61

000001f4 <__do_copy_data>:
     1f4:	13 e0       	ldi	r17, 0x03	; 3
     1f6:	a0 e0       	ldi	r26, 0x00	; 0
     1f8:	b1 e0       	ldi	r27, 0x01	; 1
     1fa:	e8 e3       	ldi	r30, 0x38	; 56
     1fc:	fa e2       	ldi	r31, 0x2A	; 42
     1fe:	00 e0       	ldi	r16, 0x00	; 0
     200:	0b bf       	out	0x3b, r16	; 59
     202:	02 c0       	rjmp	.+4      	; 0x208 <__do_copy_data+0x14>
     204:	07 90       	elpm	r0, Z+
     206:	0d 92       	st	X+, r0
     208:	a6 30       	cpi	r26, 0x06	; 6
     20a:	b1 07       	cpc	r27, r17
     20c:	d9 f7       	brne	.-10     	; 0x204 <__do_copy_data+0x10>

0000020e <__do_clear_bss>:
     20e:	2f e0       	ldi	r18, 0x0F	; 15
     210:	a6 e0       	ldi	r26, 0x06	; 6
     212:	b3 e0       	ldi	r27, 0x03	; 3
     214:	01 c0       	rjmp	.+2      	; 0x218 <.do_clear_bss_start>

00000216 <.do_clear_bss_loop>:
     216:	1d 92       	st	X+, r1

00000218 <.do_clear_bss_start>:
     218:	a0 3b       	cpi	r26, 0xB0	; 176
     21a:	b2 07       	cpc	r27, r18
     21c:	e1 f7       	brne	.-8      	; 0x216 <.do_clear_bss_loop>
     21e:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <main>
     222:	0c 94 1a 15 	jmp	0x2a34	; 0x2a34 <_exit>

00000226 <__bad_interrupt>:
     226:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000022a <set_component>:
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     22a:	8f 92       	push	r8
     22c:	af 92       	push	r10
     22e:	cf 92       	push	r12
     230:	ef 92       	push	r14
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     232:	0f 93       	push	r16
     234:	cf 93       	push	r28
     236:	df 93       	push	r29
     238:	cd b7       	in	r28, 0x3d	; 61
     23a:	de b7       	in	r29, 0x3e	; 62
     23c:	9c e1       	ldi	r25, 0x1C	; 28
     23e:	89 9f       	mul	r24, r25
     240:	f0 01       	movw	r30, r0
     242:	11 24       	eor	r1, r1
     244:	ea 5c       	subi	r30, 0xCA	; 202
     246:	fc 4f       	sbci	r31, 0xFC	; 252
     248:	60 83       	st	Z, r22
     24a:	41 83       	std	Z+1, r20	; 0x01
     24c:	22 83       	std	Z+2, r18	; 0x02
     24e:	13 82       	std	Z+3, r1	; 0x03
     250:	04 83       	std	Z+4, r16	; 0x04
     252:	e5 82       	std	Z+5, r14	; 0x05
     254:	c6 82       	std	Z+6, r12	; 0x06
     256:	a7 82       	std	Z+7, r10	; 0x07
     258:	13 86       	std	Z+11, r1	; 0x0b
     25a:	14 86       	std	Z+12, r1	; 0x0c
     25c:	85 86       	std	Z+13, r8	; 0x0d
     25e:	8a 85       	ldd	r24, Y+10	; 0x0a
     260:	86 87       	std	Z+14, r24	; 0x0e
     262:	8b 85       	ldd	r24, Y+11	; 0x0b
     264:	87 87       	std	Z+15, r24	; 0x0f
     266:	8c 85       	ldd	r24, Y+12	; 0x0c
     268:	80 8b       	std	Z+16, r24	; 0x10
     26a:	14 8a       	std	Z+20, r1	; 0x14
     26c:	15 8a       	std	Z+21, r1	; 0x15
     26e:	8d 85       	ldd	r24, Y+13	; 0x0d
     270:	86 8b       	std	Z+22, r24	; 0x16
     272:	8e 85       	ldd	r24, Y+14	; 0x0e
     274:	87 8b       	std	Z+23, r24	; 0x17
     276:	13 8e       	std	Z+27, r1	; 0x1b
     278:	df 91       	pop	r29
     27a:	cf 91       	pop	r28
     27c:	0f 91       	pop	r16
     27e:	ef 90       	pop	r14
     280:	cf 90       	pop	r12
     282:	af 90       	pop	r10
     284:	8f 90       	pop	r8
     286:	08 95       	ret

00000288 <initialize_svit>:
     288:	5f 92       	push	r5
     28a:	6f 92       	push	r6
     28c:	7f 92       	push	r7
     28e:	8f 92       	push	r8
     290:	9f 92       	push	r9
     292:	af 92       	push	r10
     294:	bf 92       	push	r11
     296:	cf 92       	push	r12
     298:	df 92       	push	r13
     29a:	ef 92       	push	r14
     29c:	ff 92       	push	r15
     29e:	0f 93       	push	r16
     2a0:	1f 93       	push	r17
     2a2:	cf 93       	push	r28
     2a4:	df 93       	push	r29
     2a6:	80 e6       	ldi	r24, 0x60	; 96
     2a8:	87 b9       	out	0x07, r24	; 7
     2aa:	8f e8       	ldi	r24, 0x8F	; 143
     2ac:	86 b9       	out	0x06, r24	; 6
     2ae:	1f 92       	push	r1
     2b0:	13 e0       	ldi	r17, 0x03	; 3
     2b2:	1f 93       	push	r17
     2b4:	c0 e1       	ldi	r28, 0x10	; 16
     2b6:	cf 93       	push	r28
     2b8:	d0 ea       	ldi	r29, 0xA0	; 160
     2ba:	df 93       	push	r29
     2bc:	86 e0       	ldi	r24, 0x06	; 6
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2be:	d8 2e       	mov	r13, r24
     2c0:	df 92       	push	r13
     2c2:	81 2c       	mov	r8, r1
     2c4:	90 e1       	ldi	r25, 0x10	; 16
     2c6:	a9 2e       	mov	r10, r25
     2c8:	20 ea       	ldi	r18, 0xA0	; 160
     2ca:	c2 2e       	mov	r12, r18
     2cc:	3b e0       	ldi	r19, 0x0B	; 11
     2ce:	e3 2e       	mov	r14, r19
     2d0:	00 e0       	ldi	r16, 0x00	; 0
     2d2:	21 e0       	ldi	r18, 0x01	; 1
     2d4:	47 e0       	ldi	r20, 0x07	; 7
     2d6:	60 e0       	ldi	r22, 0x00	; 0
     2d8:	80 e0       	ldi	r24, 0x00	; 0
     2da:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     2de:	87 e0       	ldi	r24, 0x07	; 7
     2e0:	8f 93       	push	r24
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     2e2:	bb 24       	eor	r11, r11
     2e4:	b3 94       	inc	r11
     2e6:	bf 92       	push	r11
     2e8:	cf 93       	push	r28
     2ea:	df 93       	push	r29
     2ec:	8f 93       	push	r24
     2ee:	47 e1       	ldi	r20, 0x17	; 23
     2f0:	e4 2e       	mov	r14, r20
     2f2:	21 e0       	ldi	r18, 0x01	; 1
     2f4:	48 e0       	ldi	r20, 0x08	; 8
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2f6:	61 e0       	ldi	r22, 0x01	; 1
     2f8:	81 e0       	ldi	r24, 0x01	; 1
     2fa:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     2fe:	1f 92       	push	r1
     300:	1f 93       	push	r17
     302:	cf 93       	push	r28
     304:	df 93       	push	r29
     306:	1f 92       	push	r1
     308:	88 24       	eor	r8, r8
     30a:	83 94       	inc	r8
     30c:	53 e1       	ldi	r21, 0x13	; 19
     30e:	e5 2e       	mov	r14, r21
     310:	01 e0       	ldi	r16, 0x01	; 1
     312:	21 e0       	ldi	r18, 0x01	; 1
     314:	41 e0       	ldi	r20, 0x01	; 1
     316:	62 e0       	ldi	r22, 0x02	; 2
     318:	82 e0       	ldi	r24, 0x02	; 2
     31a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     31e:	1f 92       	push	r1
     320:	1f 93       	push	r17
     322:	cf 93       	push	r28
     324:	df 93       	push	r29
     326:	8e e0       	ldi	r24, 0x0E	; 14
     328:	8f 93       	push	r24
     32a:	62 e0       	ldi	r22, 0x02	; 2
     32c:	86 2e       	mov	r8, r22
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     32e:	7d e0       	ldi	r23, 0x0D	; 13
     330:	e7 2e       	mov	r14, r23
     332:	02 e0       	ldi	r16, 0x02	; 2
     334:	21 e0       	ldi	r18, 0x01	; 1
     336:	41 e0       	ldi	r20, 0x01	; 1
     338:	63 e0       	ldi	r22, 0x03	; 3
     33a:	83 e0       	ldi	r24, 0x03	; 3
     33c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     340:	1f 92       	push	r1
     342:	1f 93       	push	r17
     344:	cf 93       	push	r28
     346:	df 93       	push	r29
     348:	bf 92       	push	r11
     34a:	88 24       	eor	r8, r8
     34c:	83 94       	inc	r8
     34e:	e5 e1       	ldi	r30, 0x15	; 21
     350:	ee 2e       	mov	r14, r30
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     352:	01 e0       	ldi	r16, 0x01	; 1
     354:	21 e0       	ldi	r18, 0x01	; 1
     356:	42 e0       	ldi	r20, 0x02	; 2
     358:	64 e0       	ldi	r22, 0x04	; 4
     35a:	84 e0       	ldi	r24, 0x04	; 4
     35c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     360:	1f 92       	push	r1
     362:	1f 93       	push	r17
     364:	cf 93       	push	r28
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     366:	df 93       	push	r29
     368:	f2 e0       	ldi	r31, 0x02	; 2
     36a:	ff 2e       	mov	r15, r31
     36c:	ff 92       	push	r15
     36e:	aa e1       	ldi	r26, 0x1A	; 26
     370:	ea 2e       	mov	r14, r26
     372:	21 e0       	ldi	r18, 0x01	; 1
     374:	43 e0       	ldi	r20, 0x03	; 3
     376:	65 e0       	ldi	r22, 0x05	; 5
     378:	85 e0       	ldi	r24, 0x05	; 5
     37a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     37e:	1f 92       	push	r1
     380:	1f 93       	push	r17
     382:	cf 93       	push	r28
     384:	df 93       	push	r29
     386:	1f 93       	push	r17
     388:	bd e1       	ldi	r27, 0x1D	; 29
     38a:	eb 2e       	mov	r14, r27
     38c:	21 e0       	ldi	r18, 0x01	; 1
     38e:	44 e0       	ldi	r20, 0x04	; 4
     390:	66 e0       	ldi	r22, 0x06	; 6
     392:	86 e0       	ldi	r24, 0x06	; 6
     394:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     398:	8d b7       	in	r24, 0x3d	; 61
     39a:	9e b7       	in	r25, 0x3e	; 62
     39c:	83 96       	adiw	r24, 0x23	; 35
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     39e:	0f b6       	in	r0, 0x3f	; 63
     3a0:	f8 94       	cli
     3a2:	9e bf       	out	0x3e, r25	; 62
     3a4:	0f be       	out	0x3f, r0	; 63
     3a6:	8d bf       	out	0x3d, r24	; 61
     3a8:	1f 92       	push	r1
     3aa:	1f 93       	push	r17
     3ac:	cf 93       	push	r28
     3ae:	df 93       	push	r29
     3b0:	8f e1       	ldi	r24, 0x1F	; 31
     3b2:	98 2e       	mov	r9, r24
     3b4:	9f 92       	push	r9
     3b6:	9e e0       	ldi	r25, 0x0E	; 14
     3b8:	e9 2e       	mov	r14, r25
     3ba:	21 e0       	ldi	r18, 0x01	; 1
     3bc:	45 e0       	ldi	r20, 0x05	; 5
     3be:	67 e0       	ldi	r22, 0x07	; 7
     3c0:	87 e0       	ldi	r24, 0x07	; 7
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     3c2:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     3c6:	1f 92       	push	r1
     3c8:	1f 93       	push	r17
     3ca:	cf 93       	push	r28
     3cc:	df 93       	push	r29
     3ce:	24 e0       	ldi	r18, 0x04	; 4
     3d0:	52 2e       	mov	r5, r18
     3d2:	5f 92       	push	r5
     3d4:	3b e1       	ldi	r19, 0x1B	; 27
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     3d6:	e3 2e       	mov	r14, r19
     3d8:	21 e0       	ldi	r18, 0x01	; 1
     3da:	46 e0       	ldi	r20, 0x06	; 6
     3dc:	68 e0       	ldi	r22, 0x08	; 8
     3de:	88 e0       	ldi	r24, 0x08	; 8
     3e0:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     3e4:	1f 92       	push	r1
     3e6:	1f 93       	push	r17
     3e8:	cf 93       	push	r28
     3ea:	df 93       	push	r29
     3ec:	48 e0       	ldi	r20, 0x08	; 8
     3ee:	64 2e       	mov	r6, r20
     3f0:	6f 92       	push	r6
     3f2:	5f e0       	ldi	r21, 0x0F	; 15
     3f4:	e5 2e       	mov	r14, r21
     3f6:	21 e0       	ldi	r18, 0x01	; 1
     3f8:	49 e0       	ldi	r20, 0x09	; 9
     3fa:	69 e0       	ldi	r22, 0x09	; 9
     3fc:	89 e0       	ldi	r24, 0x09	; 9
     3fe:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     402:	1f 92       	push	r1
     404:	1f 93       	push	r17
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     406:	cf 93       	push	r28
     408:	df 93       	push	r29
     40a:	69 e0       	ldi	r22, 0x09	; 9
     40c:	76 2e       	mov	r7, r22
     40e:	7f 92       	push	r7
     410:	79 e1       	ldi	r23, 0x19	; 25
     412:	e7 2e       	mov	r14, r23
     414:	21 e0       	ldi	r18, 0x01	; 1
     416:	4a e0       	ldi	r20, 0x0A	; 10
     418:	6a e0       	ldi	r22, 0x0A	; 10
     41a:	8a e0       	ldi	r24, 0x0A	; 10
     41c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     420:	1f 92       	push	r1
     422:	1f 93       	push	r17
     424:	cf 93       	push	r28
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     426:	df 93       	push	r29
     428:	8a e0       	ldi	r24, 0x0A	; 10
     42a:	8f 93       	push	r24
     42c:	e8 e1       	ldi	r30, 0x18	; 24
     42e:	ee 2e       	mov	r14, r30
     430:	20 e0       	ldi	r18, 0x00	; 0
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     432:	4b e0       	ldi	r20, 0x0B	; 11
     434:	6b e0       	ldi	r22, 0x0B	; 11
     436:	8b e0       	ldi	r24, 0x0B	; 11
     438:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     43c:	1f 92       	push	r1
     43e:	1f 93       	push	r17
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
	}
    else 
	{
	  debug = 0x0B;
     444:	cf 93       	push	r28
     446:	f1 e1       	ldi	r31, 0x11	; 17
     448:	ef 2e       	mov	r14, r31
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     44a:	20 e0       	ldi	r18, 0x00	; 0
     44c:	4c e0       	ldi	r20, 0x0C	; 12
     44e:	6c e0       	ldi	r22, 0x0C	; 12
     450:	8c e0       	ldi	r24, 0x0C	; 12
     452:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     456:	6f 92       	push	r6
     458:	ff 92       	push	r15
     45a:	cf 93       	push	r28
     45c:	df 93       	push	r29
     45e:	8c e0       	ldi	r24, 0x0C	; 12
     460:	8f 93       	push	r24
     462:	a6 e1       	ldi	r26, 0x16	; 22
     464:	ea 2e       	mov	r14, r26
     466:	21 e0       	ldi	r18, 0x01	; 1
     468:	4d e0       	ldi	r20, 0x0D	; 13
     46a:	6d e0       	ldi	r22, 0x0D	; 13
     46c:	8d e0       	ldi	r24, 0x0D	; 13
     46e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     472:	8d b7       	in	r24, 0x3d	; 61
     474:	9e b7       	in	r25, 0x3e	; 62
     476:	83 96       	adiw	r24, 0x23	; 35
     478:	0f b6       	in	r0, 0x3f	; 63
     47a:	f8 94       	cli
     47c:	9e bf       	out	0x3e, r25	; 62
     47e:	0f be       	out	0x3f, r0	; 63
     480:	8d bf       	out	0x3d, r24	; 61
     482:	1f 92       	push	r1
     484:	1f 93       	push	r17
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	df 92       	push	r13
     48c:	81 2c       	mov	r8, r1
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     48e:	b4 e0       	ldi	r27, 0x04	; 4
     490:	eb 2e       	mov	r14, r27
     492:	00 e0       	ldi	r16, 0x00	; 0
     494:	21 e0       	ldi	r18, 0x01	; 1
     496:	4e e0       	ldi	r20, 0x0E	; 14
     498:	6e e0       	ldi	r22, 0x0E	; 14
     49a:	8e e0       	ldi	r24, 0x0E	; 14
     49c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4a0:	1f 92       	push	r1
     4a2:	1f 93       	push	r17
     4a4:	cf 93       	push	r28
     4a6:	df 93       	push	r29
     4a8:	1f 92       	push	r1
     4aa:	03 e0       	ldi	r16, 0x03	; 3
     4ac:	80 2e       	mov	r8, r16
     4ae:	85 e1       	ldi	r24, 0x15	; 21
     4b0:	e8 2e       	mov	r14, r24
     4b2:	02 e0       	ldi	r16, 0x02	; 2
     4b4:	21 e0       	ldi	r18, 0x01	; 1
     4b6:	40 e1       	ldi	r20, 0x10	; 16
     4b8:	6f e0       	ldi	r22, 0x0F	; 15
     4ba:	8f e0       	ldi	r24, 0x0F	; 15
     4bc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4c0:	1f 92       	push	r1
     4c2:	1f 93       	push	r17
     4c4:	cf 93       	push	r28
     4c6:	df 93       	push	r29
     4c8:	8d e0       	ldi	r24, 0x0D	; 13
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     4ca:	8f 93       	push	r24
     4cc:	88 24       	eor	r8, r8
     4ce:	83 94       	inc	r8
     4d0:	92 e1       	ldi	r25, 0x12	; 18
     4d2:	e9 2e       	mov	r14, r25
     4d4:	01 e0       	ldi	r16, 0x01	; 1
     4d6:	21 e0       	ldi	r18, 0x01	; 1
     4d8:	4f e0       	ldi	r20, 0x0F	; 15
     4da:	60 e1       	ldi	r22, 0x10	; 16
     4dc:	80 e1       	ldi	r24, 0x10	; 16
     4de:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4e2:	1f 92       	push	r1
     4e4:	1f 93       	push	r17
     4e6:	cf 93       	push	r28
     4e8:	df 93       	push	r29
     4ea:	25 e0       	ldi	r18, 0x05	; 5
     4ec:	62 2e       	mov	r6, r18
     4ee:	6f 92       	push	r6
     4f0:	3c e1       	ldi	r19, 0x1C	; 28
     4f2:	e3 2e       	mov	r14, r19
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	4f ef       	ldi	r20, 0xFF	; 255
     4f8:	61 e1       	ldi	r22, 0x11	; 17
     4fa:	81 e1       	ldi	r24, 0x11	; 17
     4fc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     500:	1f 92       	push	r1
     502:	1f 93       	push	r17
     504:	cf 93       	push	r28
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     506:	df 93       	push	r29
     508:	cf 93       	push	r28
     50a:	42 e0       	ldi	r20, 0x02	; 2
     50c:	84 2e       	mov	r8, r20
     50e:	5f e0       	ldi	r21, 0x0F	; 15
     510:	e5 2e       	mov	r14, r21
     512:	02 e0       	ldi	r16, 0x02	; 2
     514:	20 e0       	ldi	r18, 0x00	; 0
     516:	4f ef       	ldi	r20, 0xFF	; 255
     518:	62 e1       	ldi	r22, 0x12	; 18
     51a:	82 e1       	ldi	r24, 0x12	; 18
     51c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     520:	1f 92       	push	r1
     522:	1f 93       	push	r17
     524:	cf 93       	push	r28
     526:	df 93       	push	r29
     528:	82 e1       	ldi	r24, 0x12	; 18
     52a:	8f 93       	push	r24
     52c:	61 e1       	ldi	r22, 0x11	; 17
     52e:	e6 2e       	mov	r14, r22
     530:	20 e0       	ldi	r18, 0x00	; 0
     532:	4f ef       	ldi	r20, 0xFF	; 255
     534:	63 e1       	ldi	r22, 0x13	; 19
     536:	83 e1       	ldi	r24, 0x13	; 19
     538:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     53c:	7f 92       	push	r7
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     53e:	ff 92       	push	r15
     540:	cf 93       	push	r28
     542:	df 93       	push	r29
     544:	ff 92       	push	r15
     546:	81 2c       	mov	r8, r1
     548:	ee 24       	eor	r14, r14
     54a:	e3 94       	inc	r14
     54c:	00 e0       	ldi	r16, 0x00	; 0
     54e:	21 e0       	ldi	r18, 0x01	; 1
     550:	4f ef       	ldi	r20, 0xFF	; 255
     552:	64 e1       	ldi	r22, 0x14	; 20
     554:	84 e1       	ldi	r24, 0x14	; 20
     556:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     55a:	8d b7       	in	r24, 0x3d	; 61
     55c:	9e b7       	in	r25, 0x3e	; 62
     55e:	83 96       	adiw	r24, 0x23	; 35
     560:	0f b6       	in	r0, 0x3f	; 63
     562:	f8 94       	cli
     564:	9e bf       	out	0x3e, r25	; 62
     566:	0f be       	out	0x3f, r0	; 63
     568:	8d bf       	out	0x3d, r24	; 61
     56a:	8b e0       	ldi	r24, 0x0B	; 11
     56c:	8f 93       	push	r24
     56e:	ff 92       	push	r15
     570:	cf 93       	push	r28
     572:	df 93       	push	r29
     574:	7e e1       	ldi	r23, 0x1E	; 30
     576:	77 2e       	mov	r7, r23
     578:	7f 92       	push	r7
     57a:	e2 e0       	ldi	r30, 0x02	; 2
     57c:	8e 2e       	mov	r8, r30
     57e:	f4 e1       	ldi	r31, 0x14	; 20
     580:	ef 2e       	mov	r14, r31
     582:	02 e0       	ldi	r16, 0x02	; 2
     584:	21 e0       	ldi	r18, 0x01	; 1
     586:	4f ef       	ldi	r20, 0xFF	; 255
     588:	65 e1       	ldi	r22, 0x15	; 21
     58a:	85 e1       	ldi	r24, 0x15	; 21
     58c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     590:	1f 92       	push	r1
     592:	1f 93       	push	r17
     594:	cf 93       	push	r28
     596:	df 93       	push	r29
     598:	1f 93       	push	r17
     59a:	81 2c       	mov	r8, r1
     59c:	a7 e0       	ldi	r26, 0x07	; 7
     59e:	ea 2e       	mov	r14, r26
     5a0:	00 e0       	ldi	r16, 0x00	; 0
     5a2:	21 e0       	ldi	r18, 0x01	; 1
     5a4:	4f ef       	ldi	r20, 0xFF	; 255
     5a6:	66 e1       	ldi	r22, 0x16	; 22
     5a8:	86 e1       	ldi	r24, 0x16	; 22
     5aa:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     5ae:	1f 92       	push	r1
     5b0:	ff 92       	push	r15
     5b2:	cf 93       	push	r28
     5b4:	df 93       	push	r29
     5b6:	84 e1       	ldi	r24, 0x14	; 20
     5b8:	8f 93       	push	r24
     5ba:	b2 e1       	ldi	r27, 0x12	; 18
     5bc:	eb 2e       	mov	r14, r27
     5be:	21 e0       	ldi	r18, 0x01	; 1
     5c0:	4f ef       	ldi	r20, 0xFF	; 255
     5c2:	67 e1       	ldi	r22, 0x17	; 23
     5c4:	87 e1       	ldi	r24, 0x17	; 23
     5c6:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     5ca:	bf 92       	push	r11
     5cc:	ff 92       	push	r15
     5ce:	cf 93       	push	r28
     5d0:	df 93       	push	r29
     5d2:	85 e1       	ldi	r24, 0x15	; 21
     5d4:	8f 93       	push	r24
     5d6:	83 e1       	ldi	r24, 0x13	; 19
     5d8:	e8 2e       	mov	r14, r24
     5da:	21 e0       	ldi	r18, 0x01	; 1
     5dc:	4f ef       	ldi	r20, 0xFF	; 255
     5de:	68 e1       	ldi	r22, 0x18	; 24
     5e0:	88 e1       	ldi	r24, 0x18	; 24
     5e2:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     5e6:	ff 92       	push	r15
     5e8:	ff 92       	push	r15
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     5ee:	86 e1       	ldi	r24, 0x16	; 22
     5f0:	8f 93       	push	r24
     5f2:	9a e0       	ldi	r25, 0x0A	; 10
     5f4:	e9 2e       	mov	r14, r25
     5f6:	21 e0       	ldi	r18, 0x01	; 1
     5f8:	4f ef       	ldi	r20, 0xFF	; 255
     5fa:	69 e1       	ldi	r22, 0x19	; 25
     5fc:	89 e1       	ldi	r24, 0x19	; 25
     5fe:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     602:	1f 93       	push	r17
     604:	ff 92       	push	r15
     606:	cf 93       	push	r28
     608:	df 93       	push	r29
     60a:	87 e1       	ldi	r24, 0x17	; 23
     60c:	8f 93       	push	r24
     60e:	2f e0       	ldi	r18, 0x0F	; 15
     610:	e2 2e       	mov	r14, r18
     612:	21 e0       	ldi	r18, 0x01	; 1
     614:	4f ef       	ldi	r20, 0xFF	; 255
     616:	6a e1       	ldi	r22, 0x1A	; 26
     618:	8a e1       	ldi	r24, 0x1A	; 26
     61a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     61e:	5f 92       	push	r5
     620:	ff 92       	push	r15
     622:	cf 93       	push	r28
     624:	df 93       	push	r29
     626:	88 e1       	ldi	r24, 0x18	; 24
     628:	8f 93       	push	r24
     62a:	39 e0       	ldi	r19, 0x09	; 9
     62c:	e3 2e       	mov	r14, r19
     62e:	21 e0       	ldi	r18, 0x01	; 1
     630:	4f ef       	ldi	r20, 0xFF	; 255
     632:	6b e1       	ldi	r22, 0x1B	; 27
     634:	8b e1       	ldi	r24, 0x1B	; 27
     636:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     63a:	8d b7       	in	r24, 0x3d	; 61
     63c:	9e b7       	in	r25, 0x3e	; 62
     63e:	83 96       	adiw	r24, 0x23	; 35
     640:	0f b6       	in	r0, 0x3f	; 63
     642:	f8 94       	cli
     644:	9e bf       	out	0x3e, r25	; 62
     646:	0f be       	out	0x3f, r0	; 63
     648:	8d bf       	out	0x3d, r24	; 61
     64a:	1f 92       	push	r1
     64c:	1f 93       	push	r17
     64e:	cf 93       	push	r28
     650:	df 93       	push	r29
     652:	89 e1       	ldi	r24, 0x19	; 25
     654:	8f 93       	push	r24
     656:	4e e0       	ldi	r20, 0x0E	; 14
     658:	e4 2e       	mov	r14, r20
     65a:	21 e0       	ldi	r18, 0x01	; 1
     65c:	4f ef       	ldi	r20, 0xFF	; 255
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     65e:	6c e1       	ldi	r22, 0x1C	; 28
     660:	8c e1       	ldi	r24, 0x1C	; 28
     662:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     666:	1f 92       	push	r1
     668:	1f 93       	push	r17
     66a:	cf 93       	push	r28
     66c:	df 93       	push	r29
     66e:	8a e1       	ldi	r24, 0x1A	; 26
     670:	8f 93       	push	r24
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     672:	50 e1       	ldi	r21, 0x10	; 16
     674:	e5 2e       	mov	r14, r21
     676:	21 e0       	ldi	r18, 0x01	; 1
     678:	4f ef       	ldi	r20, 0xFF	; 255
     67a:	6d e1       	ldi	r22, 0x1D	; 29
     67c:	8d e1       	ldi	r24, 0x1D	; 29
     67e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     682:	1f 92       	push	r1
     684:	1f 93       	push	r17
     686:	cf 93       	push	r28
     688:	df 93       	push	r29
     68a:	8b e1       	ldi	r24, 0x1B	; 27
     68c:	8f 93       	push	r24
     68e:	68 e0       	ldi	r22, 0x08	; 8
     690:	e6 2e       	mov	r14, r22
     692:	21 e0       	ldi	r18, 0x01	; 1
     694:	4f ef       	ldi	r20, 0xFF	; 255
     696:	6e e1       	ldi	r22, 0x1E	; 30
     698:	8e e1       	ldi	r24, 0x1E	; 30
     69a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     69e:	6f 92       	push	r6
     6a0:	ff 92       	push	r15
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6a2:	cf 93       	push	r28
     6a4:	df 93       	push	r29
     6a6:	8c e1       	ldi	r24, 0x1C	; 28
     6a8:	8f 93       	push	r24
     6aa:	7d e0       	ldi	r23, 0x0D	; 13
     6ac:	e7 2e       	mov	r14, r23
     6ae:	21 e0       	ldi	r18, 0x01	; 1
     6b0:	4f ef       	ldi	r20, 0xFF	; 255
     6b2:	6f e1       	ldi	r22, 0x1F	; 31
     6b4:	8f e1       	ldi	r24, 0x1F	; 31
     6b6:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6ba:	1f 92       	push	r1
     6bc:	1f 93       	push	r17
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     6c2:	8d e1       	ldi	r24, 0x1D	; 29
     6c4:	8f 93       	push	r24
     6c6:	ec e0       	ldi	r30, 0x0C	; 12
     6c8:	ee 2e       	mov	r14, r30
     6ca:	21 e0       	ldi	r18, 0x01	; 1
     6cc:	4f ef       	ldi	r20, 0xFF	; 255
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6ce:	60 e2       	ldi	r22, 0x20	; 32
     6d0:	80 e2       	ldi	r24, 0x20	; 32
     6d2:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6d6:	1f 92       	push	r1
     6d8:	1f 93       	push	r17
     6da:	cf 93       	push	r28
     6dc:	df 93       	push	r29
     6de:	7f 92       	push	r7
     6e0:	fb e0       	ldi	r31, 0x0B	; 11
     6e2:	ef 2e       	mov	r14, r31
     6e4:	21 e0       	ldi	r18, 0x01	; 1
     6e6:	4f ef       	ldi	r20, 0xFF	; 255
     6e8:	61 e2       	ldi	r22, 0x21	; 33
     6ea:	81 e2       	ldi	r24, 0x21	; 33
     6ec:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6f0:	1f 92       	push	r1
     6f2:	1f 93       	push	r17
     6f4:	cf 93       	push	r28
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     6f6:	df 93       	push	r29
     6f8:	9f 92       	push	r9
     6fa:	a1 e1       	ldi	r26, 0x11	; 17
     6fc:	ea 2e       	mov	r14, r26
     6fe:	21 e0       	ldi	r18, 0x01	; 1
     700:	4f ef       	ldi	r20, 0xFF	; 255
     702:	62 e2       	ldi	r22, 0x22	; 34
     704:	82 e2       	ldi	r24, 0x22	; 34
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
	}
  	percent = 100*(1 - batt_time/discharge_max_time);
     706:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     70a:	8d b7       	in	r24, 0x3d	; 61
     70c:	9e b7       	in	r25, 0x3e	; 62
     70e:	83 96       	adiw	r24, 0x23	; 35
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	f8 94       	cli
     714:	9e bf       	out	0x3e, r25	; 62
     716:	0f be       	out	0x3f, r0	; 63
     718:	8d bf       	out	0x3d, r24	; 61
     71a:	df 92       	push	r13
     71c:	ff 92       	push	r15
     71e:	cf 93       	push	r28
     720:	df 93       	push	r29
     722:	1f 92       	push	r1
     724:	b5 e0       	ldi	r27, 0x05	; 5
     726:	eb 2e       	mov	r14, r27
     728:	21 e0       	ldi	r18, 0x01	; 1
     72a:	4f ef       	ldi	r20, 0xFF	; 255
     72c:	63 e2       	ldi	r22, 0x23	; 35
     72e:	83 e2       	ldi	r24, 0x23	; 35
     730:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     734:	0f 90       	pop	r0
     736:	0f 90       	pop	r0
     738:	0f 90       	pop	r0
     73a:	0f 90       	pop	r0
  }
  else 
  {
    float temp_real = 0;
    if (real < 13.35)
     73c:	0f 90       	pop	r0
     73e:	df 91       	pop	r29
     740:	cf 91       	pop	r28
     742:	1f 91       	pop	r17
     744:	0f 91       	pop	r16
     746:	ff 90       	pop	r15
     748:	ef 90       	pop	r14
     74a:	df 90       	pop	r13
     74c:	cf 90       	pop	r12
     74e:	bf 90       	pop	r11
	{
	  debug = 0x0C;
     750:	af 90       	pop	r10
     752:	9f 90       	pop	r9
     754:	8f 90       	pop	r8
	  // voltage is normalized by mean 13.13 and std 0.1754 (real - 13.13)/0.1754
	  temp_real = (real - 13.13)*5.701254;
     756:	7f 90       	pop	r7
     758:	6f 90       	pop	r6
     75a:	5f 90       	pop	r5
     75c:	08 95       	ret

0000075e <receive_message>:
     75e:	ff 92       	push	r15
     760:	0f 93       	push	r16
     762:	1f 93       	push	r17
     764:	cf 93       	push	r28
     766:	df 93       	push	r29
     768:	f8 2e       	mov	r15, r24
     76a:	fb 01       	movw	r30, r22
     76c:	c1 81       	ldd	r28, Z+1	; 0x01
     76e:	90 81       	ld	r25, Z
     770:	93 30       	cpi	r25, 0x03	; 3
     772:	09 f4       	brne	.+2      	; 0x776 <receive_message+0x18>
     774:	5a c0       	rjmp	.+180    	; 0x82a <receive_message+0xcc>
	  batt_time = p1*pow(temp_real,3) + p2*pow(temp_real,2) + p3*temp_real + p4;
     776:	30 f4       	brcc	.+12     	; 0x784 <receive_message+0x26>
     778:	0c 2f       	mov	r16, r28
     77a:	10 e0       	ldi	r17, 0x00	; 0
     77c:	91 30       	cpi	r25, 0x01	; 1
     77e:	11 f1       	breq	.+68     	; 0x7c4 <receive_message+0x66>
     780:	90 f5       	brcc	.+100    	; 0x7e6 <receive_message+0x88>
     782:	0c c0       	rjmp	.+24     	; 0x79c <receive_message+0x3e>
     784:	95 30       	cpi	r25, 0x05	; 5
     786:	09 f4       	brne	.+2      	; 0x78a <receive_message+0x2c>
     788:	55 c0       	rjmp	.+170    	; 0x834 <receive_message+0xd6>
     78a:	08 f4       	brcc	.+2      	; 0x78e <receive_message+0x30>
     78c:	50 c0       	rjmp	.+160    	; 0x82e <receive_message+0xd0>
     78e:	96 30       	cpi	r25, 0x06	; 6
     790:	09 f4       	brne	.+2      	; 0x794 <receive_message+0x36>
     792:	60 c0       	rjmp	.+192    	; 0x854 <receive_message+0xf6>
     794:	97 30       	cpi	r25, 0x07	; 7
     796:	09 f0       	breq	.+2      	; 0x79a <receive_message+0x3c>
     798:	7b c0       	rjmp	.+246    	; 0x890 <receive_message+0x132>
     79a:	6b c0       	rjmp	.+214    	; 0x872 <receive_message+0x114>
     79c:	8c e2       	ldi	r24, 0x2C	; 44
     79e:	80 93 9b 0d 	sts	0x0D9B, r24
     7a2:	8c e1       	ldi	r24, 0x1C	; 28
     7a4:	80 9f       	mul	r24, r16
     7a6:	e0 01       	movw	r28, r0
     7a8:	81 9f       	mul	r24, r17
     7aa:	d0 0d       	add	r29, r0
     7ac:	11 24       	eor	r1, r1
     7ae:	ca 5c       	subi	r28, 0xCA	; 202
     7b0:	dc 4f       	sbci	r29, 0xFC	; 252
     7b2:	89 81       	ldd	r24, Y+1	; 0x01
     7b4:	8f 3f       	cpi	r24, 0xFF	; 255
     7b6:	21 f0       	breq	.+8      	; 0x7c0 <receive_message+0x62>
     7b8:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <switch_on>
     7bc:	81 e0       	ldi	r24, 0x01	; 1
     7be:	8a 83       	std	Y+2, r24	; 0x02
     7c0:	40 e0       	ldi	r20, 0x00	; 0
     7c2:	0f c0       	rjmp	.+30     	; 0x7e2 <receive_message+0x84>
     7c4:	8c e1       	ldi	r24, 0x1C	; 28
     7c6:	80 9f       	mul	r24, r16
     7c8:	e0 01       	movw	r28, r0
     7ca:	81 9f       	mul	r24, r17
     7cc:	d0 0d       	add	r29, r0
     7ce:	11 24       	eor	r1, r1
     7d0:	ca 5c       	subi	r28, 0xCA	; 202
     7d2:	dc 4f       	sbci	r29, 0xFC	; 252
     7d4:	89 81       	ldd	r24, Y+1	; 0x01
     7d6:	8f 3f       	cpi	r24, 0xFF	; 255
     7d8:	19 f0       	breq	.+6      	; 0x7e0 <receive_message+0x82>
     7da:	0e 94 3b 09 	call	0x1276	; 0x1276 <switch_off>
     7de:	1a 82       	std	Y+2, r1	; 0x02
     7e0:	41 e0       	ldi	r20, 0x01	; 1
     7e2:	62 e0       	ldi	r22, 0x02	; 2
     7e4:	57 c0       	rjmp	.+174    	; 0x894 <receive_message+0x136>
     7e6:	8c e1       	ldi	r24, 0x1C	; 28
     7e8:	80 9f       	mul	r24, r16
     7ea:	e0 01       	movw	r28, r0
     7ec:	81 9f       	mul	r24, r17
     7ee:	d0 0d       	add	r29, r0
     7f0:	11 24       	eor	r1, r1
     7f2:	ca 5c       	subi	r28, 0xCA	; 202
     7f4:	dc 4f       	sbci	r29, 0xFC	; 252
     7f6:	89 81       	ldd	r24, Y+1	; 0x01
     7f8:	8f 3f       	cpi	r24, 0xFF	; 255
     7fa:	19 f0       	breq	.+6      	; 0x802 <receive_message+0xa4>
     7fc:	0e 94 3b 09 	call	0x1276	; 0x1276 <switch_off>
     800:	1a 82       	std	Y+2, r1	; 0x02
     802:	85 e0       	ldi	r24, 0x05	; 5
     804:	8a 95       	dec	r24
     806:	f1 f7       	brne	.-4      	; 0x804 <receive_message+0xa6>
     808:	8c e1       	ldi	r24, 0x1C	; 28
     80a:	80 9f       	mul	r24, r16
     80c:	e0 01       	movw	r28, r0
     80e:	81 9f       	mul	r24, r17
	}
	else 
	{
	  debug = 0x0D;
     810:	d0 0d       	add	r29, r0
     812:	11 24       	eor	r1, r1
     814:	ca 5c       	subi	r28, 0xCA	; 202
	  // voltage is normalized by mean 13.7 and std 0.1558 (real - 13.7)/0.1558;
	  temp_real = (real - 13.7)*6.418485;
     816:	dc 4f       	sbci	r29, 0xFC	; 252
     818:	89 81       	ldd	r24, Y+1	; 0x01
     81a:	8f 3f       	cpi	r24, 0xFF	; 255
     81c:	21 f0       	breq	.+8      	; 0x826 <receive_message+0xc8>
     81e:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <switch_on>
     822:	81 e0       	ldi	r24, 0x01	; 1
     824:	8a 83       	std	Y+2, r24	; 0x02
     826:	42 e0       	ldi	r20, 0x02	; 2
     828:	dc cf       	rjmp	.-72     	; 0x7e2 <receive_message+0x84>
     82a:	43 e0       	ldi	r20, 0x03	; 3
     82c:	da cf       	rjmp	.-76     	; 0x7e2 <receive_message+0x84>
     82e:	40 e0       	ldi	r20, 0x00	; 0
     830:	60 e0       	ldi	r22, 0x00	; 0
     832:	30 c0       	rjmp	.+96     	; 0x894 <receive_message+0x136>
     834:	8c e1       	ldi	r24, 0x1C	; 28
      batt_time = q1*pow(temp_real,3) + q2*pow(temp_real,2) + q3*temp_real + q4;
     836:	c8 9f       	mul	r28, r24
     838:	e0 01       	movw	r28, r0
     83a:	11 24       	eor	r1, r1
     83c:	ca 5c       	subi	r28, 0xCA	; 202
     83e:	dc 4f       	sbci	r29, 0xFC	; 252
     840:	89 81       	ldd	r24, Y+1	; 0x01
     842:	8f 3f       	cpi	r24, 0xFF	; 255
     844:	29 f0       	breq	.+10     	; 0x850 <receive_message+0xf2>
     846:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <switch_on>
     84a:	81 e0       	ldi	r24, 0x01	; 1
     84c:	8a 83       	std	Y+2, r24	; 0x02
     84e:	8b 83       	std	Y+3, r24	; 0x03
     850:	45 e0       	ldi	r20, 0x05	; 5
     852:	c7 cf       	rjmp	.-114    	; 0x7e2 <receive_message+0x84>
     854:	8c e1       	ldi	r24, 0x1C	; 28
     856:	c8 9f       	mul	r28, r24
     858:	e0 01       	movw	r28, r0
     85a:	11 24       	eor	r1, r1
     85c:	ca 5c       	subi	r28, 0xCA	; 202
     85e:	dc 4f       	sbci	r29, 0xFC	; 252
     860:	89 81       	ldd	r24, Y+1	; 0x01
     862:	8f 3f       	cpi	r24, 0xFF	; 255
     864:	f9 f0       	breq	.+62     	; 0x8a4 <receive_message+0x146>
     866:	82 81       	ldd	r24, Z+2	; 0x02
     868:	8e 83       	std	Y+6, r24	; 0x06
     86a:	82 81       	ldd	r24, Z+2	; 0x02
     86c:	80 93 7d 0b 	sts	0x0B7D, r24
     870:	19 c0       	rjmp	.+50     	; 0x8a4 <receive_message+0x146>
     872:	8c e1       	ldi	r24, 0x1C	; 28
     874:	c8 9f       	mul	r28, r24
     876:	e0 01       	movw	r28, r0
     878:	11 24       	eor	r1, r1
     87a:	ca 5c       	subi	r28, 0xCA	; 202
     87c:	dc 4f       	sbci	r29, 0xFC	; 252
     87e:	89 81       	ldd	r24, Y+1	; 0x01
     880:	8f 3f       	cpi	r24, 0xFF	; 255
     882:	81 f0       	breq	.+32     	; 0x8a4 <receive_message+0x146>
     884:	82 81       	ldd	r24, Z+2	; 0x02
     886:	8f 87       	std	Y+15, r24	; 0x0f
     888:	82 81       	ldd	r24, Z+2	; 0x02
     88a:	80 93 78 0b 	sts	0x0B78, r24
     88e:	0a c0       	rjmp	.+20     	; 0x8a4 <receive_message+0x146>
     890:	40 e0       	ldi	r20, 0x00	; 0
     892:	61 e0       	ldi	r22, 0x01	; 1
     894:	8f 2d       	mov	r24, r15
     896:	df 91       	pop	r29
     898:	cf 91       	pop	r28
     89a:	1f 91       	pop	r17
     89c:	0f 91       	pop	r16
     89e:	ff 90       	pop	r15
     8a0:	0c 94 7b 11 	jmp	0x22f6	; 0x22f6 <transmit_packet>
     8a4:	df 91       	pop	r29
     8a6:	cf 91       	pop	r28
     8a8:	1f 91       	pop	r17
     8aa:	0f 91       	pop	r16
     8ac:	ff 90       	pop	r15
     8ae:	08 95       	ret

000008b0 <StateofCharge>:
     8b0:	cf 93       	push	r28
     8b2:	90 91 6d 09 	lds	r25, 0x096D
     8b6:	9f 3f       	cpi	r25, 0xFF	; 255
     8b8:	09 f4       	brne	.+2      	; 0x8bc <StateofCharge+0xc>
     8ba:	c2 c0       	rjmp	.+388    	; 0xa40 <StateofCharge+0x190>
     8bc:	80 91 57 09 	lds	r24, 0x0957
     8c0:	88 23       	and	r24, r24
     8c2:	09 f4       	brne	.+2      	; 0x8c6 <StateofCharge+0x16>
     8c4:	bd c0       	rjmp	.+378    	; 0xa40 <StateofCharge+0x190>
     8c6:	80 91 6e 09 	lds	r24, 0x096E
     8ca:	88 23       	and	r24, r24
     8cc:	21 f0       	breq	.+8      	; 0x8d6 <StateofCharge+0x26>
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	80 93 a6 0d 	sts	0x0DA6, r24
     8d4:	02 c0       	rjmp	.+4      	; 0x8da <StateofCharge+0x2a>
     8d6:	10 92 a6 0d 	sts	0x0DA6, r1
     8da:	80 91 a6 0d 	lds	r24, 0x0DA6
     8de:	88 23       	and	r24, r24
     8e0:	19 f0       	breq	.+6      	; 0x8e8 <StateofCharge+0x38>
	}
  	percent = 100*(batt_time/charge_max_time);
     8e2:	9f 37       	cpi	r25, 0x7F	; 127
     8e4:	20 f0       	brcs	.+8      	; 0x8ee <StateofCharge+0x3e>
     8e6:	a0 c0       	rjmp	.+320    	; 0xa28 <StateofCharge+0x178>
     8e8:	98 37       	cpi	r25, 0x78	; 120
     8ea:	08 f0       	brcs	.+2      	; 0x8ee <StateofCharge+0x3e>
     8ec:	9d c0       	rjmp	.+314    	; 0xa28 <StateofCharge+0x178>
     8ee:	95 36       	cpi	r25, 0x65	; 101
     8f0:	08 f4       	brcc	.+2      	; 0x8f4 <StateofCharge+0x44>
     8f2:	95 c0       	rjmp	.+298    	; 0xa1e <StateofCharge+0x16e>
     8f4:	c0 91 06 03 	lds	r28, 0x0306
     8f8:	2c 2f       	mov	r18, r28
     8fa:	2f 5f       	subi	r18, 0xFF	; 255
     8fc:	20 93 06 03 	sts	0x0306, r18
     900:	88 23       	and	r24, r24
     902:	f1 f1       	breq	.+124    	; 0x980 <StateofCharge+0xd0>
     904:	80 91 81 0d 	lds	r24, 0x0D81
     908:	9a 36       	cpi	r25, 0x6A	; 106
     90a:	20 f4       	brcc	.+8      	; 0x914 <StateofCharge+0x64>
     90c:	82 95       	swap	r24
     90e:	86 95       	lsr	r24
     910:	86 95       	lsr	r24
     912:	0b c0       	rjmp	.+22     	; 0x92a <StateofCharge+0x7a>
     914:	29 2f       	mov	r18, r25
     916:	2a 56       	subi	r18, 0x6A	; 106
     918:	82 95       	swap	r24
     91a:	86 95       	lsr	r24
     91c:	86 95       	lsr	r24
     91e:	83 70       	andi	r24, 0x03	; 3
     920:	2a 30       	cpi	r18, 0x0A	; 10
  }
  
  // Percent limiting for periodic function
  if (percent < 1) 
     922:	10 f4       	brcc	.+4      	; 0x928 <StateofCharge+0x78>
     924:	8f 5f       	subi	r24, 0xFF	; 255
     926:	01 c0       	rjmp	.+2      	; 0x92a <StateofCharge+0x7a>
     928:	8e 5f       	subi	r24, 0xFE	; 254
     92a:	83 70       	andi	r24, 0x03	; 3
     92c:	80 93 99 0d 	sts	0x0D99, r24
     930:	e9 2f       	mov	r30, r25
     932:	f0 e0       	ldi	r31, 0x00	; 0
     934:	e5 56       	subi	r30, 0x65	; 101
     936:	f1 09       	sbc	r31, r1
     938:	ee 0f       	add	r30, r30
     93a:	ff 1f       	adc	r31, r31
     93c:	ee 0f       	add	r30, r30
     93e:	ff 1f       	adc	r31, r31
     940:	e8 0f       	add	r30, r24
     942:	f1 1d       	adc	r31, r1
     944:	ee 0f       	add	r30, r30
  { 
  	debug2 = 0xA0;
     946:	ff 1f       	adc	r31, r31
     948:	e4 57       	subi	r30, 0x74	; 116
     94a:	ff 4f       	sbci	r31, 0xFF	; 255
  	soc = 0; 
     94c:	65 91       	lpm	r22, Z+
     94e:	74 91       	lpm	r23, Z
     950:	6b 50       	subi	r22, 0x0B	; 11
  }
  else if (percent > 99) 
     952:	71 09       	sbc	r23, r1
     954:	80 e0       	ldi	r24, 0x00	; 0
     956:	90 e0       	ldi	r25, 0x00	; 0
     958:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <__floatunsisf>
     95c:	28 eb       	ldi	r18, 0xB8	; 184
     95e:	3e e1       	ldi	r19, 0x1E	; 30
     960:	49 e2       	ldi	r20, 0x29	; 41
     962:	51 e4       	ldi	r21, 0x41	; 65
     964:	0e 94 91 12 	call	0x2522	; 0x2522 <__divsf3>
  { 
  	debug2 = 0xB0;
     968:	60 93 2d 07 	sts	0x072D, r22
  	soc = 255;
     96c:	70 93 2e 07 	sts	0x072E, r23
     970:	80 93 2f 07 	sts	0x072F, r24
  }
  else { 
  	debug2 = 0xC0;
     974:	90 93 30 07 	sts	0x0730, r25
     978:	c9 5f       	subi	r28, 0xF9	; 249
  	soc = (char)floor((int)(percent)); 
     97a:	c0 93 06 03 	sts	0x0306, r28
     97e:	60 c0       	rjmp	.+192    	; 0xa40 <StateofCharge+0x190>
     980:	9a 36       	cpi	r25, 0x6A	; 106
     982:	30 f4       	brcc	.+12     	; 0x990 <StateofCharge+0xe0>
     984:	80 91 81 0d 	lds	r24, 0x0D81
     988:	82 95       	swap	r24
     98a:	86 95       	lsr	r24
     98c:	86 95       	lsr	r24
     98e:	17 c0       	rjmp	.+46     	; 0x9be <StateofCharge+0x10e>
     990:	89 2f       	mov	r24, r25
     992:	8a 56       	subi	r24, 0x6A	; 106
     994:	8a 30       	cpi	r24, 0x0A	; 10
     996:	40 f4       	brcc	.+16     	; 0x9a8 <StateofCharge+0xf8>
     998:	80 91 81 0d 	lds	r24, 0x0D81
  }
}
     99c:	82 95       	swap	r24
     99e:	86 95       	lsr	r24
     9a0:	86 95       	lsr	r24
     9a2:	83 70       	andi	r24, 0x03	; 3
     9a4:	8f 5f       	subi	r24, 0xFF	; 255
     9a6:	0b c0       	rjmp	.+22     	; 0x9be <StateofCharge+0x10e>
     9a8:	89 2f       	mov	r24, r25
     9aa:	84 57       	subi	r24, 0x74	; 116
     9ac:	83 30       	cpi	r24, 0x03	; 3
     9ae:	48 f4       	brcc	.+18     	; 0x9c2 <StateofCharge+0x112>
     9b0:	80 91 81 0d 	lds	r24, 0x0D81
     9b4:	82 95       	swap	r24
     9b6:	86 95       	lsr	r24
     9b8:	86 95       	lsr	r24
     9ba:	83 70       	andi	r24, 0x03	; 3
     9bc:	8e 5f       	subi	r24, 0xFE	; 254
     9be:	83 70       	andi	r24, 0x03	; 3
     9c0:	01 c0       	rjmp	.+2      	; 0x9c4 <StateofCharge+0x114>
     9c2:	80 e0       	ldi	r24, 0x00	; 0
				percent = (charge20Pc[(batt1_voltage - 0x65)*4 + ltOffset] - 11) / (10.57);
				antioptimizer+=6;
				
			}else{
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     9c4:	80 93 99 0d 	sts	0x0D99, r24
							((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
							((batt1_voltage >= 0x74) && (batt1_voltage <= 0x76)) ? (((batt1_voltageLow >> 6) + 2) % 0x04) :
							0x00;
				
				percent = 100 - ((discharge20Pc[(0x77 - batt1_voltage)*4 - ltOffset]) ) / (10.07);
     9c8:	e7 e7       	ldi	r30, 0x77	; 119
     9ca:	f0 e0       	ldi	r31, 0x00	; 0
     9cc:	e9 1b       	sub	r30, r25
     9ce:	f1 09       	sbc	r31, r1
     9d0:	ee 0f       	add	r30, r30
     9d2:	ff 1f       	adc	r31, r31
     9d4:	ee 0f       	add	r30, r30
     9d6:	ff 1f       	adc	r31, r31
     9d8:	e8 1b       	sub	r30, r24
     9da:	f1 09       	sbc	r31, r1
     9dc:	ee 0f       	add	r30, r30
     9de:	ff 1f       	adc	r31, r31
     9e0:	e8 59       	subi	r30, 0x98	; 152
     9e2:	fe 4f       	sbci	r31, 0xFE	; 254
     9e4:	65 91       	lpm	r22, Z+
     9e6:	74 91       	lpm	r23, Z
     9e8:	80 e0       	ldi	r24, 0x00	; 0
     9ea:	90 e0       	ldi	r25, 0x00	; 0
     9ec:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <__floatunsisf>
     9f0:	28 eb       	ldi	r18, 0xB8	; 184
     9f2:	3e e1       	ldi	r19, 0x1E	; 30
     9f4:	41 e2       	ldi	r20, 0x21	; 33
     9f6:	51 e4       	ldi	r21, 0x41	; 65
     9f8:	0e 94 91 12 	call	0x2522	; 0x2522 <__divsf3>
     9fc:	9b 01       	movw	r18, r22
     9fe:	ac 01       	movw	r20, r24
     a00:	60 e0       	ldi	r22, 0x00	; 0
     a02:	70 e0       	ldi	r23, 0x00	; 0
     a04:	88 ec       	ldi	r24, 0xC8	; 200
     a06:	92 e4       	ldi	r25, 0x42	; 66
     a08:	0e 94 28 12 	call	0x2450	; 0x2450 <__subsf3>
     a0c:	60 93 2d 07 	sts	0x072D, r22
     a10:	70 93 2e 07 	sts	0x072E, r23
     a14:	80 93 2f 07 	sts	0x072F, r24
     a18:	90 93 30 07 	sts	0x0730, r25
     a1c:	11 c0       	rjmp	.+34     	; 0xa40 <StateofCharge+0x190>
			}
		}else if(batt1_voltage <= 0x64){
			percent = -1;
     a1e:	80 e0       	ldi	r24, 0x00	; 0
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	a0 e8       	ldi	r26, 0x80	; 128
     a24:	bf eb       	ldi	r27, 0xBF	; 191
     a26:	04 c0       	rjmp	.+8      	; 0xa30 <StateofCharge+0x180>
		}else if(  ((batt1_voltage > 0x7E)&&isCharging) || ((!isCharging)&&(batt1_voltage > 0x77)) ){
			percent = 108;
     a28:	80 e0       	ldi	r24, 0x00	; 0
     a2a:	90 e0       	ldi	r25, 0x00	; 0
     a2c:	a8 ed       	ldi	r26, 0xD8	; 216
     a2e:	b2 e4       	ldi	r27, 0x42	; 66
     a30:	80 93 2d 07 	sts	0x072D, r24
     a34:	90 93 2e 07 	sts	0x072E, r25
     a38:	a0 93 2f 07 	sts	0x072F, r26
     a3c:	b0 93 30 07 	sts	0x0730, r27
		}
	}
	
	if(solar1_current < 0xFF && solar1_current > 0x00){
     a40:	80 91 6e 09 	lds	r24, 0x096E
     a44:	81 50       	subi	r24, 0x01	; 1
     a46:	8e 3f       	cpi	r24, 0xFE	; 254
     a48:	28 f4       	brcc	.+10     	; 0xa54 <StateofCharge+0x1a4>
		antioptimizer++;
     a4a:	80 91 06 03 	lds	r24, 0x0306
     a4e:	8f 5f       	subi	r24, 0xFF	; 255
     a50:	80 93 06 03 	sts	0x0306, r24
	}
	
	
}
     a54:	cf 91       	pop	r28
     a56:	08 95       	ret

00000a58 <assign_charge_fit>:



/* Assigns values to the Fourier coefficients of the charge approximation */
void assign_charge_fit( void ) {
  charge_max_time = 10188;
     a58:	80 e0       	ldi	r24, 0x00	; 0
     a5a:	90 e3       	ldi	r25, 0x30	; 48
     a5c:	af e1       	ldi	r26, 0x1F	; 31
     a5e:	b6 e4       	ldi	r27, 0x46	; 70
     a60:	80 93 74 09 	sts	0x0974, r24
     a64:	90 93 75 09 	sts	0x0975, r25
     a68:	a0 93 76 09 	sts	0x0976, r26
     a6c:	b0 93 77 09 	sts	0x0977, r27
  // x is normalized by mean 13.13 and std 0.1754
  p1 = 18.57;
     a70:	8c e5       	ldi	r24, 0x5C	; 92
     a72:	9f e8       	ldi	r25, 0x8F	; 143
     a74:	a4 e9       	ldi	r26, 0x94	; 148
     a76:	b1 e4       	ldi	r27, 0x41	; 65
     a78:	80 93 46 09 	sts	0x0946, r24
     a7c:	90 93 47 09 	sts	0x0947, r25
     a80:	a0 93 48 09 	sts	0x0948, r26
     a84:	b0 93 49 09 	sts	0x0949, r27
  p2 = 184.8;
     a88:	8d ec       	ldi	r24, 0xCD	; 205
     a8a:	9c ec       	ldi	r25, 0xCC	; 204
     a8c:	a8 e3       	ldi	r26, 0x38	; 56
     a8e:	b3 e4       	ldi	r27, 0x43	; 67
     a90:	80 93 23 03 	sts	0x0323, r24
     a94:	90 93 24 03 	sts	0x0324, r25
     a98:	a0 93 25 03 	sts	0x0325, r26
     a9c:	b0 93 26 03 	sts	0x0326, r27
  p3 = 663.6;
     aa0:	86 e6       	ldi	r24, 0x66	; 102
     aa2:	96 ee       	ldi	r25, 0xE6	; 230
     aa4:	a5 e2       	ldi	r26, 0x25	; 37
     aa6:	b4 e4       	ldi	r27, 0x44	; 68
     aa8:	80 93 8d 0d 	sts	0x0D8D, r24
     aac:	90 93 8e 0d 	sts	0x0D8E, r25
     ab0:	a0 93 8f 0d 	sts	0x0D8F, r26
     ab4:	b0 93 90 0d 	sts	0x0D90, r27
  p4 = 838.6;
     ab8:	86 e6       	ldi	r24, 0x66	; 102
     aba:	96 ea       	ldi	r25, 0xA6	; 166
     abc:	a1 e5       	ldi	r26, 0x51	; 81
     abe:	b4 e4       	ldi	r27, 0x44	; 68
     ac0:	80 93 a9 0d 	sts	0x0DA9, r24
     ac4:	90 93 aa 0d 	sts	0x0DAA, r25
     ac8:	a0 93 ab 0d 	sts	0x0DAB, r26
     acc:	b0 93 ac 0d 	sts	0x0DAC, r27
  //where x is normalized by mean 13.7 and std 0.1558
  q1 = 78.49;
     ad0:	81 ee       	ldi	r24, 0xE1	; 225
     ad2:	9a ef       	ldi	r25, 0xFA	; 250
     ad4:	ac e9       	ldi	r26, 0x9C	; 156
     ad6:	b2 e4       	ldi	r27, 0x42	; 66
     ad8:	80 93 68 09 	sts	0x0968, r24
     adc:	90 93 69 09 	sts	0x0969, r25
     ae0:	a0 93 6a 09 	sts	0x096A, r26
     ae4:	b0 93 6b 09 	sts	0x096B, r27
  q2 = 543.1;
     ae8:	86 e6       	ldi	r24, 0x66	; 102
     aea:	96 ec       	ldi	r25, 0xC6	; 198
     aec:	a7 e0       	ldi	r26, 0x07	; 7
     aee:	b4 e4       	ldi	r27, 0x44	; 68
     af0:	80 93 26 07 	sts	0x0726, r24
     af4:	90 93 27 07 	sts	0x0727, r25
     af8:	a0 93 28 07 	sts	0x0728, r26
     afc:	b0 93 29 07 	sts	0x0729, r27
  q3 = 2427;
     b00:	80 e0       	ldi	r24, 0x00	; 0
     b02:	90 eb       	ldi	r25, 0xB0	; 176
     b04:	a7 e1       	ldi	r26, 0x17	; 23
     b06:	b5 e4       	ldi	r27, 0x45	; 69
     b08:	80 93 64 09 	sts	0x0964, r24
     b0c:	90 93 65 09 	sts	0x0965, r25
     b10:	a0 93 66 09 	sts	0x0966, r26
     b14:	b0 93 67 09 	sts	0x0967, r27
  q4 = 5587;
     b18:	80 e0       	ldi	r24, 0x00	; 0
     b1a:	98 e9       	ldi	r25, 0x98	; 152
     b1c:	ae ea       	ldi	r26, 0xAE	; 174
     b1e:	b5 e4       	ldi	r27, 0x45	; 69
     b20:	80 93 9e 0d 	sts	0x0D9E, r24
     b24:	90 93 9f 0d 	sts	0x0D9F, r25
     b28:	a0 93 a0 0d 	sts	0x0DA0, r26
     b2c:	b0 93 a1 0d 	sts	0x0DA1, r27
     b30:	08 95       	ret

00000b32 <assign_discharge_fit>:
}

/* Assigns values to the Fourier coefficients of the discharge approximation */

void assign_discharge_fit( void ) {
  discharge_max_time = 17547;
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	96 e1       	ldi	r25, 0x16	; 22
     b36:	a9 e8       	ldi	r26, 0x89	; 137
     b38:	b6 e4       	ldi	r27, 0x46	; 70
     b3a:	80 93 3b 07 	sts	0x073B, r24
     b3e:	90 93 3c 07 	sts	0x073C, r25
     b42:	a0 93 3d 07 	sts	0x073D, r26
     b46:	b0 93 3e 07 	sts	0x073E, r27
  f0 = -1.543291233254410E4;
     b4a:	88 eb       	ldi	r24, 0xB8	; 184
     b4c:	93 ec       	ldi	r25, 0xC3	; 195
     b4e:	90 93 8a 0d 	sts	0x0D8A, r25
     b52:	80 93 89 0d 	sts	0x0D89, r24
  f1 = -1.819810644993805E4;
     b56:	8a ee       	ldi	r24, 0xEA	; 234
     b58:	98 eb       	ldi	r25, 0xB8	; 184
     b5a:	90 93 94 0d 	sts	0x0D94, r25
     b5e:	80 93 93 0d 	sts	0x0D93, r24
  b1 = -2.548949173344369E4;
     b62:	8f e6       	ldi	r24, 0x6F	; 111
     b64:	9c e9       	ldi	r25, 0x9C	; 156
     b66:	90 93 2b 07 	sts	0x072B, r25
     b6a:	80 93 2a 07 	sts	0x072A, r24
  f2 = 1.141365113433748E4;
     b6e:	85 e9       	ldi	r24, 0x95	; 149
     b70:	9c e2       	ldi	r25, 0x2C	; 44
     b72:	90 93 5d 09 	sts	0x095D, r25
     b76:	80 93 5c 09 	sts	0x095C, r24
  b2 = -2.190399298389397E4;
     b7a:	81 e7       	ldi	r24, 0x71	; 113
     b7c:	9a ea       	ldi	r25, 0xAA	; 170
     b7e:	90 93 21 03 	sts	0x0321, r25
     b82:	80 93 20 03 	sts	0x0320, r24
  f3 = 1.453849538420288E4;
     b86:	8a ec       	ldi	r24, 0xCA	; 202
     b88:	98 e3       	ldi	r25, 0x38	; 56
     b8a:	90 93 51 09 	sts	0x0951, r25
     b8e:	80 93 50 09 	sts	0x0950, r24
  b3 = 7.700208204268025E2;
     b92:	82 e0       	ldi	r24, 0x02	; 2
     b94:	93 e0       	ldi	r25, 0x03	; 3
     b96:	90 93 8c 0d 	sts	0x0D8C, r25
     b9a:	80 93 8b 0d 	sts	0x0D8B, r24
  f4 = 1.965482651710955E3;
     b9e:	8d ea       	ldi	r24, 0xAD	; 173
     ba0:	97 e0       	ldi	r25, 0x07	; 7
     ba2:	90 93 92 0d 	sts	0x0D92, r25
     ba6:	80 93 91 0d 	sts	0x0D91, r24
  b4 = 5.504490550919407E3;
     baa:	80 e8       	ldi	r24, 0x80	; 128
     bac:	95 e1       	ldi	r25, 0x15	; 21
     bae:	90 93 45 07 	sts	0x0745, r25
     bb2:	80 93 44 07 	sts	0x0744, r24
  f5 = -9.466488439471518E2;
     bb6:	8e e4       	ldi	r24, 0x4E	; 78
     bb8:	9c ef       	ldi	r25, 0xFC	; 252
     bba:	90 93 43 07 	sts	0x0743, r25
     bbe:	80 93 42 07 	sts	0x0742, r24
  b5 = 8.270458368650347E2;
     bc2:	8b e3       	ldi	r24, 0x3B	; 59
     bc4:	93 e0       	ldi	r25, 0x03	; 3
     bc6:	90 93 88 0d 	sts	0x0D88, r25
     bca:	80 93 87 0d 	sts	0x0D87, r24
  w = 2.725333178515558;
     bce:	8c ed       	ldi	r24, 0xDC	; 220
     bd0:	9b e6       	ldi	r25, 0x6B	; 107
     bd2:	ae e2       	ldi	r26, 0x2E	; 46
     bd4:	b0 e4       	ldi	r27, 0x40	; 64
     bd6:	80 93 31 07 	sts	0x0731, r24
     bda:	90 93 32 07 	sts	0x0732, r25
     bde:	a0 93 33 07 	sts	0x0733, r26
     be2:	b0 93 34 07 	sts	0x0734, r27
  
  h0 = 2.979485572689352E8;
     be6:	80 e8       	ldi	r24, 0x80	; 128
     be8:	95 e5       	ldi	r25, 0x55	; 85
     bea:	a2 ec       	ldi	r26, 0xC2	; 194
     bec:	b1 e1       	ldi	r27, 0x11	; 17
     bee:	80 93 58 09 	sts	0x0958, r24
     bf2:	90 93 59 09 	sts	0x0959, r25
     bf6:	a0 93 5a 09 	sts	0x095A, r26
     bfa:	b0 93 5b 09 	sts	0x095B, r27
  h1 = 2.088787459098652E8;
     bfe:	80 ea       	ldi	r24, 0xA0	; 160
     c00:	9c e3       	ldi	r25, 0x3C	; 60
     c02:	a3 e7       	ldi	r26, 0x73	; 115
     c04:	bc e0       	ldi	r27, 0x0C	; 12
     c06:	80 93 2b 03 	sts	0x032B, r24
     c0a:	90 93 2c 03 	sts	0x032C, r25
     c0e:	a0 93 2d 03 	sts	0x032D, r26
     c12:	b0 93 2e 03 	sts	0x032E, r27
  g1 = 4.359717315569648E8;
     c16:	80 ea       	ldi	r24, 0xA0	; 160
     c18:	96 e6       	ldi	r25, 0x66	; 102
     c1a:	ac ef       	ldi	r26, 0xFC	; 252
     c1c:	b9 e1       	ldi	r27, 0x19	; 25
     c1e:	80 93 30 03 	sts	0x0330, r24
     c22:	90 93 31 03 	sts	0x0331, r25
     c26:	a0 93 32 03 	sts	0x0332, r26
     c2a:	b0 93 33 03 	sts	0x0333, r27
  h2 =  -1.569778955752849E8;
     c2e:	80 e2       	ldi	r24, 0x20	; 32
     c30:	95 eb       	ldi	r25, 0xB5	; 181
     c32:	a4 ea       	ldi	r26, 0xA4	; 164
     c34:	b6 ef       	ldi	r27, 0xF6	; 246
     c36:	80 93 53 09 	sts	0x0953, r24
     c3a:	90 93 54 09 	sts	0x0954, r25
     c3e:	a0 93 55 09 	sts	0x0955, r26
     c42:	b0 93 56 09 	sts	0x0956, r27
  g2 =  1.969854815603661E8;
     c46:	80 e9       	ldi	r24, 0x90	; 144
     c48:	92 ec       	ldi	r25, 0xC2	; 194
     c4a:	ad eb       	ldi	r26, 0xBD	; 189
     c4c:	bb e0       	ldi	r27, 0x0B	; 11
     c4e:	80 93 4b 09 	sts	0x094B, r24
     c52:	90 93 4c 09 	sts	0x094C, r25
     c56:	a0 93 4d 09 	sts	0x094D, r26
     c5a:	b0 93 4e 09 	sts	0x094E, r27
  h3 =  -7.513816845838763E7;
     c5e:	88 e8       	ldi	r24, 0x88	; 136
     c60:	9b e7       	ldi	r25, 0x7B	; 123
     c62:	a5 e8       	ldi	r26, 0x85	; 133
     c64:	bb ef       	ldi	r27, 0xFB	; 251
     c66:	80 93 95 0d 	sts	0x0D95, r24
     c6a:	90 93 96 0d 	sts	0x0D96, r25
     c6e:	a0 93 97 0d 	sts	0x0D97, r26
     c72:	b0 93 98 0d 	sts	0x0D98, r27
  g3 =  -1.633385950799686E7;
     c76:	8c ed       	ldi	r24, 0xDC	; 220
     c78:	93 ec       	ldi	r25, 0xC3	; 195
     c7a:	a6 e0       	ldi	r26, 0x06	; 6
     c7c:	bf ef       	ldi	r27, 0xFF	; 255
     c7e:	80 93 1c 03 	sts	0x031C, r24
     c82:	90 93 1d 03 	sts	0x031D, r25
     c86:	a0 93 1e 03 	sts	0x031E, r26
     c8a:	b0 93 1f 03 	sts	0x031F, r27
  h4 =   -2.642581886559125E6;
     c8e:	8a e6       	ldi	r24, 0x6A	; 106
     c90:	9d ea       	ldi	r25, 0xAD	; 173
     c92:	a7 ed       	ldi	r26, 0xD7	; 215
     c94:	bf ef       	ldi	r27, 0xFF	; 255
     c96:	80 93 7d 0d 	sts	0x0D7D, r24
     c9a:	90 93 7e 0d 	sts	0x0D7E, r25
     c9e:	a0 93 7f 0d 	sts	0x0D7F, r26
     ca2:	b0 93 80 0d 	sts	0x0D80, r27
  g4 =   -1.016608352073227E7;
     ca6:	8c eb       	ldi	r24, 0xBC	; 188
     ca8:	90 ee       	ldi	r25, 0xE0	; 224
     caa:	a4 e6       	ldi	r26, 0x64	; 100
     cac:	bf ef       	ldi	r27, 0xFF	; 255
     cae:	80 93 07 03 	sts	0x0307, r24
     cb2:	90 93 08 03 	sts	0x0308, r25
     cb6:	a0 93 09 03 	sts	0x0309, r26
     cba:	b0 93 0a 03 	sts	0x030A, r27
  w2 =  0.364797662747743;
     cbe:	82 ec       	ldi	r24, 0xC2	; 194
     cc0:	96 ec       	ldi	r25, 0xC6	; 198
     cc2:	aa eb       	ldi	r26, 0xBA	; 186
     cc4:	be e3       	ldi	r27, 0x3E	; 62
     cc6:	80 93 79 0b 	sts	0x0B79, r24
     cca:	90 93 7a 0b 	sts	0x0B7A, r25
     cce:	a0 93 7b 0b 	sts	0x0B7B, r26
     cd2:	b0 93 7c 0b 	sts	0x0B7C, r27
     cd6:	08 95       	ret

00000cd8 <initialize>:
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       6     );  // Fake Data
}

void initialize( void )
{
     cd8:	ef 92       	push	r14
     cda:	ff 92       	push	r15
     cdc:	0f 93       	push	r16
     cde:	1f 93       	push	r17
     ce0:	cf 93       	push	r28
     ce2:	df 93       	push	r29
   // pin initialization
  DDRA  = 0b11111111;
     ce4:	1f ef       	ldi	r17, 0xFF	; 255
     ce6:	1a bb       	out	0x1a, r17	; 26
  PORTA = 0b00000111;
     ce8:	87 e0       	ldi	r24, 0x07	; 7
     cea:	8b bb       	out	0x1b, r24	; 27

  DDRB  = 0b11111111;
     cec:	17 bb       	out	0x17, r17	; 23
  PORTB = 0b11100000;
     cee:	80 ee       	ldi	r24, 0xE0	; 224
     cf0:	88 bb       	out	0x18, r24	; 24

  DDRC  = 0b11111111;
     cf2:	14 bb       	out	0x14, r17	; 20
  PORTC = 0b11111111;
     cf4:	15 bb       	out	0x15, r17	; 21

  DDRD  = 0b11111011;
     cf6:	8b ef       	ldi	r24, 0xFB	; 251
     cf8:	81 bb       	out	0x11, r24	; 17
  PORTD = 0b11110000;
     cfa:	80 ef       	ldi	r24, 0xF0	; 240
     cfc:	82 bb       	out	0x12, r24	; 18

  DDRE  = 0b11111110;
     cfe:	9e ef       	ldi	r25, 0xFE	; 254
     d00:	92 b9       	out	0x02, r25	; 2
  PORTE = 0b00000000;
     d02:	13 b8       	out	0x03, r1	; 3

  DDRF  = 0b11110000;
     d04:	80 93 61 00 	sts	0x0061, r24
  //0b11111111;	//testing
  PORTF = 0b00000000;
     d08:	10 92 62 00 	sts	0x0062, r1

  DDRG  = 0b00011111;
     d0c:	8f e1       	ldi	r24, 0x1F	; 31
     d0e:	80 93 64 00 	sts	0x0064, r24
  PORTG = 0b00000100;
     d12:	04 e0       	ldi	r16, 0x04	; 4
     d14:	00 93 65 00 	sts	0x0065, r16
  // compare value = 124
  // compare match interrupt freq = (14.7456 MHz / 1024 / 100) = 144 Hz
  // use timer0_counter to get 144 / 144 = 1 Hz

  // enable clear on match interrupt
  TIMSK = ( 1 << OCIE0 );
     d18:	82 e0       	ldi	r24, 0x02	; 2
     d1a:	87 bf       	out	0x37, r24	; 55
  OCR0 = 71;
     d1c:	87 e4       	ldi	r24, 0x47	; 71
     d1e:	81 bf       	out	0x31, r24	; 49

  // enable clear on match mode, set prescalar to 1024
  TCCR0 = ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );
     d20:	8f e0       	ldi	r24, 0x0F	; 15
     d22:	83 bf       	out	0x33, r24	; 51

  timer0_counter[0] = 99;
     d24:	83 e6       	ldi	r24, 0x63	; 99
     d26:	80 93 76 0b 	sts	0x0B76, r24
  timer0_counter[1] = 199;
     d2a:	87 ec       	ldi	r24, 0xC7	; 199
     d2c:	80 93 77 0b 	sts	0x0B77, r24
  period of interrupts = 28800 / 14400 Hz = 2 s/interrupt
  use timer1_counter to get a total period of 2*65535 =  s (24 hours is 86400 seconds)
  */
  
  // Enable clear on match interrupt for the 16 bit timer/counter 1, register A
  OCR1A = 28800;		//28800 corresponds to 2 seconds
     d30:	80 e8       	ldi	r24, 0x80	; 128
     d32:	90 e7       	ldi	r25, 0x70	; 112
     d34:	9b bd       	out	0x2b, r25	; 43
     d36:	8a bd       	out	0x2a, r24	; 42

  // Enable clear on match mode, set prescalar to 1024.
  // CS[2:0] = 101 (1024 prescalar)
  // WGM[3:0] = 0100 (Clear Timer on Compare (CTC) when timer matches OCR1A)
  
  TCCR1B = ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS10 );
     d38:	8d e0       	ldi	r24, 0x0D	; 13
     d3a:	8e bd       	out	0x2e, r24	; 46
  // Explicit Default Defs
  // TCCR1A |= 0;
  // TCNT1 = 0;
  timer1_counter[0] = CYCLE_COUNTER;	//CYCLE_COUNTER   = 900 for 2 seconds interrupt handler = 1800 secs (30 minutes)
     d3c:	84 e8       	ldi	r24, 0x84	; 132
     d3e:	80 93 9a 0d 	sts	0x0D9A, r24
  timer1_counter[1] = CYCLE_COUNTER_2;	//CYCLE_COUNTER_2 = 300 for 2 seconds interrupt handler = 600 secs  (10 minutes)
     d42:	8c e2       	ldi	r24, 0x2C	; 44
     d44:	80 93 9b 0d 	sts	0x0D9B, r24
  //---------------------------------------------------------------------  
  // End of timer 1 Setup
  //--------------------------------------------------------------------- 
  
  // communication
  uart_init();
     d48:	0e 94 de 0a 	call	0x15bc	; 0x15bc <uart_init>

  // for use in debugging
  // stdout = stdin = stderr = &uart_str;

  tel_packet_size[0] = 0;
     d4c:	10 92 28 03 	sts	0x0328, r1
     d50:	10 92 27 03 	sts	0x0327, r1
  tel_packet_size[1] = 0;
     d54:	10 92 2a 03 	sts	0x032A, r1
     d58:	10 92 29 03 	sts	0x0329, r1
  tel_packet_index[0] = 0;
     d5c:	10 92 3f 07 	sts	0x073F, r1
  tel_packet_index[1] = 0;
     d60:	10 92 40 07 	sts	0x0740, r1
  uart_vcp_buff[0] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     d64:	8a e0       	ldi	r24, 0x0A	; 10
     d66:	90 e0       	ldi	r25, 0x00	; 0
     d68:	0e 94 d7 13 	call	0x27ae	; 0x27ae <malloc>
     d6c:	7c 01       	movw	r14, r24
     d6e:	e2 ea       	ldi	r30, 0xA2	; 162
     d70:	fd e0       	ldi	r31, 0x0D	; 13
     d72:	80 83       	st	Z, r24
     d74:	f1 82       	std	Z+1, r15	; 0x01
  uart_vcp_buff[1] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     d76:	8a e0       	ldi	r24, 0x0A	; 10
     d78:	90 e0       	ldi	r25, 0x00	; 0
     d7a:	0e 94 d7 13 	call	0x27ae	; 0x27ae <malloc>
     d7e:	c4 ea       	ldi	r28, 0xA4	; 164
     d80:	dd e0       	ldi	r29, 0x0D	; 13
     d82:	88 83       	st	Y, r24
     d84:	99 83       	std	Y+1, r25	; 0x01
  vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     d86:	4f ef       	ldi	r20, 0xFF	; 255
     d88:	50 e0       	ldi	r21, 0x00	; 0
     d8a:	6f e7       	ldi	r22, 0x7F	; 127
     d8c:	7b e0       	ldi	r23, 0x0B	; 11
     d8e:	c7 01       	movw	r24, r14
     d90:	0e 94 04 0b 	call	0x1608	; 0x1608 <vcpptr_init>
  vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     d94:	4f ef       	ldi	r20, 0xFF	; 255
     d96:	50 e0       	ldi	r21, 0x00	; 0
     d98:	6e e7       	ldi	r22, 0x7E	; 126
     d9a:	7c e0       	ldi	r23, 0x0C	; 12
     d9c:	88 81       	ld	r24, Y
     d9e:	99 81       	ldd	r25, Y+1	; 0x01
     da0:	0e 94 04 0b 	call	0x1608	; 0x1608 <vcpptr_init>

  rx_flag[0] = 0;
     da4:	10 92 a7 0d 	sts	0x0DA7, r1
  rx_flag[1] = 0;
     da8:	10 92 a8 0d 	sts	0x0DA8, r1

  // svit
  initialize_svit();
     dac:	0e 94 44 01 	call	0x288	; 0x288 <initialize_svit>

  // rev up those interrupts
  sei();
     db0:	78 94       	sei

  //ADC conversions
  adc_flag = 1;
     db2:	c1 e0       	ldi	r28, 0x01	; 1
     db4:	c0 93 45 09 	sts	0x0945, r28
	adc_component = 0;
     db8:	10 92 35 03 	sts	0x0335, r1
	adc_sensor_type = ADC_INIT;//get default case on first interation as to not enter switch
     dbc:	00 93 52 09 	sts	0x0952, r16
  ADC_high = 0;
     dc0:	10 92 63 09 	sts	0x0963, r1

  V_upper_val_change = 0;
     dc4:	10 92 7d 0b 	sts	0x0B7D, r1
  I_upper_val_change = 0;
     dc8:	10 92 78 0b 	sts	0x0B78, r1

  //---------------------------------------------------------------------  
  // SOC Initializations
  //--------------------------------------------------------------------- 
  // and shunt and safe transmit flags
  safe_mode = 0;
     dcc:	10 92 4f 09 	sts	0x094F, r1
  transmit_safe = 0;
     dd0:	10 92 4a 09 	sts	0x094A, r1
  transmit_shunt = 0;
     dd4:	10 92 86 0d 	sts	0x0D86, r1
  been_to_safe = 0;
     dd8:	10 92 2f 03 	sts	0x032F, r1
  been_to_shunt = 0;
     ddc:	10 92 6f 09 	sts	0x096F, r1
  assign_charge_fit();
     de0:	0e 94 2c 05 	call	0xa58	; 0xa58 <assign_charge_fit>
  assign_discharge_fit();
     de4:	0e 94 99 05 	call	0xb32	; 0xb32 <assign_discharge_fit>
  
  // First get battery voltage so that the SoC can
  // accurately determine whether batteries are charging or discharging
  batt1_voltage = 0xff;
     de8:	10 93 6d 09 	sts	0x096D, r17
  batt2_voltage = 0xff;
     dec:	10 93 7e 0b 	sts	0x0B7E, r17
  charging = 0xff;
     df0:	10 93 36 07 	sts	0x0736, r17
  chargeforward = 0;
     df4:	10 92 9d 0d 	sts	0x0D9D, r1
  chargebackward = 0;
     df8:	10 92 34 03 	sts	0x0334, r1
  debug = 0;
     dfc:	10 92 35 07 	sts	0x0735, r1
  debug2 = 0;
     e00:	10 92 41 07 	sts	0x0741, r1
  percent = 0;
     e04:	10 92 2d 07 	sts	0x072D, r1
     e08:	10 92 2e 07 	sts	0x072E, r1
     e0c:	10 92 2f 07 	sts	0x072F, r1
     e10:	10 92 30 07 	sts	0x0730, r1
  soc = 0;
     e14:	10 92 ab 0f 	sts	0x0FAB, r1
  high = 0;
     e18:	10 92 5e 09 	sts	0x095E, r1
  low = 0;
     e1c:	10 92 6c 09 	sts	0x096C, r1
  limit_check_overriden = 0; // Initially limit checking is NOT OVERRIDEN
     e20:	10 92 2c 07 	sts	0x072C, r1
  isCharging = 0;
     e24:	10 92 a6 0d 	sts	0x0DA6, r1
  hasCheckedCurr = 0;
     e28:	10 92 57 09 	sts	0x0957, r1
  //--------------------------------------------------------------------- 

  //---------------------------------------------------------------------  
  // Timer Initializations
  //---------------------------------------------------------------------
  cdh_heartbeat_flag = 0;	//Default: do not have flag to restart components on
     e2c:	10 92 22 03 	sts	0x0322, r1
  rad_torq_flag = 1;		//Indicates need to delay radio/torquer on signals later
     e30:	c0 93 0b 03 	sts	0x030B, r28
  SVIT_t *component; 	// Initialize Radios to be OFF
  component = &svit[components[RADIO_1]];
     e34:	a0 91 17 03 	lds	r26, 0x0317
     e38:	cc e1       	ldi	r28, 0x1C	; 28
     e3a:	ca 9f       	mul	r28, r26
     e3c:	d0 01       	movw	r26, r0
     e3e:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     e40:	aa 5c       	subi	r26, 0xCA	; 202
     e42:	bc 4f       	sbci	r27, 0xFC	; 252
     e44:	11 96       	adiw	r26, 0x01	; 1
     e46:	8c 91       	ld	r24, X
     e48:	0e 94 3b 09 	call	0x1276	; 0x1276 <switch_off>
  component = &svit[components[RADIO_2]];
     e4c:	e0 91 18 03 	lds	r30, 0x0318
     e50:	ce 9f       	mul	r28, r30
     e52:	f0 01       	movw	r30, r0
     e54:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     e56:	ea 5c       	subi	r30, 0xCA	; 202
     e58:	fc 4f       	sbci	r31, 0xFC	; 252
     e5a:	81 81       	ldd	r24, Z+1	; 0x01
     e5c:	0e 94 3b 09 	call	0x1276	; 0x1276 <switch_off>
  component = &svit[TORQUER_1];	// Initialize Torque Coils to be OFF
  component->switch_state = SW_OFF;
     e60:	10 92 14 05 	sts	0x0514, r1
  component = &svit[TORQUER_2];
  component->switch_state = SW_OFF;
     e64:	10 92 30 05 	sts	0x0530, r1
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
     e68:	10 92 4c 05 	sts	0x054C, r1
  torquer_off(TORQUER_1);
     e6c:	81 e1       	ldi	r24, 0x11	; 17
     e6e:	0e 94 c1 08 	call	0x1182	; 0x1182 <torquer_off>
  torquer_off(TORQUER_2);
     e72:	82 e1       	ldi	r24, 0x12	; 18
     e74:	0e 94 c1 08 	call	0x1182	; 0x1182 <torquer_off>
  torquer_off(TORQUER_3);
     e78:	83 e1       	ldi	r24, 0x13	; 19
  //---------------------------------------------------------------------  
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}
     e7a:	df 91       	pop	r29
     e7c:	cf 91       	pop	r28
     e7e:	1f 91       	pop	r17
     e80:	0f 91       	pop	r16
     e82:	ff 90       	pop	r15
     e84:	ef 90       	pop	r14
  component->switch_state = SW_OFF;
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
  torquer_off(TORQUER_1);
  torquer_off(TORQUER_2);
  torquer_off(TORQUER_3);
     e86:	0c 94 c1 08 	jmp	0x1182	; 0x1182 <torquer_off>

00000e8a <compareVoltage>:
void compareVoltage( void ) {
  SVIT_t *component;
  //component = &svit[BATTERY_1_b];
  //chargebackward = average_samples( component->I_samples );
  component = &svit[BATTERY_1];
  chargeforward= average_samples( component->I_samples );
     e8a:	87 e7       	ldi	r24, 0x77	; 119
     e8c:	95 e0       	ldi	r25, 0x05	; 5
     e8e:	0e 94 7e 09 	call	0x12fc	; 0x12fc <average_samples>
     e92:	80 93 9d 0d 	sts	0x0D9D, r24
  if (chargeforward > 2){
     e96:	83 30       	cpi	r24, 0x03	; 3
     e98:	10 f0       	brcs	.+4      	; 0xe9e <compareVoltage+0x14>
    charging = 0xdd;//discharging
     e9a:	8d ed       	ldi	r24, 0xDD	; 221
     e9c:	01 c0       	rjmp	.+2      	; 0xea0 <compareVoltage+0x16>
    }
  else{
    charging = 0xcc;
     e9e:	8c ec       	ldi	r24, 0xCC	; 204
     ea0:	80 93 36 07 	sts	0x0736, r24
     ea4:	08 95       	ret

00000ea6 <limit_check>:
we should at least get the framework set up for limit checking on arbitrary values.
The power board should have upper and lower limits for vsense and csense data, 
and turn off components if their voltage/current is too high. ONLY CHECKS
BATTERY 1 VOLTAGE LINE RIGHT NOW.
*/
void limit_check( void ) {
     ea6:	cf 92       	push	r12
     ea8:	df 92       	push	r13
     eaa:	ef 92       	push	r14
     eac:	ff 92       	push	r15
     eae:	0f 93       	push	r16
     eb0:	1f 93       	push	r17
     eb2:	cf 93       	push	r28
     eb4:	df 93       	push	r29
	unsigned char sw;
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
     eb6:	c0 90 2d 07 	lds	r12, 0x072D
     eba:	d0 90 2e 07 	lds	r13, 0x072E
     ebe:	e0 90 2f 07 	lds	r14, 0x072F
     ec2:	f0 90 30 07 	lds	r15, 0x0730
     ec6:	20 e0       	ldi	r18, 0x00	; 0
     ec8:	30 e0       	ldi	r19, 0x00	; 0
     eca:	a9 01       	movw	r20, r18
     ecc:	c7 01       	movw	r24, r14
     ece:	b6 01       	movw	r22, r12
     ed0:	0e 94 8d 12 	call	0x251a	; 0x251a <__cmpsf2>
     ed4:	87 ff       	sbrs	r24, 7
     ed6:	4c c0       	rjmp	.+152    	; 0xf70 <limit_check+0xca>
     ed8:	29 e2       	ldi	r18, 0x29	; 41
     eda:	3c e5       	ldi	r19, 0x5C	; 92
     edc:	4f e0       	ldi	r20, 0x0F	; 15
     ede:	5f eb       	ldi	r21, 0xBF	; 191
     ee0:	c7 01       	movw	r24, r14
     ee2:	b6 01       	movw	r22, r12
     ee4:	0e 94 8d 12 	call	0x251a	; 0x251a <__cmpsf2>
     ee8:	87 ff       	sbrs	r24, 7
     eea:	0a c0       	rjmp	.+20     	; 0xf00 <limit_check+0x5a>
     eec:	25 e8       	ldi	r18, 0x85	; 133
     eee:	3b ee       	ldi	r19, 0xEB	; 235
     ef0:	41 e1       	ldi	r20, 0x11	; 17
     ef2:	5f eb       	ldi	r21, 0xBF	; 191
     ef4:	c7 01       	movw	r24, r14
     ef6:	b6 01       	movw	r22, r12
     ef8:	0e 94 ab 13 	call	0x2756	; 0x2756 <__gesf2>
     efc:	18 16       	cp	r1, r24
     efe:	c4 f1       	brlt	.+112    	; 0xf70 <limit_check+0xca>
		safe_mode = 1;
     f00:	81 e0       	ldi	r24, 0x01	; 1
     f02:	80 93 4f 09 	sts	0x094F, r24
     f06:	0c e0       	ldi	r16, 0x0C	; 12
     f08:	13 e0       	ldi	r17, 0x03	; 3
		for (sw = 0; sw < sizeof(components); sw++) {
			component = &svit[components[sw]];
     f0a:	3c e1       	ldi	r19, 0x1C	; 28
     f0c:	f3 2e       	mov	r15, r19
     f0e:	f8 01       	movw	r30, r16
     f10:	c1 91       	ld	r28, Z+
     f12:	8f 01       	movw	r16, r30
     f14:	fc 9e       	mul	r15, r28
     f16:	e0 01       	movw	r28, r0
     f18:	11 24       	eor	r1, r1
     f1a:	ca 5c       	subi	r28, 0xCA	; 202
     f1c:	dc 4f       	sbci	r29, 0xFC	; 252
			switch_off( component->switch_num );
     f1e:	89 81       	ldd	r24, Y+1	; 0x01
     f20:	0e 94 3b 09 	call	0x1276	; 0x1276 <switch_off>
			component->switch_state = SW_OFF;
     f24:	1a 82       	std	Y+2, r1	; 0x02
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
		safe_mode = 1;
		for (sw = 0; sw < sizeof(components); sw++) {
     f26:	f3 e0       	ldi	r31, 0x03	; 3
     f28:	0c 31       	cpi	r16, 0x1C	; 28
     f2a:	1f 07       	cpc	r17, r31
     f2c:	81 f7       	brne	.-32     	; 0xf0e <limit_check+0x68>
			component = &svit[components[sw]];
			switch_off( component->switch_num );
			component->switch_state = SW_OFF;
		}
		component = &svit[TORQUER_1];
		component->switch_state = SW_OFF;
     f2e:	10 92 14 05 	sts	0x0514, r1
		component = &svit[TORQUER_2];
		component->switch_state = SW_OFF;
     f32:	10 92 30 05 	sts	0x0530, r1
		component = &svit[TORQUER_3];
		component->switch_state = SW_OFF;
     f36:	10 92 4c 05 	sts	0x054C, r1
		torquer_off(TORQUER_1);
     f3a:	81 e1       	ldi	r24, 0x11	; 17
     f3c:	0e 94 c1 08 	call	0x1182	; 0x1182 <torquer_off>
		torquer_off(TORQUER_2);
     f40:	82 e1       	ldi	r24, 0x12	; 18
     f42:	0e 94 c1 08 	call	0x1182	; 0x1182 <torquer_off>
		torquer_off(TORQUER_3);
     f46:	83 e1       	ldi	r24, 0x13	; 19
     f48:	0e 94 c1 08 	call	0x1182	; 0x1182 <torquer_off>
		// Only transmit once
		if (!transmit_safe && !been_to_safe) { 
     f4c:	80 91 4a 09 	lds	r24, 0x094A
     f50:	81 11       	cpse	r24, r1
     f52:	08 c0       	rjmp	.+16     	; 0xf64 <limit_check+0xbe>
     f54:	80 91 2f 03 	lds	r24, 0x032F
     f58:	81 11       	cpse	r24, r1
     f5a:	04 c0       	rjmp	.+8      	; 0xf64 <limit_check+0xbe>
			transmit_packet( 0, VCP_ACK, SAFE_MODE);
     f5c:	40 e0       	ldi	r20, 0x00	; 0
     f5e:	62 e0       	ldi	r22, 0x02	; 2
     f60:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <transmit_packet>
			transmit_safe = 1;
		}
		else {}
		been_to_safe = 1;
     f64:	81 e0       	ldi	r24, 0x01	; 1
     f66:	80 93 2f 03 	sts	0x032F, r24
		transmit_safe = 1;
     f6a:	80 93 4a 09 	sts	0x094A, r24
     f6e:	28 c0       	rjmp	.+80     	; 0xfc0 <limit_check+0x11a>
	}
	else if (percent > SHUNT_MODE  && isCharging) {
     f70:	20 e0       	ldi	r18, 0x00	; 0
     f72:	30 e0       	ldi	r19, 0x00	; 0
     f74:	48 ec       	ldi	r20, 0xC8	; 200
     f76:	52 e4       	ldi	r21, 0x42	; 66
     f78:	c7 01       	movw	r24, r14
     f7a:	b6 01       	movw	r22, r12
     f7c:	0e 94 ab 13 	call	0x2756	; 0x2756 <__gesf2>
     f80:	18 16       	cp	r1, r24
     f82:	f4 f4       	brge	.+60     	; 0xfc0 <limit_check+0x11a>
     f84:	80 91 a6 0d 	lds	r24, 0x0DA6
     f88:	88 23       	and	r24, r24
     f8a:	d1 f0       	breq	.+52     	; 0xfc0 <limit_check+0x11a>
	    safe_mode = 0;
     f8c:	10 92 4f 09 	sts	0x094F, r1
		// turn on the maestro and send ack_command w/ value of SHUNT_MODE
		component = &svit[MAESTRO];
		switch_on( component->switch_num );
     f90:	80 91 a3 04 	lds	r24, 0x04A3
     f94:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <switch_on>
		component->switch_state = SW_ON;
     f98:	81 e0       	ldi	r24, 0x01	; 1
     f9a:	80 93 a4 04 	sts	0x04A4, r24
		// Only transmit once
		if (!transmit_shunt && !been_to_shunt) {
     f9e:	80 91 86 0d 	lds	r24, 0x0D86
     fa2:	81 11       	cpse	r24, r1
     fa4:	08 c0       	rjmp	.+16     	; 0xfb6 <limit_check+0x110>
     fa6:	80 91 6f 09 	lds	r24, 0x096F
     faa:	81 11       	cpse	r24, r1
     fac:	04 c0       	rjmp	.+8      	; 0xfb6 <limit_check+0x110>
			transmit_packet( 0, VCP_ACK, SHUNT_MODE);
     fae:	44 e6       	ldi	r20, 0x64	; 100
     fb0:	62 e0       	ldi	r22, 0x02	; 2
     fb2:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <transmit_packet>
		}
		else {}	
		been_to_shunt = 1;
     fb6:	81 e0       	ldi	r24, 0x01	; 1
     fb8:	80 93 6f 09 	sts	0x096F, r24
		transmit_shunt = 1;	
     fbc:	80 93 86 0d 	sts	0x0D86, r24
	}
	else {} // To avoid annoying compile warning 
}
     fc0:	df 91       	pop	r29
     fc2:	cf 91       	pop	r28
     fc4:	1f 91       	pop	r17
     fc6:	0f 91       	pop	r16
     fc8:	ff 90       	pop	r15
     fca:	ef 90       	pop	r14
     fcc:	df 90       	pop	r13
     fce:	cf 90       	pop	r12
     fd0:	08 95       	ret

00000fd2 <main>:


// MAIN
int main( void ) 
{  
  initialize();
     fd2:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <initialize>
  //fprintf( stdout, "uart initialized\n" );
	
  //Testing
  cntr = 0;
     fd6:	10 92 44 09 	sts	0x0944, r1

  while(1)
  {
	cntr = 1 - cntr; //Testing
     fda:	11 e0       	ldi	r17, 0x01	; 1
	
    if ( timer0_counter[1] == 0 )
    {
        timer0_counter[1] = 199;
     fdc:	c7 ec       	ldi	r28, 0xC7	; 199
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     fde:	dc e2       	ldi	r29, 0x2C	; 44
  //Testing
  cntr = 0;

  while(1)
  {
	cntr = 1 - cntr; //Testing
     fe0:	80 91 44 09 	lds	r24, 0x0944
     fe4:	91 2f       	mov	r25, r17
     fe6:	98 1b       	sub	r25, r24
     fe8:	90 93 44 09 	sts	0x0944, r25
	
    if ( timer0_counter[1] == 0 )
     fec:	80 91 77 0b 	lds	r24, 0x0B77
     ff0:	81 11       	cpse	r24, r1
     ff2:	07 c0       	rjmp	.+14     	; 0x1002 <main+0x30>
    {
        timer0_counter[1] = 199;
     ff4:	c0 93 77 0b 	sts	0x0B77, r28
        transmit_packet( 1, VCP_POWER_TELEMETRY, 0);
     ff8:	40 e0       	ldi	r20, 0x00	; 0
     ffa:	60 e0       	ldi	r22, 0x00	; 0
     ffc:	81 e0       	ldi	r24, 0x01	; 1
     ffe:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <transmit_packet>
    }
	  if ( timer0_counter[0] == 0 )
    1002:	80 91 76 0b 	lds	r24, 0x0B76
    1006:	81 11       	cpse	r24, r1
    1008:	06 c0       	rjmp	.+12     	; 0x1016 <main+0x44>
    {
        timer0_counter[0] = 199;
    100a:	c0 93 76 0b 	sts	0x0B76, r28
        transmit_packet( 0, VCP_POWER_TELEMETRY, 0);
    100e:	40 e0       	ldi	r20, 0x00	; 0
    1010:	60 e0       	ldi	r22, 0x00	; 0
    1012:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <transmit_packet>
    }
	  if ( rx_flag[0] > 0 )
    1016:	80 91 a7 0d 	lds	r24, 0x0DA7
    101a:	88 23       	and	r24, r24
    101c:	c9 f0       	breq	.+50     	; 0x1050 <main+0x7e>
    {
        rx_flag[0]--;
    101e:	80 91 a7 0d 	lds	r24, 0x0DA7
    1022:	81 50       	subi	r24, 0x01	; 1
    1024:	80 93 a7 0d 	sts	0x0DA7, r24
        receive_message( 0, uart_vcp_buff[0]->message, uart_vcp_buff[0]->index );
    1028:	e0 91 a2 0d 	lds	r30, 0x0DA2
    102c:	f0 91 a3 0d 	lds	r31, 0x0DA3
    1030:	61 81       	ldd	r22, Z+1	; 0x01
    1032:	72 81       	ldd	r23, Z+2	; 0x02
    1034:	47 81       	ldd	r20, Z+7	; 0x07
    1036:	80 e0       	ldi	r24, 0x00	; 0
    1038:	0e 94 af 03 	call	0x75e	; 0x75e <receive_message>
        vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
    103c:	4f ef       	ldi	r20, 0xFF	; 255
    103e:	50 e0       	ldi	r21, 0x00	; 0
    1040:	6f e7       	ldi	r22, 0x7F	; 127
    1042:	7b e0       	ldi	r23, 0x0B	; 11
    1044:	80 91 a2 0d 	lds	r24, 0x0DA2
    1048:	90 91 a3 0d 	lds	r25, 0x0DA3
    104c:	0e 94 04 0b 	call	0x1608	; 0x1608 <vcpptr_init>
    }
	  if ( rx_flag[1] > 0 )
    1050:	80 91 a8 0d 	lds	r24, 0x0DA8
    1054:	88 23       	and	r24, r24
    1056:	c9 f0       	breq	.+50     	; 0x108a <main+0xb8>
    {
        rx_flag[1]--;
    1058:	80 91 a8 0d 	lds	r24, 0x0DA8
    105c:	81 50       	subi	r24, 0x01	; 1
    105e:	80 93 a8 0d 	sts	0x0DA8, r24
        receive_message( 1, uart_vcp_buff[1]->message, uart_vcp_buff[1]->index );
    1062:	e0 91 a4 0d 	lds	r30, 0x0DA4
    1066:	f0 91 a5 0d 	lds	r31, 0x0DA5
    106a:	61 81       	ldd	r22, Z+1	; 0x01
    106c:	72 81       	ldd	r23, Z+2	; 0x02
    106e:	47 81       	ldd	r20, Z+7	; 0x07
    1070:	81 e0       	ldi	r24, 0x01	; 1
    1072:	0e 94 af 03 	call	0x75e	; 0x75e <receive_message>
        vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
    1076:	4f ef       	ldi	r20, 0xFF	; 255
    1078:	50 e0       	ldi	r21, 0x00	; 0
    107a:	6e e7       	ldi	r22, 0x7E	; 126
    107c:	7c e0       	ldi	r23, 0x0C	; 12
    107e:	80 91 a4 0d 	lds	r24, 0x0DA4
    1082:	90 91 a5 0d 	lds	r25, 0x0DA5
    1086:	0e 94 04 0b 	call	0x1608	; 0x1608 <vcpptr_init>
    }
    if (adc_flag == 1)
    108a:	80 91 45 09 	lds	r24, 0x0945
    108e:	81 30       	cpi	r24, 0x01	; 1
    1090:	91 f4       	brne	.+36     	; 0x10b6 <main+0xe4>
    {
        adc_flag = 0;
    1092:	10 92 45 09 	sts	0x0945, r1
        read_VIT();
    1096:	0e 94 b5 09 	call	0x136a	; 0x136a <read_VIT>
		//calcSOC();
		StateofCharge();
    109a:	0e 94 58 04 	call	0x8b0	; 0x8b0 <StateofCharge>

		/*
		Manual Override on Limit Checking: The power board must be able to receive a 
		command to disable and/or change the limits in the limit checking code
		*/
		if (!limit_check_overriden) {
    109e:	80 91 2c 07 	lds	r24, 0x072C
    10a2:	81 11       	cpse	r24, r1
    10a4:	02 c0       	rjmp	.+4      	; 0x10aa <main+0xd8>
			limit_check(); // First determine if voltage is within valid range, then switch
    10a6:	0e 94 53 07 	call	0xea6	; 0xea6 <limit_check>
		}

		if ( adc_component == 23 ) 
    10aa:	80 91 35 03 	lds	r24, 0x0335
    10ae:	87 31       	cpi	r24, 0x17	; 23
    10b0:	11 f4       	brne	.+4      	; 0x10b6 <main+0xe4>
      	{ //23ish anything after battery values are calculated
  			  compareVoltage();
    10b2:	0e 94 45 07 	call	0xe8a	; 0xe8a <compareVoltage>
	   	}
    }	
	
	//Restart all board components if CDH-IB heartbeat timeout
	if (cdh_heartbeat_flag == 1){
    10b6:	80 91 22 03 	lds	r24, 0x0322
    10ba:	81 30       	cpi	r24, 0x01	; 1
    10bc:	09 f0       	breq	.+2      	; 0x10c0 <main+0xee>
    10be:	90 cf       	rjmp	.-224    	; 0xfe0 <main+0xe>
		//Restart all components
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
    10c0:	10 92 22 03 	sts	0x0322, r1
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
    10c4:	d0 93 9b 0d 	sts	0x0D9B, r29
    10c8:	8b cf       	rjmp	.-234    	; 0xfe0 <main+0xe>

000010ca <torquer_off.part.0>:
void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
  {
    case TORQUER_1:
      CLR( PORTC, 0 );
    10ca:	a8 98       	cbi	0x15, 0	; 21
	  CLR( PORTG, 1 );
    10cc:	e5 e6       	ldi	r30, 0x65	; 101
    10ce:	f0 e0       	ldi	r31, 0x00	; 0
    10d0:	80 81       	ld	r24, Z
    10d2:	8d 7f       	andi	r24, 0xFD	; 253
    10d4:	80 83       	st	Z, r24
    10d6:	08 95       	ret

000010d8 <set_mux_sel>:
#include "mcupwr-Defs.h"


void set_mux_sel( uint8_t mux_num, uint8_t mux_sel )
{
  switch( mux_num )
    10d8:	81 30       	cpi	r24, 0x01	; 1
    10da:	f9 f0       	breq	.+62     	; 0x111a <__stack+0x1b>
    10dc:	20 f0       	brcs	.+8      	; 0x10e6 <set_mux_sel+0xe>
    10de:	82 30       	cpi	r24, 0x02	; 2
    10e0:	09 f0       	breq	.+2      	; 0x10e4 <set_mux_sel+0xc>
    10e2:	4e c0       	rjmp	.+156    	; 0x1180 <__stack+0x81>
    10e4:	34 c0       	rjmp	.+104    	; 0x114e <__stack+0x4f>
  {
    case MUX0:
      READ( mux_sel, 4 ) ? SET( PORTA, 7 ) : CLR( PORTA, 7 );
    10e6:	64 ff       	sbrs	r22, 4
    10e8:	02 c0       	rjmp	.+4      	; 0x10ee <set_mux_sel+0x16>
    10ea:	df 9a       	sbi	0x1b, 7	; 27
    10ec:	01 c0       	rjmp	.+2      	; 0x10f0 <set_mux_sel+0x18>
    10ee:	df 98       	cbi	0x1b, 7	; 27
      READ( mux_sel, 3 ) ? SET( PORTA, 6 ) : CLR( PORTA, 6 );
    10f0:	63 ff       	sbrs	r22, 3
    10f2:	02 c0       	rjmp	.+4      	; 0x10f8 <set_mux_sel+0x20>
    10f4:	de 9a       	sbi	0x1b, 6	; 27
    10f6:	01 c0       	rjmp	.+2      	; 0x10fa <set_mux_sel+0x22>
    10f8:	de 98       	cbi	0x1b, 6	; 27
      READ( mux_sel, 2 ) ? SET( PORTA, 5 ) : CLR( PORTA, 5 );
    10fa:	62 ff       	sbrs	r22, 2
    10fc:	02 c0       	rjmp	.+4      	; 0x1102 <__stack+0x3>
    10fe:	dd 9a       	sbi	0x1b, 5	; 27
    1100:	01 c0       	rjmp	.+2      	; 0x1104 <__stack+0x5>
    1102:	dd 98       	cbi	0x1b, 5	; 27
      READ( mux_sel, 1 ) ? SET( PORTA, 4 ) : CLR( PORTA, 4 );
    1104:	61 ff       	sbrs	r22, 1
    1106:	02 c0       	rjmp	.+4      	; 0x110c <__stack+0xd>
    1108:	dc 9a       	sbi	0x1b, 4	; 27
    110a:	01 c0       	rjmp	.+2      	; 0x110e <__stack+0xf>
    110c:	dc 98       	cbi	0x1b, 4	; 27
      READ( mux_sel, 0 ) ? SET( PORTA, 3 ) : CLR( PORTA, 3 );
    110e:	60 ff       	sbrs	r22, 0
    1110:	02 c0       	rjmp	.+4      	; 0x1116 <__stack+0x17>
    1112:	db 9a       	sbi	0x1b, 3	; 27
    1114:	08 95       	ret
    1116:	db 98       	cbi	0x1b, 3	; 27
    1118:	08 95       	ret

      break;

    case MUX1:
      READ( mux_sel, 4 ) ? SET( PORTB, 0 ) : CLR( PORTB, 0 );
    111a:	64 ff       	sbrs	r22, 4
    111c:	02 c0       	rjmp	.+4      	; 0x1122 <__stack+0x23>
    111e:	c0 9a       	sbi	0x18, 0	; 24
    1120:	01 c0       	rjmp	.+2      	; 0x1124 <__stack+0x25>
    1122:	c0 98       	cbi	0x18, 0	; 24
      READ( mux_sel, 3 ) ? SET( PORTB, 1 ) : CLR( PORTB, 1 );
    1124:	63 ff       	sbrs	r22, 3
    1126:	02 c0       	rjmp	.+4      	; 0x112c <__stack+0x2d>
    1128:	c1 9a       	sbi	0x18, 1	; 24
    112a:	01 c0       	rjmp	.+2      	; 0x112e <__stack+0x2f>
    112c:	c1 98       	cbi	0x18, 1	; 24
      READ( mux_sel, 2 ) ? SET( PORTB, 2 ) : CLR( PORTB, 2 );
    112e:	62 ff       	sbrs	r22, 2
    1130:	02 c0       	rjmp	.+4      	; 0x1136 <__stack+0x37>
    1132:	c2 9a       	sbi	0x18, 2	; 24
    1134:	01 c0       	rjmp	.+2      	; 0x1138 <__stack+0x39>
    1136:	c2 98       	cbi	0x18, 2	; 24
      READ( mux_sel, 1 ) ? SET( PORTB, 3 ) : CLR( PORTB, 3 );
    1138:	61 ff       	sbrs	r22, 1
    113a:	02 c0       	rjmp	.+4      	; 0x1140 <__stack+0x41>
    113c:	c3 9a       	sbi	0x18, 3	; 24
    113e:	01 c0       	rjmp	.+2      	; 0x1142 <__stack+0x43>
    1140:	c3 98       	cbi	0x18, 3	; 24
      READ( mux_sel, 0 ) ? SET( PORTB, 4 ) : CLR( PORTB, 4 );
    1142:	60 ff       	sbrs	r22, 0
    1144:	02 c0       	rjmp	.+4      	; 0x114a <__stack+0x4b>
    1146:	c4 9a       	sbi	0x18, 4	; 24
    1148:	08 95       	ret
    114a:	c4 98       	cbi	0x18, 4	; 24
    114c:	08 95       	ret

      break;

    case MUX2:
      READ( mux_sel, 4 ) ? SET( PORTE, 3 ) : CLR( PORTE, 3 );
    114e:	64 ff       	sbrs	r22, 4
    1150:	02 c0       	rjmp	.+4      	; 0x1156 <__stack+0x57>
    1152:	1b 9a       	sbi	0x03, 3	; 3
    1154:	01 c0       	rjmp	.+2      	; 0x1158 <__stack+0x59>
    1156:	1b 98       	cbi	0x03, 3	; 3
      READ( mux_sel, 3 ) ? SET( PORTE, 4 ) : CLR( PORTE, 4 );
    1158:	63 ff       	sbrs	r22, 3
    115a:	02 c0       	rjmp	.+4      	; 0x1160 <__stack+0x61>
    115c:	1c 9a       	sbi	0x03, 4	; 3
    115e:	01 c0       	rjmp	.+2      	; 0x1162 <__stack+0x63>
    1160:	1c 98       	cbi	0x03, 4	; 3
      READ( mux_sel, 2 ) ? SET( PORTE, 5 ) : CLR( PORTE, 5 );
    1162:	62 ff       	sbrs	r22, 2
    1164:	02 c0       	rjmp	.+4      	; 0x116a <__stack+0x6b>
    1166:	1d 9a       	sbi	0x03, 5	; 3
    1168:	01 c0       	rjmp	.+2      	; 0x116c <__stack+0x6d>
    116a:	1d 98       	cbi	0x03, 5	; 3
      READ( mux_sel, 1 ) ? SET( PORTE, 6 ) : CLR( PORTE, 6 );
    116c:	61 ff       	sbrs	r22, 1
    116e:	02 c0       	rjmp	.+4      	; 0x1174 <__stack+0x75>
    1170:	1e 9a       	sbi	0x03, 6	; 3
    1172:	01 c0       	rjmp	.+2      	; 0x1176 <__stack+0x77>
    1174:	1e 98       	cbi	0x03, 6	; 3
      READ( mux_sel, 0 ) ? SET( PORTE, 7 ) : CLR( PORTE, 7 );
    1176:	60 ff       	sbrs	r22, 0
    1178:	02 c0       	rjmp	.+4      	; 0x117e <__stack+0x7f>
    117a:	1f 9a       	sbi	0x03, 7	; 3
    117c:	08 95       	ret
    117e:	1f 98       	cbi	0x03, 7	; 3
    1180:	08 95       	ret

00001182 <torquer_off>:
  }
}

void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
    1182:	82 31       	cpi	r24, 0x12	; 18
    1184:	31 f0       	breq	.+12     	; 0x1192 <torquer_off+0x10>
    1186:	83 31       	cpi	r24, 0x13	; 19
    1188:	59 f0       	breq	.+22     	; 0x11a0 <torquer_off+0x1e>
    118a:	81 31       	cpi	r24, 0x11	; 17
    118c:	99 f4       	brne	.+38     	; 0x11b4 <torquer_off+0x32>
    118e:	0c 94 65 08 	jmp	0x10ca	; 0x10ca <torquer_off.part.0>
      CLR( PORTC, 0 );
	  CLR( PORTG, 1 );
      break;

    case TORQUER_2:
      CLR( PORTG, 0 );
    1192:	80 91 65 00 	lds	r24, 0x0065
    1196:	8e 7f       	andi	r24, 0xFE	; 254
    1198:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTD, 0 );
    119c:	90 98       	cbi	0x12, 0	; 18
      break;
    119e:	08 95       	ret

    case TORQUER_3:
      CLR( PORTG, 3 );
    11a0:	80 91 65 00 	lds	r24, 0x0065
    11a4:	87 7f       	andi	r24, 0xF7	; 247
    11a6:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTG, 4 );
    11aa:	80 91 65 00 	lds	r24, 0x0065
    11ae:	8f 7e       	andi	r24, 0xEF	; 239
    11b0:	80 93 65 00 	sts	0x0065, r24
    11b4:	08 95       	ret

000011b6 <torquer_on>:
  }  
}

void torquer_on( uint8_t torquer_num )
{
  switch( torquer_num )
    11b6:	82 31       	cpi	r24, 0x12	; 18
    11b8:	49 f0       	breq	.+18     	; 0x11cc <torquer_on+0x16>
    11ba:	83 31       	cpi	r24, 0x13	; 19
    11bc:	71 f0       	breq	.+28     	; 0x11da <torquer_on+0x24>
    11be:	81 31       	cpi	r24, 0x11	; 17
    11c0:	b1 f4       	brne	.+44     	; 0x11ee <torquer_on+0x38>
  {
    case TORQUER_1:
      SET( PORTC, 0 );
    11c2:	a8 9a       	sbi	0x15, 0	; 21
	  SET( PORTG, 1 );
    11c4:	80 91 65 00 	lds	r24, 0x0065
    11c8:	82 60       	ori	r24, 0x02	; 2
    11ca:	0f c0       	rjmp	.+30     	; 0x11ea <torquer_on+0x34>
      break;

    case TORQUER_2:
      SET( PORTG, 0 );
    11cc:	80 91 65 00 	lds	r24, 0x0065
    11d0:	81 60       	ori	r24, 0x01	; 1
    11d2:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTD, 0 );
    11d6:	90 9a       	sbi	0x12, 0	; 18
      break;
    11d8:	08 95       	ret

    case TORQUER_3:
      SET( PORTG, 3 );
    11da:	80 91 65 00 	lds	r24, 0x0065
    11de:	88 60       	ori	r24, 0x08	; 8
    11e0:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTG, 4 );
    11e4:	80 91 65 00 	lds	r24, 0x0065
    11e8:	80 61       	ori	r24, 0x10	; 16
    11ea:	80 93 65 00 	sts	0x0065, r24
    11ee:	08 95       	ret

000011f0 <switch_on>:
  }
}

void switch_on( uint8_t switch_num )
{
  switch ( switch_num )
    11f0:	88 30       	cpi	r24, 0x08	; 8
    11f2:	59 f1       	breq	.+86     	; 0x124a <switch_on+0x5a>
    11f4:	68 f4       	brcc	.+26     	; 0x1210 <switch_on+0x20>
    11f6:	84 30       	cpi	r24, 0x04	; 4
    11f8:	01 f1       	breq	.+64     	; 0x123a <switch_on+0x4a>
    11fa:	30 f4       	brcc	.+12     	; 0x1208 <switch_on+0x18>
    11fc:	82 30       	cpi	r24, 0x02	; 2
    11fe:	c9 f0       	breq	.+50     	; 0x1232 <switch_on+0x42>
    1200:	d0 f4       	brcc	.+52     	; 0x1236 <switch_on+0x46>
    1202:	81 30       	cpi	r24, 0x01	; 1
    1204:	b9 f5       	brne	.+110    	; 0x1274 <switch_on+0x84>
    1206:	13 c0       	rjmp	.+38     	; 0x122e <switch_on+0x3e>
    1208:	86 30       	cpi	r24, 0x06	; 6
    120a:	d9 f0       	breq	.+54     	; 0x1242 <switch_on+0x52>
    120c:	e0 f4       	brcc	.+56     	; 0x1246 <switch_on+0x56>
    120e:	17 c0       	rjmp	.+46     	; 0x123e <switch_on+0x4e>
    1210:	8c 30       	cpi	r24, 0x0C	; 12
    1212:	39 f1       	breq	.+78     	; 0x1262 <switch_on+0x72>
    1214:	20 f4       	brcc	.+8      	; 0x121e <switch_on+0x2e>
    1216:	8a 30       	cpi	r24, 0x0A	; 10
    1218:	01 f1       	breq	.+64     	; 0x125a <switch_on+0x6a>
    121a:	08 f5       	brcc	.+66     	; 0x125e <switch_on+0x6e>
    121c:	18 c0       	rjmp	.+48     	; 0x124e <switch_on+0x5e>
    121e:	8e 30       	cpi	r24, 0x0E	; 14
    1220:	21 f1       	breq	.+72     	; 0x126a <switch_on+0x7a>
    1222:	08 f1       	brcs	.+66     	; 0x1266 <switch_on+0x76>
    1224:	8f 30       	cpi	r24, 0x0F	; 15
    1226:	19 f1       	breq	.+70     	; 0x126e <switch_on+0x7e>
    1228:	80 31       	cpi	r24, 0x10	; 16
    122a:	21 f5       	brne	.+72     	; 0x1274 <switch_on+0x84>
    122c:	22 c0       	rjmp	.+68     	; 0x1272 <switch_on+0x82>
  {
    case 1:
      SET( PORTA, 0 );
    122e:	d8 9a       	sbi	0x1b, 0	; 27
      break;
    1230:	08 95       	ret

    case 2:
      SET( PORTA, 1 );
    1232:	d9 9a       	sbi	0x1b, 1	; 27
      break;
    1234:	08 95       	ret

    case 3:
      SET( PORTA, 2 );
    1236:	da 9a       	sbi	0x1b, 2	; 27
      break;
    1238:	08 95       	ret

    case 4:
      SET( PORTB, 5 );
    123a:	c5 9a       	sbi	0x18, 5	; 24
      break;
    123c:	08 95       	ret

    case 5:
      SET( PORTB, 6 );
    123e:	c6 9a       	sbi	0x18, 6	; 24
      break;
    1240:	08 95       	ret

    case 6:
      SET( PORTB, 7 );
    1242:	c7 9a       	sbi	0x18, 7	; 24
      break;
    1244:	08 95       	ret

    case 7:
      SET( PORTD, 4 );
    1246:	94 9a       	sbi	0x12, 4	; 18
      break;
    1248:	08 95       	ret

    case 8:
      SET( PORTD, 5 );
    124a:	95 9a       	sbi	0x12, 5	; 18
      break;
    124c:	08 95       	ret

    case 9:
      SET( PORTG, 2 );
    124e:	80 91 65 00 	lds	r24, 0x0065
    1252:	84 60       	ori	r24, 0x04	; 4
    1254:	80 93 65 00 	sts	0x0065, r24
      break;
    1258:	08 95       	ret

    case 10: 
      SET( PORTC, 7 );
    125a:	af 9a       	sbi	0x15, 7	; 21
      break;
    125c:	08 95       	ret

    case 11:
      SET( PORTC, 6 );
    125e:	ae 9a       	sbi	0x15, 6	; 21
      break;
    1260:	08 95       	ret

    case 12:
      SET( PORTC, 5 );
    1262:	ad 9a       	sbi	0x15, 5	; 21
      break;
    1264:	08 95       	ret

    case 13:
      SET( PORTC, 4 );
    1266:	ac 9a       	sbi	0x15, 4	; 21
      break;
    1268:	08 95       	ret

    case 14:
      SET( PORTC, 3 );
    126a:	ab 9a       	sbi	0x15, 3	; 21
      break;
    126c:	08 95       	ret

    case 15:
      SET( PORTC, 2 );
    126e:	aa 9a       	sbi	0x15, 2	; 21
      break;
    1270:	08 95       	ret

    case 16:
      SET( PORTC, 1 );
    1272:	a9 9a       	sbi	0x15, 1	; 21
    1274:	08 95       	ret

00001276 <switch_off>:
  }
}

void switch_off( uint8_t switch_num )
{
  switch ( switch_num )
    1276:	88 30       	cpi	r24, 0x08	; 8
    1278:	59 f1       	breq	.+86     	; 0x12d0 <switch_off+0x5a>
    127a:	68 f4       	brcc	.+26     	; 0x1296 <switch_off+0x20>
    127c:	84 30       	cpi	r24, 0x04	; 4
    127e:	01 f1       	breq	.+64     	; 0x12c0 <switch_off+0x4a>
    1280:	30 f4       	brcc	.+12     	; 0x128e <switch_off+0x18>
    1282:	82 30       	cpi	r24, 0x02	; 2
    1284:	c9 f0       	breq	.+50     	; 0x12b8 <switch_off+0x42>
    1286:	d0 f4       	brcc	.+52     	; 0x12bc <switch_off+0x46>
    1288:	81 30       	cpi	r24, 0x01	; 1
    128a:	b9 f5       	brne	.+110    	; 0x12fa <switch_off+0x84>
    128c:	13 c0       	rjmp	.+38     	; 0x12b4 <switch_off+0x3e>
    128e:	86 30       	cpi	r24, 0x06	; 6
    1290:	d9 f0       	breq	.+54     	; 0x12c8 <switch_off+0x52>
    1292:	e0 f4       	brcc	.+56     	; 0x12cc <switch_off+0x56>
    1294:	17 c0       	rjmp	.+46     	; 0x12c4 <switch_off+0x4e>
    1296:	8c 30       	cpi	r24, 0x0C	; 12
    1298:	39 f1       	breq	.+78     	; 0x12e8 <switch_off+0x72>
    129a:	20 f4       	brcc	.+8      	; 0x12a4 <switch_off+0x2e>
    129c:	8a 30       	cpi	r24, 0x0A	; 10
    129e:	01 f1       	breq	.+64     	; 0x12e0 <switch_off+0x6a>
    12a0:	08 f5       	brcc	.+66     	; 0x12e4 <switch_off+0x6e>
    12a2:	18 c0       	rjmp	.+48     	; 0x12d4 <switch_off+0x5e>
    12a4:	8e 30       	cpi	r24, 0x0E	; 14
    12a6:	21 f1       	breq	.+72     	; 0x12f0 <switch_off+0x7a>
    12a8:	08 f1       	brcs	.+66     	; 0x12ec <switch_off+0x76>
    12aa:	8f 30       	cpi	r24, 0x0F	; 15
    12ac:	19 f1       	breq	.+70     	; 0x12f4 <switch_off+0x7e>
    12ae:	80 31       	cpi	r24, 0x10	; 16
    12b0:	21 f5       	brne	.+72     	; 0x12fa <switch_off+0x84>
    12b2:	22 c0       	rjmp	.+68     	; 0x12f8 <switch_off+0x82>
  {
    case 1:
      CLR( PORTA, 0 );
    12b4:	d8 98       	cbi	0x1b, 0	; 27
      break;
    12b6:	08 95       	ret

    case 2:
      CLR( PORTA, 1 );
    12b8:	d9 98       	cbi	0x1b, 1	; 27
      break;
    12ba:	08 95       	ret

    case 3:
      CLR( PORTA, 2 );
    12bc:	da 98       	cbi	0x1b, 2	; 27
      break;
    12be:	08 95       	ret

    case 4:
      CLR( PORTB, 5 );
    12c0:	c5 98       	cbi	0x18, 5	; 24
      break;
    12c2:	08 95       	ret

    case 5:
      CLR( PORTB, 6 );
    12c4:	c6 98       	cbi	0x18, 6	; 24
      break;
    12c6:	08 95       	ret

    case 6:
      CLR( PORTB, 7 );
    12c8:	c7 98       	cbi	0x18, 7	; 24
      break;
    12ca:	08 95       	ret

    case 7:
      CLR( PORTD, 4 );
    12cc:	94 98       	cbi	0x12, 4	; 18
      break;
    12ce:	08 95       	ret

    case 8:
      CLR( PORTD, 5 );
    12d0:	95 98       	cbi	0x12, 5	; 18
      break;
    12d2:	08 95       	ret

    case 9:
      CLR( PORTG, 2 );
    12d4:	80 91 65 00 	lds	r24, 0x0065
    12d8:	8b 7f       	andi	r24, 0xFB	; 251
    12da:	80 93 65 00 	sts	0x0065, r24
      break;
    12de:	08 95       	ret

    case 10: 
      CLR( PORTC, 7 );
    12e0:	af 98       	cbi	0x15, 7	; 21
      break;
    12e2:	08 95       	ret

    case 11:
      CLR( PORTC, 6 );
    12e4:	ae 98       	cbi	0x15, 6	; 21
      break;
    12e6:	08 95       	ret

    case 12:
      CLR( PORTC, 5 );
    12e8:	ad 98       	cbi	0x15, 5	; 21
      break;
    12ea:	08 95       	ret

    case 13:
      CLR( PORTC, 4 );
    12ec:	ac 98       	cbi	0x15, 4	; 21
      break;
    12ee:	08 95       	ret

    case 14:
      CLR( PORTC, 3 );
    12f0:	ab 98       	cbi	0x15, 3	; 21
      break;
    12f2:	08 95       	ret

    case 15:
      CLR( PORTC, 2 );
    12f4:	aa 98       	cbi	0x15, 2	; 21
      break;
    12f6:	08 95       	ret

    case 16:
      CLR( PORTC, 1 );
    12f8:	a9 98       	cbi	0x15, 1	; 21
    12fa:	08 95       	ret

000012fc <average_samples>:
    return  average_samples( component->I_samples );
  }
}

uint8_t average_samples( uint8_t samples[NUM_SAMPLES] )
{
    12fc:	fc 01       	movw	r30, r24
  uint8_t average = 0;
  uint16_t sum = 0;

  for(uint8_t avg_index = 0; avg_index < NUM_SAMPLES; avg_index++)
    sum += samples[avg_index];
    12fe:	21 81       	ldd	r18, Z+1	; 0x01
    1300:	80 81       	ld	r24, Z
    1302:	90 e0       	ldi	r25, 0x00	; 0
    1304:	82 0f       	add	r24, r18
    1306:	91 1d       	adc	r25, r1
    1308:	22 81       	ldd	r18, Z+2	; 0x02
    130a:	82 0f       	add	r24, r18
    130c:	91 1d       	adc	r25, r1

  average = sum / NUM_SAMPLES;
    130e:	63 e0       	ldi	r22, 0x03	; 3
    1310:	70 e0       	ldi	r23, 0x00	; 0
    1312:	0e 94 af 13 	call	0x275e	; 0x275e <__udivmodhi4>
    1316:	86 2f       	mov	r24, r22

  return average;
}
    1318:	08 95       	ret

0000131a <SVIT_check_I_critical>:
}

uint8_t SVIT_check_I_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    131a:	9c e1       	ldi	r25, 0x1C	; 28
    131c:	89 9f       	mul	r24, r25
    131e:	f0 01       	movw	r30, r0
    1320:	11 24       	eor	r1, r1
    1322:	ea 5c       	subi	r30, 0xCA	; 202
    1324:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->I_critical_value != 0 )
    1326:	85 89       	ldd	r24, Z+21	; 0x15
    1328:	88 23       	and	r24, r24
    132a:	11 f0       	breq	.+4      	; 0x1330 <SVIT_check_I_critical+0x16>
  {
    temp= component->I_critical_value;
    component->I_critical_value = 0;
    132c:	15 8a       	std	Z+21, r1	; 0x15
    132e:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->I_samples );
    1330:	cf 01       	movw	r24, r30
    1332:	41 96       	adiw	r24, 0x11	; 17
    1334:	0c 94 7e 09 	jmp	0x12fc	; 0x12fc <average_samples>

00001338 <SVIT_check_V_critical>:
}

uint8_t SVIT_check_V_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1338:	9c e1       	ldi	r25, 0x1C	; 28
    133a:	89 9f       	mul	r24, r25
    133c:	f0 01       	movw	r30, r0
    133e:	11 24       	eor	r1, r1
    1340:	ea 5c       	subi	r30, 0xCA	; 202
    1342:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->V_critical_value != 0 )
    1344:	84 85       	ldd	r24, Z+12	; 0x0c
    1346:	88 23       	and	r24, r24
    1348:	11 f0       	breq	.+4      	; 0x134e <SVIT_check_V_critical+0x16>
  {
    temp= component->V_critical_value;
    component->V_critical_value = 0;
    134a:	14 86       	std	Z+12, r1	; 0x0c
    134c:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->V_samples );
    134e:	cf 01       	movw	r24, r30
    1350:	08 96       	adiw	r24, 0x08	; 8
    1352:	0c 94 7e 09 	jmp	0x12fc	; 0x12fc <average_samples>

00001356 <perform_ADC>:
}

void perform_ADC( uint8_t mux_num )
{
  // set Vref to AVCC and set the ADC channel to the correct pin ( mux_num )
  ADMUX = (1 << ADLAR) | ( 1 << REFS0 );
    1356:	90 e6       	ldi	r25, 0x60	; 96
    1358:	97 b9       	out	0x07, r25	; 7
  ADMUX &= ~0x3;
    135a:	97 b1       	in	r25, 0x07	; 7
    135c:	9c 7f       	andi	r25, 0xFC	; 252
    135e:	97 b9       	out	0x07, r25	; 7
  ADMUX |= mux_num;
    1360:	97 b1       	in	r25, 0x07	; 7
    1362:	98 2b       	or	r25, r24
    1364:	97 b9       	out	0x07, r25	; 7

  // signal ADC to start a new conversion
  ADCSRA |= ( 1 << ADSC );
    1366:	36 9a       	sbi	0x06, 6	; 6
    1368:	08 95       	ret

0000136a <read_VIT>:

  // when the conversion finishes, the result is stored in ADCL and ADCH
}

void read_VIT( void )
{
    136a:	1f 93       	push	r17
    136c:	cf 93       	push	r28
    136e:	df 93       	push	r29
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type ){
    1370:	80 91 52 09 	lds	r24, 0x0952
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1374:	c0 91 35 03 	lds	r28, 0x0335
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type ){
    1378:	82 30       	cpi	r24, 0x02	; 2
    137a:	09 f4       	brne	.+2      	; 0x137e <read_VIT+0x14>
    137c:	6a c0       	rjmp	.+212    	; 0x1452 <read_VIT+0xe8>
    137e:	20 f4       	brcc	.+8      	; 0x1388 <read_VIT+0x1e>
    1380:	81 30       	cpi	r24, 0x01	; 1
    1382:	09 f0       	breq	.+2      	; 0x1386 <read_VIT+0x1c>
    1384:	01 c1       	rjmp	.+514    	; 0x1588 <read_VIT+0x21e>
    1386:	07 c0       	rjmp	.+14     	; 0x1396 <read_VIT+0x2c>
    1388:	83 30       	cpi	r24, 0x03	; 3
    138a:	09 f4       	brne	.+2      	; 0x138e <read_VIT+0x24>
    138c:	c1 c0       	rjmp	.+386    	; 0x1510 <read_VIT+0x1a6>
    138e:	84 30       	cpi	r24, 0x04	; 4
    1390:	09 f0       	breq	.+2      	; 0x1394 <read_VIT+0x2a>
    1392:	fa c0       	rjmp	.+500    	; 0x1588 <read_VIT+0x21e>
    1394:	e5 c0       	rjmp	.+458    	; 0x1560 <read_VIT+0x1f6>
		case ADC_VOLTAGE:
			component = &svit[adc_component];
    1396:	8c e1       	ldi	r24, 0x1C	; 28
    1398:	c8 9f       	mul	r28, r24
    139a:	e0 01       	movw	r28, r0
    139c:	11 24       	eor	r1, r1
    139e:	ca 5c       	subi	r28, 0xCA	; 202
    13a0:	dc 4f       	sbci	r29, 0xFC	; 252
			sample_index = component->V_sample_index;
			component->V_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    13a2:	2b 85       	ldd	r18, Y+11	; 0x0b
    13a4:	30 e0       	ldi	r19, 0x00	; 0
    13a6:	c9 01       	movw	r24, r18
    13a8:	01 96       	adiw	r24, 0x01	; 1
    13aa:	63 e0       	ldi	r22, 0x03	; 3
    13ac:	70 e0       	ldi	r23, 0x00	; 0
    13ae:	0e 94 c3 13 	call	0x2786	; 0x2786 <__divmodhi4>
    13b2:	8b 87       	std	Y+11, r24	; 0x0b

			// SoC: If component is a battery, store in different global variable
			if (component->name == BATTERY_1) {
    13b4:	98 81       	ld	r25, Y
    13b6:	94 31       	cpi	r25, 0x14	; 20
    13b8:	89 f4       	brne	.+34     	; 0x13dc <read_VIT+0x72>
				batt1_voltage = ADC_high;
    13ba:	80 91 63 09 	lds	r24, 0x0963
    13be:	80 93 6d 09 	sts	0x096D, r24
				batt1_voltageLow = ADC_low;
    13c2:	80 91 9c 0d 	lds	r24, 0x0D9C
    13c6:	80 93 81 0d 	sts	0x0D81, r24
				high = ADC_high;
    13ca:	80 91 63 09 	lds	r24, 0x0963
    13ce:	80 93 5e 09 	sts	0x095E, r24
				low = ADC_low;
    13d2:	80 91 9c 0d 	lds	r24, 0x0D9C
    13d6:	80 93 6c 09 	sts	0x096C, r24
    13da:	06 c0       	rjmp	.+12     	; 0x13e8 <read_VIT+0x7e>
				//debug = adc_component;
			}
			else if (component->name == BATTERY_2) {
    13dc:	95 31       	cpi	r25, 0x15	; 21
    13de:	21 f4       	brne	.+8      	; 0x13e8 <read_VIT+0x7e>
				batt2_voltage = ADC_high;
    13e0:	80 91 63 09 	lds	r24, 0x0963
    13e4:	80 93 7e 0b 	sts	0x0B7E, r24
			}
			component->V_samples[sample_index] = ADC_high;
    13e8:	80 91 63 09 	lds	r24, 0x0963
    13ec:	fe 01       	movw	r30, r28
    13ee:	e2 0f       	add	r30, r18
    13f0:	f3 1f       	adc	r31, r19
    13f2:	80 87       	std	Z+8, r24	; 0x08
            
			//OverVoltage
	  		if ( ( ADC_high > component->V_upper_limit ) && ( component->force_on != 1 ) ){
    13f4:	20 91 63 09 	lds	r18, 0x0963
    13f8:	8e 81       	ldd	r24, Y+6	; 0x06
    13fa:	82 17       	cp	r24, r18
    13fc:	20 f4       	brcc	.+8      	; 0x1406 <read_VIT+0x9c>
    13fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1400:	81 30       	cpi	r24, 0x01	; 1
    1402:	09 f0       	breq	.+2      	; 0x1406 <read_VIT+0x9c>
    1404:	08 c0       	rjmp	.+16     	; 0x1416 <read_VIT+0xac>
  				}
				component->switch_state = SW_OFF;
				component->V_critical_value = ADC_high;
			}
			//UnderVoltage
			else if((ADC_high < component->V_lower_limit) && component->switch_state){
    1406:	20 91 63 09 	lds	r18, 0x0963
    140a:	8f 81       	ldd	r24, Y+7	; 0x07
    140c:	28 17       	cp	r18, r24
    140e:	d8 f4       	brcc	.+54     	; 0x1446 <read_VIT+0xdc>
    1410:	8a 81       	ldd	r24, Y+2	; 0x02
    1412:	88 23       	and	r24, r24
    1414:	c1 f0       	breq	.+48     	; 0x1446 <read_VIT+0xdc>
				if ( component->switch_num != SW_NULL ){
    1416:	89 81       	ldd	r24, Y+1	; 0x01
    1418:	8f 3f       	cpi	r24, 0xFF	; 255
    141a:	19 f0       	breq	.+6      	; 0x1422 <read_VIT+0xb8>
					switch_off( component->switch_num );
    141c:	0e 94 3b 09 	call	0x1276	; 0x1276 <switch_off>
    1420:	0e c0       	rjmp	.+28     	; 0x143e <read_VIT+0xd4>
				}else {
					switch ( component->name ){
    1422:	92 31       	cpi	r25, 0x12	; 18
    1424:	39 f0       	breq	.+14     	; 0x1434 <read_VIT+0xca>
    1426:	93 31       	cpi	r25, 0x13	; 19
    1428:	39 f0       	breq	.+14     	; 0x1438 <read_VIT+0xce>
    142a:	91 31       	cpi	r25, 0x11	; 17
    142c:	41 f4       	brne	.+16     	; 0x143e <read_VIT+0xd4>
    142e:	0e 94 65 08 	call	0x10ca	; 0x10ca <torquer_off.part.0>
    1432:	05 c0       	rjmp	.+10     	; 0x143e <read_VIT+0xd4>
						case TORQUER_1:
							torquer_off( TORQUER_1 );
							break;
						case TORQUER_2:
							torquer_off( TORQUER_2 );
    1434:	82 e1       	ldi	r24, 0x12	; 18
    1436:	01 c0       	rjmp	.+2      	; 0x143a <read_VIT+0xd0>
							break;
						case TORQUER_3:
							torquer_off( TORQUER_3 );
    1438:	83 e1       	ldi	r24, 0x13	; 19
    143a:	0e 94 c1 08 	call	0x1182	; 0x1182 <torquer_off>
							break;
						default:
							break;
					}
				}
				component->switch_state = SW_OFF;
    143e:	1a 82       	std	Y+2, r1	; 0x02
				component->V_critical_value = ADC_high;
    1440:	80 91 63 09 	lds	r24, 0x0963
    1444:	8c 87       	std	Y+12, r24	; 0x0c
			}
			adc_sensor_type = ADC_CURRENT;
    1446:	82 e0       	ldi	r24, 0x02	; 2
    1448:	80 93 52 09 	sts	0x0952, r24

		    //perform next ADC conversion
		    mux_num = component->I_mux_num;
    144c:	1d 85       	ldd	r17, Y+13	; 0x0d
		    mux_sel = component->I_mux_sel;
		    set_mux_sel( mux_num, mux_sel );
    144e:	6e 85       	ldd	r22, Y+14	; 0x0e
    1450:	92 c0       	rjmp	.+292    	; 0x1576 <read_VIT+0x20c>
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1452:	9c e1       	ldi	r25, 0x1C	; 28
    1454:	c9 9f       	mul	r28, r25
    1456:	e0 01       	movw	r28, r0
    1458:	11 24       	eor	r1, r1
    145a:	ca 5c       	subi	r28, 0xCA	; 202
    145c:	dc 4f       	sbci	r29, 0xFC	; 252
	  	sample_index = component->I_sample_index;
	  	component->I_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    145e:	2c 89       	ldd	r18, Y+20	; 0x14
    1460:	30 e0       	ldi	r19, 0x00	; 0
    1462:	c9 01       	movw	r24, r18
    1464:	01 96       	adiw	r24, 0x01	; 1
    1466:	63 e0       	ldi	r22, 0x03	; 3
    1468:	70 e0       	ldi	r23, 0x00	; 0
    146a:	0e 94 c3 13 	call	0x2786	; 0x2786 <__divmodhi4>
    146e:	8c 8b       	std	Y+20, r24	; 0x14
		// SoC hardcode backward current
//		if (adc_component == BATTERY_1_b) {
			//debug = 5;
		//}
		
		if(component->name == SOLAR_1){
    1470:	98 81       	ld	r25, Y
    1472:	97 31       	cpi	r25, 0x17	; 23
    1474:	39 f4       	brne	.+14     	; 0x1484 <read_VIT+0x11a>
			solar1_current = ADC_high;
    1476:	80 91 63 09 	lds	r24, 0x0963
    147a:	80 93 6e 09 	sts	0x096E, r24
			hasCheckedCurr = 1;
    147e:	81 e0       	ldi	r24, 0x01	; 1
    1480:	80 93 57 09 	sts	0x0957, r24
		}

	  	component->I_samples[sample_index] = ADC_high;
    1484:	80 91 63 09 	lds	r24, 0x0963
    1488:	fe 01       	movw	r30, r28
    148a:	e2 0f       	add	r30, r18
    148c:	f3 1f       	adc	r31, r19
    148e:	81 8b       	std	Z+17, r24	; 0x11
    
	    if ( ( ADC_high > component->I_upper_limit ) && ( component->force_on != 1 ) )
    1490:	20 91 63 09 	lds	r18, 0x0963
    1494:	8f 85       	ldd	r24, Y+15	; 0x0f
    1496:	82 17       	cp	r24, r18
    1498:	d8 f4       	brcc	.+54     	; 0x14d0 <read_VIT+0x166>
    149a:	8b 81       	ldd	r24, Y+3	; 0x03
    149c:	81 30       	cpi	r24, 0x01	; 1
    149e:	c1 f0       	breq	.+48     	; 0x14d0 <read_VIT+0x166>
	  	{
	  		if ( component->switch_num != SW_NULL )
    14a0:	89 81       	ldd	r24, Y+1	; 0x01
    14a2:	8f 3f       	cpi	r24, 0xFF	; 255
    14a4:	19 f0       	breq	.+6      	; 0x14ac <read_VIT+0x142>
	  		{
	  		  switch_off( component->switch_num );
    14a6:	0e 94 3b 09 	call	0x1276	; 0x1276 <switch_off>
    14aa:	0e c0       	rjmp	.+28     	; 0x14c8 <read_VIT+0x15e>
	  		}
	  		else
	  		{
	  		  switch ( component->name )
    14ac:	92 31       	cpi	r25, 0x12	; 18
    14ae:	39 f0       	breq	.+14     	; 0x14be <read_VIT+0x154>
    14b0:	93 31       	cpi	r25, 0x13	; 19
    14b2:	39 f0       	breq	.+14     	; 0x14c2 <read_VIT+0x158>
    14b4:	91 31       	cpi	r25, 0x11	; 17
    14b6:	41 f4       	brne	.+16     	; 0x14c8 <read_VIT+0x15e>
    14b8:	0e 94 65 08 	call	0x10ca	; 0x10ca <torquer_off.part.0>
    14bc:	05 c0       	rjmp	.+10     	; 0x14c8 <read_VIT+0x15e>
		  	  {
  		  		case TORQUER_1:
	  	  		  torquer_off( TORQUER_1 );
		    		  break;
			    	case TORQUER_2:
			  	    torquer_off( TORQUER_2 );
    14be:	82 e1       	ldi	r24, 0x12	; 18
    14c0:	01 c0       	rjmp	.+2      	; 0x14c4 <read_VIT+0x15a>
			  	    break;
  		  		case TORQUER_3:
	  	  		  torquer_off( TORQUER_3 );
    14c2:	83 e1       	ldi	r24, 0x13	; 19
    14c4:	0e 94 c1 08 	call	0x1182	; 0x1182 <torquer_off>
		    		  break;
			     	default:
				      break;
			    }
			  }
			  component->switch_state = 0;
    14c8:	1a 82       	std	Y+2, r1	; 0x02
        component->I_critical_value = ADC_high;
    14ca:	80 91 63 09 	lds	r24, 0x0963
    14ce:	8d 8b       	std	Y+21, r24	; 0x15
		  }
      //perform next ADC conversion
      mux_num = component->T_mux_num;
    14d0:	1e 89       	ldd	r17, Y+22	; 0x16
      if( mux_num != MUX_NULL )
    14d2:	13 30       	cpi	r17, 0x03	; 3
    14d4:	29 f0       	breq	.+10     	; 0x14e0 <read_VIT+0x176>
      {
		    adc_sensor_type = ADC_TEMPERATURE;
    14d6:	83 e0       	ldi	r24, 0x03	; 3
    14d8:	80 93 52 09 	sts	0x0952, r24
        mux_sel = component->T_mux_sel;        
    14dc:	6f 89       	ldd	r22, Y+23	; 0x17
    14de:	4b c0       	rjmp	.+150    	; 0x1576 <read_VIT+0x20c>
		  }
      else
      {
        adc_sensor_type = ADC_VOLTAGE;
    14e0:	81 e0       	ldi	r24, 0x01	; 1
    14e2:	80 93 52 09 	sts	0x0952, r24
		    adc_component = ( adc_component + 1 ) % SVIT_SZ;
    14e6:	80 91 35 03 	lds	r24, 0x0335
    14ea:	90 e0       	ldi	r25, 0x00	; 0
    14ec:	01 96       	adiw	r24, 0x01	; 1
    14ee:	64 e2       	ldi	r22, 0x24	; 36
    14f0:	70 e0       	ldi	r23, 0x00	; 0
    14f2:	0e 94 c3 13 	call	0x2786	; 0x2786 <__divmodhi4>
    14f6:	80 93 35 03 	sts	0x0335, r24
        component = &svit[adc_component];
    14fa:	2c e1       	ldi	r18, 0x1C	; 28
    14fc:	28 9f       	mul	r18, r24
    14fe:	f0 01       	movw	r30, r0
    1500:	29 9f       	mul	r18, r25
    1502:	f0 0d       	add	r31, r0
    1504:	11 24       	eor	r1, r1
    1506:	ea 5c       	subi	r30, 0xCA	; 202
    1508:	fc 4f       	sbci	r31, 0xFC	; 252
        mux_num = component->V_mux_num;
    150a:	14 81       	ldd	r17, Z+4	; 0x04
        mux_sel = component->V_mux_sel;
    150c:	65 81       	ldd	r22, Z+5	; 0x05
    150e:	33 c0       	rjmp	.+102    	; 0x1576 <read_VIT+0x20c>
      break;
    //-------------------------------------------------------------------
    // Measure temperature
    //-------------------------------------------------------------------
	  case ADC_TEMPERATURE:
		  component = &svit[adc_component];
    1510:	d0 e0       	ldi	r29, 0x00	; 0
    1512:	4c e1       	ldi	r20, 0x1C	; 28
    1514:	4c 9f       	mul	r20, r28
    1516:	f0 01       	movw	r30, r0
    1518:	4d 9f       	mul	r20, r29
    151a:	f0 0d       	add	r31, r0
    151c:	11 24       	eor	r1, r1
    151e:	ea 5c       	subi	r30, 0xCA	; 202
    1520:	fc 4f       	sbci	r31, 0xFC	; 252
		  sample_index = component->T_sample_index;
		  component->T_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    1522:	23 8d       	ldd	r18, Z+27	; 0x1b
    1524:	30 e0       	ldi	r19, 0x00	; 0
    1526:	c9 01       	movw	r24, r18
    1528:	01 96       	adiw	r24, 0x01	; 1
    152a:	63 e0       	ldi	r22, 0x03	; 3
    152c:	70 e0       	ldi	r23, 0x00	; 0
    152e:	0e 94 c3 13 	call	0x2786	; 0x2786 <__divmodhi4>
    1532:	83 8f       	std	Z+27, r24	; 0x1b
		  component->T_samples[sample_index] = ADC_high;
    1534:	80 91 63 09 	lds	r24, 0x0963
    1538:	e2 0f       	add	r30, r18
    153a:	f3 1f       	adc	r31, r19
    153c:	80 8f       	std	Z+24, r24	; 0x18
      //perform next ADC conversion
  	  adc_sensor_type = ADC_VOLTAGE;
    153e:	81 e0       	ldi	r24, 0x01	; 1
    1540:	80 93 52 09 	sts	0x0952, r24
		  adc_component = ( adc_component + 1 ) % SVIT_SZ;
    1544:	ce 01       	movw	r24, r28
    1546:	01 96       	adiw	r24, 0x01	; 1
    1548:	64 e2       	ldi	r22, 0x24	; 36
    154a:	70 e0       	ldi	r23, 0x00	; 0
    154c:	0e 94 c3 13 	call	0x2786	; 0x2786 <__divmodhi4>
    1550:	80 93 35 03 	sts	0x0335, r24
      component = &svit[adc_component];
    1554:	48 9f       	mul	r20, r24
    1556:	f0 01       	movw	r30, r0
    1558:	49 9f       	mul	r20, r25
    155a:	f0 0d       	add	r31, r0
    155c:	11 24       	eor	r1, r1
    155e:	1d c0       	rjmp	.+58     	; 0x159a <read_VIT+0x230>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
		  break;
    case ADC_INIT:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    1560:	81 e0       	ldi	r24, 0x01	; 1
    1562:	80 93 52 09 	sts	0x0952, r24
      component = &svit[adc_component];
    1566:	9c e1       	ldi	r25, 0x1C	; 28
    1568:	c9 9f       	mul	r28, r25
    156a:	e0 01       	movw	r28, r0
    156c:	11 24       	eor	r1, r1
    156e:	ca 5c       	subi	r28, 0xCA	; 202
    1570:	dc 4f       	sbci	r29, 0xFC	; 252
      mux_num = component->V_mux_num;
    1572:	1c 81       	ldd	r17, Y+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    1574:	6d 81       	ldd	r22, Y+5	; 0x05
    1576:	81 2f       	mov	r24, r17
    1578:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <set_mux_sel>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    157c:	83 e3       	ldi	r24, 0x33	; 51
    157e:	93 e7       	ldi	r25, 0x73	; 115
    1580:	01 97       	sbiw	r24, 0x01	; 1
    1582:	f1 f7       	brne	.-4      	; 0x1580 <read_VIT+0x216>
      //_delay_us(1);
	  //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
    1584:	81 2f       	mov	r24, r17
    1586:	15 c0       	rjmp	.+42     	; 0x15b2 <read_VIT+0x248>
      break;
	  default:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    1588:	81 e0       	ldi	r24, 0x01	; 1
    158a:	80 93 52 09 	sts	0x0952, r24
      component = &svit[adc_component];
    158e:	e0 91 35 03 	lds	r30, 0x0335
    1592:	9c e1       	ldi	r25, 0x1C	; 28
    1594:	e9 9f       	mul	r30, r25
    1596:	f0 01       	movw	r30, r0
    1598:	11 24       	eor	r1, r1
    159a:	ea 5c       	subi	r30, 0xCA	; 202
    159c:	fc 4f       	sbci	r31, 0xFC	; 252
      mux_num = component->V_mux_num;
    159e:	c4 81       	ldd	r28, Z+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    15a0:	65 81       	ldd	r22, Z+5	; 0x05
    15a2:	8c 2f       	mov	r24, r28
    15a4:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <set_mux_sel>
    15a8:	83 e3       	ldi	r24, 0x33	; 51
    15aa:	93 e7       	ldi	r25, 0x73	; 115
    15ac:	01 97       	sbiw	r24, 0x01	; 1
    15ae:	f1 f7       	brne	.-4      	; 0x15ac <read_VIT+0x242>
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    15b0:	8c 2f       	mov	r24, r28
      break;
  } 
}
    15b2:	df 91       	pop	r29
    15b4:	cf 91       	pop	r28
    15b6:	1f 91       	pop	r17
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    15b8:	0c 94 ab 09 	jmp	0x1356	; 0x1356 <perform_ADC>

000015bc <uart_init>:
{
  #if F_CPU < 2000000UL && defined(U2X)
  UCSR0A = UCSR1A = _BV(U2X); /* improve baud rate error by using 2x clk */
  UBRR0L = UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  #else
  UBRR0L = UBRR1L = 7;//(F_CPU / (16UL * UART_BAUD)) - 1;//7;
    15bc:	87 e0       	ldi	r24, 0x07	; 7
    15be:	80 93 99 00 	sts	0x0099, r24
    15c2:	89 b9       	out	0x09, r24	; 9
  #endif
  UCSR0B = _BV(TXEN0) | _BV(RXEN0); /* tx/rx enable */
    15c4:	88 e1       	ldi	r24, 0x18	; 24
    15c6:	8a b9       	out	0x0a, r24	; 10
  UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
    15c8:	ea e9       	ldi	r30, 0x9A	; 154
    15ca:	f0 e0       	ldi	r31, 0x00	; 0
    15cc:	80 83       	st	Z, r24


  UCSR1B = UCSR1B | _BV(TXCIE1);
    15ce:	80 81       	ld	r24, Z
    15d0:	80 64       	ori	r24, 0x40	; 64
    15d2:	80 83       	st	Z, r24
  UCSR1B = UCSR1B | _BV(RXCIE1);
    15d4:	80 81       	ld	r24, Z
    15d6:	80 68       	ori	r24, 0x80	; 128
    15d8:	80 83       	st	Z, r24
  UCSR0B = UCSR0B | _BV(TXCIE0);
    15da:	56 9a       	sbi	0x0a, 6	; 10
  UCSR0B = UCSR0B | _BV(RXCIE0);
    15dc:	57 9a       	sbi	0x0a, 7	; 10
    15de:	08 95       	ret

000015e0 <append_crc16>:
 * Adds a byte of data into the crc calculation using
 * the table above.
 */
void append_crc16(uint8 byte, uint16ptr crc)
{
	*crc = ((*crc) >> 8) ^ ccitt_crc16[((*crc) ^ (byte)) & 0xff];
    15e0:	fb 01       	movw	r30, r22
    15e2:	20 81       	ld	r18, Z
    15e4:	31 81       	ldd	r19, Z+1	; 0x01
    15e6:	f9 01       	movw	r30, r18
    15e8:	e8 27       	eor	r30, r24
    15ea:	ff 27       	eor	r31, r31
    15ec:	ee 0f       	add	r30, r30
    15ee:	ff 1f       	adc	r31, r31
    15f0:	ea 5f       	subi	r30, 0xFA	; 250
    15f2:	fe 4f       	sbci	r31, 0xFE	; 254
    15f4:	23 2f       	mov	r18, r19
    15f6:	33 27       	eor	r19, r19
    15f8:	80 81       	ld	r24, Z
    15fa:	91 81       	ldd	r25, Z+1	; 0x01
    15fc:	82 27       	eor	r24, r18
    15fe:	93 27       	eor	r25, r19
    1600:	fb 01       	movw	r30, r22
    1602:	91 83       	std	Z+1, r25	; 0x01
    1604:	80 83       	st	Z, r24
    1606:	08 95       	ret

00001608 <vcpptr_init>:
// Parameters: 
// vcp_ptrbuffer	*buff -					Pointer to the vcp buffer structure
// uint8			*message_buffer -		Pointer to the allocated data buffer
// uint16			message_buffer_size -	Size of the allocated data buffer
void vcpptr_init(vcp_ptrbuffer *buff, uint8 *message_buffer, uint16 message_buffer_size)
{
    1608:	fc 01       	movw	r30, r24
	buff->address =	0;
    160a:	10 82       	st	Z, r1
	buff->message =	message_buffer;
    160c:	72 83       	std	Z+2, r23	; 0x02
    160e:	61 83       	std	Z+1, r22	; 0x01
	buff->size =	message_buffer_size;
    1610:	56 83       	std	Z+6, r21	; 0x06
    1612:	45 83       	std	Z+5, r20	; 0x05
	buff->index	=	0;
    1614:	10 86       	std	Z+8, r1	; 0x08
    1616:	17 82       	std	Z+7, r1	; 0x07
	buff->crc =		CRC16_INIT_VALUE;
    1618:	14 82       	std	Z+4, r1	; 0x04
    161a:	13 82       	std	Z+3, r1	; 0x03
	buff->status =	VCP_IDLE;
    161c:	11 86       	std	Z+9, r1	; 0x09
    161e:	08 95       	ret

00001620 <Create_VCP_frame>:
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
    1620:	4f 92       	push	r4
    1622:	5f 92       	push	r5
    1624:	6f 92       	push	r6
    1626:	7f 92       	push	r7
    1628:	8f 92       	push	r8
    162a:	9f 92       	push	r9
    162c:	af 92       	push	r10
    162e:	bf 92       	push	r11
    1630:	cf 92       	push	r12
    1632:	df 92       	push	r13
    1634:	ef 92       	push	r14
    1636:	ff 92       	push	r15
    1638:	0f 93       	push	r16
    163a:	1f 93       	push	r17
    163c:	cf 93       	push	r28
    163e:	df 93       	push	r29
    1640:	00 d0       	rcall	.+0      	; 0x1642 <Create_VCP_frame+0x22>
    1642:	1f 92       	push	r1
    1644:	cd b7       	in	r28, 0x3d	; 61
    1646:	de b7       	in	r29, 0x3e	; 62
    1648:	6c 01       	movw	r12, r24
    164a:	5b 01       	movw	r10, r22
    164c:	79 01       	movw	r14, r18
	uint16_t crc = CRC16_INIT_VALUE;
    164e:	1a 82       	std	Y+2, r1	; 0x02
    1650:	19 82       	std	Y+1, r1	; 0x01
	uint16_t src_index = 0;
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
    1652:	00 97       	sbiw	r24, 0x00	; 0
    1654:	09 f4       	brne	.+2      	; 0x1658 <Create_VCP_frame+0x38>
    1656:	58 c0       	rjmp	.+176    	; 0x1708 <Create_VCP_frame+0xe8>
    1658:	21 15       	cp	r18, r1
    165a:	31 05       	cpc	r19, r1
    165c:	09 f4       	brne	.+2      	; 0x1660 <Create_VCP_frame+0x40>
    165e:	54 c0       	rjmp	.+168    	; 0x1708 <Create_VCP_frame+0xe8>
		return VCP_NULL_ERR;

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
    1660:	4c 30       	cpi	r20, 0x0C	; 12
    1662:	18 f0       	brcs	.+6      	; 0x166a <Create_VCP_frame+0x4a>
    1664:	48 33       	cpi	r20, 0x38	; 56
    1666:	09 f0       	breq	.+2      	; 0x166a <Create_VCP_frame+0x4a>
    1668:	51 c0       	rjmp	.+162    	; 0x170c <Create_VCP_frame+0xec>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    166a:	44 24       	eor	r4, r4
    166c:	43 94       	inc	r4
    166e:	51 2c       	mov	r5, r1
    1670:	4c 0e       	add	r4, r28
    1672:	5d 1e       	adc	r5, r29
    1674:	b2 01       	movw	r22, r4
    1676:	84 2f       	mov	r24, r20
    1678:	4b 83       	std	Y+3, r20	; 0x03
    167a:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <append_crc16>
// uint8ptr		dst -		Pointer to the destination buffer
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
    167e:	37 01       	movw	r6, r14
    1680:	60 0e       	add	r6, r16
    1682:	71 1e       	adc	r7, r17
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    1684:	47 01       	movw	r8, r14
    1686:	07 c0       	rjmp	.+14     	; 0x1696 <Create_VCP_frame+0x76>
	  append_crc16(src[src_index], &crc);
    1688:	b2 01       	movw	r22, r4
    168a:	f4 01       	movw	r30, r8
    168c:	81 91       	ld	r24, Z+
    168e:	4f 01       	movw	r8, r30
    1690:	4b 83       	std	Y+3, r20	; 0x03
    1692:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <append_crc16>
    1696:	4b 81       	ldd	r20, Y+3	; 0x03
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    1698:	86 14       	cp	r8, r6
    169a:	97 04       	cpc	r9, r7
    169c:	a9 f7       	brne	.-22     	; 0x1688 <Create_VCP_frame+0x68>
	  append_crc16(src[src_index], &crc);
	
	// Add CRC to the end of the source buffer
	src[src_index++] = ((crc >> 8) & 0xFF);
    169e:	89 81       	ldd	r24, Y+1	; 0x01
    16a0:	9a 81       	ldd	r25, Y+2	; 0x02
    16a2:	f7 01       	movw	r30, r14
    16a4:	e0 0f       	add	r30, r16
    16a6:	f1 1f       	adc	r31, r17
    16a8:	90 83       	st	Z, r25
	src[src_index++] = (crc & 0xFF);
    16aa:	81 83       	std	Z+1, r24	; 0x01
    16ac:	0e 5f       	subi	r16, 0xFE	; 254
    16ae:	1f 4f       	sbci	r17, 0xFF	; 255
	payload_size = src_index;
	
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
    16b0:	80 ec       	ldi	r24, 0xC0	; 192
    16b2:	f6 01       	movw	r30, r12
    16b4:	80 83       	st	Z, r24
	// then insert VCP address
	dst[dst_index++] =					addr;
    16b6:	41 83       	std	Z+1, r20	; 0x01
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    16b8:	d7 01       	movw	r26, r14
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
    16ba:	42 e0       	ldi	r20, 0x02	; 2
    16bc:	50 e0       	ldi	r21, 0x00	; 0
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    16be:	2d ed       	ldi	r18, 0xDD	; 221
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
    16c0:	3b ed       	ldi	r19, 0xDB	; 219
			dst[dst_index++] =			TFEND;
    16c2:	6c ed       	ldi	r22, 0xDC	; 220
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    16c4:	0f c0       	rjmp	.+30     	; 0x16e4 <Create_VCP_frame+0xc4>
	{
		if (src[src_index] == FEND)
    16c6:	8d 91       	ld	r24, X+
    16c8:	80 3c       	cpi	r24, 0xC0	; 192
    16ca:	19 f4       	brne	.+6      	; 0x16d2 <Create_VCP_frame+0xb2>
		{
			dst[dst_index++] =			FESC;
    16cc:	30 83       	st	Z, r19
			dst[dst_index++] =			TFEND;
    16ce:	61 83       	std	Z+1, r22	; 0x01
    16d0:	04 c0       	rjmp	.+8      	; 0x16da <Create_VCP_frame+0xba>
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
    16d2:	80 83       	st	Z, r24
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
    16d4:	8b 3d       	cpi	r24, 0xDB	; 219
    16d6:	21 f4       	brne	.+8      	; 0x16e0 <Create_VCP_frame+0xc0>
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    16d8:	21 83       	std	Z+1, r18	; 0x01
    16da:	4e 5f       	subi	r20, 0xFE	; 254
    16dc:	5f 4f       	sbci	r21, 0xFF	; 255
    16de:	02 c0       	rjmp	.+4      	; 0x16e4 <Create_VCP_frame+0xc4>
		}
		else
		{
			dst[dst_index++] =			src[src_index];
    16e0:	4f 5f       	subi	r20, 0xFF	; 255
    16e2:	5f 4f       	sbci	r21, 0xFF	; 255
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    16e4:	cd 01       	movw	r24, r26
    16e6:	8e 19       	sub	r24, r14
    16e8:	9f 09       	sbc	r25, r15
    16ea:	f6 01       	movw	r30, r12
    16ec:	e4 0f       	add	r30, r20
    16ee:	f5 1f       	adc	r31, r21
    16f0:	80 17       	cp	r24, r16
    16f2:	91 07       	cpc	r25, r17
    16f4:	40 f3       	brcs	.-48     	; 0x16c6 <Create_VCP_frame+0xa6>
		//if (dst_index >= *dst_size - 1)
			//return VCP_OVR_ERR;
	}
	
	// End the frame with FEND
	dst[dst_index++] =					FEND;
    16f6:	80 ec       	ldi	r24, 0xC0	; 192
    16f8:	80 83       	st	Z, r24
    16fa:	4f 5f       	subi	r20, 0xFF	; 255
    16fc:	5f 4f       	sbci	r21, 0xFF	; 255
	
	// Save the frame size
	*dst_size = dst_index;
    16fe:	f5 01       	movw	r30, r10
    1700:	51 83       	std	Z+1, r21	; 0x01
    1702:	40 83       	st	Z, r20
	
	// All good
	return VCP_TERM;
    1704:	81 e0       	ldi	r24, 0x01	; 1
    1706:	03 c0       	rjmp	.+6      	; 0x170e <Create_VCP_frame+0xee>
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
		return VCP_NULL_ERR;
    1708:	85 e0       	ldi	r24, 0x05	; 5
    170a:	01 c0       	rjmp	.+2      	; 0x170e <Create_VCP_frame+0xee>

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
		return VCP_ADDR_ERR;
    170c:	86 e0       	ldi	r24, 0x06	; 6
	// Save the frame size
	*dst_size = dst_index;
	
	// All good
	return VCP_TERM;
}
    170e:	0f 90       	pop	r0
    1710:	0f 90       	pop	r0
    1712:	0f 90       	pop	r0
    1714:	df 91       	pop	r29
    1716:	cf 91       	pop	r28
    1718:	1f 91       	pop	r17
    171a:	0f 91       	pop	r16
    171c:	ff 90       	pop	r15
    171e:	ef 90       	pop	r14
    1720:	df 90       	pop	r13
    1722:	cf 90       	pop	r12
    1724:	bf 90       	pop	r11
    1726:	af 90       	pop	r10
    1728:	9f 90       	pop	r9
    172a:	8f 90       	pop	r8
    172c:	7f 90       	pop	r7
    172e:	6f 90       	pop	r6
    1730:	5f 90       	pop	r5
    1732:	4f 90       	pop	r4
    1734:	08 95       	ret

00001736 <Receive_VCP_byte>:
// and return VCP status.
// Parameters:
// vcp_ptrbuffer	*buff -	Pointer to the vcp buffer structure
// uint8			byte -	received byte
uint8_t Receive_VCP_byte(vcp_ptrbuffer *buff, uint8 byte)
{
    1736:	cf 92       	push	r12
    1738:	df 92       	push	r13
    173a:	ef 92       	push	r14
    173c:	ff 92       	push	r15
    173e:	0f 93       	push	r16
    1740:	1f 93       	push	r17
    1742:	cf 93       	push	r28
    1744:	df 93       	push	r29
    1746:	ec 01       	movw	r28, r24
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
    1748:	29 81       	ldd	r18, Y+1	; 0x01
    174a:	3a 81       	ldd	r19, Y+2	; 0x02
    174c:	21 15       	cp	r18, r1
    174e:	31 05       	cpc	r19, r1
    1750:	09 f4       	brne	.+2      	; 0x1754 <Receive_VCP_byte+0x1e>
    1752:	84 c0       	rjmp	.+264    	; 0x185c <Receive_VCP_byte+0x126>
		return VCP_NULL_ERR;
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
    1754:	8f 81       	ldd	r24, Y+7	; 0x07
    1756:	98 85       	ldd	r25, Y+8	; 0x08
    1758:	4d 81       	ldd	r20, Y+5	; 0x05
    175a:	5e 81       	ldd	r21, Y+6	; 0x06
    175c:	41 50       	subi	r20, 0x01	; 1
    175e:	51 09       	sbc	r21, r1
    1760:	84 17       	cp	r24, r20
    1762:	95 07       	cpc	r25, r21
    1764:	08 f0       	brcs	.+2      	; 0x1768 <Receive_VCP_byte+0x32>
    1766:	7c c0       	rjmp	.+248    	; 0x1860 <Receive_VCP_byte+0x12a>
		return VCP_OVR_ERR;
	
	// State Machine
	switch (buff->status)
    1768:	49 85       	ldd	r20, Y+9	; 0x09
    176a:	42 30       	cpi	r20, 0x02	; 2
    176c:	39 f1       	breq	.+78     	; 0x17bc <Receive_VCP_byte+0x86>
    176e:	18 f4       	brcc	.+6      	; 0x1776 <Receive_VCP_byte+0x40>
    1770:	44 23       	and	r20, r20
    1772:	31 f0       	breq	.+12     	; 0x1780 <Receive_VCP_byte+0x4a>
    1774:	38 c0       	rjmp	.+112    	; 0x17e6 <Receive_VCP_byte+0xb0>
    1776:	40 31       	cpi	r20, 0x10	; 16
    1778:	31 f0       	breq	.+12     	; 0x1786 <Receive_VCP_byte+0x50>
    177a:	40 32       	cpi	r20, 0x20	; 32
    177c:	a1 f5       	brne	.+104    	; 0x17e6 <Receive_VCP_byte+0xb0>
    177e:	0a c0       	rjmp	.+20     	; 0x1794 <Receive_VCP_byte+0x5e>
	{
		case VCP_IDLE:										
			if (byte == FEND)
    1780:	60 3c       	cpi	r22, 0xC0	; 192
    1782:	91 f5       	brne	.+100    	; 0x17e8 <Receive_VCP_byte+0xb2>
    1784:	0d c0       	rjmp	.+26     	; 0x17a0 <Receive_VCP_byte+0x6a>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
    1786:	6c 30       	cpi	r22, 0x0C	; 12
    1788:	18 f0       	brcs	.+6      	; 0x1790 <Receive_VCP_byte+0x5a>
    178a:	68 33       	cpi	r22, 0x38	; 56
    178c:	09 f0       	breq	.+2      	; 0x1790 <Receive_VCP_byte+0x5a>
    178e:	6a c0       	rjmp	.+212    	; 0x1864 <Receive_VCP_byte+0x12e>
				return VCP_ADDR_ERR;
			else
			{
				buff->address = byte;
    1790:	68 83       	st	Y, r22
    1792:	26 c0       	rjmp	.+76     	; 0x17e0 <Receive_VCP_byte+0xaa>
				buff->status = VCP_RECEIVING;
			}	
			break;
		case VCP_RECEIVING:
			if (byte == FEND)
    1794:	60 3c       	cpi	r22, 0xC0	; 192
    1796:	31 f4       	brne	.+12     	; 0x17a4 <Receive_VCP_byte+0x6e>
			{
				if (buff->index > 0)
    1798:	89 2b       	or	r24, r25
    179a:	11 f0       	breq	.+4      	; 0x17a0 <Receive_VCP_byte+0x6a>
					// Done
					buff->status = VCP_TERM;
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	21 c0       	rjmp	.+66     	; 0x17e2 <Receive_VCP_byte+0xac>
				else
					// No data between FENDs - assume lost sync and start over
					buff->status = VCP_ADDRESS;
    17a0:	80 e1       	ldi	r24, 0x10	; 16
    17a2:	1f c0       	rjmp	.+62     	; 0x17e2 <Receive_VCP_byte+0xac>
			}
			else if (byte == FESC)
    17a4:	6b 3d       	cpi	r22, 0xDB	; 219
    17a6:	11 f4       	brne	.+4      	; 0x17ac <Receive_VCP_byte+0x76>
				buff->status = VCP_ESC;
    17a8:	82 e0       	ldi	r24, 0x02	; 2
    17aa:	1b c0       	rjmp	.+54     	; 0x17e2 <Receive_VCP_byte+0xac>
			else
			{
				buff->message[(buff->index)++] = byte;	
    17ac:	f9 01       	movw	r30, r18
    17ae:	e8 0f       	add	r30, r24
    17b0:	f9 1f       	adc	r31, r25
    17b2:	60 83       	st	Z, r22
    17b4:	01 96       	adiw	r24, 0x01	; 1
    17b6:	98 87       	std	Y+8, r25	; 0x08
    17b8:	8f 83       	std	Y+7, r24	; 0x07
    17ba:	16 c0       	rjmp	.+44     	; 0x17e8 <Receive_VCP_byte+0xb2>
			}						
			break;
		case VCP_ESC:
			if (byte == TFEND)
    17bc:	6c 3d       	cpi	r22, 0xDC	; 220
    17be:	29 f4       	brne	.+10     	; 0x17ca <Receive_VCP_byte+0x94>
			{
				buff->message[(buff->index)++] = FEND;
    17c0:	f9 01       	movw	r30, r18
    17c2:	e8 0f       	add	r30, r24
    17c4:	f9 1f       	adc	r31, r25
    17c6:	40 ec       	ldi	r20, 0xC0	; 192
    17c8:	07 c0       	rjmp	.+14     	; 0x17d8 <Receive_VCP_byte+0xa2>
				buff->status = VCP_RECEIVING;
			}
			else if (byte == TFESC)
    17ca:	6d 3d       	cpi	r22, 0xDD	; 221
    17cc:	09 f0       	breq	.+2      	; 0x17d0 <Receive_VCP_byte+0x9a>
    17ce:	4c c0       	rjmp	.+152    	; 0x1868 <Receive_VCP_byte+0x132>
			{
				buff->message[(buff->index)++] = FESC;
    17d0:	f9 01       	movw	r30, r18
    17d2:	e8 0f       	add	r30, r24
    17d4:	f9 1f       	adc	r31, r25
    17d6:	4b ed       	ldi	r20, 0xDB	; 219
    17d8:	40 83       	st	Z, r20
    17da:	01 96       	adiw	r24, 0x01	; 1
    17dc:	98 87       	std	Y+8, r25	; 0x08
    17de:	8f 83       	std	Y+7, r24	; 0x07
				buff->status = VCP_RECEIVING;
    17e0:	80 e2       	ldi	r24, 0x20	; 32
    17e2:	89 87       	std	Y+9, r24	; 0x09
    17e4:	01 c0       	rjmp	.+2      	; 0x17e8 <Receive_VCP_byte+0xb2>
			}
			else
				return VCP_ESC_ERR;	
			break;
		default:
			buff->status = VCP_IDLE;
    17e6:	19 86       	std	Y+9, r1	; 0x09
			break; 
	}
	
	// End of frame
	if (buff->status == VCP_TERM)
    17e8:	89 85       	ldd	r24, Y+9	; 0x09
    17ea:	81 30       	cpi	r24, 0x01	; 1
    17ec:	11 f0       	breq	.+4      	; 0x17f2 <Receive_VCP_byte+0xbc>
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
    17ee:	89 85       	ldd	r24, Y+9	; 0x09
    17f0:	3c c0       	rjmp	.+120    	; 0x186a <Receive_VCP_byte+0x134>
	
	// End of frame
	if (buff->status == VCP_TERM)
	{
		// Message CRC is last 2 bytes 
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
    17f2:	89 81       	ldd	r24, Y+1	; 0x01
    17f4:	9a 81       	ldd	r25, Y+2	; 0x02
    17f6:	4f 81       	ldd	r20, Y+7	; 0x07
    17f8:	58 85       	ldd	r21, Y+8	; 0x08
    17fa:	84 0f       	add	r24, r20
    17fc:	95 1f       	adc	r25, r21
    17fe:	fc 01       	movw	r30, r24
    1800:	32 97       	sbiw	r30, 0x02	; 2
    1802:	30 81       	ld	r19, Z
    1804:	20 e0       	ldi	r18, 0x00	; 0
    1806:	fc 01       	movw	r30, r24
    1808:	31 97       	sbiw	r30, 0x01	; 1
    180a:	80 81       	ld	r24, Z
    180c:	69 01       	movw	r12, r18
    180e:	c8 0e       	add	r12, r24
    1810:	d1 1c       	adc	r13, r1
		// Remove CRC bytes from the message
		buff->index -= 2;
    1812:	42 50       	subi	r20, 0x02	; 2
    1814:	51 09       	sbc	r21, r1
    1816:	58 87       	std	Y+8, r21	; 0x08
    1818:	4f 83       	std	Y+7, r20	; 0x07
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
    181a:	7e 01       	movw	r14, r28
    181c:	83 e0       	ldi	r24, 0x03	; 3
    181e:	e8 0e       	add	r14, r24
    1820:	f1 1c       	adc	r15, r1
    1822:	b7 01       	movw	r22, r14
    1824:	88 81       	ld	r24, Y
    1826:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <append_crc16>
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    182a:	00 e0       	ldi	r16, 0x00	; 0
    182c:	10 e0       	ldi	r17, 0x00	; 0
    182e:	0a c0       	rjmp	.+20     	; 0x1844 <Receive_VCP_byte+0x10e>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
    1830:	e9 81       	ldd	r30, Y+1	; 0x01
    1832:	fa 81       	ldd	r31, Y+2	; 0x02
    1834:	e0 0f       	add	r30, r16
    1836:	f1 1f       	adc	r31, r17
    1838:	b7 01       	movw	r22, r14
    183a:	80 81       	ld	r24, Z
    183c:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <append_crc16>
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
		// Remove CRC bytes from the message
		buff->index -= 2;
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    1840:	0f 5f       	subi	r16, 0xFF	; 255
    1842:	1f 4f       	sbci	r17, 0xFF	; 255
    1844:	8f 81       	ldd	r24, Y+7	; 0x07
    1846:	98 85       	ldd	r25, Y+8	; 0x08
    1848:	08 17       	cp	r16, r24
    184a:	19 07       	cpc	r17, r25
    184c:	88 f3       	brcs	.-30     	; 0x1830 <Receive_VCP_byte+0xfa>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
		}
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
    184e:	8b 81       	ldd	r24, Y+3	; 0x03
    1850:	9c 81       	ldd	r25, Y+4	; 0x04
    1852:	8c 15       	cp	r24, r12
    1854:	9d 05       	cpc	r25, r13
    1856:	59 f2       	breq	.-106    	; 0x17ee <Receive_VCP_byte+0xb8>
			return VCP_CRC_ERR;
    1858:	84 e0       	ldi	r24, 0x04	; 4
    185a:	07 c0       	rjmp	.+14     	; 0x186a <Receive_VCP_byte+0x134>
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
		return VCP_NULL_ERR;
    185c:	85 e0       	ldi	r24, 0x05	; 5
    185e:	05 c0       	rjmp	.+10     	; 0x186a <Receive_VCP_byte+0x134>
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
		return VCP_OVR_ERR;
    1860:	83 e0       	ldi	r24, 0x03	; 3
    1862:	03 c0       	rjmp	.+6      	; 0x186a <Receive_VCP_byte+0x134>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
				return VCP_ADDR_ERR;
    1864:	86 e0       	ldi	r24, 0x06	; 6
    1866:	01 c0       	rjmp	.+2      	; 0x186a <Receive_VCP_byte+0x134>
			{
				buff->message[(buff->index)++] = FESC;
				buff->status = VCP_RECEIVING;
			}
			else
				return VCP_ESC_ERR;	
    1868:	87 e0       	ldi	r24, 0x07	; 7
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
}
    186a:	df 91       	pop	r29
    186c:	cf 91       	pop	r28
    186e:	1f 91       	pop	r17
    1870:	0f 91       	pop	r16
    1872:	ff 90       	pop	r15
    1874:	ef 90       	pop	r14
    1876:	df 90       	pop	r13
    1878:	cf 90       	pop	r12
    187a:	08 95       	ret

0000187c <tx_put_byte.part.0>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    return;
  if( tel_packet_index[uart] < tel_packet_size[uart] )
    187c:	28 2f       	mov	r18, r24
    187e:	30 e0       	ldi	r19, 0x00	; 0
    1880:	f9 01       	movw	r30, r18
    1882:	e1 5c       	subi	r30, 0xC1	; 193
    1884:	f8 4f       	sbci	r31, 0xF8	; 248
    1886:	60 81       	ld	r22, Z
    1888:	d9 01       	movw	r26, r18
    188a:	aa 0f       	add	r26, r26
    188c:	bb 1f       	adc	r27, r27
    188e:	a9 5d       	subi	r26, 0xD9	; 217
    1890:	bc 4f       	sbci	r27, 0xFC	; 252
    1892:	4d 91       	ld	r20, X+
    1894:	5c 91       	ld	r21, X
    1896:	70 e0       	ldi	r23, 0x00	; 0
    1898:	64 17       	cp	r22, r20
    189a:	75 07       	cpc	r23, r21
    189c:	10 f5       	brcc	.+68     	; 0x18e2 <tx_put_byte.part.0+0x66>
  {
      if ( uart == 0 )
    189e:	81 11       	cpse	r24, r1
    18a0:	0e c0       	rjmp	.+28     	; 0x18be <tx_put_byte.part.0+0x42>
      UDR0 = tel_packet[uart][tel_packet_index[uart]++];
    18a2:	80 81       	ld	r24, Z
    18a4:	9f ef       	ldi	r25, 0xFF	; 255
    18a6:	92 9f       	mul	r25, r18
    18a8:	d0 01       	movw	r26, r0
    18aa:	93 9f       	mul	r25, r19
    18ac:	b0 0d       	add	r27, r0
    18ae:	11 24       	eor	r1, r1
    18b0:	a8 0f       	add	r26, r24
    18b2:	b1 1d       	adc	r27, r1
    18b4:	aa 5b       	subi	r26, 0xBA	; 186
    18b6:	b8 4f       	sbci	r27, 0xF8	; 248
    18b8:	9c 91       	ld	r25, X
    18ba:	9c b9       	out	0x0c, r25	; 12
    18bc:	10 c0       	rjmp	.+32     	; 0x18de <tx_put_byte.part.0+0x62>
    else if ( uart == 1 )
    18be:	81 30       	cpi	r24, 0x01	; 1
    18c0:	81 f4       	brne	.+32     	; 0x18e2 <tx_put_byte.part.0+0x66>
      UDR1 = tel_packet[uart][tel_packet_index[uart]++];
    18c2:	80 81       	ld	r24, Z
    18c4:	9f ef       	ldi	r25, 0xFF	; 255
    18c6:	92 9f       	mul	r25, r18
    18c8:	d0 01       	movw	r26, r0
    18ca:	93 9f       	mul	r25, r19
    18cc:	b0 0d       	add	r27, r0
    18ce:	11 24       	eor	r1, r1
    18d0:	a8 0f       	add	r26, r24
    18d2:	b1 1d       	adc	r27, r1
    18d4:	aa 5b       	subi	r26, 0xBA	; 186
    18d6:	b8 4f       	sbci	r27, 0xF8	; 248
    18d8:	9c 91       	ld	r25, X
    18da:	90 93 9c 00 	sts	0x009C, r25
    18de:	8f 5f       	subi	r24, 0xFF	; 255
    18e0:	80 83       	st	Z, r24
    18e2:	08 95       	ret

000018e4 <__vector_15>:
#include "vcp_library.h"
#include "crclib.h"
#include "uart.h"

ISR(TIMER0_COMP_vect)
{
    18e4:	1f 92       	push	r1
    18e6:	0f 92       	push	r0
    18e8:	0f b6       	in	r0, 0x3f	; 63
    18ea:	0f 92       	push	r0
    18ec:	11 24       	eor	r1, r1
    18ee:	8f 93       	push	r24
  if ( timer0_counter[0] > 0 )
    18f0:	80 91 76 0b 	lds	r24, 0x0B76
    18f4:	88 23       	and	r24, r24
    18f6:	29 f0       	breq	.+10     	; 0x1902 <__vector_15+0x1e>
    --timer0_counter[0];
    18f8:	80 91 76 0b 	lds	r24, 0x0B76
    18fc:	81 50       	subi	r24, 0x01	; 1
    18fe:	80 93 76 0b 	sts	0x0B76, r24
  if ( timer0_counter[1] > 0 )
    1902:	80 91 77 0b 	lds	r24, 0x0B77
    1906:	88 23       	and	r24, r24
    1908:	29 f0       	breq	.+10     	; 0x1914 <__vector_15+0x30>
    --timer0_counter[1];
    190a:	80 91 77 0b 	lds	r24, 0x0B77
    190e:	81 50       	subi	r24, 0x01	; 1
    1910:	80 93 77 0b 	sts	0x0B77, r24
	//if (cntr == 0)
	//	PORTC |= 0x01;
	//else
	//	PORTC &= 0xFE;
	//_delay_ms(500);
}
    1914:	8f 91       	pop	r24
    1916:	0f 90       	pop	r0
    1918:	0f be       	out	0x3f, r0	; 63
    191a:	0f 90       	pop	r0
    191c:	1f 90       	pop	r1
    191e:	18 95       	reti

00001920 <__vector_12>:

/* Timer 1(A) routine */
ISR(TIMER1_COMPA_vect)		//Handle Radio & Torquer 30 min delays here; handle 10 min CDH-IB no heartbeat restart
{
    1920:	1f 92       	push	r1
    1922:	0f 92       	push	r0
    1924:	0f b6       	in	r0, 0x3f	; 63
    1926:	0f 92       	push	r0
    1928:	11 24       	eor	r1, r1
    192a:	0b b6       	in	r0, 0x3b	; 59
    192c:	0f 92       	push	r0
    192e:	2f 93       	push	r18
    1930:	3f 93       	push	r19
    1932:	4f 93       	push	r20
    1934:	5f 93       	push	r21
    1936:	6f 93       	push	r22
    1938:	7f 93       	push	r23
    193a:	8f 93       	push	r24
    193c:	9f 93       	push	r25
    193e:	af 93       	push	r26
    1940:	bf 93       	push	r27
    1942:	cf 93       	push	r28
    1944:	ef 93       	push	r30
    1946:	ff 93       	push	r31
	SVIT_t *component;
	
	//Testing
	//PORTC ^= 0xFF;
		
	if (timer1_counter[0] <= 0	  &&     rad_torq_flag){	//provides 30 minute delay			
    1948:	80 91 9a 0d 	lds	r24, 0x0D9A
    194c:	81 11       	cpse	r24, r1
    194e:	31 c0       	rjmp	.+98     	; 0x19b2 <__vector_12+0x92>
    1950:	80 91 0b 03 	lds	r24, 0x030B
    1954:	88 23       	and	r24, r24
    1956:	69 f1       	breq	.+90     	; 0x19b2 <__vector_12+0x92>
	//if ( receive_flag == 1){		//If message is received, reset timer1_counter[0] to CYCLE_COUNTER
	    timer1_counter[0] = CYCLE_COUNTER;
    1958:	84 e8       	ldi	r24, 0x84	; 132
    195a:	80 93 9a 0d 	sts	0x0D9A, r24
		
		//CHECK: Should the ISR do this code or not?
		
		//Turn on radios
		component = &svit[RADIO_1];
		switch_on( component->switch_num );
    195e:	80 91 6b 04 	lds	r24, 0x046B
    1962:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <switch_on>
		component->switch_state = SW_ON;
    1966:	c1 e0       	ldi	r28, 0x01	; 1
    1968:	c0 93 6c 04 	sts	0x046C, r28
		component = &svit[RADIO_2];
		switch_on( component->switch_num );
    196c:	80 91 87 04 	lds	r24, 0x0487
    1970:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <switch_on>
		component->switch_state = SW_ON;
    1974:	c0 93 88 04 	sts	0x0488, r28
		
		//Turn on torque coils			
		component = &svit[TORQUER_1];
		switch_on( component->switch_num );
    1978:	80 91 13 05 	lds	r24, 0x0513
    197c:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <switch_on>
		component->switch_state = SW_ON;
    1980:	c0 93 14 05 	sts	0x0514, r28
		component = &svit[TORQUER_2];
		switch_on( component->switch_num );
    1984:	80 91 2f 05 	lds	r24, 0x052F
    1988:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <switch_on>
		component->switch_state = SW_ON;
    198c:	c0 93 30 05 	sts	0x0530, r28
		component = &svit[TORQUER_3];
		switch_on( component->switch_num );
    1990:	80 91 4b 05 	lds	r24, 0x054B
    1994:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <switch_on>
		component->switch_state = SW_ON;
    1998:	c0 93 4c 05 	sts	0x054C, r28
		torquer_on(TORQUER_1);
    199c:	81 e1       	ldi	r24, 0x11	; 17
    199e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <torquer_on>
		torquer_on(TORQUER_2);
    19a2:	82 e1       	ldi	r24, 0x12	; 18
    19a4:	0e 94 db 08 	call	0x11b6	; 0x11b6 <torquer_on>
		torquer_on(TORQUER_3);
    19a8:	83 e1       	ldi	r24, 0x13	; 19
    19aa:	0e 94 db 08 	call	0x11b6	; 0x11b6 <torquer_on>
		
		//PORTC ^= 0x02;	//LED for STK testing
		//PORTC ^= 0x01;
		
		//Don't reexecute this code
		rad_torq_flag = 0;
    19ae:	10 92 0b 03 	sts	0x030B, r1
	}
	
	if (timer1_counter[1] <= 0   &&   !cdh_heartbeat_flag){		//If heartbeat timer 1 has expired AND we haven't already ordered a restart
    19b2:	80 91 9b 0d 	lds	r24, 0x0D9B
    19b6:	81 11       	cpse	r24, r1
    19b8:	07 c0       	rjmp	.+14     	; 0x19c8 <__vector_12+0xa8>
    19ba:	80 91 22 03 	lds	r24, 0x0322
    19be:	81 11       	cpse	r24, r1
    19c0:	03 c0       	rjmp	.+6      	; 0x19c8 <__vector_12+0xa8>
		//Order full component restart
		cdh_heartbeat_flag = 1;
    19c2:	81 e0       	ldi	r24, 0x01	; 1
    19c4:	80 93 22 03 	sts	0x0322, r24
		
	}
	
	//else{
		PORTC ^= 0x01;		//LED for STK testing at PORTC0
    19c8:	85 b3       	in	r24, 0x15	; 21
    19ca:	91 e0       	ldi	r25, 0x01	; 1
    19cc:	89 27       	eor	r24, r25
    19ce:	85 bb       	out	0x15, r24	; 21
    19d0:	2f ef       	ldi	r18, 0xFF	; 255
    19d2:	8f e7       	ldi	r24, 0x7F	; 127
    19d4:	96 e1       	ldi	r25, 0x16	; 22
    19d6:	21 50       	subi	r18, 0x01	; 1
    19d8:	80 40       	sbci	r24, 0x00	; 0
    19da:	90 40       	sbci	r25, 0x00	; 0
    19dc:	e1 f7       	brne	.-8      	; 0x19d6 <__vector_12+0xb6>
    19de:	00 c0       	rjmp	.+0      	; 0x19e0 <__vector_12+0xc0>
    19e0:	00 00       	nop
		_delay_ms(500);
		--timer1_counter[0];
    19e2:	80 91 9a 0d 	lds	r24, 0x0D9A
    19e6:	81 50       	subi	r24, 0x01	; 1
    19e8:	80 93 9a 0d 	sts	0x0D9A, r24
		--timer1_counter[1];
    19ec:	80 91 9b 0d 	lds	r24, 0x0D9B
    19f0:	81 50       	subi	r24, 0x01	; 1
    19f2:	80 93 9b 0d 	sts	0x0D9B, r24
	//}
}
    19f6:	ff 91       	pop	r31
    19f8:	ef 91       	pop	r30
    19fa:	cf 91       	pop	r28
    19fc:	bf 91       	pop	r27
    19fe:	af 91       	pop	r26
    1a00:	9f 91       	pop	r25
    1a02:	8f 91       	pop	r24
    1a04:	7f 91       	pop	r23
    1a06:	6f 91       	pop	r22
    1a08:	5f 91       	pop	r21
    1a0a:	4f 91       	pop	r20
    1a0c:	3f 91       	pop	r19
    1a0e:	2f 91       	pop	r18
    1a10:	0f 90       	pop	r0
    1a12:	0b be       	out	0x3b, r0	; 59
    1a14:	0f 90       	pop	r0
    1a16:	0f be       	out	0x3f, r0	; 63
    1a18:	0f 90       	pop	r0
    1a1a:	1f 90       	pop	r1
    1a1c:	18 95       	reti

00001a1e <__vector_32>:

ISR(USART1_TX_vect)
{
    1a1e:	1f 92       	push	r1
    1a20:	0f 92       	push	r0
    1a22:	0f b6       	in	r0, 0x3f	; 63
    1a24:	0f 92       	push	r0
    1a26:	11 24       	eor	r1, r1
    1a28:	0b b6       	in	r0, 0x3b	; 59
    1a2a:	0f 92       	push	r0
    1a2c:	2f 93       	push	r18
    1a2e:	3f 93       	push	r19
    1a30:	4f 93       	push	r20
    1a32:	5f 93       	push	r21
    1a34:	6f 93       	push	r22
    1a36:	7f 93       	push	r23
    1a38:	8f 93       	push	r24
    1a3a:	9f 93       	push	r25
    1a3c:	af 93       	push	r26
    1a3e:	bf 93       	push	r27
    1a40:	ef 93       	push	r30
    1a42:	ff 93       	push	r31
    1a44:	81 e0       	ldi	r24, 0x01	; 1
    1a46:	0e 94 3e 0c 	call	0x187c	; 0x187c <tx_put_byte.part.0>
  tx_put_byte( 1 );
}
    1a4a:	ff 91       	pop	r31
    1a4c:	ef 91       	pop	r30
    1a4e:	bf 91       	pop	r27
    1a50:	af 91       	pop	r26
    1a52:	9f 91       	pop	r25
    1a54:	8f 91       	pop	r24
    1a56:	7f 91       	pop	r23
    1a58:	6f 91       	pop	r22
    1a5a:	5f 91       	pop	r21
    1a5c:	4f 91       	pop	r20
    1a5e:	3f 91       	pop	r19
    1a60:	2f 91       	pop	r18
    1a62:	0f 90       	pop	r0
    1a64:	0b be       	out	0x3b, r0	; 59
    1a66:	0f 90       	pop	r0
    1a68:	0f be       	out	0x3f, r0	; 63
    1a6a:	0f 90       	pop	r0
    1a6c:	1f 90       	pop	r1
    1a6e:	18 95       	reti

00001a70 <__vector_30>:

ISR(USART1_RX_vect)
{
    1a70:	1f 92       	push	r1
    1a72:	0f 92       	push	r0
    1a74:	0f b6       	in	r0, 0x3f	; 63
    1a76:	0f 92       	push	r0
    1a78:	11 24       	eor	r1, r1
    1a7a:	0b b6       	in	r0, 0x3b	; 59
    1a7c:	0f 92       	push	r0
    1a7e:	2f 93       	push	r18
    1a80:	3f 93       	push	r19
    1a82:	4f 93       	push	r20
    1a84:	5f 93       	push	r21
    1a86:	6f 93       	push	r22
    1a88:	7f 93       	push	r23
    1a8a:	8f 93       	push	r24
    1a8c:	9f 93       	push	r25
    1a8e:	af 93       	push	r26
    1a90:	bf 93       	push	r27
    1a92:	ef 93       	push	r30
    1a94:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[1], UDR1 ) == VCP_TERM )
    1a96:	60 91 9c 00 	lds	r22, 0x009C
    1a9a:	80 91 a4 0d 	lds	r24, 0x0DA4
    1a9e:	90 91 a5 0d 	lds	r25, 0x0DA5
    1aa2:	0e 94 9b 0b 	call	0x1736	; 0x1736 <Receive_VCP_byte>
    1aa6:	81 30       	cpi	r24, 0x01	; 1
    1aa8:	29 f4       	brne	.+10     	; 0x1ab4 <__vector_30+0x44>
  {
    rx_flag[1]++;
    1aaa:	80 91 a8 0d 	lds	r24, 0x0DA8
    1aae:	8f 5f       	subi	r24, 0xFF	; 255
    1ab0:	80 93 a8 0d 	sts	0x0DA8, r24
  }
}
    1ab4:	ff 91       	pop	r31
    1ab6:	ef 91       	pop	r30
    1ab8:	bf 91       	pop	r27
    1aba:	af 91       	pop	r26
    1abc:	9f 91       	pop	r25
    1abe:	8f 91       	pop	r24
    1ac0:	7f 91       	pop	r23
    1ac2:	6f 91       	pop	r22
    1ac4:	5f 91       	pop	r21
    1ac6:	4f 91       	pop	r20
    1ac8:	3f 91       	pop	r19
    1aca:	2f 91       	pop	r18
    1acc:	0f 90       	pop	r0
    1ace:	0b be       	out	0x3b, r0	; 59
    1ad0:	0f 90       	pop	r0
    1ad2:	0f be       	out	0x3f, r0	; 63
    1ad4:	0f 90       	pop	r0
    1ad6:	1f 90       	pop	r1
    1ad8:	18 95       	reti

00001ada <__vector_21>:

ISR ( ADC_vect )
{
    1ada:	1f 92       	push	r1
    1adc:	0f 92       	push	r0
    1ade:	0f b6       	in	r0, 0x3f	; 63
    1ae0:	0f 92       	push	r0
    1ae2:	11 24       	eor	r1, r1
    1ae4:	8f 93       	push	r24
  ADC_low = ADCL;	// Left adjusted; read 2 LSB then 8 MSB
    1ae6:	84 b1       	in	r24, 0x04	; 4
    1ae8:	80 93 9c 0d 	sts	0x0D9C, r24
  ADC_high = ADCH;
    1aec:	85 b1       	in	r24, 0x05	; 5
    1aee:	80 93 63 09 	sts	0x0963, r24
  adc_flag = 1;
    1af2:	81 e0       	ldi	r24, 0x01	; 1
    1af4:	80 93 45 09 	sts	0x0945, r24
}
    1af8:	8f 91       	pop	r24
    1afa:	0f 90       	pop	r0
    1afc:	0f be       	out	0x3f, r0	; 63
    1afe:	0f 90       	pop	r0
    1b00:	1f 90       	pop	r1
    1b02:	18 95       	reti

00001b04 <__vector_20>:

ISR( USART0_TX_vect )
{
    1b04:	1f 92       	push	r1
    1b06:	0f 92       	push	r0
    1b08:	0f b6       	in	r0, 0x3f	; 63
    1b0a:	0f 92       	push	r0
    1b0c:	11 24       	eor	r1, r1
    1b0e:	0b b6       	in	r0, 0x3b	; 59
    1b10:	0f 92       	push	r0
    1b12:	2f 93       	push	r18
    1b14:	3f 93       	push	r19
    1b16:	4f 93       	push	r20
    1b18:	5f 93       	push	r21
    1b1a:	6f 93       	push	r22
    1b1c:	7f 93       	push	r23
    1b1e:	8f 93       	push	r24
    1b20:	9f 93       	push	r25
    1b22:	af 93       	push	r26
    1b24:	bf 93       	push	r27
    1b26:	ef 93       	push	r30
    1b28:	ff 93       	push	r31
    1b2a:	80 e0       	ldi	r24, 0x00	; 0
    1b2c:	0e 94 3e 0c 	call	0x187c	; 0x187c <tx_put_byte.part.0>
  tx_put_byte( 0 );
}
    1b30:	ff 91       	pop	r31
    1b32:	ef 91       	pop	r30
    1b34:	bf 91       	pop	r27
    1b36:	af 91       	pop	r26
    1b38:	9f 91       	pop	r25
    1b3a:	8f 91       	pop	r24
    1b3c:	7f 91       	pop	r23
    1b3e:	6f 91       	pop	r22
    1b40:	5f 91       	pop	r21
    1b42:	4f 91       	pop	r20
    1b44:	3f 91       	pop	r19
    1b46:	2f 91       	pop	r18
    1b48:	0f 90       	pop	r0
    1b4a:	0b be       	out	0x3b, r0	; 59
    1b4c:	0f 90       	pop	r0
    1b4e:	0f be       	out	0x3f, r0	; 63
    1b50:	0f 90       	pop	r0
    1b52:	1f 90       	pop	r1
    1b54:	18 95       	reti

00001b56 <__vector_18>:

ISR( USART0_RX_vect )
{
    1b56:	1f 92       	push	r1
    1b58:	0f 92       	push	r0
    1b5a:	0f b6       	in	r0, 0x3f	; 63
    1b5c:	0f 92       	push	r0
    1b5e:	11 24       	eor	r1, r1
    1b60:	0b b6       	in	r0, 0x3b	; 59
    1b62:	0f 92       	push	r0
    1b64:	2f 93       	push	r18
    1b66:	3f 93       	push	r19
    1b68:	4f 93       	push	r20
    1b6a:	5f 93       	push	r21
    1b6c:	6f 93       	push	r22
    1b6e:	7f 93       	push	r23
    1b70:	8f 93       	push	r24
    1b72:	9f 93       	push	r25
    1b74:	af 93       	push	r26
    1b76:	bf 93       	push	r27
    1b78:	ef 93       	push	r30
    1b7a:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[0], UDR0 ) == VCP_TERM )
    1b7c:	6c b1       	in	r22, 0x0c	; 12
    1b7e:	80 91 a2 0d 	lds	r24, 0x0DA2
    1b82:	90 91 a3 0d 	lds	r25, 0x0DA3
    1b86:	0e 94 9b 0b 	call	0x1736	; 0x1736 <Receive_VCP_byte>
    1b8a:	81 30       	cpi	r24, 0x01	; 1
    1b8c:	29 f4       	brne	.+10     	; 0x1b98 <__vector_18+0x42>
  {
    rx_flag[0]++;
    1b8e:	80 91 a7 0d 	lds	r24, 0x0DA7
    1b92:	8f 5f       	subi	r24, 0xFF	; 255
    1b94:	80 93 a7 0d 	sts	0x0DA7, r24
  }
}
    1b98:	ff 91       	pop	r31
    1b9a:	ef 91       	pop	r30
    1b9c:	bf 91       	pop	r27
    1b9e:	af 91       	pop	r26
    1ba0:	9f 91       	pop	r25
    1ba2:	8f 91       	pop	r24
    1ba4:	7f 91       	pop	r23
    1ba6:	6f 91       	pop	r22
    1ba8:	5f 91       	pop	r21
    1baa:	4f 91       	pop	r20
    1bac:	3f 91       	pop	r19
    1bae:	2f 91       	pop	r18
    1bb0:	0f 90       	pop	r0
    1bb2:	0b be       	out	0x3b, r0	; 59
    1bb4:	0f 90       	pop	r0
    1bb6:	0f be       	out	0x3f, r0	; 63
    1bb8:	0f 90       	pop	r0
    1bba:	1f 90       	pop	r1
    1bbc:	18 95       	reti

00001bbe <tx_put_byte>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    1bbe:	82 30       	cpi	r24, 0x02	; 2
    1bc0:	10 f4       	brcc	.+4      	; 0x1bc6 <tx_put_byte+0x8>
    1bc2:	0c 94 3e 0c 	jmp	0x187c	; 0x187c <tx_put_byte.part.0>
    1bc6:	08 95       	ret

00001bc8 <construct_telemetry_packet>:
  }
}


void construct_telemetry_packet( uint8_t* packet_payload )
{
    1bc8:	2f 92       	push	r2
    1bca:	3f 92       	push	r3
    1bcc:	4f 92       	push	r4
    1bce:	5f 92       	push	r5
    1bd0:	6f 92       	push	r6
    1bd2:	7f 92       	push	r7
    1bd4:	8f 92       	push	r8
    1bd6:	9f 92       	push	r9
    1bd8:	af 92       	push	r10
    1bda:	bf 92       	push	r11
    1bdc:	cf 92       	push	r12
    1bde:	df 92       	push	r13
    1be0:	ef 92       	push	r14
    1be2:	ff 92       	push	r15
    1be4:	0f 93       	push	r16
    1be6:	1f 93       	push	r17
    1be8:	cf 93       	push	r28
    1bea:	df 93       	push	r29
    1bec:	cd b7       	in	r28, 0x3d	; 61
    1bee:	de b7       	in	r29, 0x3e	; 62
    1bf0:	28 97       	sbiw	r28, 0x08	; 8
    1bf2:	0f b6       	in	r0, 0x3f	; 63
    1bf4:	f8 94       	cli
    1bf6:	de bf       	out	0x3e, r29	; 62
    1bf8:	0f be       	out	0x3f, r0	; 63
    1bfa:	cd bf       	out	0x3d, r28	; 61
    1bfc:	98 87       	std	Y+8, r25	; 0x08
    1bfe:	8f 83       	std	Y+7, r24	; 0x07
  packet_payload[0] = VCP_POWER_TELEMETRY;
    1c00:	dc 01       	movw	r26, r24
    1c02:	1c 92       	st	X, r1
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
    1c04:	30 91 50 04 	lds	r19, 0x0450
    1c08:	33 0f       	add	r19, r19
                  ( svit[RADIO_1].switch_state << 2 )    |
    1c0a:	80 91 6c 04 	lds	r24, 0x046C
    1c0e:	b4 e0       	ldi	r27, 0x04	; 4
    1c10:	8b 9f       	mul	r24, r27
    1c12:	c0 01       	movw	r24, r0
    1c14:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1c16:	38 2b       	or	r19, r24
    1c18:	80 91 34 04 	lds	r24, 0x0434
    1c1c:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
    1c1e:	80 91 88 04 	lds	r24, 0x0488
    1c22:	e8 e0       	ldi	r30, 0x08	; 8
    1c24:	8e 9f       	mul	r24, r30
    1c26:	c0 01       	movw	r24, r0
    1c28:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1c2a:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
    1c2c:	80 91 dc 04 	lds	r24, 0x04DC
    1c30:	f0 e1       	ldi	r31, 0x10	; 16
    1c32:	8f 9f       	mul	r24, r31
    1c34:	c0 01       	movw	r24, r0
    1c36:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1c38:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;
    1c3a:	80 91 f8 04 	lds	r24, 0x04F8
    1c3e:	20 e2       	ldi	r18, 0x20	; 32
    1c40:	82 9f       	mul	r24, r18
    1c42:	c0 01       	movw	r24, r0
    1c44:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1c46:	38 2b       	or	r19, r24
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
    1c48:	40 91 30 05 	lds	r20, 0x0530
    1c4c:	44 0f       	add	r20, r20
                  ( svit[TORQUER_3].switch_state << 2 ) |
    1c4e:	80 91 4c 05 	lds	r24, 0x054C
    1c52:	54 e0       	ldi	r21, 0x04	; 4
    1c54:	85 9f       	mul	r24, r21
    1c56:	c0 01       	movw	r24, r0
    1c58:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1c5a:	48 2b       	or	r20, r24
    1c5c:	80 91 14 05 	lds	r24, 0x0514
    1c60:	48 2b       	or	r20, r24
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );
    1c62:	e4 ea       	ldi	r30, 0xA4	; 164
    1c64:	f4 e0       	ldi	r31, 0x04	; 4
    1c66:	80 81       	ld	r24, Z
    1c68:	a8 e0       	ldi	r26, 0x08	; 8
    1c6a:	8a 9f       	mul	r24, r26
    1c6c:	c0 01       	movw	r24, r0
    1c6e:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1c70:	48 2b       	or	r20, r24
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
    1c72:	20 91 54 03 	lds	r18, 0x0354
    1c76:	22 0f       	add	r18, r18
                  ( svit[FC_5V].switch_state << 2 )        |
    1c78:	80 91 70 03 	lds	r24, 0x0370
    1c7c:	b4 e0       	ldi	r27, 0x04	; 4
    1c7e:	8b 9f       	mul	r24, r27
    1c80:	c0 01       	movw	r24, r0
    1c82:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1c84:	28 2b       	or	r18, r24
    1c86:	80 91 38 03 	lds	r24, 0x0338
    1c8a:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
    1c8c:	80 91 a8 03 	lds	r24, 0x03A8
    1c90:	58 e0       	ldi	r21, 0x08	; 8
    1c92:	85 9f       	mul	r24, r21
    1c94:	c0 01       	movw	r24, r0
    1c96:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1c98:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
    1c9a:	80 91 c4 03 	lds	r24, 0x03C4
    1c9e:	a0 e1       	ldi	r26, 0x10	; 16
    1ca0:	8a 9f       	mul	r24, r26
    1ca2:	c0 01       	movw	r24, r0
    1ca4:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1ca6:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
    1ca8:	80 91 e0 03 	lds	r24, 0x03E0
    1cac:	b0 e2       	ldi	r27, 0x20	; 32
    1cae:	8b 9f       	mul	r24, r27
    1cb0:	c0 01       	movw	r24, r0
    1cb2:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1cb4:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
    1cb6:	80 91 fc 03 	lds	r24, 0x03FC
    1cba:	50 e4       	ldi	r21, 0x40	; 64
    1cbc:	85 9f       	mul	r24, r21
    1cbe:	c0 01       	movw	r24, r0
    1cc0:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1cc2:	28 2b       	or	r18, r24
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;
    1cc4:	80 91 18 04 	lds	r24, 0x0418
    1cc8:	a0 e8       	ldi	r26, 0x80	; 128
    1cca:	8a 9f       	mul	r24, r26
    1ccc:	c0 01       	movw	r24, r0
    1cce:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1cd0:	28 2b       	or	r18, r24
  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );

  packet_payload[1] = on_off_state0;
    1cd2:	af 81       	ldd	r26, Y+7	; 0x07
    1cd4:	b8 85       	ldd	r27, Y+8	; 0x08
    1cd6:	11 96       	adiw	r26, 0x01	; 1
    1cd8:	2c 93       	st	X, r18
    1cda:	11 97       	sbiw	r26, 0x01	; 1
  packet_payload[2] = on_off_state1;
    1cdc:	12 96       	adiw	r26, 0x02	; 2
    1cde:	3c 93       	st	X, r19
    1ce0:	12 97       	sbiw	r26, 0x02	; 2
  packet_payload[3] = on_off_state2;
    1ce2:	13 96       	adiw	r26, 0x03	; 3
    1ce4:	4c 93       	st	X, r20
    1ce6:	13 97       	sbiw	r26, 0x03	; 3
  packet_payload[4] = 0x99;
    1ce8:	89 e9       	ldi	r24, 0x99	; 153
    1cea:	14 96       	adiw	r26, 0x04	; 4
    1cec:	8c 93       	st	X, r24
    1cee:	14 97       	sbiw	r26, 0x04	; 4
  packet_payload[5] = svit[MAESTRO].switch_state;
    1cf0:	80 81       	ld	r24, Z
    1cf2:	15 96       	adiw	r26, 0x05	; 5
    1cf4:	8c 93       	st	X, r24

  // voltage values (raw ADC output)
  packet_payload[6]  = SVIT_check_V_critical( svit[SPECTROMETER].name );
    1cf6:	26 e3       	ldi	r18, 0x36	; 54
    1cf8:	62 2e       	mov	r6, r18
    1cfa:	23 e0       	ldi	r18, 0x03	; 3
    1cfc:	72 2e       	mov	r7, r18
    1cfe:	f3 01       	movw	r30, r6
    1d00:	80 81       	ld	r24, Z
    1d02:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1d06:	af 81       	ldd	r26, Y+7	; 0x07
    1d08:	b8 85       	ldd	r27, Y+8	; 0x08
    1d0a:	16 96       	adiw	r26, 0x06	; 6
    1d0c:	8c 93       	st	X, r24
  packet_payload[7]  = SVIT_check_V_critical( svit[STAR_TRACKER].name );
    1d0e:	32 e5       	ldi	r19, 0x52	; 82
    1d10:	83 2e       	mov	r8, r19
    1d12:	33 e0       	ldi	r19, 0x03	; 3
    1d14:	93 2e       	mov	r9, r19
    1d16:	f4 01       	movw	r30, r8
    1d18:	80 81       	ld	r24, Z
    1d1a:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1d1e:	af 81       	ldd	r26, Y+7	; 0x07
    1d20:	b8 85       	ldd	r27, Y+8	; 0x08
    1d22:	17 96       	adiw	r26, 0x07	; 7
    1d24:	8c 93       	st	X, r24
  packet_payload[8]  = SVIT_check_V_critical( svit[FC_5V].name );
    1d26:	4e e6       	ldi	r20, 0x6E	; 110
    1d28:	a4 2e       	mov	r10, r20
    1d2a:	43 e0       	ldi	r20, 0x03	; 3
    1d2c:	b4 2e       	mov	r11, r20
    1d2e:	f5 01       	movw	r30, r10
    1d30:	80 81       	ld	r24, Z
    1d32:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1d36:	af 81       	ldd	r26, Y+7	; 0x07
    1d38:	b8 85       	ldd	r27, Y+8	; 0x08
    1d3a:	18 96       	adiw	r26, 0x08	; 8
    1d3c:	8c 93       	st	X, r24
  packet_payload[9]  = SVIT_check_V_critical( svit[FC_3_3V].name );
    1d3e:	5a e8       	ldi	r21, 0x8A	; 138
    1d40:	c5 2e       	mov	r12, r21
    1d42:	53 e0       	ldi	r21, 0x03	; 3
    1d44:	d5 2e       	mov	r13, r21
    1d46:	f6 01       	movw	r30, r12
    1d48:	80 81       	ld	r24, Z
    1d4a:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1d4e:	af 81       	ldd	r26, Y+7	; 0x07
    1d50:	b8 85       	ldd	r27, Y+8	; 0x08
    1d52:	19 96       	adiw	r26, 0x09	; 9
    1d54:	8c 93       	st	X, r24
  packet_payload[10] = SVIT_check_V_critical( svit[GPS_1].name );
    1d56:	66 ea       	ldi	r22, 0xA6	; 166
    1d58:	e6 2e       	mov	r14, r22
    1d5a:	63 e0       	ldi	r22, 0x03	; 3
    1d5c:	f6 2e       	mov	r15, r22
    1d5e:	f7 01       	movw	r30, r14
    1d60:	80 81       	ld	r24, Z
    1d62:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1d66:	af 81       	ldd	r26, Y+7	; 0x07
    1d68:	b8 85       	ldd	r27, Y+8	; 0x08
    1d6a:	1a 96       	adiw	r26, 0x0a	; 10
    1d6c:	8c 93       	st	X, r24
  packet_payload[11] = SVIT_check_V_critical( svit[CDH_IB].name );
    1d6e:	0e ed       	ldi	r16, 0xDE	; 222
    1d70:	13 e0       	ldi	r17, 0x03	; 3
    1d72:	f8 01       	movw	r30, r16
    1d74:	80 81       	ld	r24, Z
    1d76:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1d7a:	af 81       	ldd	r26, Y+7	; 0x07
    1d7c:	b8 85       	ldd	r27, Y+8	; 0x08
    1d7e:	1b 96       	adiw	r26, 0x0b	; 11
    1d80:	8c 93       	st	X, r24
  packet_payload[12] = SVIT_check_V_critical( svit[HEATER_1].name );
    1d82:	ea ef       	ldi	r30, 0xFA	; 250
    1d84:	f3 e0       	ldi	r31, 0x03	; 3
    1d86:	80 81       	ld	r24, Z
    1d88:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1d8c:	af 81       	ldd	r26, Y+7	; 0x07
    1d8e:	b8 85       	ldd	r27, Y+8	; 0x08
    1d90:	1c 96       	adiw	r26, 0x0c	; 12
    1d92:	8c 93       	st	X, r24
  packet_payload[13] = SVIT_check_V_critical( svit[HEATER_2].name );
    1d94:	76 e1       	ldi	r23, 0x16	; 22
    1d96:	47 2e       	mov	r4, r23
    1d98:	74 e0       	ldi	r23, 0x04	; 4
    1d9a:	57 2e       	mov	r5, r23
    1d9c:	f2 01       	movw	r30, r4
    1d9e:	80 81       	ld	r24, Z
    1da0:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1da4:	af 81       	ldd	r26, Y+7	; 0x07
    1da6:	b8 85       	ldd	r27, Y+8	; 0x08
    1da8:	1d 96       	adiw	r26, 0x0d	; 13
    1daa:	8c 93       	st	X, r24
  packet_payload[14] = SVIT_check_V_critical( svit[CMG].name );
    1dac:	e2 e3       	ldi	r30, 0x32	; 50
    1dae:	2e 2e       	mov	r2, r30
    1db0:	e4 e0       	ldi	r30, 0x04	; 4
    1db2:	3e 2e       	mov	r3, r30
    1db4:	f1 01       	movw	r30, r2
    1db6:	80 81       	ld	r24, Z
    1db8:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1dbc:	af 81       	ldd	r26, Y+7	; 0x07
    1dbe:	b8 85       	ldd	r27, Y+8	; 0x08
    1dc0:	1e 96       	adiw	r26, 0x0e	; 14
    1dc2:	8c 93       	st	X, r24
  packet_payload[15] = SVIT_check_V_critical( svit[SUN_SENSOR].name );
    1dc4:	2e e4       	ldi	r18, 0x4E	; 78
    1dc6:	34 e0       	ldi	r19, 0x04	; 4
    1dc8:	f9 01       	movw	r30, r18
    1dca:	80 81       	ld	r24, Z
    1dcc:	29 83       	std	Y+1, r18	; 0x01
    1dce:	3a 83       	std	Y+2, r19	; 0x02
    1dd0:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1dd4:	af 81       	ldd	r26, Y+7	; 0x07
    1dd6:	b8 85       	ldd	r27, Y+8	; 0x08
    1dd8:	1f 96       	adiw	r26, 0x0f	; 15
    1dda:	8c 93       	st	X, r24
  packet_payload[16] = SVIT_check_V_critical( svit[RADIO_1].name );
    1ddc:	4a e6       	ldi	r20, 0x6A	; 106
    1dde:	54 e0       	ldi	r21, 0x04	; 4
    1de0:	fa 01       	movw	r30, r20
    1de2:	80 81       	ld	r24, Z
    1de4:	4b 83       	std	Y+3, r20	; 0x03
    1de6:	5c 83       	std	Y+4, r21	; 0x04
    1de8:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1dec:	af 81       	ldd	r26, Y+7	; 0x07
    1dee:	b8 85       	ldd	r27, Y+8	; 0x08
    1df0:	50 96       	adiw	r26, 0x10	; 16
    1df2:	8c 93       	st	X, r24
  packet_payload[17] = SVIT_check_V_critical( svit[RADIO_2].name );
    1df4:	66 e8       	ldi	r22, 0x86	; 134
    1df6:	74 e0       	ldi	r23, 0x04	; 4
    1df8:	fb 01       	movw	r30, r22
    1dfa:	80 81       	ld	r24, Z
    1dfc:	6d 83       	std	Y+5, r22	; 0x05
    1dfe:	7e 83       	std	Y+6, r23	; 0x06
    1e00:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1e04:	af 81       	ldd	r26, Y+7	; 0x07
    1e06:	b8 85       	ldd	r27, Y+8	; 0x08
    1e08:	51 96       	adiw	r26, 0x11	; 17
    1e0a:	8c 93       	st	X, r24
  packet_payload[18] = SVIT_check_V_critical( svit[FOG_15V].name );
    1e0c:	ea ed       	ldi	r30, 0xDA	; 218
    1e0e:	f4 e0       	ldi	r31, 0x04	; 4
    1e10:	80 81       	ld	r24, Z
    1e12:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1e16:	af 81       	ldd	r26, Y+7	; 0x07
    1e18:	b8 85       	ldd	r27, Y+8	; 0x08
    1e1a:	52 96       	adiw	r26, 0x12	; 18
    1e1c:	8c 93       	st	X, r24
  packet_payload[19] = SVIT_check_V_critical( svit[FOG_5V].name );
    1e1e:	e6 ef       	ldi	r30, 0xF6	; 246
    1e20:	f4 e0       	ldi	r31, 0x04	; 4
    1e22:	80 81       	ld	r24, Z
    1e24:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1e28:	af 81       	ldd	r26, Y+7	; 0x07
    1e2a:	b8 85       	ldd	r27, Y+8	; 0x08
    1e2c:	53 96       	adiw	r26, 0x13	; 19
    1e2e:	8c 93       	st	X, r24
  packet_payload[20] = SVIT_check_V_critical( svit[TORQUER_1].name );
    1e30:	e2 e1       	ldi	r30, 0x12	; 18
    1e32:	f5 e0       	ldi	r31, 0x05	; 5
    1e34:	80 81       	ld	r24, Z
    1e36:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1e3a:	af 81       	ldd	r26, Y+7	; 0x07
    1e3c:	b8 85       	ldd	r27, Y+8	; 0x08
    1e3e:	54 96       	adiw	r26, 0x14	; 20
    1e40:	8c 93       	st	X, r24
  packet_payload[21] = SVIT_check_V_critical( svit[TORQUER_2].name );
    1e42:	ee e2       	ldi	r30, 0x2E	; 46
    1e44:	f5 e0       	ldi	r31, 0x05	; 5
    1e46:	80 81       	ld	r24, Z
    1e48:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1e4c:	af 81       	ldd	r26, Y+7	; 0x07
    1e4e:	b8 85       	ldd	r27, Y+8	; 0x08
    1e50:	55 96       	adiw	r26, 0x15	; 21
    1e52:	8c 93       	st	X, r24
  packet_payload[22] = SVIT_check_V_critical( svit[TORQUER_3].name );
    1e54:	ea e4       	ldi	r30, 0x4A	; 74
    1e56:	f5 e0       	ldi	r31, 0x05	; 5
    1e58:	80 81       	ld	r24, Z
    1e5a:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1e5e:	af 81       	ldd	r26, Y+7	; 0x07
    1e60:	b8 85       	ldd	r27, Y+8	; 0x08
    1e62:	56 96       	adiw	r26, 0x16	; 22
    1e64:	8c 93       	st	X, r24
  packet_payload[23] = SVIT_check_V_critical( svit[BATTERY_1].name );
    1e66:	e6 e6       	ldi	r30, 0x66	; 102
    1e68:	f5 e0       	ldi	r31, 0x05	; 5
    1e6a:	80 81       	ld	r24, Z
    1e6c:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1e70:	af 81       	ldd	r26, Y+7	; 0x07
    1e72:	b8 85       	ldd	r27, Y+8	; 0x08
    1e74:	57 96       	adiw	r26, 0x17	; 23
    1e76:	8c 93       	st	X, r24
  packet_payload[24] = SVIT_check_V_critical( svit[BATTERY_2].name );
    1e78:	e2 e8       	ldi	r30, 0x82	; 130
    1e7a:	f5 e0       	ldi	r31, 0x05	; 5
    1e7c:	80 81       	ld	r24, Z
    1e7e:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1e82:	af 81       	ldd	r26, Y+7	; 0x07
    1e84:	b8 85       	ldd	r27, Y+8	; 0x08
    1e86:	58 96       	adiw	r26, 0x18	; 24
    1e88:	8c 93       	st	X, r24
  packet_payload[25] = SVIT_check_V_critical( svit[SOLAR_FULL].name );
    1e8a:	ee e9       	ldi	r30, 0x9E	; 158
    1e8c:	f5 e0       	ldi	r31, 0x05	; 5
    1e8e:	80 81       	ld	r24, Z
    1e90:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1e94:	af 81       	ldd	r26, Y+7	; 0x07
    1e96:	b8 85       	ldd	r27, Y+8	; 0x08
    1e98:	59 96       	adiw	r26, 0x19	; 25
    1e9a:	8c 93       	st	X, r24
  packet_payload[26] = SVIT_check_V_critical( svit[SOLAR_1].name );
    1e9c:	ea eb       	ldi	r30, 0xBA	; 186
    1e9e:	f5 e0       	ldi	r31, 0x05	; 5
    1ea0:	80 81       	ld	r24, Z
    1ea2:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1ea6:	af 81       	ldd	r26, Y+7	; 0x07
    1ea8:	b8 85       	ldd	r27, Y+8	; 0x08
    1eaa:	5a 96       	adiw	r26, 0x1a	; 26
    1eac:	8c 93       	st	X, r24
  packet_payload[27] = SVIT_check_V_critical( svit[SOLAR_2].name );
    1eae:	e6 ed       	ldi	r30, 0xD6	; 214
    1eb0:	f5 e0       	ldi	r31, 0x05	; 5
    1eb2:	80 81       	ld	r24, Z
    1eb4:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1eb8:	af 81       	ldd	r26, Y+7	; 0x07
    1eba:	b8 85       	ldd	r27, Y+8	; 0x08
    1ebc:	5b 96       	adiw	r26, 0x1b	; 27
    1ebe:	8c 93       	st	X, r24
  packet_payload[28] = SVIT_check_V_critical( svit[SOLAR_3].name );
    1ec0:	e2 ef       	ldi	r30, 0xF2	; 242
    1ec2:	f5 e0       	ldi	r31, 0x05	; 5
    1ec4:	80 81       	ld	r24, Z
    1ec6:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1eca:	af 81       	ldd	r26, Y+7	; 0x07
    1ecc:	b8 85       	ldd	r27, Y+8	; 0x08
    1ece:	5c 96       	adiw	r26, 0x1c	; 28
    1ed0:	8c 93       	st	X, r24
  packet_payload[29] = SVIT_check_V_critical( svit[SOLAR_4].name );
    1ed2:	ee e0       	ldi	r30, 0x0E	; 14
    1ed4:	f6 e0       	ldi	r31, 0x06	; 6
    1ed6:	80 81       	ld	r24, Z
    1ed8:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1edc:	af 81       	ldd	r26, Y+7	; 0x07
    1ede:	b8 85       	ldd	r27, Y+8	; 0x08
    1ee0:	5d 96       	adiw	r26, 0x1d	; 29
    1ee2:	8c 93       	st	X, r24
  packet_payload[30] = SVIT_check_V_critical( svit[SOLAR_5].name );
    1ee4:	ea e2       	ldi	r30, 0x2A	; 42
    1ee6:	f6 e0       	ldi	r31, 0x06	; 6
    1ee8:	80 81       	ld	r24, Z
    1eea:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1eee:	af 81       	ldd	r26, Y+7	; 0x07
    1ef0:	b8 85       	ldd	r27, Y+8	; 0x08
    1ef2:	5e 96       	adiw	r26, 0x1e	; 30
    1ef4:	8c 93       	st	X, r24
  packet_payload[31] = SVIT_check_V_critical( svit[SOLAR_6].name );
    1ef6:	e6 e4       	ldi	r30, 0x46	; 70
    1ef8:	f6 e0       	ldi	r31, 0x06	; 6
    1efa:	80 81       	ld	r24, Z
    1efc:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1f00:	af 81       	ldd	r26, Y+7	; 0x07
    1f02:	b8 85       	ldd	r27, Y+8	; 0x08
    1f04:	5f 96       	adiw	r26, 0x1f	; 31
    1f06:	8c 93       	st	X, r24
  packet_payload[32] = SVIT_check_V_critical( svit[SOLAR_7].name );
    1f08:	e2 e6       	ldi	r30, 0x62	; 98
    1f0a:	f6 e0       	ldi	r31, 0x06	; 6
    1f0c:	80 81       	ld	r24, Z
    1f0e:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1f12:	af 81       	ldd	r26, Y+7	; 0x07
    1f14:	b8 85       	ldd	r27, Y+8	; 0x08
    1f16:	90 96       	adiw	r26, 0x20	; 32
    1f18:	8c 93       	st	X, r24
  packet_payload[33] = SVIT_check_V_critical( svit[SOLAR_8].name );
    1f1a:	ee e7       	ldi	r30, 0x7E	; 126
    1f1c:	f6 e0       	ldi	r31, 0x06	; 6
    1f1e:	80 81       	ld	r24, Z
    1f20:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1f24:	af 81       	ldd	r26, Y+7	; 0x07
    1f26:	b8 85       	ldd	r27, Y+8	; 0x08
    1f28:	91 96       	adiw	r26, 0x21	; 33
    1f2a:	8c 93       	st	X, r24
  packet_payload[34] = SVIT_check_V_critical( svit[SOLAR_9].name );
    1f2c:	ea e9       	ldi	r30, 0x9A	; 154
    1f2e:	f6 e0       	ldi	r31, 0x06	; 6
    1f30:	80 81       	ld	r24, Z
    1f32:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1f36:	af 81       	ldd	r26, Y+7	; 0x07
    1f38:	b8 85       	ldd	r27, Y+8	; 0x08
    1f3a:	92 96       	adiw	r26, 0x22	; 34
    1f3c:	8c 93       	st	X, r24
  packet_payload[35] = SVIT_check_V_critical( svit[SOLAR_10].name );
    1f3e:	e6 eb       	ldi	r30, 0xB6	; 182
    1f40:	f6 e0       	ldi	r31, 0x06	; 6
    1f42:	80 81       	ld	r24, Z
    1f44:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1f48:	af 81       	ldd	r26, Y+7	; 0x07
    1f4a:	b8 85       	ldd	r27, Y+8	; 0x08
    1f4c:	93 96       	adiw	r26, 0x23	; 35
    1f4e:	8c 93       	st	X, r24
  packet_payload[36] = SVIT_check_V_critical( svit[SOLAR_11].name );
    1f50:	e2 ed       	ldi	r30, 0xD2	; 210
    1f52:	f6 e0       	ldi	r31, 0x06	; 6
    1f54:	80 81       	ld	r24, Z
    1f56:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1f5a:	af 81       	ldd	r26, Y+7	; 0x07
    1f5c:	b8 85       	ldd	r27, Y+8	; 0x08
    1f5e:	94 96       	adiw	r26, 0x24	; 36
    1f60:	8c 93       	st	X, r24
  packet_payload[37] = SVIT_check_V_critical( svit[SOLAR_12].name );
    1f62:	ee ee       	ldi	r30, 0xEE	; 238
    1f64:	f6 e0       	ldi	r31, 0x06	; 6
    1f66:	80 81       	ld	r24, Z
    1f68:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1f6c:	af 81       	ldd	r26, Y+7	; 0x07
    1f6e:	b8 85       	ldd	r27, Y+8	; 0x08
    1f70:	95 96       	adiw	r26, 0x25	; 37
    1f72:	8c 93       	st	X, r24
  packet_payload[38] = SVIT_check_V_critical( svit[POWER_BOARD].name );
    1f74:	80 91 0a 07 	lds	r24, 0x070A
    1f78:	0e 94 9c 09 	call	0x1338	; 0x1338 <SVIT_check_V_critical>
    1f7c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f7e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f80:	86 a3       	std	Z+38, r24	; 0x26
  //uint8_t voltage_error1;
  //uint8_t voltage_error2;
  //uint8_t voltage_error3;
  //uint8_t voltage_error4;
 
  packet_payload[39] = 0;
    1f82:	17 a2       	std	Z+39, r1	; 0x27
  packet_payload[40] = 0;
    1f84:	10 a6       	std	Z+40, r1	; 0x28
  packet_payload[41] = 0;
    1f86:	11 a6       	std	Z+41, r1	; 0x29
  packet_payload[42] = 0;
    1f88:	12 a6       	std	Z+42, r1	; 0x2a
  packet_payload[43] = 0;
    1f8a:	13 a6       	std	Z+43, r1	; 0x2b

  // current values (raw ADC output)
  packet_payload[44] = SVIT_check_I_critical( svit[SPECTROMETER].name );
    1f8c:	d3 01       	movw	r26, r6
    1f8e:	8c 91       	ld	r24, X
    1f90:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    1f94:	ef 81       	ldd	r30, Y+7	; 0x07
    1f96:	f8 85       	ldd	r31, Y+8	; 0x08
    1f98:	84 a7       	std	Z+44, r24	; 0x2c
  packet_payload[45] = SVIT_check_I_critical( svit[STAR_TRACKER].name );
    1f9a:	d4 01       	movw	r26, r8
    1f9c:	8c 91       	ld	r24, X
    1f9e:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    1fa2:	ef 81       	ldd	r30, Y+7	; 0x07
    1fa4:	f8 85       	ldd	r31, Y+8	; 0x08
    1fa6:	85 a7       	std	Z+45, r24	; 0x2d
  packet_payload[46] = SVIT_check_I_critical( svit[FC_5V].name );
    1fa8:	d5 01       	movw	r26, r10
    1faa:	8c 91       	ld	r24, X
    1fac:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    1fb0:	ef 81       	ldd	r30, Y+7	; 0x07
    1fb2:	f8 85       	ldd	r31, Y+8	; 0x08
    1fb4:	86 a7       	std	Z+46, r24	; 0x2e
  packet_payload[47] = SVIT_check_I_critical( svit[FC_3_3V].name );
    1fb6:	d6 01       	movw	r26, r12
    1fb8:	8c 91       	ld	r24, X
    1fba:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    1fbe:	ef 81       	ldd	r30, Y+7	; 0x07
    1fc0:	f8 85       	ldd	r31, Y+8	; 0x08
    1fc2:	87 a7       	std	Z+47, r24	; 0x2f
  packet_payload[48] = SVIT_check_I_critical( svit[GPS_1].name );
    1fc4:	d7 01       	movw	r26, r14
    1fc6:	8c 91       	ld	r24, X
    1fc8:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    1fcc:	ef 81       	ldd	r30, Y+7	; 0x07
    1fce:	f8 85       	ldd	r31, Y+8	; 0x08
    1fd0:	80 ab       	std	Z+48, r24	; 0x30
  packet_payload[49] = SVIT_check_I_critical( svit[CDH_IB].name );
    1fd2:	d8 01       	movw	r26, r16
    1fd4:	8c 91       	ld	r24, X
    1fd6:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    1fda:	ef 81       	ldd	r30, Y+7	; 0x07
    1fdc:	f8 85       	ldd	r31, Y+8	; 0x08
    1fde:	81 ab       	std	Z+49, r24	; 0x31
  packet_payload[50] = SVIT_check_I_critical( svit[HEATER_1].name );
    1fe0:	aa ef       	ldi	r26, 0xFA	; 250
    1fe2:	b3 e0       	ldi	r27, 0x03	; 3
    1fe4:	8c 91       	ld	r24, X
    1fe6:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    1fea:	ef 81       	ldd	r30, Y+7	; 0x07
    1fec:	f8 85       	ldd	r31, Y+8	; 0x08
    1fee:	82 ab       	std	Z+50, r24	; 0x32
  packet_payload[51] = SVIT_check_I_critical( svit[HEATER_2].name );
    1ff0:	d2 01       	movw	r26, r4
    1ff2:	8c 91       	ld	r24, X
    1ff4:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    1ff8:	ef 81       	ldd	r30, Y+7	; 0x07
    1ffa:	f8 85       	ldd	r31, Y+8	; 0x08
    1ffc:	83 ab       	std	Z+51, r24	; 0x33
  packet_payload[52] = SVIT_check_I_critical( svit[CMG].name );
    1ffe:	d1 01       	movw	r26, r2
    2000:	8c 91       	ld	r24, X
    2002:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    2006:	ef 81       	ldd	r30, Y+7	; 0x07
    2008:	f8 85       	ldd	r31, Y+8	; 0x08
    200a:	84 ab       	std	Z+52, r24	; 0x34
  packet_payload[53] = SVIT_check_I_critical( svit[SUN_SENSOR].name );
    200c:	29 81       	ldd	r18, Y+1	; 0x01
    200e:	3a 81       	ldd	r19, Y+2	; 0x02
    2010:	d9 01       	movw	r26, r18
    2012:	8c 91       	ld	r24, X
    2014:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    2018:	ef 81       	ldd	r30, Y+7	; 0x07
    201a:	f8 85       	ldd	r31, Y+8	; 0x08
    201c:	85 ab       	std	Z+53, r24	; 0x35
  packet_payload[54] = SVIT_check_I_critical( svit[RADIO_1].name );
    201e:	4b 81       	ldd	r20, Y+3	; 0x03
    2020:	5c 81       	ldd	r21, Y+4	; 0x04
    2022:	da 01       	movw	r26, r20
    2024:	8c 91       	ld	r24, X
    2026:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    202a:	ef 81       	ldd	r30, Y+7	; 0x07
    202c:	f8 85       	ldd	r31, Y+8	; 0x08
    202e:	86 ab       	std	Z+54, r24	; 0x36
  packet_payload[55] = SVIT_check_I_critical( svit[RADIO_2].name );
    2030:	6d 81       	ldd	r22, Y+5	; 0x05
    2032:	7e 81       	ldd	r23, Y+6	; 0x06
    2034:	db 01       	movw	r26, r22
    2036:	8c 91       	ld	r24, X
    2038:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    203c:	ef 81       	ldd	r30, Y+7	; 0x07
    203e:	f8 85       	ldd	r31, Y+8	; 0x08
    2040:	87 ab       	std	Z+55, r24	; 0x37
  packet_payload[56] = SVIT_check_I_critical( svit[FOG_15V].name );
    2042:	aa ed       	ldi	r26, 0xDA	; 218
    2044:	b4 e0       	ldi	r27, 0x04	; 4
    2046:	8c 91       	ld	r24, X
    2048:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    204c:	ef 81       	ldd	r30, Y+7	; 0x07
    204e:	f8 85       	ldd	r31, Y+8	; 0x08
    2050:	80 af       	std	Z+56, r24	; 0x38
  packet_payload[57] = SVIT_check_I_critical( svit[FOG_5V].name );
    2052:	a6 ef       	ldi	r26, 0xF6	; 246
    2054:	b4 e0       	ldi	r27, 0x04	; 4
    2056:	8c 91       	ld	r24, X
    2058:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    205c:	ef 81       	ldd	r30, Y+7	; 0x07
    205e:	f8 85       	ldd	r31, Y+8	; 0x08
    2060:	81 af       	std	Z+57, r24	; 0x39
  packet_payload[58] = SVIT_check_I_critical( svit[TORQUER_1].name );
    2062:	a2 e1       	ldi	r26, 0x12	; 18
    2064:	b5 e0       	ldi	r27, 0x05	; 5
    2066:	8c 91       	ld	r24, X
    2068:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    206c:	ef 81       	ldd	r30, Y+7	; 0x07
    206e:	f8 85       	ldd	r31, Y+8	; 0x08
    2070:	82 af       	std	Z+58, r24	; 0x3a
  packet_payload[59] = SVIT_check_I_critical( svit[TORQUER_2].name );
    2072:	ae e2       	ldi	r26, 0x2E	; 46
    2074:	b5 e0       	ldi	r27, 0x05	; 5
    2076:	8c 91       	ld	r24, X
    2078:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    207c:	ef 81       	ldd	r30, Y+7	; 0x07
    207e:	f8 85       	ldd	r31, Y+8	; 0x08
    2080:	83 af       	std	Z+59, r24	; 0x3b
  packet_payload[60] = SVIT_check_I_critical( svit[TORQUER_3].name );
    2082:	aa e4       	ldi	r26, 0x4A	; 74
    2084:	b5 e0       	ldi	r27, 0x05	; 5
    2086:	8c 91       	ld	r24, X
    2088:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    208c:	ef 81       	ldd	r30, Y+7	; 0x07
    208e:	f8 85       	ldd	r31, Y+8	; 0x08
    2090:	84 af       	std	Z+60, r24	; 0x3c
  packet_payload[61] = SVIT_check_I_critical( svit[BATTERY_1].name );
    2092:	a6 e6       	ldi	r26, 0x66	; 102
    2094:	b5 e0       	ldi	r27, 0x05	; 5
    2096:	8c 91       	ld	r24, X
    2098:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    209c:	ef 81       	ldd	r30, Y+7	; 0x07
    209e:	f8 85       	ldd	r31, Y+8	; 0x08
    20a0:	85 af       	std	Z+61, r24	; 0x3d
  packet_payload[62] = SVIT_check_I_critical( svit[BATTERY_2].name );
    20a2:	a2 e8       	ldi	r26, 0x82	; 130
    20a4:	b5 e0       	ldi	r27, 0x05	; 5
    20a6:	8c 91       	ld	r24, X
    20a8:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    20ac:	ef 81       	ldd	r30, Y+7	; 0x07
    20ae:	f8 85       	ldd	r31, Y+8	; 0x08
    20b0:	86 af       	std	Z+62, r24	; 0x3e
  packet_payload[63] = SVIT_check_I_critical( svit[SOLAR_FULL].name );
    20b2:	ae e9       	ldi	r26, 0x9E	; 158
    20b4:	b5 e0       	ldi	r27, 0x05	; 5
    20b6:	8c 91       	ld	r24, X
    20b8:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    20bc:	ef 81       	ldd	r30, Y+7	; 0x07
    20be:	f8 85       	ldd	r31, Y+8	; 0x08
    20c0:	87 af       	std	Z+63, r24	; 0x3f
  packet_payload[64] = SVIT_check_I_critical( svit[SOLAR_1].name );
    20c2:	aa eb       	ldi	r26, 0xBA	; 186
    20c4:	b5 e0       	ldi	r27, 0x05	; 5
    20c6:	8c 91       	ld	r24, X
    20c8:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    20cc:	ef 81       	ldd	r30, Y+7	; 0x07
    20ce:	f8 85       	ldd	r31, Y+8	; 0x08
    20d0:	e0 5c       	subi	r30, 0xC0	; 192
    20d2:	ff 4f       	sbci	r31, 0xFF	; 255
    20d4:	80 83       	st	Z, r24
  packet_payload[65] = SVIT_check_I_critical( svit[SOLAR_2].name );
    20d6:	e6 ed       	ldi	r30, 0xD6	; 214
    20d8:	f5 e0       	ldi	r31, 0x05	; 5
    20da:	80 81       	ld	r24, Z
    20dc:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    20e0:	ef 81       	ldd	r30, Y+7	; 0x07
    20e2:	f8 85       	ldd	r31, Y+8	; 0x08
    20e4:	ef 5b       	subi	r30, 0xBF	; 191
    20e6:	ff 4f       	sbci	r31, 0xFF	; 255
    20e8:	80 83       	st	Z, r24
  packet_payload[66] = SVIT_check_I_critical( svit[SOLAR_3].name );
    20ea:	a2 ef       	ldi	r26, 0xF2	; 242
    20ec:	b5 e0       	ldi	r27, 0x05	; 5
    20ee:	8c 91       	ld	r24, X
    20f0:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    20f4:	ef 81       	ldd	r30, Y+7	; 0x07
    20f6:	f8 85       	ldd	r31, Y+8	; 0x08
    20f8:	ee 5b       	subi	r30, 0xBE	; 190
    20fa:	ff 4f       	sbci	r31, 0xFF	; 255
    20fc:	80 83       	st	Z, r24
  packet_payload[67] = SVIT_check_I_critical( svit[SOLAR_4].name );
    20fe:	ee e0       	ldi	r30, 0x0E	; 14
    2100:	f6 e0       	ldi	r31, 0x06	; 6
    2102:	80 81       	ld	r24, Z
    2104:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    2108:	ef 81       	ldd	r30, Y+7	; 0x07
    210a:	f8 85       	ldd	r31, Y+8	; 0x08
    210c:	ed 5b       	subi	r30, 0xBD	; 189
    210e:	ff 4f       	sbci	r31, 0xFF	; 255
    2110:	80 83       	st	Z, r24
  packet_payload[68] = SVIT_check_I_critical( svit[SOLAR_5].name );
    2112:	aa e2       	ldi	r26, 0x2A	; 42
    2114:	b6 e0       	ldi	r27, 0x06	; 6
    2116:	8c 91       	ld	r24, X
    2118:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    211c:	ef 81       	ldd	r30, Y+7	; 0x07
    211e:	f8 85       	ldd	r31, Y+8	; 0x08
    2120:	ec 5b       	subi	r30, 0xBC	; 188
    2122:	ff 4f       	sbci	r31, 0xFF	; 255
    2124:	80 83       	st	Z, r24
  packet_payload[69] = SVIT_check_I_critical( svit[SOLAR_6].name );
    2126:	e6 e4       	ldi	r30, 0x46	; 70
    2128:	f6 e0       	ldi	r31, 0x06	; 6
    212a:	80 81       	ld	r24, Z
    212c:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    2130:	ef 81       	ldd	r30, Y+7	; 0x07
    2132:	f8 85       	ldd	r31, Y+8	; 0x08
    2134:	eb 5b       	subi	r30, 0xBB	; 187
    2136:	ff 4f       	sbci	r31, 0xFF	; 255
    2138:	80 83       	st	Z, r24
  packet_payload[70] = SVIT_check_I_critical( svit[SOLAR_7].name );
    213a:	a2 e6       	ldi	r26, 0x62	; 98
    213c:	b6 e0       	ldi	r27, 0x06	; 6
    213e:	8c 91       	ld	r24, X
    2140:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    2144:	ef 81       	ldd	r30, Y+7	; 0x07
    2146:	f8 85       	ldd	r31, Y+8	; 0x08
    2148:	ea 5b       	subi	r30, 0xBA	; 186
    214a:	ff 4f       	sbci	r31, 0xFF	; 255
    214c:	80 83       	st	Z, r24
  packet_payload[71] = SVIT_check_I_critical( svit[SOLAR_8].name );
    214e:	ee e7       	ldi	r30, 0x7E	; 126
    2150:	f6 e0       	ldi	r31, 0x06	; 6
    2152:	80 81       	ld	r24, Z
    2154:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    2158:	ef 81       	ldd	r30, Y+7	; 0x07
    215a:	f8 85       	ldd	r31, Y+8	; 0x08
    215c:	e9 5b       	subi	r30, 0xB9	; 185
    215e:	ff 4f       	sbci	r31, 0xFF	; 255
    2160:	80 83       	st	Z, r24
  packet_payload[72] = SVIT_check_I_critical( svit[SOLAR_9].name );
    2162:	aa e9       	ldi	r26, 0x9A	; 154
    2164:	b6 e0       	ldi	r27, 0x06	; 6
    2166:	8c 91       	ld	r24, X
    2168:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    216c:	ef 81       	ldd	r30, Y+7	; 0x07
    216e:	f8 85       	ldd	r31, Y+8	; 0x08
    2170:	e8 5b       	subi	r30, 0xB8	; 184
    2172:	ff 4f       	sbci	r31, 0xFF	; 255
    2174:	80 83       	st	Z, r24
  packet_payload[73] = SVIT_check_I_critical( svit[SOLAR_10].name );
    2176:	e6 eb       	ldi	r30, 0xB6	; 182
    2178:	f6 e0       	ldi	r31, 0x06	; 6
    217a:	80 81       	ld	r24, Z
    217c:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    2180:	ef 81       	ldd	r30, Y+7	; 0x07
    2182:	f8 85       	ldd	r31, Y+8	; 0x08
    2184:	e7 5b       	subi	r30, 0xB7	; 183
    2186:	ff 4f       	sbci	r31, 0xFF	; 255
    2188:	80 83       	st	Z, r24
  packet_payload[74] = SVIT_check_I_critical( svit[SOLAR_11].name );
    218a:	a2 ed       	ldi	r26, 0xD2	; 210
    218c:	b6 e0       	ldi	r27, 0x06	; 6
    218e:	8c 91       	ld	r24, X
    2190:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    2194:	ef 81       	ldd	r30, Y+7	; 0x07
    2196:	f8 85       	ldd	r31, Y+8	; 0x08
    2198:	e6 5b       	subi	r30, 0xB6	; 182
    219a:	ff 4f       	sbci	r31, 0xFF	; 255
    219c:	80 83       	st	Z, r24
  packet_payload[75] = SVIT_check_I_critical( svit[SOLAR_12].name );
    219e:	ee ee       	ldi	r30, 0xEE	; 238
    21a0:	f6 e0       	ldi	r31, 0x06	; 6
    21a2:	80 81       	ld	r24, Z
    21a4:	0e 94 8d 09 	call	0x131a	; 0x131a <SVIT_check_I_critical>
    21a8:	ef 81       	ldd	r30, Y+7	; 0x07
    21aa:	f8 85       	ldd	r31, Y+8	; 0x08
    21ac:	e5 5b       	subi	r30, 0xB5	; 181
    21ae:	ff 4f       	sbci	r31, 0xFF	; 255
    21b0:	80 83       	st	Z, r24
  packet_payload[76] = 0xFF;//SVIT_check_I_critical( svit[POWER_BOARD].name );
    21b2:	ef 81       	ldd	r30, Y+7	; 0x07
    21b4:	f8 85       	ldd	r31, Y+8	; 0x08
    21b6:	e4 5b       	subi	r30, 0xB4	; 180
    21b8:	ff 4f       	sbci	r31, 0xFF	; 255
    21ba:	8f ef       	ldi	r24, 0xFF	; 255
    21bc:	80 83       	st	Z, r24
  //uint8_t current_error1;
  //uint8_t current_error2;
  //uint8_t current_error3;
  //uint8_t current_error4;

  packet_payload[77] = batt1_voltage;//V_ack_change();
    21be:	ef 81       	ldd	r30, Y+7	; 0x07
    21c0:	f8 85       	ldd	r31, Y+8	; 0x08
    21c2:	e3 5b       	subi	r30, 0xB3	; 179
    21c4:	ff 4f       	sbci	r31, 0xFF	; 255
    21c6:	90 91 6d 09 	lds	r25, 0x096D
    21ca:	90 83       	st	Z, r25
  packet_payload[78] = soc;//soc;// I_ack_change();
    21cc:	ef 81       	ldd	r30, Y+7	; 0x07
    21ce:	f8 85       	ldd	r31, Y+8	; 0x08
    21d0:	e2 5b       	subi	r30, 0xB2	; 178
    21d2:	ff 4f       	sbci	r31, 0xFF	; 255
    21d4:	90 91 ab 0f 	lds	r25, 0x0FAB
    21d8:	90 83       	st	Z, r25
  packet_payload[79] = 0x00;//low >> 6;//safe_mode;
    21da:	ef 81       	ldd	r30, Y+7	; 0x07
    21dc:	f8 85       	ldd	r31, Y+8	; 0x08
    21de:	e1 5b       	subi	r30, 0xB1	; 177
    21e0:	ff 4f       	sbci	r31, 0xFF	; 255
    21e2:	10 82       	st	Z, r1
  packet_payload[80] = 0x00;//charging;
    21e4:	ef 81       	ldd	r30, Y+7	; 0x07
    21e6:	f8 85       	ldd	r31, Y+8	; 0x08
    21e8:	e0 5b       	subi	r30, 0xB0	; 176
    21ea:	ff 4f       	sbci	r31, 0xFF	; 255
    21ec:	10 82       	st	Z, r1
  packet_payload[81] = 0x00;//chargeforward;
    21ee:	ef 81       	ldd	r30, Y+7	; 0x07
    21f0:	f8 85       	ldd	r31, Y+8	; 0x08
    21f2:	ef 5a       	subi	r30, 0xAF	; 175
    21f4:	ff 4f       	sbci	r31, 0xFF	; 255
    21f6:	10 82       	st	Z, r1

  // temperature values (raw ADC output)
  packet_payload[82] = debug;//average_samples( svit[STAR_TRACKER].T_samples );
    21f8:	ef 81       	ldd	r30, Y+7	; 0x07
    21fa:	f8 85       	ldd	r31, Y+8	; 0x08
    21fc:	ee 5a       	subi	r30, 0xAE	; 174
    21fe:	ff 4f       	sbci	r31, 0xFF	; 255
    2200:	90 91 35 07 	lds	r25, 0x0735
    2204:	90 83       	st	Z, r25
  packet_payload[83] = 0xFF;//average_samples( svit[BATTERY_1].T_samples );
    2206:	ef 81       	ldd	r30, Y+7	; 0x07
    2208:	f8 85       	ldd	r31, Y+8	; 0x08
    220a:	ed 5a       	subi	r30, 0xAD	; 173
    220c:	ff 4f       	sbci	r31, 0xFF	; 255
    220e:	80 83       	st	Z, r24
  packet_payload[84] = average_samples( svit[BATTERY_2].T_samples );
    2210:	8a e9       	ldi	r24, 0x9A	; 154
    2212:	95 e0       	ldi	r25, 0x05	; 5
    2214:	0e 94 7e 09 	call	0x12fc	; 0x12fc <average_samples>
    2218:	ef 81       	ldd	r30, Y+7	; 0x07
    221a:	f8 85       	ldd	r31, Y+8	; 0x08
    221c:	ec 5a       	subi	r30, 0xAC	; 172
    221e:	ff 4f       	sbci	r31, 0xFF	; 255
    2220:	80 83       	st	Z, r24
  packet_payload[85] = average_samples( svit[SOLAR_1].T_samples );
    2222:	82 ed       	ldi	r24, 0xD2	; 210
    2224:	95 e0       	ldi	r25, 0x05	; 5
    2226:	0e 94 7e 09 	call	0x12fc	; 0x12fc <average_samples>
    222a:	ef 81       	ldd	r30, Y+7	; 0x07
    222c:	f8 85       	ldd	r31, Y+8	; 0x08
    222e:	eb 5a       	subi	r30, 0xAB	; 171
    2230:	ff 4f       	sbci	r31, 0xFF	; 255
    2232:	80 83       	st	Z, r24
  packet_payload[86] = average_samples( svit[SOLAR_2].T_samples );
    2234:	8e ee       	ldi	r24, 0xEE	; 238
    2236:	95 e0       	ldi	r25, 0x05	; 5
    2238:	0e 94 7e 09 	call	0x12fc	; 0x12fc <average_samples>
    223c:	ef 81       	ldd	r30, Y+7	; 0x07
    223e:	f8 85       	ldd	r31, Y+8	; 0x08
    2240:	ea 5a       	subi	r30, 0xAA	; 170
    2242:	ff 4f       	sbci	r31, 0xFF	; 255
    2244:	80 83       	st	Z, r24
  packet_payload[87] = average_samples( svit[SOLAR_3].T_samples );
    2246:	8a e0       	ldi	r24, 0x0A	; 10
    2248:	96 e0       	ldi	r25, 0x06	; 6
    224a:	0e 94 7e 09 	call	0x12fc	; 0x12fc <average_samples>
    224e:	ef 81       	ldd	r30, Y+7	; 0x07
    2250:	f8 85       	ldd	r31, Y+8	; 0x08
    2252:	e9 5a       	subi	r30, 0xA9	; 169
    2254:	ff 4f       	sbci	r31, 0xFF	; 255
    2256:	80 83       	st	Z, r24
  packet_payload[88] = average_samples( svit[SOLAR_4].T_samples );
    2258:	86 e2       	ldi	r24, 0x26	; 38
    225a:	96 e0       	ldi	r25, 0x06	; 6
    225c:	0e 94 7e 09 	call	0x12fc	; 0x12fc <average_samples>
    2260:	ef 81       	ldd	r30, Y+7	; 0x07
    2262:	f8 85       	ldd	r31, Y+8	; 0x08
    2264:	e8 5a       	subi	r30, 0xA8	; 168
    2266:	ff 4f       	sbci	r31, 0xFF	; 255
    2268:	80 83       	st	Z, r24
  packet_payload[89] = average_samples( svit[SOLAR_5].T_samples );
    226a:	82 e4       	ldi	r24, 0x42	; 66
    226c:	96 e0       	ldi	r25, 0x06	; 6
    226e:	0e 94 7e 09 	call	0x12fc	; 0x12fc <average_samples>
    2272:	ef 81       	ldd	r30, Y+7	; 0x07
    2274:	f8 85       	ldd	r31, Y+8	; 0x08
    2276:	e7 5a       	subi	r30, 0xA7	; 167
    2278:	ff 4f       	sbci	r31, 0xFF	; 255
    227a:	80 83       	st	Z, r24
  packet_payload[90] = average_samples( svit[SOLAR_9].T_samples );
    227c:	82 eb       	ldi	r24, 0xB2	; 178
    227e:	96 e0       	ldi	r25, 0x06	; 6
    2280:	0e 94 7e 09 	call	0x12fc	; 0x12fc <average_samples>
    2284:	ef 81       	ldd	r30, Y+7	; 0x07
    2286:	f8 85       	ldd	r31, Y+8	; 0x08
    2288:	e6 5a       	subi	r30, 0xA6	; 166
    228a:	ff 4f       	sbci	r31, 0xFF	; 255
    228c:	80 83       	st	Z, r24
  packet_payload[91] = average_samples( svit[POWER_BOARD].T_samples );
    228e:	82 e2       	ldi	r24, 0x22	; 34
    2290:	97 e0       	ldi	r25, 0x07	; 7
    2292:	0e 94 7e 09 	call	0x12fc	; 0x12fc <average_samples>
    2296:	ef 81       	ldd	r30, Y+7	; 0x07
    2298:	f8 85       	ldd	r31, Y+8	; 0x08
    229a:	e5 5a       	subi	r30, 0xA5	; 165
    229c:	ff 4f       	sbci	r31, 0xFF	; 255
    229e:	80 83       	st	Z, r24

uint8_t V_ack_change( void )
{
  uint8_t temp;

  temp = V_upper_val_change;
    22a0:	80 91 7d 0b 	lds	r24, 0x0B7D
  V_upper_val_change = 0;
    22a4:	10 92 7d 0b 	sts	0x0B7D, r1
  //uint8_t temperature_error1;
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
    22a8:	ef 81       	ldd	r30, Y+7	; 0x07
    22aa:	f8 85       	ldd	r31, Y+8	; 0x08
    22ac:	e4 5a       	subi	r30, 0xA4	; 164
    22ae:	ff 4f       	sbci	r31, 0xFF	; 255
    22b0:	80 83       	st	Z, r24

uint8_t I_ack_change( void )
{
  uint8_t temp;

  temp = I_upper_val_change;
    22b2:	80 91 78 0b 	lds	r24, 0x0B78
  I_upper_val_change = 0;
    22b6:	10 92 78 0b 	sts	0x0B78, r1
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
  packet_payload[93] = I_ack_change();
    22ba:	ef 81       	ldd	r30, Y+7	; 0x07
    22bc:	f8 85       	ldd	r31, Y+8	; 0x08
    22be:	e3 5a       	subi	r30, 0xA3	; 163
    22c0:	ff 4f       	sbci	r31, 0xFF	; 255
    22c2:	80 83       	st	Z, r24
}
    22c4:	28 96       	adiw	r28, 0x08	; 8
    22c6:	0f b6       	in	r0, 0x3f	; 63
    22c8:	f8 94       	cli
    22ca:	de bf       	out	0x3e, r29	; 62
    22cc:	0f be       	out	0x3f, r0	; 63
    22ce:	cd bf       	out	0x3d, r28	; 61
    22d0:	df 91       	pop	r29
    22d2:	cf 91       	pop	r28
    22d4:	1f 91       	pop	r17
    22d6:	0f 91       	pop	r16
    22d8:	ff 90       	pop	r15
    22da:	ef 90       	pop	r14
    22dc:	df 90       	pop	r13
    22de:	cf 90       	pop	r12
    22e0:	bf 90       	pop	r11
    22e2:	af 90       	pop	r10
    22e4:	9f 90       	pop	r9
    22e6:	8f 90       	pop	r8
    22e8:	7f 90       	pop	r7
    22ea:	6f 90       	pop	r6
    22ec:	5f 90       	pop	r5
    22ee:	4f 90       	pop	r4
    22f0:	3f 90       	pop	r3
    22f2:	2f 90       	pop	r2
    22f4:	08 95       	ret

000022f6 <transmit_packet>:

void transmit_packet( uint8_t uart, uint8_t packet_type, uint8_t ack_command )
{
    22f6:	6f 92       	push	r6
    22f8:	7f 92       	push	r7
    22fa:	8f 92       	push	r8
    22fc:	9f 92       	push	r9
    22fe:	bf 92       	push	r11
    2300:	cf 92       	push	r12
    2302:	df 92       	push	r13
    2304:	ef 92       	push	r14
    2306:	ff 92       	push	r15
    2308:	0f 93       	push	r16
    230a:	1f 93       	push	r17
    230c:	cf 93       	push	r28
    230e:	df 93       	push	r29
    2310:	b8 2e       	mov	r11, r24
  uint8_t VCP_tx_status;

  switch( packet_type )
    2312:	61 30       	cpi	r22, 0x01	; 1
    2314:	b9 f0       	breq	.+46     	; 0x2344 <transmit_packet+0x4e>
    2316:	20 f0       	brcs	.+8      	; 0x2320 <transmit_packet+0x2a>
    2318:	62 30       	cpi	r22, 0x02	; 2
    231a:	09 f0       	breq	.+2      	; 0x231e <transmit_packet+0x28>
    231c:	8b c0       	rjmp	.+278    	; 0x2434 <transmit_packet+0x13e>
    231e:	22 c0       	rjmp	.+68     	; 0x2364 <transmit_packet+0x6e>
  {
    case VCP_POWER_TELEMETRY:
      construct_telemetry_packet( tel_packet_payload[uart] );
    2320:	c8 2f       	mov	r28, r24
    2322:	d0 e0       	ldi	r29, 0x00	; 0
    2324:	2f ef       	ldi	r18, 0xFF	; 255
    2326:	82 9f       	mul	r24, r18
    2328:	c0 01       	movw	r24, r0
    232a:	11 24       	eor	r1, r1
    232c:	83 55       	subi	r24, 0x53	; 83
    232e:	92 4f       	sbci	r25, 0xF2	; 242
    2330:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <construct_telemetry_packet>
      tel_packet_payload_size[uart] = 96;
    2334:	fe 01       	movw	r30, r28
    2336:	ee 0f       	add	r30, r30
    2338:	ff 1f       	adc	r31, r31
    233a:	e9 5c       	subi	r30, 0xC9	; 201
    233c:	f8 4f       	sbci	r31, 0xF8	; 248
    233e:	80 e6       	ldi	r24, 0x60	; 96
    2340:	90 e0       	ldi	r25, 0x00	; 0
    2342:	21 c0       	rjmp	.+66     	; 0x2386 <transmit_packet+0x90>
      break;
    case VCP_INVALID_COMMAND:
      tel_packet_payload[uart][0] = VCP_INVALID_COMMAND;
    2344:	e8 2f       	mov	r30, r24
    2346:	f0 e0       	ldi	r31, 0x00	; 0
    2348:	8f ef       	ldi	r24, 0xFF	; 255
    234a:	b8 9e       	mul	r11, r24
    234c:	d0 01       	movw	r26, r0
    234e:	11 24       	eor	r1, r1
    2350:	a3 55       	subi	r26, 0x53	; 83
    2352:	b2 4f       	sbci	r27, 0xF2	; 242
    2354:	6c 93       	st	X, r22
      tel_packet_payload_size[uart] = 1;
    2356:	ee 0f       	add	r30, r30
    2358:	ff 1f       	adc	r31, r31
    235a:	e9 5c       	subi	r30, 0xC9	; 201
    235c:	f8 4f       	sbci	r31, 0xF8	; 248
    235e:	81 e0       	ldi	r24, 0x01	; 1
    2360:	90 e0       	ldi	r25, 0x00	; 0
    2362:	11 c0       	rjmp	.+34     	; 0x2386 <transmit_packet+0x90>
      break;
    case VCP_ACK:
      tel_packet_payload[uart][0] = VCP_ACK;
    2364:	e8 2f       	mov	r30, r24
    2366:	f0 e0       	ldi	r31, 0x00	; 0
    2368:	2f ef       	ldi	r18, 0xFF	; 255
    236a:	82 9f       	mul	r24, r18
    236c:	d0 01       	movw	r26, r0
    236e:	11 24       	eor	r1, r1
    2370:	a3 55       	subi	r26, 0x53	; 83
    2372:	b2 4f       	sbci	r27, 0xF2	; 242
    2374:	6c 93       	st	X, r22
      tel_packet_payload[uart][1] = ack_command;
    2376:	11 96       	adiw	r26, 0x01	; 1
    2378:	4c 93       	st	X, r20
      tel_packet_payload_size[uart] = 2;
    237a:	ee 0f       	add	r30, r30
    237c:	ff 1f       	adc	r31, r31
    237e:	e9 5c       	subi	r30, 0xC9	; 201
    2380:	f8 4f       	sbci	r31, 0xF8	; 248
    2382:	82 e0       	ldi	r24, 0x02	; 2
    2384:	90 e0       	ldi	r25, 0x00	; 0
    2386:	91 83       	std	Z+1, r25	; 0x01
    2388:	80 83       	st	Z, r24
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    238a:	8b 2c       	mov	r8, r11
    238c:	91 2c       	mov	r9, r1
    238e:	8f ef       	ldi	r24, 0xFF	; 255
    2390:	b8 9e       	mul	r11, r24
    2392:	70 01       	movw	r14, r0
    2394:	11 24       	eor	r1, r1
    2396:	e7 01       	movw	r28, r14
    2398:	c8 58       	subi	r28, 0x88	; 136
    239a:	d6 4f       	sbci	r29, 0xF6	; 246
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
    239c:	64 01       	movw	r12, r8
    239e:	cc 0c       	add	r12, r12
    23a0:	dd 1c       	adc	r13, r13
    23a2:	f6 01       	movw	r30, r12
    23a4:	e9 5c       	subi	r30, 0xC9	; 201
    23a6:	f8 4f       	sbci	r31, 0xF8	; 248
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    23a8:	00 81       	ld	r16, Z
    23aa:	11 81       	ldd	r17, Z+1	; 0x01
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
    23ac:	97 01       	movw	r18, r14
    23ae:	23 55       	subi	r18, 0x53	; 83
    23b0:	32 4f       	sbci	r19, 0xF2	; 242
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    23b2:	a2 e8       	ldi	r26, 0x82	; 130
    23b4:	6a 2e       	mov	r6, r26
    23b6:	ad e0       	ldi	r26, 0x0D	; 13
    23b8:	7a 2e       	mov	r7, r26
    23ba:	6c 0c       	add	r6, r12
    23bc:	7d 1c       	adc	r7, r13
    23be:	41 e0       	ldi	r20, 0x01	; 1
    23c0:	b3 01       	movw	r22, r6
    23c2:	ce 01       	movw	r24, r28
    23c4:	0e 94 10 0b 	call	0x1620	; 0x1620 <Create_VCP_frame>
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
                  );

  // VCP frame creation was successful
  if ( VCP_tx_status == VCP_TERM )
    23c8:	81 30       	cpi	r24, 0x01	; 1
    23ca:	a1 f5       	brne	.+104    	; 0x2434 <transmit_packet+0x13e>
  {
    tel_packet_size[uart] = dest_size[uart];
    23cc:	f3 01       	movw	r30, r6
    23ce:	80 81       	ld	r24, Z
    23d0:	91 81       	ldd	r25, Z+1	; 0x01
    23d2:	f6 01       	movw	r30, r12
    23d4:	e9 5d       	subi	r30, 0xD9	; 217
    23d6:	fc 4f       	sbci	r31, 0xFC	; 252
    23d8:	91 83       	std	Z+1, r25	; 0x01
    23da:	80 83       	st	Z, r24
    memcpy( tel_packet[uart], dest_data[uart], tel_packet_size[uart] );
    23dc:	80 81       	ld	r24, Z
    23de:	91 81       	ldd	r25, Z+1	; 0x01
    23e0:	97 01       	movw	r18, r14
    23e2:	2a 5b       	subi	r18, 0xBA	; 186
    23e4:	38 4f       	sbci	r19, 0xF8	; 248
    23e6:	ac 01       	movw	r20, r24
    23e8:	be 01       	movw	r22, r28
    23ea:	c9 01       	movw	r24, r18
    23ec:	0e 94 11 15 	call	0x2a22	; 0x2a22 <memcpy>
    tel_packet_index[uart] = 0;
    23f0:	f4 01       	movw	r30, r8
    23f2:	e1 5c       	subi	r30, 0xC1	; 193
    23f4:	f8 4f       	sbci	r31, 0xF8	; 248
    23f6:	10 82       	st	Z, r1
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
    23f8:	f1 e0       	ldi	r31, 0x01	; 1
    23fa:	bf 12       	cpse	r11, r31
    23fc:	06 c0       	rjmp	.+12     	; 0x240a <transmit_packet+0x114>
    23fe:	80 91 9b 00 	lds	r24, 0x009B
    2402:	88 23       	and	r24, r24
    2404:	b9 f0       	breq	.+46     	; 0x2434 <transmit_packet+0x13e>
      tx_put_byte( uart );
    2406:	81 e0       	ldi	r24, 0x01	; 1
    2408:	06 c0       	rjmp	.+12     	; 0x2416 <transmit_packet+0x120>
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
    240a:	b1 10       	cpse	r11, r1
    240c:	13 c0       	rjmp	.+38     	; 0x2434 <transmit_packet+0x13e>
    240e:	8b b1       	in	r24, 0x0b	; 11
    2410:	88 23       	and	r24, r24
    2412:	81 f0       	breq	.+32     	; 0x2434 <transmit_packet+0x13e>
      tx_put_byte( uart );
    2414:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    2416:	df 91       	pop	r29
    2418:	cf 91       	pop	r28
    241a:	1f 91       	pop	r17
    241c:	0f 91       	pop	r16
    241e:	ff 90       	pop	r15
    2420:	ef 90       	pop	r14
    2422:	df 90       	pop	r13
    2424:	cf 90       	pop	r12
    2426:	bf 90       	pop	r11
    2428:	9f 90       	pop	r9
    242a:	8f 90       	pop	r8
    242c:	7f 90       	pop	r7
    242e:	6f 90       	pop	r6
    tel_packet_index[uart] = 0;
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    2430:	0c 94 df 0d 	jmp	0x1bbe	; 0x1bbe <tx_put_byte>
  }
}
    2434:	df 91       	pop	r29
    2436:	cf 91       	pop	r28
    2438:	1f 91       	pop	r17
    243a:	0f 91       	pop	r16
    243c:	ff 90       	pop	r15
    243e:	ef 90       	pop	r14
    2440:	df 90       	pop	r13
    2442:	cf 90       	pop	r12
    2444:	bf 90       	pop	r11
    2446:	9f 90       	pop	r9
    2448:	8f 90       	pop	r8
    244a:	7f 90       	pop	r7
    244c:	6f 90       	pop	r6
    244e:	08 95       	ret

00002450 <__subsf3>:
    2450:	50 58       	subi	r21, 0x80	; 128

00002452 <__addsf3>:
    2452:	bb 27       	eor	r27, r27
    2454:	aa 27       	eor	r26, r26
    2456:	0e d0       	rcall	.+28     	; 0x2474 <__addsf3x>
    2458:	44 c1       	rjmp	.+648    	; 0x26e2 <__fp_round>
    245a:	35 d1       	rcall	.+618    	; 0x26c6 <__fp_pscA>
    245c:	30 f0       	brcs	.+12     	; 0x246a <__addsf3+0x18>
    245e:	3a d1       	rcall	.+628    	; 0x26d4 <__fp_pscB>
    2460:	20 f0       	brcs	.+8      	; 0x246a <__addsf3+0x18>
    2462:	31 f4       	brne	.+12     	; 0x2470 <__addsf3+0x1e>
    2464:	9f 3f       	cpi	r25, 0xFF	; 255
    2466:	11 f4       	brne	.+4      	; 0x246c <__addsf3+0x1a>
    2468:	1e f4       	brtc	.+6      	; 0x2470 <__addsf3+0x1e>
    246a:	2a c1       	rjmp	.+596    	; 0x26c0 <__fp_nan>
    246c:	0e f4       	brtc	.+2      	; 0x2470 <__addsf3+0x1e>
    246e:	e0 95       	com	r30
    2470:	e7 fb       	bst	r30, 7
    2472:	20 c1       	rjmp	.+576    	; 0x26b4 <__fp_inf>

00002474 <__addsf3x>:
    2474:	e9 2f       	mov	r30, r25
    2476:	46 d1       	rcall	.+652    	; 0x2704 <__fp_split3>
    2478:	80 f3       	brcs	.-32     	; 0x245a <__addsf3+0x8>
    247a:	ba 17       	cp	r27, r26
    247c:	62 07       	cpc	r22, r18
    247e:	73 07       	cpc	r23, r19
    2480:	84 07       	cpc	r24, r20
    2482:	95 07       	cpc	r25, r21
    2484:	18 f0       	brcs	.+6      	; 0x248c <__addsf3x+0x18>
    2486:	71 f4       	brne	.+28     	; 0x24a4 <__addsf3x+0x30>
    2488:	9e f5       	brtc	.+102    	; 0x24f0 <__addsf3x+0x7c>
    248a:	5e c1       	rjmp	.+700    	; 0x2748 <__fp_zero>
    248c:	0e f4       	brtc	.+2      	; 0x2490 <__addsf3x+0x1c>
    248e:	e0 95       	com	r30
    2490:	0b 2e       	mov	r0, r27
    2492:	ba 2f       	mov	r27, r26
    2494:	a0 2d       	mov	r26, r0
    2496:	0b 01       	movw	r0, r22
    2498:	b9 01       	movw	r22, r18
    249a:	90 01       	movw	r18, r0
    249c:	0c 01       	movw	r0, r24
    249e:	ca 01       	movw	r24, r20
    24a0:	a0 01       	movw	r20, r0
    24a2:	11 24       	eor	r1, r1
    24a4:	ff 27       	eor	r31, r31
    24a6:	59 1b       	sub	r21, r25
    24a8:	99 f0       	breq	.+38     	; 0x24d0 <__addsf3x+0x5c>
    24aa:	59 3f       	cpi	r21, 0xF9	; 249
    24ac:	50 f4       	brcc	.+20     	; 0x24c2 <__addsf3x+0x4e>
    24ae:	50 3e       	cpi	r21, 0xE0	; 224
    24b0:	68 f1       	brcs	.+90     	; 0x250c <__addsf3x+0x98>
    24b2:	1a 16       	cp	r1, r26
    24b4:	f0 40       	sbci	r31, 0x00	; 0
    24b6:	a2 2f       	mov	r26, r18
    24b8:	23 2f       	mov	r18, r19
    24ba:	34 2f       	mov	r19, r20
    24bc:	44 27       	eor	r20, r20
    24be:	58 5f       	subi	r21, 0xF8	; 248
    24c0:	f3 cf       	rjmp	.-26     	; 0x24a8 <__addsf3x+0x34>
    24c2:	46 95       	lsr	r20
    24c4:	37 95       	ror	r19
    24c6:	27 95       	ror	r18
    24c8:	a7 95       	ror	r26
    24ca:	f0 40       	sbci	r31, 0x00	; 0
    24cc:	53 95       	inc	r21
    24ce:	c9 f7       	brne	.-14     	; 0x24c2 <__addsf3x+0x4e>
    24d0:	7e f4       	brtc	.+30     	; 0x24f0 <__addsf3x+0x7c>
    24d2:	1f 16       	cp	r1, r31
    24d4:	ba 0b       	sbc	r27, r26
    24d6:	62 0b       	sbc	r22, r18
    24d8:	73 0b       	sbc	r23, r19
    24da:	84 0b       	sbc	r24, r20
    24dc:	ba f0       	brmi	.+46     	; 0x250c <__addsf3x+0x98>
    24de:	91 50       	subi	r25, 0x01	; 1
    24e0:	a1 f0       	breq	.+40     	; 0x250a <__addsf3x+0x96>
    24e2:	ff 0f       	add	r31, r31
    24e4:	bb 1f       	adc	r27, r27
    24e6:	66 1f       	adc	r22, r22
    24e8:	77 1f       	adc	r23, r23
    24ea:	88 1f       	adc	r24, r24
    24ec:	c2 f7       	brpl	.-16     	; 0x24de <__addsf3x+0x6a>
    24ee:	0e c0       	rjmp	.+28     	; 0x250c <__addsf3x+0x98>
    24f0:	ba 0f       	add	r27, r26
    24f2:	62 1f       	adc	r22, r18
    24f4:	73 1f       	adc	r23, r19
    24f6:	84 1f       	adc	r24, r20
    24f8:	48 f4       	brcc	.+18     	; 0x250c <__addsf3x+0x98>
    24fa:	87 95       	ror	r24
    24fc:	77 95       	ror	r23
    24fe:	67 95       	ror	r22
    2500:	b7 95       	ror	r27
    2502:	f7 95       	ror	r31
    2504:	9e 3f       	cpi	r25, 0xFE	; 254
    2506:	08 f0       	brcs	.+2      	; 0x250a <__addsf3x+0x96>
    2508:	b3 cf       	rjmp	.-154    	; 0x2470 <__addsf3+0x1e>
    250a:	93 95       	inc	r25
    250c:	88 0f       	add	r24, r24
    250e:	08 f0       	brcs	.+2      	; 0x2512 <__addsf3x+0x9e>
    2510:	99 27       	eor	r25, r25
    2512:	ee 0f       	add	r30, r30
    2514:	97 95       	ror	r25
    2516:	87 95       	ror	r24
    2518:	08 95       	ret

0000251a <__cmpsf2>:
    251a:	a8 d0       	rcall	.+336    	; 0x266c <__fp_cmp>
    251c:	08 f4       	brcc	.+2      	; 0x2520 <__cmpsf2+0x6>
    251e:	81 e0       	ldi	r24, 0x01	; 1
    2520:	08 95       	ret

00002522 <__divsf3>:
    2522:	0c d0       	rcall	.+24     	; 0x253c <__divsf3x>
    2524:	de c0       	rjmp	.+444    	; 0x26e2 <__fp_round>
    2526:	d6 d0       	rcall	.+428    	; 0x26d4 <__fp_pscB>
    2528:	40 f0       	brcs	.+16     	; 0x253a <__divsf3+0x18>
    252a:	cd d0       	rcall	.+410    	; 0x26c6 <__fp_pscA>
    252c:	30 f0       	brcs	.+12     	; 0x253a <__divsf3+0x18>
    252e:	21 f4       	brne	.+8      	; 0x2538 <__divsf3+0x16>
    2530:	5f 3f       	cpi	r21, 0xFF	; 255
    2532:	19 f0       	breq	.+6      	; 0x253a <__divsf3+0x18>
    2534:	bf c0       	rjmp	.+382    	; 0x26b4 <__fp_inf>
    2536:	51 11       	cpse	r21, r1
    2538:	08 c1       	rjmp	.+528    	; 0x274a <__fp_szero>
    253a:	c2 c0       	rjmp	.+388    	; 0x26c0 <__fp_nan>

0000253c <__divsf3x>:
    253c:	e3 d0       	rcall	.+454    	; 0x2704 <__fp_split3>
    253e:	98 f3       	brcs	.-26     	; 0x2526 <__divsf3+0x4>

00002540 <__divsf3_pse>:
    2540:	99 23       	and	r25, r25
    2542:	c9 f3       	breq	.-14     	; 0x2536 <__divsf3+0x14>
    2544:	55 23       	and	r21, r21
    2546:	b1 f3       	breq	.-20     	; 0x2534 <__divsf3+0x12>
    2548:	95 1b       	sub	r25, r21
    254a:	55 0b       	sbc	r21, r21
    254c:	bb 27       	eor	r27, r27
    254e:	aa 27       	eor	r26, r26
    2550:	62 17       	cp	r22, r18
    2552:	73 07       	cpc	r23, r19
    2554:	84 07       	cpc	r24, r20
    2556:	38 f0       	brcs	.+14     	; 0x2566 <__divsf3_pse+0x26>
    2558:	9f 5f       	subi	r25, 0xFF	; 255
    255a:	5f 4f       	sbci	r21, 0xFF	; 255
    255c:	22 0f       	add	r18, r18
    255e:	33 1f       	adc	r19, r19
    2560:	44 1f       	adc	r20, r20
    2562:	aa 1f       	adc	r26, r26
    2564:	a9 f3       	breq	.-22     	; 0x2550 <__divsf3_pse+0x10>
    2566:	33 d0       	rcall	.+102    	; 0x25ce <__divsf3_pse+0x8e>
    2568:	0e 2e       	mov	r0, r30
    256a:	3a f0       	brmi	.+14     	; 0x257a <__divsf3_pse+0x3a>
    256c:	e0 e8       	ldi	r30, 0x80	; 128
    256e:	30 d0       	rcall	.+96     	; 0x25d0 <__divsf3_pse+0x90>
    2570:	91 50       	subi	r25, 0x01	; 1
    2572:	50 40       	sbci	r21, 0x00	; 0
    2574:	e6 95       	lsr	r30
    2576:	00 1c       	adc	r0, r0
    2578:	ca f7       	brpl	.-14     	; 0x256c <__divsf3_pse+0x2c>
    257a:	29 d0       	rcall	.+82     	; 0x25ce <__divsf3_pse+0x8e>
    257c:	fe 2f       	mov	r31, r30
    257e:	27 d0       	rcall	.+78     	; 0x25ce <__divsf3_pse+0x8e>
    2580:	66 0f       	add	r22, r22
    2582:	77 1f       	adc	r23, r23
    2584:	88 1f       	adc	r24, r24
    2586:	bb 1f       	adc	r27, r27
    2588:	26 17       	cp	r18, r22
    258a:	37 07       	cpc	r19, r23
    258c:	48 07       	cpc	r20, r24
    258e:	ab 07       	cpc	r26, r27
    2590:	b0 e8       	ldi	r27, 0x80	; 128
    2592:	09 f0       	breq	.+2      	; 0x2596 <__divsf3_pse+0x56>
    2594:	bb 0b       	sbc	r27, r27
    2596:	80 2d       	mov	r24, r0
    2598:	bf 01       	movw	r22, r30
    259a:	ff 27       	eor	r31, r31
    259c:	93 58       	subi	r25, 0x83	; 131
    259e:	5f 4f       	sbci	r21, 0xFF	; 255
    25a0:	2a f0       	brmi	.+10     	; 0x25ac <__divsf3_pse+0x6c>
    25a2:	9e 3f       	cpi	r25, 0xFE	; 254
    25a4:	51 05       	cpc	r21, r1
    25a6:	68 f0       	brcs	.+26     	; 0x25c2 <__divsf3_pse+0x82>
    25a8:	85 c0       	rjmp	.+266    	; 0x26b4 <__fp_inf>
    25aa:	cf c0       	rjmp	.+414    	; 0x274a <__fp_szero>
    25ac:	5f 3f       	cpi	r21, 0xFF	; 255
    25ae:	ec f3       	brlt	.-6      	; 0x25aa <__divsf3_pse+0x6a>
    25b0:	98 3e       	cpi	r25, 0xE8	; 232
    25b2:	dc f3       	brlt	.-10     	; 0x25aa <__divsf3_pse+0x6a>
    25b4:	86 95       	lsr	r24
    25b6:	77 95       	ror	r23
    25b8:	67 95       	ror	r22
    25ba:	b7 95       	ror	r27
    25bc:	f7 95       	ror	r31
    25be:	9f 5f       	subi	r25, 0xFF	; 255
    25c0:	c9 f7       	brne	.-14     	; 0x25b4 <__divsf3_pse+0x74>
    25c2:	88 0f       	add	r24, r24
    25c4:	91 1d       	adc	r25, r1
    25c6:	96 95       	lsr	r25
    25c8:	87 95       	ror	r24
    25ca:	97 f9       	bld	r25, 7
    25cc:	08 95       	ret
    25ce:	e1 e0       	ldi	r30, 0x01	; 1
    25d0:	66 0f       	add	r22, r22
    25d2:	77 1f       	adc	r23, r23
    25d4:	88 1f       	adc	r24, r24
    25d6:	bb 1f       	adc	r27, r27
    25d8:	62 17       	cp	r22, r18
    25da:	73 07       	cpc	r23, r19
    25dc:	84 07       	cpc	r24, r20
    25de:	ba 07       	cpc	r27, r26
    25e0:	20 f0       	brcs	.+8      	; 0x25ea <__divsf3_pse+0xaa>
    25e2:	62 1b       	sub	r22, r18
    25e4:	73 0b       	sbc	r23, r19
    25e6:	84 0b       	sbc	r24, r20
    25e8:	ba 0b       	sbc	r27, r26
    25ea:	ee 1f       	adc	r30, r30
    25ec:	88 f7       	brcc	.-30     	; 0x25d0 <__divsf3_pse+0x90>
    25ee:	e0 95       	com	r30
    25f0:	08 95       	ret

000025f2 <__floatunsisf>:
    25f2:	e8 94       	clt
    25f4:	09 c0       	rjmp	.+18     	; 0x2608 <__floatsisf+0x12>

000025f6 <__floatsisf>:
    25f6:	97 fb       	bst	r25, 7
    25f8:	3e f4       	brtc	.+14     	; 0x2608 <__floatsisf+0x12>
    25fa:	90 95       	com	r25
    25fc:	80 95       	com	r24
    25fe:	70 95       	com	r23
    2600:	61 95       	neg	r22
    2602:	7f 4f       	sbci	r23, 0xFF	; 255
    2604:	8f 4f       	sbci	r24, 0xFF	; 255
    2606:	9f 4f       	sbci	r25, 0xFF	; 255
    2608:	99 23       	and	r25, r25
    260a:	a9 f0       	breq	.+42     	; 0x2636 <__floatsisf+0x40>
    260c:	f9 2f       	mov	r31, r25
    260e:	96 e9       	ldi	r25, 0x96	; 150
    2610:	bb 27       	eor	r27, r27
    2612:	93 95       	inc	r25
    2614:	f6 95       	lsr	r31
    2616:	87 95       	ror	r24
    2618:	77 95       	ror	r23
    261a:	67 95       	ror	r22
    261c:	b7 95       	ror	r27
    261e:	f1 11       	cpse	r31, r1
    2620:	f8 cf       	rjmp	.-16     	; 0x2612 <__floatsisf+0x1c>
    2622:	fa f4       	brpl	.+62     	; 0x2662 <__floatsisf+0x6c>
    2624:	bb 0f       	add	r27, r27
    2626:	11 f4       	brne	.+4      	; 0x262c <__floatsisf+0x36>
    2628:	60 ff       	sbrs	r22, 0
    262a:	1b c0       	rjmp	.+54     	; 0x2662 <__floatsisf+0x6c>
    262c:	6f 5f       	subi	r22, 0xFF	; 255
    262e:	7f 4f       	sbci	r23, 0xFF	; 255
    2630:	8f 4f       	sbci	r24, 0xFF	; 255
    2632:	9f 4f       	sbci	r25, 0xFF	; 255
    2634:	16 c0       	rjmp	.+44     	; 0x2662 <__floatsisf+0x6c>
    2636:	88 23       	and	r24, r24
    2638:	11 f0       	breq	.+4      	; 0x263e <__floatsisf+0x48>
    263a:	96 e9       	ldi	r25, 0x96	; 150
    263c:	11 c0       	rjmp	.+34     	; 0x2660 <__floatsisf+0x6a>
    263e:	77 23       	and	r23, r23
    2640:	21 f0       	breq	.+8      	; 0x264a <__floatsisf+0x54>
    2642:	9e e8       	ldi	r25, 0x8E	; 142
    2644:	87 2f       	mov	r24, r23
    2646:	76 2f       	mov	r23, r22
    2648:	05 c0       	rjmp	.+10     	; 0x2654 <__floatsisf+0x5e>
    264a:	66 23       	and	r22, r22
    264c:	71 f0       	breq	.+28     	; 0x266a <__floatsisf+0x74>
    264e:	96 e8       	ldi	r25, 0x86	; 134
    2650:	86 2f       	mov	r24, r22
    2652:	70 e0       	ldi	r23, 0x00	; 0
    2654:	60 e0       	ldi	r22, 0x00	; 0
    2656:	2a f0       	brmi	.+10     	; 0x2662 <__floatsisf+0x6c>
    2658:	9a 95       	dec	r25
    265a:	66 0f       	add	r22, r22
    265c:	77 1f       	adc	r23, r23
    265e:	88 1f       	adc	r24, r24
    2660:	da f7       	brpl	.-10     	; 0x2658 <__floatsisf+0x62>
    2662:	88 0f       	add	r24, r24
    2664:	96 95       	lsr	r25
    2666:	87 95       	ror	r24
    2668:	97 f9       	bld	r25, 7
    266a:	08 95       	ret

0000266c <__fp_cmp>:
    266c:	99 0f       	add	r25, r25
    266e:	00 08       	sbc	r0, r0
    2670:	55 0f       	add	r21, r21
    2672:	aa 0b       	sbc	r26, r26
    2674:	e0 e8       	ldi	r30, 0x80	; 128
    2676:	fe ef       	ldi	r31, 0xFE	; 254
    2678:	16 16       	cp	r1, r22
    267a:	17 06       	cpc	r1, r23
    267c:	e8 07       	cpc	r30, r24
    267e:	f9 07       	cpc	r31, r25
    2680:	c0 f0       	brcs	.+48     	; 0x26b2 <__fp_cmp+0x46>
    2682:	12 16       	cp	r1, r18
    2684:	13 06       	cpc	r1, r19
    2686:	e4 07       	cpc	r30, r20
    2688:	f5 07       	cpc	r31, r21
    268a:	98 f0       	brcs	.+38     	; 0x26b2 <__fp_cmp+0x46>
    268c:	62 1b       	sub	r22, r18
    268e:	73 0b       	sbc	r23, r19
    2690:	84 0b       	sbc	r24, r20
    2692:	95 0b       	sbc	r25, r21
    2694:	39 f4       	brne	.+14     	; 0x26a4 <__fp_cmp+0x38>
    2696:	0a 26       	eor	r0, r26
    2698:	61 f0       	breq	.+24     	; 0x26b2 <__fp_cmp+0x46>
    269a:	23 2b       	or	r18, r19
    269c:	24 2b       	or	r18, r20
    269e:	25 2b       	or	r18, r21
    26a0:	21 f4       	brne	.+8      	; 0x26aa <__fp_cmp+0x3e>
    26a2:	08 95       	ret
    26a4:	0a 26       	eor	r0, r26
    26a6:	09 f4       	brne	.+2      	; 0x26aa <__fp_cmp+0x3e>
    26a8:	a1 40       	sbci	r26, 0x01	; 1
    26aa:	a6 95       	lsr	r26
    26ac:	8f ef       	ldi	r24, 0xFF	; 255
    26ae:	81 1d       	adc	r24, r1
    26b0:	81 1d       	adc	r24, r1
    26b2:	08 95       	ret

000026b4 <__fp_inf>:
    26b4:	97 f9       	bld	r25, 7
    26b6:	9f 67       	ori	r25, 0x7F	; 127
    26b8:	80 e8       	ldi	r24, 0x80	; 128
    26ba:	70 e0       	ldi	r23, 0x00	; 0
    26bc:	60 e0       	ldi	r22, 0x00	; 0
    26be:	08 95       	ret

000026c0 <__fp_nan>:
    26c0:	9f ef       	ldi	r25, 0xFF	; 255
    26c2:	80 ec       	ldi	r24, 0xC0	; 192
    26c4:	08 95       	ret

000026c6 <__fp_pscA>:
    26c6:	00 24       	eor	r0, r0
    26c8:	0a 94       	dec	r0
    26ca:	16 16       	cp	r1, r22
    26cc:	17 06       	cpc	r1, r23
    26ce:	18 06       	cpc	r1, r24
    26d0:	09 06       	cpc	r0, r25
    26d2:	08 95       	ret

000026d4 <__fp_pscB>:
    26d4:	00 24       	eor	r0, r0
    26d6:	0a 94       	dec	r0
    26d8:	12 16       	cp	r1, r18
    26da:	13 06       	cpc	r1, r19
    26dc:	14 06       	cpc	r1, r20
    26de:	05 06       	cpc	r0, r21
    26e0:	08 95       	ret

000026e2 <__fp_round>:
    26e2:	09 2e       	mov	r0, r25
    26e4:	03 94       	inc	r0
    26e6:	00 0c       	add	r0, r0
    26e8:	11 f4       	brne	.+4      	; 0x26ee <__fp_round+0xc>
    26ea:	88 23       	and	r24, r24
    26ec:	52 f0       	brmi	.+20     	; 0x2702 <__fp_round+0x20>
    26ee:	bb 0f       	add	r27, r27
    26f0:	40 f4       	brcc	.+16     	; 0x2702 <__fp_round+0x20>
    26f2:	bf 2b       	or	r27, r31
    26f4:	11 f4       	brne	.+4      	; 0x26fa <__fp_round+0x18>
    26f6:	60 ff       	sbrs	r22, 0
    26f8:	04 c0       	rjmp	.+8      	; 0x2702 <__fp_round+0x20>
    26fa:	6f 5f       	subi	r22, 0xFF	; 255
    26fc:	7f 4f       	sbci	r23, 0xFF	; 255
    26fe:	8f 4f       	sbci	r24, 0xFF	; 255
    2700:	9f 4f       	sbci	r25, 0xFF	; 255
    2702:	08 95       	ret

00002704 <__fp_split3>:
    2704:	57 fd       	sbrc	r21, 7
    2706:	90 58       	subi	r25, 0x80	; 128
    2708:	44 0f       	add	r20, r20
    270a:	55 1f       	adc	r21, r21
    270c:	59 f0       	breq	.+22     	; 0x2724 <__fp_splitA+0x10>
    270e:	5f 3f       	cpi	r21, 0xFF	; 255
    2710:	71 f0       	breq	.+28     	; 0x272e <__fp_splitA+0x1a>
    2712:	47 95       	ror	r20

00002714 <__fp_splitA>:
    2714:	88 0f       	add	r24, r24
    2716:	97 fb       	bst	r25, 7
    2718:	99 1f       	adc	r25, r25
    271a:	61 f0       	breq	.+24     	; 0x2734 <__fp_splitA+0x20>
    271c:	9f 3f       	cpi	r25, 0xFF	; 255
    271e:	79 f0       	breq	.+30     	; 0x273e <__fp_splitA+0x2a>
    2720:	87 95       	ror	r24
    2722:	08 95       	ret
    2724:	12 16       	cp	r1, r18
    2726:	13 06       	cpc	r1, r19
    2728:	14 06       	cpc	r1, r20
    272a:	55 1f       	adc	r21, r21
    272c:	f2 cf       	rjmp	.-28     	; 0x2712 <__fp_split3+0xe>
    272e:	46 95       	lsr	r20
    2730:	f1 df       	rcall	.-30     	; 0x2714 <__fp_splitA>
    2732:	08 c0       	rjmp	.+16     	; 0x2744 <__fp_splitA+0x30>
    2734:	16 16       	cp	r1, r22
    2736:	17 06       	cpc	r1, r23
    2738:	18 06       	cpc	r1, r24
    273a:	99 1f       	adc	r25, r25
    273c:	f1 cf       	rjmp	.-30     	; 0x2720 <__fp_splitA+0xc>
    273e:	86 95       	lsr	r24
    2740:	71 05       	cpc	r23, r1
    2742:	61 05       	cpc	r22, r1
    2744:	08 94       	sec
    2746:	08 95       	ret

00002748 <__fp_zero>:
    2748:	e8 94       	clt

0000274a <__fp_szero>:
    274a:	bb 27       	eor	r27, r27
    274c:	66 27       	eor	r22, r22
    274e:	77 27       	eor	r23, r23
    2750:	cb 01       	movw	r24, r22
    2752:	97 f9       	bld	r25, 7
    2754:	08 95       	ret

00002756 <__gesf2>:
    2756:	8a df       	rcall	.-236    	; 0x266c <__fp_cmp>
    2758:	08 f4       	brcc	.+2      	; 0x275c <__gesf2+0x6>
    275a:	8f ef       	ldi	r24, 0xFF	; 255
    275c:	08 95       	ret

0000275e <__udivmodhi4>:
    275e:	aa 1b       	sub	r26, r26
    2760:	bb 1b       	sub	r27, r27
    2762:	51 e1       	ldi	r21, 0x11	; 17
    2764:	07 c0       	rjmp	.+14     	; 0x2774 <__udivmodhi4_ep>

00002766 <__udivmodhi4_loop>:
    2766:	aa 1f       	adc	r26, r26
    2768:	bb 1f       	adc	r27, r27
    276a:	a6 17       	cp	r26, r22
    276c:	b7 07       	cpc	r27, r23
    276e:	10 f0       	brcs	.+4      	; 0x2774 <__udivmodhi4_ep>
    2770:	a6 1b       	sub	r26, r22
    2772:	b7 0b       	sbc	r27, r23

00002774 <__udivmodhi4_ep>:
    2774:	88 1f       	adc	r24, r24
    2776:	99 1f       	adc	r25, r25
    2778:	5a 95       	dec	r21
    277a:	a9 f7       	brne	.-22     	; 0x2766 <__udivmodhi4_loop>
    277c:	80 95       	com	r24
    277e:	90 95       	com	r25
    2780:	bc 01       	movw	r22, r24
    2782:	cd 01       	movw	r24, r26
    2784:	08 95       	ret

00002786 <__divmodhi4>:
    2786:	97 fb       	bst	r25, 7
    2788:	07 2e       	mov	r0, r23
    278a:	16 f4       	brtc	.+4      	; 0x2790 <__divmodhi4+0xa>
    278c:	00 94       	com	r0
    278e:	07 d0       	rcall	.+14     	; 0x279e <__divmodhi4_neg1>
    2790:	77 fd       	sbrc	r23, 7
    2792:	09 d0       	rcall	.+18     	; 0x27a6 <__divmodhi4_neg2>
    2794:	0e 94 af 13 	call	0x275e	; 0x275e <__udivmodhi4>
    2798:	07 fc       	sbrc	r0, 7
    279a:	05 d0       	rcall	.+10     	; 0x27a6 <__divmodhi4_neg2>
    279c:	3e f4       	brtc	.+14     	; 0x27ac <__divmodhi4_exit>

0000279e <__divmodhi4_neg1>:
    279e:	90 95       	com	r25
    27a0:	81 95       	neg	r24
    27a2:	9f 4f       	sbci	r25, 0xFF	; 255
    27a4:	08 95       	ret

000027a6 <__divmodhi4_neg2>:
    27a6:	70 95       	com	r23
    27a8:	61 95       	neg	r22
    27aa:	7f 4f       	sbci	r23, 0xFF	; 255

000027ac <__divmodhi4_exit>:
    27ac:	08 95       	ret

000027ae <malloc>:
    27ae:	0f 93       	push	r16
    27b0:	1f 93       	push	r17
    27b2:	cf 93       	push	r28
    27b4:	df 93       	push	r29
    27b6:	82 30       	cpi	r24, 0x02	; 2
    27b8:	91 05       	cpc	r25, r1
    27ba:	10 f4       	brcc	.+4      	; 0x27c0 <malloc+0x12>
    27bc:	82 e0       	ldi	r24, 0x02	; 2
    27be:	90 e0       	ldi	r25, 0x00	; 0
    27c0:	e0 91 ae 0f 	lds	r30, 0x0FAE
    27c4:	f0 91 af 0f 	lds	r31, 0x0FAF
    27c8:	20 e0       	ldi	r18, 0x00	; 0
    27ca:	30 e0       	ldi	r19, 0x00	; 0
    27cc:	c0 e0       	ldi	r28, 0x00	; 0
    27ce:	d0 e0       	ldi	r29, 0x00	; 0
    27d0:	23 c0       	rjmp	.+70     	; 0x2818 <malloc+0x6a>
    27d2:	40 81       	ld	r20, Z
    27d4:	51 81       	ldd	r21, Z+1	; 0x01
    27d6:	48 17       	cp	r20, r24
    27d8:	59 07       	cpc	r21, r25
    27da:	a8 f0       	brcs	.+42     	; 0x2806 <malloc+0x58>
    27dc:	48 17       	cp	r20, r24
    27de:	59 07       	cpc	r21, r25
    27e0:	61 f4       	brne	.+24     	; 0x27fa <malloc+0x4c>
    27e2:	82 81       	ldd	r24, Z+2	; 0x02
    27e4:	93 81       	ldd	r25, Z+3	; 0x03
    27e6:	20 97       	sbiw	r28, 0x00	; 0
    27e8:	19 f0       	breq	.+6      	; 0x27f0 <malloc+0x42>
    27ea:	9b 83       	std	Y+3, r25	; 0x03
    27ec:	8a 83       	std	Y+2, r24	; 0x02
    27ee:	2e c0       	rjmp	.+92     	; 0x284c <malloc+0x9e>
    27f0:	90 93 af 0f 	sts	0x0FAF, r25
    27f4:	80 93 ae 0f 	sts	0x0FAE, r24
    27f8:	29 c0       	rjmp	.+82     	; 0x284c <malloc+0x9e>
    27fa:	21 15       	cp	r18, r1
    27fc:	31 05       	cpc	r19, r1
    27fe:	29 f0       	breq	.+10     	; 0x280a <malloc+0x5c>
    2800:	42 17       	cp	r20, r18
    2802:	53 07       	cpc	r21, r19
    2804:	10 f0       	brcs	.+4      	; 0x280a <malloc+0x5c>
    2806:	a9 01       	movw	r20, r18
    2808:	02 c0       	rjmp	.+4      	; 0x280e <malloc+0x60>
    280a:	be 01       	movw	r22, r28
    280c:	df 01       	movw	r26, r30
    280e:	02 81       	ldd	r16, Z+2	; 0x02
    2810:	13 81       	ldd	r17, Z+3	; 0x03
    2812:	ef 01       	movw	r28, r30
    2814:	9a 01       	movw	r18, r20
    2816:	f8 01       	movw	r30, r16
    2818:	30 97       	sbiw	r30, 0x00	; 0
    281a:	d9 f6       	brne	.-74     	; 0x27d2 <malloc+0x24>
    281c:	21 15       	cp	r18, r1
    281e:	31 05       	cpc	r19, r1
    2820:	09 f1       	breq	.+66     	; 0x2864 <malloc+0xb6>
    2822:	28 1b       	sub	r18, r24
    2824:	39 0b       	sbc	r19, r25
    2826:	24 30       	cpi	r18, 0x04	; 4
    2828:	31 05       	cpc	r19, r1
    282a:	90 f4       	brcc	.+36     	; 0x2850 <malloc+0xa2>
    282c:	12 96       	adiw	r26, 0x02	; 2
    282e:	8d 91       	ld	r24, X+
    2830:	9c 91       	ld	r25, X
    2832:	13 97       	sbiw	r26, 0x03	; 3
    2834:	61 15       	cp	r22, r1
    2836:	71 05       	cpc	r23, r1
    2838:	21 f0       	breq	.+8      	; 0x2842 <malloc+0x94>
    283a:	fb 01       	movw	r30, r22
    283c:	93 83       	std	Z+3, r25	; 0x03
    283e:	82 83       	std	Z+2, r24	; 0x02
    2840:	04 c0       	rjmp	.+8      	; 0x284a <malloc+0x9c>
    2842:	90 93 af 0f 	sts	0x0FAF, r25
    2846:	80 93 ae 0f 	sts	0x0FAE, r24
    284a:	fd 01       	movw	r30, r26
    284c:	32 96       	adiw	r30, 0x02	; 2
    284e:	44 c0       	rjmp	.+136    	; 0x28d8 <malloc+0x12a>
    2850:	fd 01       	movw	r30, r26
    2852:	e2 0f       	add	r30, r18
    2854:	f3 1f       	adc	r31, r19
    2856:	81 93       	st	Z+, r24
    2858:	91 93       	st	Z+, r25
    285a:	22 50       	subi	r18, 0x02	; 2
    285c:	31 09       	sbc	r19, r1
    285e:	2d 93       	st	X+, r18
    2860:	3c 93       	st	X, r19
    2862:	3a c0       	rjmp	.+116    	; 0x28d8 <malloc+0x12a>
    2864:	20 91 ac 0f 	lds	r18, 0x0FAC
    2868:	30 91 ad 0f 	lds	r19, 0x0FAD
    286c:	23 2b       	or	r18, r19
    286e:	41 f4       	brne	.+16     	; 0x2880 <malloc+0xd2>
    2870:	20 91 02 01 	lds	r18, 0x0102
    2874:	30 91 03 01 	lds	r19, 0x0103
    2878:	30 93 ad 0f 	sts	0x0FAD, r19
    287c:	20 93 ac 0f 	sts	0x0FAC, r18
    2880:	20 91 00 01 	lds	r18, 0x0100
    2884:	30 91 01 01 	lds	r19, 0x0101
    2888:	21 15       	cp	r18, r1
    288a:	31 05       	cpc	r19, r1
    288c:	41 f4       	brne	.+16     	; 0x289e <malloc+0xf0>
    288e:	2d b7       	in	r18, 0x3d	; 61
    2890:	3e b7       	in	r19, 0x3e	; 62
    2892:	40 91 04 01 	lds	r20, 0x0104
    2896:	50 91 05 01 	lds	r21, 0x0105
    289a:	24 1b       	sub	r18, r20
    289c:	35 0b       	sbc	r19, r21
    289e:	e0 91 ac 0f 	lds	r30, 0x0FAC
    28a2:	f0 91 ad 0f 	lds	r31, 0x0FAD
    28a6:	e2 17       	cp	r30, r18
    28a8:	f3 07       	cpc	r31, r19
    28aa:	a0 f4       	brcc	.+40     	; 0x28d4 <malloc+0x126>
    28ac:	2e 1b       	sub	r18, r30
    28ae:	3f 0b       	sbc	r19, r31
    28b0:	28 17       	cp	r18, r24
    28b2:	39 07       	cpc	r19, r25
    28b4:	78 f0       	brcs	.+30     	; 0x28d4 <malloc+0x126>
    28b6:	ac 01       	movw	r20, r24
    28b8:	4e 5f       	subi	r20, 0xFE	; 254
    28ba:	5f 4f       	sbci	r21, 0xFF	; 255
    28bc:	24 17       	cp	r18, r20
    28be:	35 07       	cpc	r19, r21
    28c0:	48 f0       	brcs	.+18     	; 0x28d4 <malloc+0x126>
    28c2:	4e 0f       	add	r20, r30
    28c4:	5f 1f       	adc	r21, r31
    28c6:	50 93 ad 0f 	sts	0x0FAD, r21
    28ca:	40 93 ac 0f 	sts	0x0FAC, r20
    28ce:	81 93       	st	Z+, r24
    28d0:	91 93       	st	Z+, r25
    28d2:	02 c0       	rjmp	.+4      	; 0x28d8 <malloc+0x12a>
    28d4:	e0 e0       	ldi	r30, 0x00	; 0
    28d6:	f0 e0       	ldi	r31, 0x00	; 0
    28d8:	cf 01       	movw	r24, r30
    28da:	df 91       	pop	r29
    28dc:	cf 91       	pop	r28
    28de:	1f 91       	pop	r17
    28e0:	0f 91       	pop	r16
    28e2:	08 95       	ret

000028e4 <free>:
    28e4:	ef 92       	push	r14
    28e6:	ff 92       	push	r15
    28e8:	0f 93       	push	r16
    28ea:	1f 93       	push	r17
    28ec:	cf 93       	push	r28
    28ee:	df 93       	push	r29
    28f0:	00 97       	sbiw	r24, 0x00	; 0
    28f2:	09 f4       	brne	.+2      	; 0x28f6 <free+0x12>
    28f4:	8f c0       	rjmp	.+286    	; 0x2a14 <free+0x130>
    28f6:	dc 01       	movw	r26, r24
    28f8:	12 97       	sbiw	r26, 0x02	; 2
    28fa:	13 96       	adiw	r26, 0x03	; 3
    28fc:	1c 92       	st	X, r1
    28fe:	1e 92       	st	-X, r1
    2900:	12 97       	sbiw	r26, 0x02	; 2
    2902:	e0 90 ae 0f 	lds	r14, 0x0FAE
    2906:	f0 90 af 0f 	lds	r15, 0x0FAF
    290a:	e1 14       	cp	r14, r1
    290c:	f1 04       	cpc	r15, r1
    290e:	89 f4       	brne	.+34     	; 0x2932 <free+0x4e>
    2910:	2d 91       	ld	r18, X+
    2912:	3c 91       	ld	r19, X
    2914:	11 97       	sbiw	r26, 0x01	; 1
    2916:	28 0f       	add	r18, r24
    2918:	39 1f       	adc	r19, r25
    291a:	80 91 ac 0f 	lds	r24, 0x0FAC
    291e:	90 91 ad 0f 	lds	r25, 0x0FAD
    2922:	82 17       	cp	r24, r18
    2924:	93 07       	cpc	r25, r19
    2926:	89 f5       	brne	.+98     	; 0x298a <free+0xa6>
    2928:	b0 93 ad 0f 	sts	0x0FAD, r27
    292c:	a0 93 ac 0f 	sts	0x0FAC, r26
    2930:	71 c0       	rjmp	.+226    	; 0x2a14 <free+0x130>
    2932:	e7 01       	movw	r28, r14
    2934:	20 e0       	ldi	r18, 0x00	; 0
    2936:	30 e0       	ldi	r19, 0x00	; 0
    2938:	01 c0       	rjmp	.+2      	; 0x293c <free+0x58>
    293a:	ea 01       	movw	r28, r20
    293c:	ca 17       	cp	r28, r26
    293e:	db 07       	cpc	r29, r27
    2940:	38 f4       	brcc	.+14     	; 0x2950 <free+0x6c>
    2942:	4a 81       	ldd	r20, Y+2	; 0x02
    2944:	5b 81       	ldd	r21, Y+3	; 0x03
    2946:	9e 01       	movw	r18, r28
    2948:	41 15       	cp	r20, r1
    294a:	51 05       	cpc	r21, r1
    294c:	b1 f7       	brne	.-20     	; 0x293a <free+0x56>
    294e:	22 c0       	rjmp	.+68     	; 0x2994 <free+0xb0>
    2950:	bc 01       	movw	r22, r24
    2952:	62 50       	subi	r22, 0x02	; 2
    2954:	71 09       	sbc	r23, r1
    2956:	fb 01       	movw	r30, r22
    2958:	d3 83       	std	Z+3, r29	; 0x03
    295a:	c2 83       	std	Z+2, r28	; 0x02
    295c:	00 81       	ld	r16, Z
    295e:	11 81       	ldd	r17, Z+1	; 0x01
    2960:	ac 01       	movw	r20, r24
    2962:	40 0f       	add	r20, r16
    2964:	51 1f       	adc	r21, r17
    2966:	4c 17       	cp	r20, r28
    2968:	5d 07       	cpc	r21, r29
    296a:	61 f4       	brne	.+24     	; 0x2984 <free+0xa0>
    296c:	48 81       	ld	r20, Y
    296e:	59 81       	ldd	r21, Y+1	; 0x01
    2970:	40 0f       	add	r20, r16
    2972:	51 1f       	adc	r21, r17
    2974:	4e 5f       	subi	r20, 0xFE	; 254
    2976:	5f 4f       	sbci	r21, 0xFF	; 255
    2978:	51 83       	std	Z+1, r21	; 0x01
    297a:	40 83       	st	Z, r20
    297c:	4a 81       	ldd	r20, Y+2	; 0x02
    297e:	5b 81       	ldd	r21, Y+3	; 0x03
    2980:	53 83       	std	Z+3, r21	; 0x03
    2982:	42 83       	std	Z+2, r20	; 0x02
    2984:	21 15       	cp	r18, r1
    2986:	31 05       	cpc	r19, r1
    2988:	29 f4       	brne	.+10     	; 0x2994 <free+0xb0>
    298a:	b0 93 af 0f 	sts	0x0FAF, r27
    298e:	a0 93 ae 0f 	sts	0x0FAE, r26
    2992:	40 c0       	rjmp	.+128    	; 0x2a14 <free+0x130>
    2994:	f9 01       	movw	r30, r18
    2996:	b3 83       	std	Z+3, r27	; 0x03
    2998:	a2 83       	std	Z+2, r26	; 0x02
    299a:	e9 01       	movw	r28, r18
    299c:	69 91       	ld	r22, Y+
    299e:	79 91       	ld	r23, Y+
    29a0:	c6 0f       	add	r28, r22
    29a2:	d7 1f       	adc	r29, r23
    29a4:	ac 17       	cp	r26, r28
    29a6:	bd 07       	cpc	r27, r29
    29a8:	79 f4       	brne	.+30     	; 0x29c8 <free+0xe4>
    29aa:	dc 01       	movw	r26, r24
    29ac:	5e 91       	ld	r21, -X
    29ae:	4e 91       	ld	r20, -X
    29b0:	46 0f       	add	r20, r22
    29b2:	57 1f       	adc	r21, r23
    29b4:	4e 5f       	subi	r20, 0xFE	; 254
    29b6:	5f 4f       	sbci	r21, 0xFF	; 255
    29b8:	51 83       	std	Z+1, r21	; 0x01
    29ba:	40 83       	st	Z, r20
    29bc:	12 96       	adiw	r26, 0x02	; 2
    29be:	8d 91       	ld	r24, X+
    29c0:	9c 91       	ld	r25, X
    29c2:	13 97       	sbiw	r26, 0x03	; 3
    29c4:	93 83       	std	Z+3, r25	; 0x03
    29c6:	82 83       	std	Z+2, r24	; 0x02
    29c8:	a0 e0       	ldi	r26, 0x00	; 0
    29ca:	b0 e0       	ldi	r27, 0x00	; 0
    29cc:	02 c0       	rjmp	.+4      	; 0x29d2 <free+0xee>
    29ce:	d7 01       	movw	r26, r14
    29d0:	7c 01       	movw	r14, r24
    29d2:	f7 01       	movw	r30, r14
    29d4:	82 81       	ldd	r24, Z+2	; 0x02
    29d6:	93 81       	ldd	r25, Z+3	; 0x03
    29d8:	00 97       	sbiw	r24, 0x00	; 0
    29da:	c9 f7       	brne	.-14     	; 0x29ce <free+0xea>
    29dc:	c7 01       	movw	r24, r14
    29de:	02 96       	adiw	r24, 0x02	; 2
    29e0:	20 81       	ld	r18, Z
    29e2:	31 81       	ldd	r19, Z+1	; 0x01
    29e4:	82 0f       	add	r24, r18
    29e6:	93 1f       	adc	r25, r19
    29e8:	20 91 ac 0f 	lds	r18, 0x0FAC
    29ec:	30 91 ad 0f 	lds	r19, 0x0FAD
    29f0:	28 17       	cp	r18, r24
    29f2:	39 07       	cpc	r19, r25
    29f4:	79 f4       	brne	.+30     	; 0x2a14 <free+0x130>
    29f6:	10 97       	sbiw	r26, 0x00	; 0
    29f8:	29 f4       	brne	.+10     	; 0x2a04 <free+0x120>
    29fa:	10 92 af 0f 	sts	0x0FAF, r1
    29fe:	10 92 ae 0f 	sts	0x0FAE, r1
    2a02:	04 c0       	rjmp	.+8      	; 0x2a0c <free+0x128>
    2a04:	13 96       	adiw	r26, 0x03	; 3
    2a06:	1c 92       	st	X, r1
    2a08:	1e 92       	st	-X, r1
    2a0a:	12 97       	sbiw	r26, 0x02	; 2
    2a0c:	f0 92 ad 0f 	sts	0x0FAD, r15
    2a10:	e0 92 ac 0f 	sts	0x0FAC, r14
    2a14:	df 91       	pop	r29
    2a16:	cf 91       	pop	r28
    2a18:	1f 91       	pop	r17
    2a1a:	0f 91       	pop	r16
    2a1c:	ff 90       	pop	r15
    2a1e:	ef 90       	pop	r14
    2a20:	08 95       	ret

00002a22 <memcpy>:
    2a22:	fb 01       	movw	r30, r22
    2a24:	dc 01       	movw	r26, r24
    2a26:	02 c0       	rjmp	.+4      	; 0x2a2c <memcpy+0xa>
    2a28:	01 90       	ld	r0, Z+
    2a2a:	0d 92       	st	X+, r0
    2a2c:	41 50       	subi	r20, 0x01	; 1
    2a2e:	50 40       	sbci	r21, 0x00	; 0
    2a30:	d8 f7       	brcc	.-10     	; 0x2a28 <memcpy+0x6>
    2a32:	08 95       	ret

00002a34 <_exit>:
    2a34:	f8 94       	cli

00002a36 <__stop_program>:
    2a36:	ff cf       	rjmp	.-2      	; 0x2a36 <__stop_program>
