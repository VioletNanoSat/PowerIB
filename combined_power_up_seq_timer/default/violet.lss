
violet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000206  00800100  00002a34  00002ac8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002a34  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000cac  00800306  00800306  00002cce  2**0
                  ALLOC
  3 .stab         00003ff0  00000000  00000000  00002cd0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000010d7  00000000  00000000  00006cc0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00007d97  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000278  00000000  00000000  00007dc6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000502b  00000000  00000000  0000803e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000010af  00000000  00000000  0000d069  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000013e2  00000000  00000000  0000e118  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a78  00000000  00000000  0000f4fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b1b  00000000  00000000  0000ff74  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002fb7  00000000  00000000  00010a8f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000200  00000000  00000000  00013a46  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
{
       0:	0c 94 f4 00 	jmp	0x1e8	; 0x1e8 <__ctors_end>
       4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
       8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
       c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      10:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 * insert_str
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
      14:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      18:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
{
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
      1c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      20:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      24:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      28:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
		output[i] = input[i - start_index];

	return i;
}
      2c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      30:	0c 94 9c 0c 	jmp	0x1938	; 0x1938 <__vector_12>
      34:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      38:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      3c:	0c 94 79 0c 	jmp	0x18f2	; 0x18f2 <__vector_15>
      40:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      44:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      48:	0c 94 a9 0d 	jmp	0x1b52	; 0x1b52 <__vector_18>
      4c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      50:	0c 94 80 0d 	jmp	0x1b00	; 0x1b00 <__vector_20>
      54:	0c 94 6b 0d 	jmp	0x1ad6	; 0x1ad6 <__vector_21>
      58:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      5c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      60:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      64:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      68:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      6c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      70:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      74:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      78:	0c 94 36 0d 	jmp	0x1a6c	; 0x1a6c <__vector_30>
      7c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      80:	0c 94 0d 0d 	jmp	0x1a1a	; 0x1a1a <__vector_32>
      84:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      88:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>

0000008c <charge20Pc>:
      8c:	08 00 09 00 09 00 0a 00 0b 00 0c 00 0d 00 0d 00     ................
      9c:	0e 00 0f 00 10 00 11 00 12 00 13 00 14 00 15 00     ................
      ac:	16 00 17 00 19 00 1a 00 1b 00 1d 00 1e 00 1f 00     ................
      bc:	21 00 22 00 24 00 25 00 27 00 28 00 2b 00 2c 00     !.".$.%.'.(.+.,.
      cc:	2e 00 30 00 32 00 34 00 36 00 38 00 3b 00 3e 00     ..0.2.4.6.8.;.>.
      dc:	3f 00 42 00 45 00 48 00 4c 00 50 00 59 00 6b 00     ?.B.E.H.L.P.Y.k.
      ec:	7f 00 8a 00 9c 00 a8 00 b3 00 c1 00 ce 00 dd 00     ................
      fc:	ea 00 f9 00 0d 01 1f 01 2b 01 3f 01 7e 01 a9 01     ........+.?.~...
     10c:	b7 01 e1 01 ff 01 18 02 28 02 3d 02 4d 02 62 02     ........(.=.M.b.
     11c:	7d 02 90 02 b8 02 c5 02 d6 02 e9 02 fa 02 08 03     }...............
     12c:	16 03 25 03 32 03 40 03 4d 03 60 03 6f 03 77 03     ..%.2.@.M.`.o.w.
     13c:	83 03 95 03 9f 03 aa 03 b4 03 c0 03 c9 03 d5 03     ................
     14c:	df 03 eb 03 f5 03 00 04 05 04 12 04 19 04 22 04     ..............".
     15c:	2c 04 34 04 37 04 40 04 74 04 7e 04                 ,.4.7.@.t.~.

00000168 <discharge20Pc>:
     168:	00 00 03 00 03 00 03 00 03 00 03 00 03 00 03 00     ................
     178:	03 00 03 00 03 00 03 00 03 00 03 00 03 00 03 00     ................
     188:	03 00 04 00 04 00 04 00 04 00 18 00 18 00 18 00     ................
     198:	18 00 40 00 40 00 40 00 40 00 68 00 68 00 68 00     ..@.@.@.@.h.h.h.
     1a8:	68 00 99 00 99 00 99 00 99 00 cd 00 cd 00 cd 00     h...............
     1b8:	cd 00 ff 00 ff 00 ff 00 ff 00 39 01 39 01 39 01     ..........9.9.9.
     1c8:	39 01 97 01 97 01 97 01 97 01 26 02 a9 02 40 03     9.........&...@.
     1d8:	91 03 ef 03 18 04 2a 04 34 04 3e 04 45 04 4d 04     ......*.4.>.E.M.

000001e8 <__ctors_end>:
     1e8:	11 24       	eor	r1, r1
     1ea:	1f be       	out	0x3f, r1	; 63
     1ec:	cf ef       	ldi	r28, 0xFF	; 255
     1ee:	d0 e1       	ldi	r29, 0x10	; 16
     1f0:	de bf       	out	0x3e, r29	; 62
     1f2:	cd bf       	out	0x3d, r28	; 61

000001f4 <__do_copy_data>:
     1f4:	13 e0       	ldi	r17, 0x03	; 3
     1f6:	a0 e0       	ldi	r26, 0x00	; 0
     1f8:	b1 e0       	ldi	r27, 0x01	; 1
     1fa:	e4 e3       	ldi	r30, 0x34	; 52
     1fc:	fa e2       	ldi	r31, 0x2A	; 42
     1fe:	00 e0       	ldi	r16, 0x00	; 0
     200:	0b bf       	out	0x3b, r16	; 59
     202:	02 c0       	rjmp	.+4      	; 0x208 <__do_copy_data+0x14>
     204:	07 90       	elpm	r0, Z+
     206:	0d 92       	st	X+, r0
     208:	a6 30       	cpi	r26, 0x06	; 6
     20a:	b1 07       	cpc	r27, r17
     20c:	d9 f7       	brne	.-10     	; 0x204 <__do_copy_data+0x10>

0000020e <__do_clear_bss>:
     20e:	2f e0       	ldi	r18, 0x0F	; 15
     210:	a6 e0       	ldi	r26, 0x06	; 6
     212:	b3 e0       	ldi	r27, 0x03	; 3
     214:	01 c0       	rjmp	.+2      	; 0x218 <.do_clear_bss_start>

00000216 <.do_clear_bss_loop>:
     216:	1d 92       	st	X+, r1

00000218 <.do_clear_bss_start>:
     218:	a2 3b       	cpi	r26, 0xB2	; 178
     21a:	b2 07       	cpc	r27, r18
     21c:	e1 f7       	brne	.-8      	; 0x216 <.do_clear_bss_loop>
     21e:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <main>
     222:	0c 94 18 15 	jmp	0x2a30	; 0x2a30 <_exit>

00000226 <__bad_interrupt>:
     226:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000022a <set_component>:
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     22a:	8f 92       	push	r8
     22c:	af 92       	push	r10
     22e:	cf 92       	push	r12
     230:	ef 92       	push	r14
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     232:	0f 93       	push	r16
     234:	cf 93       	push	r28
     236:	df 93       	push	r29
     238:	cd b7       	in	r28, 0x3d	; 61
     23a:	de b7       	in	r29, 0x3e	; 62
     23c:	9c e1       	ldi	r25, 0x1C	; 28
     23e:	89 9f       	mul	r24, r25
     240:	f0 01       	movw	r30, r0
     242:	11 24       	eor	r1, r1
     244:	e8 5c       	subi	r30, 0xC8	; 200
     246:	fc 4f       	sbci	r31, 0xFC	; 252
     248:	60 83       	st	Z, r22
     24a:	41 83       	std	Z+1, r20	; 0x01
     24c:	22 83       	std	Z+2, r18	; 0x02
     24e:	13 82       	std	Z+3, r1	; 0x03
     250:	04 83       	std	Z+4, r16	; 0x04
     252:	e5 82       	std	Z+5, r14	; 0x05
     254:	c6 82       	std	Z+6, r12	; 0x06
     256:	a7 82       	std	Z+7, r10	; 0x07
     258:	13 86       	std	Z+11, r1	; 0x0b
     25a:	14 86       	std	Z+12, r1	; 0x0c
     25c:	85 86       	std	Z+13, r8	; 0x0d
     25e:	8a 85       	ldd	r24, Y+10	; 0x0a
     260:	86 87       	std	Z+14, r24	; 0x0e
     262:	8b 85       	ldd	r24, Y+11	; 0x0b
     264:	87 87       	std	Z+15, r24	; 0x0f
     266:	8c 85       	ldd	r24, Y+12	; 0x0c
     268:	80 8b       	std	Z+16, r24	; 0x10
     26a:	14 8a       	std	Z+20, r1	; 0x14
     26c:	15 8a       	std	Z+21, r1	; 0x15
     26e:	8d 85       	ldd	r24, Y+13	; 0x0d
     270:	86 8b       	std	Z+22, r24	; 0x16
     272:	8e 85       	ldd	r24, Y+14	; 0x0e
     274:	87 8b       	std	Z+23, r24	; 0x17
     276:	13 8e       	std	Z+27, r1	; 0x1b
     278:	df 91       	pop	r29
     27a:	cf 91       	pop	r28
     27c:	0f 91       	pop	r16
     27e:	ef 90       	pop	r14
     280:	cf 90       	pop	r12
     282:	af 90       	pop	r10
     284:	8f 90       	pop	r8
     286:	08 95       	ret

00000288 <initialize_svit>:
     288:	5f 92       	push	r5
     28a:	6f 92       	push	r6
     28c:	7f 92       	push	r7
     28e:	8f 92       	push	r8
     290:	9f 92       	push	r9
     292:	af 92       	push	r10
     294:	bf 92       	push	r11
     296:	cf 92       	push	r12
     298:	df 92       	push	r13
     29a:	ef 92       	push	r14
     29c:	ff 92       	push	r15
     29e:	0f 93       	push	r16
     2a0:	1f 93       	push	r17
     2a2:	cf 93       	push	r28
     2a4:	df 93       	push	r29
     2a6:	80 e6       	ldi	r24, 0x60	; 96
     2a8:	87 b9       	out	0x07, r24	; 7
     2aa:	8f e8       	ldi	r24, 0x8F	; 143
     2ac:	86 b9       	out	0x06, r24	; 6
     2ae:	1f 92       	push	r1
     2b0:	13 e0       	ldi	r17, 0x03	; 3
     2b2:	1f 93       	push	r17
     2b4:	c0 e1       	ldi	r28, 0x10	; 16
     2b6:	cf 93       	push	r28
     2b8:	d0 ea       	ldi	r29, 0xA0	; 160
     2ba:	df 93       	push	r29
     2bc:	86 e0       	ldi	r24, 0x06	; 6
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2be:	d8 2e       	mov	r13, r24
     2c0:	df 92       	push	r13
     2c2:	81 2c       	mov	r8, r1
     2c4:	90 e1       	ldi	r25, 0x10	; 16
     2c6:	a9 2e       	mov	r10, r25
     2c8:	20 ea       	ldi	r18, 0xA0	; 160
     2ca:	c2 2e       	mov	r12, r18
     2cc:	3b e0       	ldi	r19, 0x0B	; 11
     2ce:	e3 2e       	mov	r14, r19
     2d0:	00 e0       	ldi	r16, 0x00	; 0
     2d2:	21 e0       	ldi	r18, 0x01	; 1
     2d4:	47 e0       	ldi	r20, 0x07	; 7
     2d6:	60 e0       	ldi	r22, 0x00	; 0
     2d8:	80 e0       	ldi	r24, 0x00	; 0
     2da:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     2de:	87 e0       	ldi	r24, 0x07	; 7
     2e0:	8f 93       	push	r24
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     2e2:	bb 24       	eor	r11, r11
     2e4:	b3 94       	inc	r11
     2e6:	bf 92       	push	r11
     2e8:	cf 93       	push	r28
     2ea:	df 93       	push	r29
     2ec:	8f 93       	push	r24
     2ee:	47 e1       	ldi	r20, 0x17	; 23
     2f0:	e4 2e       	mov	r14, r20
     2f2:	21 e0       	ldi	r18, 0x01	; 1
     2f4:	48 e0       	ldi	r20, 0x08	; 8
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2f6:	61 e0       	ldi	r22, 0x01	; 1
     2f8:	81 e0       	ldi	r24, 0x01	; 1
     2fa:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     2fe:	1f 92       	push	r1
     300:	1f 93       	push	r17
     302:	cf 93       	push	r28
     304:	df 93       	push	r29
     306:	1f 92       	push	r1
     308:	88 24       	eor	r8, r8
     30a:	83 94       	inc	r8
     30c:	53 e1       	ldi	r21, 0x13	; 19
     30e:	e5 2e       	mov	r14, r21
     310:	01 e0       	ldi	r16, 0x01	; 1
     312:	21 e0       	ldi	r18, 0x01	; 1
     314:	41 e0       	ldi	r20, 0x01	; 1
     316:	62 e0       	ldi	r22, 0x02	; 2
     318:	82 e0       	ldi	r24, 0x02	; 2
     31a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     31e:	1f 92       	push	r1
     320:	1f 93       	push	r17
     322:	cf 93       	push	r28
     324:	df 93       	push	r29
     326:	8e e0       	ldi	r24, 0x0E	; 14
     328:	8f 93       	push	r24
     32a:	62 e0       	ldi	r22, 0x02	; 2
     32c:	86 2e       	mov	r8, r22
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     32e:	7d e0       	ldi	r23, 0x0D	; 13
     330:	e7 2e       	mov	r14, r23
     332:	02 e0       	ldi	r16, 0x02	; 2
     334:	21 e0       	ldi	r18, 0x01	; 1
     336:	41 e0       	ldi	r20, 0x01	; 1
     338:	63 e0       	ldi	r22, 0x03	; 3
     33a:	83 e0       	ldi	r24, 0x03	; 3
     33c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     340:	1f 92       	push	r1
     342:	1f 93       	push	r17
     344:	cf 93       	push	r28
     346:	df 93       	push	r29
     348:	bf 92       	push	r11
     34a:	88 24       	eor	r8, r8
     34c:	83 94       	inc	r8
     34e:	e5 e1       	ldi	r30, 0x15	; 21
     350:	ee 2e       	mov	r14, r30
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     352:	01 e0       	ldi	r16, 0x01	; 1
     354:	21 e0       	ldi	r18, 0x01	; 1
     356:	42 e0       	ldi	r20, 0x02	; 2
     358:	64 e0       	ldi	r22, 0x04	; 4
     35a:	84 e0       	ldi	r24, 0x04	; 4
     35c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     360:	1f 92       	push	r1
     362:	1f 93       	push	r17
     364:	cf 93       	push	r28
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     366:	df 93       	push	r29
     368:	f2 e0       	ldi	r31, 0x02	; 2
     36a:	ff 2e       	mov	r15, r31
     36c:	ff 92       	push	r15
     36e:	aa e1       	ldi	r26, 0x1A	; 26
     370:	ea 2e       	mov	r14, r26
     372:	21 e0       	ldi	r18, 0x01	; 1
     374:	43 e0       	ldi	r20, 0x03	; 3
     376:	65 e0       	ldi	r22, 0x05	; 5
     378:	85 e0       	ldi	r24, 0x05	; 5
     37a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     37e:	1f 92       	push	r1
     380:	1f 93       	push	r17
     382:	cf 93       	push	r28
     384:	df 93       	push	r29
     386:	1f 93       	push	r17
     388:	bd e1       	ldi	r27, 0x1D	; 29
     38a:	eb 2e       	mov	r14, r27
     38c:	21 e0       	ldi	r18, 0x01	; 1
     38e:	44 e0       	ldi	r20, 0x04	; 4
     390:	66 e0       	ldi	r22, 0x06	; 6
     392:	86 e0       	ldi	r24, 0x06	; 6
     394:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     398:	8d b7       	in	r24, 0x3d	; 61
     39a:	9e b7       	in	r25, 0x3e	; 62
     39c:	83 96       	adiw	r24, 0x23	; 35
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     39e:	0f b6       	in	r0, 0x3f	; 63
     3a0:	f8 94       	cli
     3a2:	9e bf       	out	0x3e, r25	; 62
     3a4:	0f be       	out	0x3f, r0	; 63
     3a6:	8d bf       	out	0x3d, r24	; 61
     3a8:	1f 92       	push	r1
     3aa:	1f 93       	push	r17
     3ac:	cf 93       	push	r28
     3ae:	df 93       	push	r29
     3b0:	8f e1       	ldi	r24, 0x1F	; 31
     3b2:	98 2e       	mov	r9, r24
     3b4:	9f 92       	push	r9
     3b6:	9e e0       	ldi	r25, 0x0E	; 14
     3b8:	e9 2e       	mov	r14, r25
     3ba:	21 e0       	ldi	r18, 0x01	; 1
     3bc:	45 e0       	ldi	r20, 0x05	; 5
     3be:	67 e0       	ldi	r22, 0x07	; 7
     3c0:	87 e0       	ldi	r24, 0x07	; 7
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     3c2:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     3c6:	1f 92       	push	r1
     3c8:	1f 93       	push	r17
     3ca:	cf 93       	push	r28
     3cc:	df 93       	push	r29
     3ce:	24 e0       	ldi	r18, 0x04	; 4
     3d0:	52 2e       	mov	r5, r18
     3d2:	5f 92       	push	r5
     3d4:	3b e1       	ldi	r19, 0x1B	; 27
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     3d6:	e3 2e       	mov	r14, r19
     3d8:	21 e0       	ldi	r18, 0x01	; 1
     3da:	46 e0       	ldi	r20, 0x06	; 6
     3dc:	68 e0       	ldi	r22, 0x08	; 8
     3de:	88 e0       	ldi	r24, 0x08	; 8
     3e0:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     3e4:	1f 92       	push	r1
     3e6:	1f 93       	push	r17
     3e8:	cf 93       	push	r28
     3ea:	df 93       	push	r29
     3ec:	48 e0       	ldi	r20, 0x08	; 8
     3ee:	64 2e       	mov	r6, r20
     3f0:	6f 92       	push	r6
     3f2:	5f e0       	ldi	r21, 0x0F	; 15
     3f4:	e5 2e       	mov	r14, r21
     3f6:	21 e0       	ldi	r18, 0x01	; 1
     3f8:	49 e0       	ldi	r20, 0x09	; 9
     3fa:	69 e0       	ldi	r22, 0x09	; 9
     3fc:	89 e0       	ldi	r24, 0x09	; 9
     3fe:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     402:	1f 92       	push	r1
     404:	1f 93       	push	r17
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     406:	cf 93       	push	r28
     408:	df 93       	push	r29
     40a:	69 e0       	ldi	r22, 0x09	; 9
     40c:	76 2e       	mov	r7, r22
     40e:	7f 92       	push	r7
     410:	79 e1       	ldi	r23, 0x19	; 25
     412:	e7 2e       	mov	r14, r23
     414:	21 e0       	ldi	r18, 0x01	; 1
     416:	4a e0       	ldi	r20, 0x0A	; 10
     418:	6a e0       	ldi	r22, 0x0A	; 10
     41a:	8a e0       	ldi	r24, 0x0A	; 10
     41c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     420:	1f 92       	push	r1
     422:	1f 93       	push	r17
     424:	cf 93       	push	r28
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     426:	df 93       	push	r29
     428:	8a e0       	ldi	r24, 0x0A	; 10
     42a:	8f 93       	push	r24
     42c:	e8 e1       	ldi	r30, 0x18	; 24
     42e:	ee 2e       	mov	r14, r30
     430:	20 e0       	ldi	r18, 0x00	; 0
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     432:	4b e0       	ldi	r20, 0x0B	; 11
     434:	6b e0       	ldi	r22, 0x0B	; 11
     436:	8b e0       	ldi	r24, 0x0B	; 11
     438:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     43c:	1f 92       	push	r1
     43e:	1f 93       	push	r17
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
	}
    else 
	{
	  debug = 0x0B;
     444:	cf 93       	push	r28
     446:	f1 e1       	ldi	r31, 0x11	; 17
     448:	ef 2e       	mov	r14, r31
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     44a:	20 e0       	ldi	r18, 0x00	; 0
     44c:	4c e0       	ldi	r20, 0x0C	; 12
     44e:	6c e0       	ldi	r22, 0x0C	; 12
     450:	8c e0       	ldi	r24, 0x0C	; 12
     452:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     456:	6f 92       	push	r6
     458:	ff 92       	push	r15
     45a:	cf 93       	push	r28
     45c:	df 93       	push	r29
     45e:	8c e0       	ldi	r24, 0x0C	; 12
     460:	8f 93       	push	r24
     462:	a6 e1       	ldi	r26, 0x16	; 22
     464:	ea 2e       	mov	r14, r26
     466:	21 e0       	ldi	r18, 0x01	; 1
     468:	4d e0       	ldi	r20, 0x0D	; 13
     46a:	6d e0       	ldi	r22, 0x0D	; 13
     46c:	8d e0       	ldi	r24, 0x0D	; 13
     46e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     472:	8d b7       	in	r24, 0x3d	; 61
     474:	9e b7       	in	r25, 0x3e	; 62
     476:	83 96       	adiw	r24, 0x23	; 35
     478:	0f b6       	in	r0, 0x3f	; 63
     47a:	f8 94       	cli
     47c:	9e bf       	out	0x3e, r25	; 62
     47e:	0f be       	out	0x3f, r0	; 63
     480:	8d bf       	out	0x3d, r24	; 61
     482:	1f 92       	push	r1
     484:	1f 93       	push	r17
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	df 92       	push	r13
     48c:	81 2c       	mov	r8, r1
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     48e:	b4 e0       	ldi	r27, 0x04	; 4
     490:	eb 2e       	mov	r14, r27
     492:	00 e0       	ldi	r16, 0x00	; 0
     494:	21 e0       	ldi	r18, 0x01	; 1
     496:	4e e0       	ldi	r20, 0x0E	; 14
     498:	6e e0       	ldi	r22, 0x0E	; 14
     49a:	8e e0       	ldi	r24, 0x0E	; 14
     49c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4a0:	1f 92       	push	r1
     4a2:	1f 93       	push	r17
     4a4:	cf 93       	push	r28
     4a6:	df 93       	push	r29
     4a8:	1f 92       	push	r1
     4aa:	03 e0       	ldi	r16, 0x03	; 3
     4ac:	80 2e       	mov	r8, r16
     4ae:	85 e1       	ldi	r24, 0x15	; 21
     4b0:	e8 2e       	mov	r14, r24
     4b2:	02 e0       	ldi	r16, 0x02	; 2
     4b4:	21 e0       	ldi	r18, 0x01	; 1
     4b6:	40 e1       	ldi	r20, 0x10	; 16
     4b8:	6f e0       	ldi	r22, 0x0F	; 15
     4ba:	8f e0       	ldi	r24, 0x0F	; 15
     4bc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4c0:	1f 92       	push	r1
     4c2:	1f 93       	push	r17
     4c4:	cf 93       	push	r28
     4c6:	df 93       	push	r29
     4c8:	8d e0       	ldi	r24, 0x0D	; 13
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     4ca:	8f 93       	push	r24
     4cc:	88 24       	eor	r8, r8
     4ce:	83 94       	inc	r8
     4d0:	92 e1       	ldi	r25, 0x12	; 18
     4d2:	e9 2e       	mov	r14, r25
     4d4:	01 e0       	ldi	r16, 0x01	; 1
     4d6:	21 e0       	ldi	r18, 0x01	; 1
     4d8:	4f e0       	ldi	r20, 0x0F	; 15
     4da:	60 e1       	ldi	r22, 0x10	; 16
     4dc:	80 e1       	ldi	r24, 0x10	; 16
     4de:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4e2:	1f 92       	push	r1
     4e4:	1f 93       	push	r17
     4e6:	cf 93       	push	r28
     4e8:	df 93       	push	r29
     4ea:	25 e0       	ldi	r18, 0x05	; 5
     4ec:	62 2e       	mov	r6, r18
     4ee:	6f 92       	push	r6
     4f0:	3c e1       	ldi	r19, 0x1C	; 28
     4f2:	e3 2e       	mov	r14, r19
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	4f ef       	ldi	r20, 0xFF	; 255
     4f8:	61 e1       	ldi	r22, 0x11	; 17
     4fa:	81 e1       	ldi	r24, 0x11	; 17
     4fc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     500:	1f 92       	push	r1
     502:	1f 93       	push	r17
     504:	cf 93       	push	r28
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     506:	df 93       	push	r29
     508:	cf 93       	push	r28
     50a:	42 e0       	ldi	r20, 0x02	; 2
     50c:	84 2e       	mov	r8, r20
     50e:	5f e0       	ldi	r21, 0x0F	; 15
     510:	e5 2e       	mov	r14, r21
     512:	02 e0       	ldi	r16, 0x02	; 2
     514:	20 e0       	ldi	r18, 0x00	; 0
     516:	4f ef       	ldi	r20, 0xFF	; 255
     518:	62 e1       	ldi	r22, 0x12	; 18
     51a:	82 e1       	ldi	r24, 0x12	; 18
     51c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     520:	1f 92       	push	r1
     522:	1f 93       	push	r17
     524:	cf 93       	push	r28
     526:	df 93       	push	r29
     528:	82 e1       	ldi	r24, 0x12	; 18
     52a:	8f 93       	push	r24
     52c:	61 e1       	ldi	r22, 0x11	; 17
     52e:	e6 2e       	mov	r14, r22
     530:	20 e0       	ldi	r18, 0x00	; 0
     532:	4f ef       	ldi	r20, 0xFF	; 255
     534:	63 e1       	ldi	r22, 0x13	; 19
     536:	83 e1       	ldi	r24, 0x13	; 19
     538:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     53c:	7f 92       	push	r7
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     53e:	ff 92       	push	r15
     540:	cf 93       	push	r28
     542:	df 93       	push	r29
     544:	ff 92       	push	r15
     546:	81 2c       	mov	r8, r1
     548:	ee 24       	eor	r14, r14
     54a:	e3 94       	inc	r14
     54c:	00 e0       	ldi	r16, 0x00	; 0
     54e:	21 e0       	ldi	r18, 0x01	; 1
     550:	4f ef       	ldi	r20, 0xFF	; 255
     552:	64 e1       	ldi	r22, 0x14	; 20
     554:	84 e1       	ldi	r24, 0x14	; 20
     556:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     55a:	8d b7       	in	r24, 0x3d	; 61
     55c:	9e b7       	in	r25, 0x3e	; 62
     55e:	83 96       	adiw	r24, 0x23	; 35
     560:	0f b6       	in	r0, 0x3f	; 63
     562:	f8 94       	cli
     564:	9e bf       	out	0x3e, r25	; 62
     566:	0f be       	out	0x3f, r0	; 63
     568:	8d bf       	out	0x3d, r24	; 61
     56a:	8b e0       	ldi	r24, 0x0B	; 11
     56c:	8f 93       	push	r24
     56e:	ff 92       	push	r15
     570:	cf 93       	push	r28
     572:	df 93       	push	r29
     574:	7e e1       	ldi	r23, 0x1E	; 30
     576:	77 2e       	mov	r7, r23
     578:	7f 92       	push	r7
     57a:	e2 e0       	ldi	r30, 0x02	; 2
     57c:	8e 2e       	mov	r8, r30
     57e:	f4 e1       	ldi	r31, 0x14	; 20
     580:	ef 2e       	mov	r14, r31
     582:	02 e0       	ldi	r16, 0x02	; 2
     584:	21 e0       	ldi	r18, 0x01	; 1
     586:	4f ef       	ldi	r20, 0xFF	; 255
     588:	65 e1       	ldi	r22, 0x15	; 21
     58a:	85 e1       	ldi	r24, 0x15	; 21
     58c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     590:	1f 92       	push	r1
     592:	1f 93       	push	r17
     594:	cf 93       	push	r28
     596:	df 93       	push	r29
     598:	1f 93       	push	r17
     59a:	81 2c       	mov	r8, r1
     59c:	a7 e0       	ldi	r26, 0x07	; 7
     59e:	ea 2e       	mov	r14, r26
     5a0:	00 e0       	ldi	r16, 0x00	; 0
     5a2:	21 e0       	ldi	r18, 0x01	; 1
     5a4:	4f ef       	ldi	r20, 0xFF	; 255
     5a6:	66 e1       	ldi	r22, 0x16	; 22
     5a8:	86 e1       	ldi	r24, 0x16	; 22
     5aa:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     5ae:	1f 92       	push	r1
     5b0:	ff 92       	push	r15
     5b2:	cf 93       	push	r28
     5b4:	df 93       	push	r29
     5b6:	84 e1       	ldi	r24, 0x14	; 20
     5b8:	8f 93       	push	r24
     5ba:	b2 e1       	ldi	r27, 0x12	; 18
     5bc:	eb 2e       	mov	r14, r27
     5be:	21 e0       	ldi	r18, 0x01	; 1
     5c0:	4f ef       	ldi	r20, 0xFF	; 255
     5c2:	67 e1       	ldi	r22, 0x17	; 23
     5c4:	87 e1       	ldi	r24, 0x17	; 23
     5c6:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     5ca:	bf 92       	push	r11
     5cc:	ff 92       	push	r15
     5ce:	cf 93       	push	r28
     5d0:	df 93       	push	r29
     5d2:	85 e1       	ldi	r24, 0x15	; 21
     5d4:	8f 93       	push	r24
     5d6:	83 e1       	ldi	r24, 0x13	; 19
     5d8:	e8 2e       	mov	r14, r24
     5da:	21 e0       	ldi	r18, 0x01	; 1
     5dc:	4f ef       	ldi	r20, 0xFF	; 255
     5de:	68 e1       	ldi	r22, 0x18	; 24
     5e0:	88 e1       	ldi	r24, 0x18	; 24
     5e2:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     5e6:	ff 92       	push	r15
     5e8:	ff 92       	push	r15
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     5ee:	86 e1       	ldi	r24, 0x16	; 22
     5f0:	8f 93       	push	r24
     5f2:	9a e0       	ldi	r25, 0x0A	; 10
     5f4:	e9 2e       	mov	r14, r25
     5f6:	21 e0       	ldi	r18, 0x01	; 1
     5f8:	4f ef       	ldi	r20, 0xFF	; 255
     5fa:	69 e1       	ldi	r22, 0x19	; 25
     5fc:	89 e1       	ldi	r24, 0x19	; 25
     5fe:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     602:	1f 93       	push	r17
     604:	ff 92       	push	r15
     606:	cf 93       	push	r28
     608:	df 93       	push	r29
     60a:	87 e1       	ldi	r24, 0x17	; 23
     60c:	8f 93       	push	r24
     60e:	2f e0       	ldi	r18, 0x0F	; 15
     610:	e2 2e       	mov	r14, r18
     612:	21 e0       	ldi	r18, 0x01	; 1
     614:	4f ef       	ldi	r20, 0xFF	; 255
     616:	6a e1       	ldi	r22, 0x1A	; 26
     618:	8a e1       	ldi	r24, 0x1A	; 26
     61a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     61e:	5f 92       	push	r5
     620:	ff 92       	push	r15
     622:	cf 93       	push	r28
     624:	df 93       	push	r29
     626:	88 e1       	ldi	r24, 0x18	; 24
     628:	8f 93       	push	r24
     62a:	39 e0       	ldi	r19, 0x09	; 9
     62c:	e3 2e       	mov	r14, r19
     62e:	21 e0       	ldi	r18, 0x01	; 1
     630:	4f ef       	ldi	r20, 0xFF	; 255
     632:	6b e1       	ldi	r22, 0x1B	; 27
     634:	8b e1       	ldi	r24, 0x1B	; 27
     636:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     63a:	8d b7       	in	r24, 0x3d	; 61
     63c:	9e b7       	in	r25, 0x3e	; 62
     63e:	83 96       	adiw	r24, 0x23	; 35
     640:	0f b6       	in	r0, 0x3f	; 63
     642:	f8 94       	cli
     644:	9e bf       	out	0x3e, r25	; 62
     646:	0f be       	out	0x3f, r0	; 63
     648:	8d bf       	out	0x3d, r24	; 61
     64a:	1f 92       	push	r1
     64c:	1f 93       	push	r17
     64e:	cf 93       	push	r28
     650:	df 93       	push	r29
     652:	89 e1       	ldi	r24, 0x19	; 25
     654:	8f 93       	push	r24
     656:	4e e0       	ldi	r20, 0x0E	; 14
     658:	e4 2e       	mov	r14, r20
     65a:	21 e0       	ldi	r18, 0x01	; 1
     65c:	4f ef       	ldi	r20, 0xFF	; 255
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     65e:	6c e1       	ldi	r22, 0x1C	; 28
     660:	8c e1       	ldi	r24, 0x1C	; 28
     662:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     666:	1f 92       	push	r1
     668:	1f 93       	push	r17
     66a:	cf 93       	push	r28
     66c:	df 93       	push	r29
     66e:	8a e1       	ldi	r24, 0x1A	; 26
     670:	8f 93       	push	r24
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     672:	50 e1       	ldi	r21, 0x10	; 16
     674:	e5 2e       	mov	r14, r21
     676:	21 e0       	ldi	r18, 0x01	; 1
     678:	4f ef       	ldi	r20, 0xFF	; 255
     67a:	6d e1       	ldi	r22, 0x1D	; 29
     67c:	8d e1       	ldi	r24, 0x1D	; 29
     67e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     682:	1f 92       	push	r1
     684:	1f 93       	push	r17
     686:	cf 93       	push	r28
     688:	df 93       	push	r29
     68a:	8b e1       	ldi	r24, 0x1B	; 27
     68c:	8f 93       	push	r24
     68e:	68 e0       	ldi	r22, 0x08	; 8
     690:	e6 2e       	mov	r14, r22
     692:	21 e0       	ldi	r18, 0x01	; 1
     694:	4f ef       	ldi	r20, 0xFF	; 255
     696:	6e e1       	ldi	r22, 0x1E	; 30
     698:	8e e1       	ldi	r24, 0x1E	; 30
     69a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     69e:	6f 92       	push	r6
     6a0:	ff 92       	push	r15
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6a2:	cf 93       	push	r28
     6a4:	df 93       	push	r29
     6a6:	8c e1       	ldi	r24, 0x1C	; 28
     6a8:	8f 93       	push	r24
     6aa:	7d e0       	ldi	r23, 0x0D	; 13
     6ac:	e7 2e       	mov	r14, r23
     6ae:	21 e0       	ldi	r18, 0x01	; 1
     6b0:	4f ef       	ldi	r20, 0xFF	; 255
     6b2:	6f e1       	ldi	r22, 0x1F	; 31
     6b4:	8f e1       	ldi	r24, 0x1F	; 31
     6b6:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6ba:	1f 92       	push	r1
     6bc:	1f 93       	push	r17
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     6c2:	8d e1       	ldi	r24, 0x1D	; 29
     6c4:	8f 93       	push	r24
     6c6:	ec e0       	ldi	r30, 0x0C	; 12
     6c8:	ee 2e       	mov	r14, r30
     6ca:	21 e0       	ldi	r18, 0x01	; 1
     6cc:	4f ef       	ldi	r20, 0xFF	; 255
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6ce:	60 e2       	ldi	r22, 0x20	; 32
     6d0:	80 e2       	ldi	r24, 0x20	; 32
     6d2:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6d6:	1f 92       	push	r1
     6d8:	1f 93       	push	r17
     6da:	cf 93       	push	r28
     6dc:	df 93       	push	r29
     6de:	7f 92       	push	r7
     6e0:	fb e0       	ldi	r31, 0x0B	; 11
     6e2:	ef 2e       	mov	r14, r31
     6e4:	21 e0       	ldi	r18, 0x01	; 1
     6e6:	4f ef       	ldi	r20, 0xFF	; 255
     6e8:	61 e2       	ldi	r22, 0x21	; 33
     6ea:	81 e2       	ldi	r24, 0x21	; 33
     6ec:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6f0:	1f 92       	push	r1
     6f2:	1f 93       	push	r17
     6f4:	cf 93       	push	r28
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     6f6:	df 93       	push	r29
     6f8:	9f 92       	push	r9
     6fa:	a1 e1       	ldi	r26, 0x11	; 17
     6fc:	ea 2e       	mov	r14, r26
     6fe:	21 e0       	ldi	r18, 0x01	; 1
     700:	4f ef       	ldi	r20, 0xFF	; 255
     702:	62 e2       	ldi	r22, 0x22	; 34
     704:	82 e2       	ldi	r24, 0x22	; 34
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
	}
  	percent = 100*(1 - batt_time/discharge_max_time);
     706:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     70a:	8d b7       	in	r24, 0x3d	; 61
     70c:	9e b7       	in	r25, 0x3e	; 62
     70e:	83 96       	adiw	r24, 0x23	; 35
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	f8 94       	cli
     714:	9e bf       	out	0x3e, r25	; 62
     716:	0f be       	out	0x3f, r0	; 63
     718:	8d bf       	out	0x3d, r24	; 61
     71a:	df 92       	push	r13
     71c:	ff 92       	push	r15
     71e:	cf 93       	push	r28
     720:	df 93       	push	r29
     722:	1f 92       	push	r1
     724:	b5 e0       	ldi	r27, 0x05	; 5
     726:	eb 2e       	mov	r14, r27
     728:	21 e0       	ldi	r18, 0x01	; 1
     72a:	4f ef       	ldi	r20, 0xFF	; 255
     72c:	63 e2       	ldi	r22, 0x23	; 35
     72e:	83 e2       	ldi	r24, 0x23	; 35
     730:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     734:	0f 90       	pop	r0
     736:	0f 90       	pop	r0
     738:	0f 90       	pop	r0
     73a:	0f 90       	pop	r0
  }
  else 
  {
    float temp_real = 0;
    if (real < 13.35)
     73c:	0f 90       	pop	r0
     73e:	df 91       	pop	r29
     740:	cf 91       	pop	r28
     742:	1f 91       	pop	r17
     744:	0f 91       	pop	r16
     746:	ff 90       	pop	r15
     748:	ef 90       	pop	r14
     74a:	df 90       	pop	r13
     74c:	cf 90       	pop	r12
     74e:	bf 90       	pop	r11
	{
	  debug = 0x0C;
     750:	af 90       	pop	r10
     752:	9f 90       	pop	r9
     754:	8f 90       	pop	r8
	  // voltage is normalized by mean 13.13 and std 0.1754 (real - 13.13)/0.1754
	  temp_real = (real - 13.13)*5.701254;
     756:	7f 90       	pop	r7
     758:	6f 90       	pop	r6
     75a:	5f 90       	pop	r5
     75c:	08 95       	ret

0000075e <receive_message>:
     75e:	ff 92       	push	r15
     760:	0f 93       	push	r16
     762:	1f 93       	push	r17
     764:	cf 93       	push	r28
     766:	df 93       	push	r29
     768:	f8 2e       	mov	r15, r24
     76a:	fb 01       	movw	r30, r22
     76c:	c1 81       	ldd	r28, Z+1	; 0x01
     76e:	90 81       	ld	r25, Z
     770:	93 30       	cpi	r25, 0x03	; 3
     772:	09 f4       	brne	.+2      	; 0x776 <receive_message+0x18>
     774:	5a c0       	rjmp	.+180    	; 0x82a <receive_message+0xcc>
	  batt_time = p1*pow(temp_real,3) + p2*pow(temp_real,2) + p3*temp_real + p4;
     776:	30 f4       	brcc	.+12     	; 0x784 <receive_message+0x26>
     778:	0c 2f       	mov	r16, r28
     77a:	10 e0       	ldi	r17, 0x00	; 0
     77c:	91 30       	cpi	r25, 0x01	; 1
     77e:	11 f1       	breq	.+68     	; 0x7c4 <receive_message+0x66>
     780:	90 f5       	brcc	.+100    	; 0x7e6 <receive_message+0x88>
     782:	0c c0       	rjmp	.+24     	; 0x79c <receive_message+0x3e>
     784:	95 30       	cpi	r25, 0x05	; 5
     786:	09 f4       	brne	.+2      	; 0x78a <receive_message+0x2c>
     788:	55 c0       	rjmp	.+170    	; 0x834 <receive_message+0xd6>
     78a:	08 f4       	brcc	.+2      	; 0x78e <receive_message+0x30>
     78c:	50 c0       	rjmp	.+160    	; 0x82e <receive_message+0xd0>
     78e:	96 30       	cpi	r25, 0x06	; 6
     790:	09 f4       	brne	.+2      	; 0x794 <receive_message+0x36>
     792:	60 c0       	rjmp	.+192    	; 0x854 <receive_message+0xf6>
     794:	97 30       	cpi	r25, 0x07	; 7
     796:	09 f0       	breq	.+2      	; 0x79a <receive_message+0x3c>
     798:	7b c0       	rjmp	.+246    	; 0x890 <receive_message+0x132>
     79a:	6b c0       	rjmp	.+214    	; 0x872 <receive_message+0x114>
     79c:	8c e2       	ldi	r24, 0x2C	; 44
     79e:	80 93 9d 0d 	sts	0x0D9D, r24
     7a2:	8c e1       	ldi	r24, 0x1C	; 28
     7a4:	80 9f       	mul	r24, r16
     7a6:	e0 01       	movw	r28, r0
     7a8:	81 9f       	mul	r24, r17
     7aa:	d0 0d       	add	r29, r0
     7ac:	11 24       	eor	r1, r1
     7ae:	c8 5c       	subi	r28, 0xC8	; 200
     7b0:	dc 4f       	sbci	r29, 0xFC	; 252
     7b2:	89 81       	ldd	r24, Y+1	; 0x01
     7b4:	8f 3f       	cpi	r24, 0xFF	; 255
     7b6:	21 f0       	breq	.+8      	; 0x7c0 <receive_message+0x62>
     7b8:	0e 94 ff 08 	call	0x11fe	; 0x11fe <switch_on>
     7bc:	81 e0       	ldi	r24, 0x01	; 1
     7be:	8a 83       	std	Y+2, r24	; 0x02
     7c0:	40 e0       	ldi	r20, 0x00	; 0
     7c2:	0f c0       	rjmp	.+30     	; 0x7e2 <receive_message+0x84>
     7c4:	8c e1       	ldi	r24, 0x1C	; 28
     7c6:	80 9f       	mul	r24, r16
     7c8:	e0 01       	movw	r28, r0
     7ca:	81 9f       	mul	r24, r17
     7cc:	d0 0d       	add	r29, r0
     7ce:	11 24       	eor	r1, r1
     7d0:	c8 5c       	subi	r28, 0xC8	; 200
     7d2:	dc 4f       	sbci	r29, 0xFC	; 252
     7d4:	89 81       	ldd	r24, Y+1	; 0x01
     7d6:	8f 3f       	cpi	r24, 0xFF	; 255
     7d8:	19 f0       	breq	.+6      	; 0x7e0 <receive_message+0x82>
     7da:	0e 94 42 09 	call	0x1284	; 0x1284 <switch_off>
     7de:	1a 82       	std	Y+2, r1	; 0x02
     7e0:	41 e0       	ldi	r20, 0x01	; 1
     7e2:	62 e0       	ldi	r22, 0x02	; 2
     7e4:	57 c0       	rjmp	.+174    	; 0x894 <receive_message+0x136>
     7e6:	8c e1       	ldi	r24, 0x1C	; 28
     7e8:	80 9f       	mul	r24, r16
     7ea:	e0 01       	movw	r28, r0
     7ec:	81 9f       	mul	r24, r17
     7ee:	d0 0d       	add	r29, r0
     7f0:	11 24       	eor	r1, r1
     7f2:	c8 5c       	subi	r28, 0xC8	; 200
     7f4:	dc 4f       	sbci	r29, 0xFC	; 252
     7f6:	89 81       	ldd	r24, Y+1	; 0x01
     7f8:	8f 3f       	cpi	r24, 0xFF	; 255
     7fa:	19 f0       	breq	.+6      	; 0x802 <receive_message+0xa4>
     7fc:	0e 94 42 09 	call	0x1284	; 0x1284 <switch_off>
     800:	1a 82       	std	Y+2, r1	; 0x02
     802:	85 e0       	ldi	r24, 0x05	; 5
     804:	8a 95       	dec	r24
     806:	f1 f7       	brne	.-4      	; 0x804 <receive_message+0xa6>
     808:	8c e1       	ldi	r24, 0x1C	; 28
     80a:	80 9f       	mul	r24, r16
     80c:	e0 01       	movw	r28, r0
     80e:	81 9f       	mul	r24, r17
	}
	else 
	{
	  debug = 0x0D;
     810:	d0 0d       	add	r29, r0
     812:	11 24       	eor	r1, r1
     814:	c8 5c       	subi	r28, 0xC8	; 200
	  // voltage is normalized by mean 13.7 and std 0.1558 (real - 13.7)/0.1558;
	  temp_real = (real - 13.7)*6.418485;
     816:	dc 4f       	sbci	r29, 0xFC	; 252
     818:	89 81       	ldd	r24, Y+1	; 0x01
     81a:	8f 3f       	cpi	r24, 0xFF	; 255
     81c:	21 f0       	breq	.+8      	; 0x826 <receive_message+0xc8>
     81e:	0e 94 ff 08 	call	0x11fe	; 0x11fe <switch_on>
     822:	81 e0       	ldi	r24, 0x01	; 1
     824:	8a 83       	std	Y+2, r24	; 0x02
     826:	42 e0       	ldi	r20, 0x02	; 2
     828:	dc cf       	rjmp	.-72     	; 0x7e2 <receive_message+0x84>
     82a:	43 e0       	ldi	r20, 0x03	; 3
     82c:	da cf       	rjmp	.-76     	; 0x7e2 <receive_message+0x84>
     82e:	40 e0       	ldi	r20, 0x00	; 0
     830:	60 e0       	ldi	r22, 0x00	; 0
     832:	30 c0       	rjmp	.+96     	; 0x894 <receive_message+0x136>
     834:	8c e1       	ldi	r24, 0x1C	; 28
      batt_time = q1*pow(temp_real,3) + q2*pow(temp_real,2) + q3*temp_real + q4;
     836:	c8 9f       	mul	r28, r24
     838:	e0 01       	movw	r28, r0
     83a:	11 24       	eor	r1, r1
     83c:	c8 5c       	subi	r28, 0xC8	; 200
     83e:	dc 4f       	sbci	r29, 0xFC	; 252
     840:	89 81       	ldd	r24, Y+1	; 0x01
     842:	8f 3f       	cpi	r24, 0xFF	; 255
     844:	29 f0       	breq	.+10     	; 0x850 <receive_message+0xf2>
     846:	0e 94 ff 08 	call	0x11fe	; 0x11fe <switch_on>
     84a:	81 e0       	ldi	r24, 0x01	; 1
     84c:	8a 83       	std	Y+2, r24	; 0x02
     84e:	8b 83       	std	Y+3, r24	; 0x03
     850:	45 e0       	ldi	r20, 0x05	; 5
     852:	c7 cf       	rjmp	.-114    	; 0x7e2 <receive_message+0x84>
     854:	8c e1       	ldi	r24, 0x1C	; 28
     856:	c8 9f       	mul	r28, r24
     858:	e0 01       	movw	r28, r0
     85a:	11 24       	eor	r1, r1
     85c:	c8 5c       	subi	r28, 0xC8	; 200
     85e:	dc 4f       	sbci	r29, 0xFC	; 252
     860:	89 81       	ldd	r24, Y+1	; 0x01
     862:	8f 3f       	cpi	r24, 0xFF	; 255
     864:	f9 f0       	breq	.+62     	; 0x8a4 <receive_message+0x146>
     866:	82 81       	ldd	r24, Z+2	; 0x02
     868:	8e 83       	std	Y+6, r24	; 0x06
     86a:	82 81       	ldd	r24, Z+2	; 0x02
     86c:	80 93 7f 0b 	sts	0x0B7F, r24
     870:	19 c0       	rjmp	.+50     	; 0x8a4 <receive_message+0x146>
     872:	8c e1       	ldi	r24, 0x1C	; 28
     874:	c8 9f       	mul	r28, r24
     876:	e0 01       	movw	r28, r0
     878:	11 24       	eor	r1, r1
     87a:	c8 5c       	subi	r28, 0xC8	; 200
     87c:	dc 4f       	sbci	r29, 0xFC	; 252
     87e:	89 81       	ldd	r24, Y+1	; 0x01
     880:	8f 3f       	cpi	r24, 0xFF	; 255
     882:	81 f0       	breq	.+32     	; 0x8a4 <receive_message+0x146>
     884:	82 81       	ldd	r24, Z+2	; 0x02
     886:	8f 87       	std	Y+15, r24	; 0x0f
     888:	82 81       	ldd	r24, Z+2	; 0x02
     88a:	80 93 7a 0b 	sts	0x0B7A, r24
     88e:	0a c0       	rjmp	.+20     	; 0x8a4 <receive_message+0x146>
     890:	40 e0       	ldi	r20, 0x00	; 0
     892:	61 e0       	ldi	r22, 0x01	; 1
     894:	8f 2d       	mov	r24, r15
     896:	df 91       	pop	r29
     898:	cf 91       	pop	r28
     89a:	1f 91       	pop	r17
     89c:	0f 91       	pop	r16
     89e:	ff 90       	pop	r15
     8a0:	0c 94 79 11 	jmp	0x22f2	; 0x22f2 <transmit_packet>
     8a4:	df 91       	pop	r29
     8a6:	cf 91       	pop	r28
     8a8:	1f 91       	pop	r17
     8aa:	0f 91       	pop	r16
     8ac:	ff 90       	pop	r15
     8ae:	08 95       	ret

000008b0 <StateofCharge>:
     8b0:	cf 93       	push	r28
     8b2:	90 91 6f 09 	lds	r25, 0x096F
     8b6:	9f 3f       	cpi	r25, 0xFF	; 255
     8b8:	09 f4       	brne	.+2      	; 0x8bc <StateofCharge+0xc>
     8ba:	c2 c0       	rjmp	.+388    	; 0xa40 <StateofCharge+0x190>
     8bc:	80 91 59 09 	lds	r24, 0x0959
     8c0:	88 23       	and	r24, r24
     8c2:	09 f4       	brne	.+2      	; 0x8c6 <StateofCharge+0x16>
     8c4:	bd c0       	rjmp	.+378    	; 0xa40 <StateofCharge+0x190>
     8c6:	80 91 70 09 	lds	r24, 0x0970
     8ca:	88 23       	and	r24, r24
     8cc:	21 f0       	breq	.+8      	; 0x8d6 <StateofCharge+0x26>
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	80 93 a8 0d 	sts	0x0DA8, r24
     8d4:	02 c0       	rjmp	.+4      	; 0x8da <StateofCharge+0x2a>
     8d6:	10 92 a8 0d 	sts	0x0DA8, r1
     8da:	80 91 a8 0d 	lds	r24, 0x0DA8
     8de:	88 23       	and	r24, r24
     8e0:	19 f0       	breq	.+6      	; 0x8e8 <StateofCharge+0x38>
	}
  	percent = 100*(batt_time/charge_max_time);
     8e2:	9f 37       	cpi	r25, 0x7F	; 127
     8e4:	20 f0       	brcs	.+8      	; 0x8ee <StateofCharge+0x3e>
     8e6:	a0 c0       	rjmp	.+320    	; 0xa28 <StateofCharge+0x178>
     8e8:	98 37       	cpi	r25, 0x78	; 120
     8ea:	08 f0       	brcs	.+2      	; 0x8ee <StateofCharge+0x3e>
     8ec:	9d c0       	rjmp	.+314    	; 0xa28 <StateofCharge+0x178>
     8ee:	95 36       	cpi	r25, 0x65	; 101
     8f0:	08 f4       	brcc	.+2      	; 0x8f4 <StateofCharge+0x44>
     8f2:	95 c0       	rjmp	.+298    	; 0xa1e <StateofCharge+0x16e>
     8f4:	c0 91 06 03 	lds	r28, 0x0306
     8f8:	2c 2f       	mov	r18, r28
     8fa:	2f 5f       	subi	r18, 0xFF	; 255
     8fc:	20 93 06 03 	sts	0x0306, r18
     900:	88 23       	and	r24, r24
     902:	f1 f1       	breq	.+124    	; 0x980 <StateofCharge+0xd0>
     904:	80 91 83 0d 	lds	r24, 0x0D83
     908:	9a 36       	cpi	r25, 0x6A	; 106
     90a:	20 f4       	brcc	.+8      	; 0x914 <StateofCharge+0x64>
     90c:	82 95       	swap	r24
     90e:	86 95       	lsr	r24
     910:	86 95       	lsr	r24
     912:	0b c0       	rjmp	.+22     	; 0x92a <StateofCharge+0x7a>
     914:	29 2f       	mov	r18, r25
     916:	2a 56       	subi	r18, 0x6A	; 106
     918:	82 95       	swap	r24
     91a:	86 95       	lsr	r24
     91c:	86 95       	lsr	r24
     91e:	83 70       	andi	r24, 0x03	; 3
     920:	2a 30       	cpi	r18, 0x0A	; 10
  }
  
  // Percent limiting for periodic function
  if (percent < 1) 
     922:	10 f4       	brcc	.+4      	; 0x928 <StateofCharge+0x78>
     924:	8f 5f       	subi	r24, 0xFF	; 255
     926:	01 c0       	rjmp	.+2      	; 0x92a <StateofCharge+0x7a>
     928:	8e 5f       	subi	r24, 0xFE	; 254
     92a:	83 70       	andi	r24, 0x03	; 3
     92c:	80 93 9b 0d 	sts	0x0D9B, r24
     930:	e9 2f       	mov	r30, r25
     932:	f0 e0       	ldi	r31, 0x00	; 0
     934:	e5 56       	subi	r30, 0x65	; 101
     936:	f1 09       	sbc	r31, r1
     938:	ee 0f       	add	r30, r30
     93a:	ff 1f       	adc	r31, r31
     93c:	ee 0f       	add	r30, r30
     93e:	ff 1f       	adc	r31, r31
     940:	e8 0f       	add	r30, r24
     942:	f1 1d       	adc	r31, r1
     944:	ee 0f       	add	r30, r30
  { 
  	debug2 = 0xA0;
     946:	ff 1f       	adc	r31, r31
     948:	e4 57       	subi	r30, 0x74	; 116
     94a:	ff 4f       	sbci	r31, 0xFF	; 255
  	soc = 0; 
     94c:	65 91       	lpm	r22, Z+
     94e:	74 91       	lpm	r23, Z
     950:	6b 50       	subi	r22, 0x0B	; 11
  }
  else if (percent > 99) 
     952:	71 09       	sbc	r23, r1
     954:	80 e0       	ldi	r24, 0x00	; 0
     956:	90 e0       	ldi	r25, 0x00	; 0
     958:	0e 94 f7 12 	call	0x25ee	; 0x25ee <__floatunsisf>
     95c:	28 eb       	ldi	r18, 0xB8	; 184
     95e:	3e e1       	ldi	r19, 0x1E	; 30
     960:	49 e2       	ldi	r20, 0x29	; 41
     962:	51 e4       	ldi	r21, 0x41	; 65
     964:	0e 94 8f 12 	call	0x251e	; 0x251e <__divsf3>
  { 
  	debug2 = 0xB0;
     968:	60 93 2f 07 	sts	0x072F, r22
  	soc = 255;
     96c:	70 93 30 07 	sts	0x0730, r23
     970:	80 93 31 07 	sts	0x0731, r24
  }
  else { 
  	debug2 = 0xC0;
     974:	90 93 32 07 	sts	0x0732, r25
     978:	c9 5f       	subi	r28, 0xF9	; 249
  	soc = (char)floor((int)(percent)); 
     97a:	c0 93 06 03 	sts	0x0306, r28
     97e:	60 c0       	rjmp	.+192    	; 0xa40 <StateofCharge+0x190>
     980:	9a 36       	cpi	r25, 0x6A	; 106
     982:	30 f4       	brcc	.+12     	; 0x990 <StateofCharge+0xe0>
     984:	80 91 83 0d 	lds	r24, 0x0D83
     988:	82 95       	swap	r24
     98a:	86 95       	lsr	r24
     98c:	86 95       	lsr	r24
     98e:	17 c0       	rjmp	.+46     	; 0x9be <StateofCharge+0x10e>
     990:	89 2f       	mov	r24, r25
     992:	8a 56       	subi	r24, 0x6A	; 106
     994:	8a 30       	cpi	r24, 0x0A	; 10
     996:	40 f4       	brcc	.+16     	; 0x9a8 <StateofCharge+0xf8>
     998:	80 91 83 0d 	lds	r24, 0x0D83
  }
}
     99c:	82 95       	swap	r24
     99e:	86 95       	lsr	r24
     9a0:	86 95       	lsr	r24
     9a2:	83 70       	andi	r24, 0x03	; 3
     9a4:	8f 5f       	subi	r24, 0xFF	; 255
     9a6:	0b c0       	rjmp	.+22     	; 0x9be <StateofCharge+0x10e>
     9a8:	89 2f       	mov	r24, r25
     9aa:	84 57       	subi	r24, 0x74	; 116
     9ac:	83 30       	cpi	r24, 0x03	; 3
     9ae:	48 f4       	brcc	.+18     	; 0x9c2 <StateofCharge+0x112>
     9b0:	80 91 83 0d 	lds	r24, 0x0D83
     9b4:	82 95       	swap	r24
     9b6:	86 95       	lsr	r24
     9b8:	86 95       	lsr	r24
     9ba:	83 70       	andi	r24, 0x03	; 3
     9bc:	8e 5f       	subi	r24, 0xFE	; 254
     9be:	83 70       	andi	r24, 0x03	; 3
     9c0:	01 c0       	rjmp	.+2      	; 0x9c4 <StateofCharge+0x114>
     9c2:	80 e0       	ldi	r24, 0x00	; 0
				percent = (charge20Pc[(batt1_voltage - 0x65)*4 + ltOffset] - 11) / (10.57);
				antioptimizer+=6;
				
			}else{
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     9c4:	80 93 9b 0d 	sts	0x0D9B, r24
							((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
							((batt1_voltage >= 0x74) && (batt1_voltage <= 0x76)) ? (((batt1_voltageLow >> 6) + 2) % 0x04) :
							0x00;
				
				percent = 100 - ((discharge20Pc[(0x77 - batt1_voltage)*4 - ltOffset]) ) / (10.07);
     9c8:	e7 e7       	ldi	r30, 0x77	; 119
     9ca:	f0 e0       	ldi	r31, 0x00	; 0
     9cc:	e9 1b       	sub	r30, r25
     9ce:	f1 09       	sbc	r31, r1
     9d0:	ee 0f       	add	r30, r30
     9d2:	ff 1f       	adc	r31, r31
     9d4:	ee 0f       	add	r30, r30
     9d6:	ff 1f       	adc	r31, r31
     9d8:	e8 1b       	sub	r30, r24
     9da:	f1 09       	sbc	r31, r1
     9dc:	ee 0f       	add	r30, r30
     9de:	ff 1f       	adc	r31, r31
     9e0:	e8 59       	subi	r30, 0x98	; 152
     9e2:	fe 4f       	sbci	r31, 0xFE	; 254
     9e4:	65 91       	lpm	r22, Z+
     9e6:	74 91       	lpm	r23, Z
     9e8:	80 e0       	ldi	r24, 0x00	; 0
     9ea:	90 e0       	ldi	r25, 0x00	; 0
     9ec:	0e 94 f7 12 	call	0x25ee	; 0x25ee <__floatunsisf>
     9f0:	28 eb       	ldi	r18, 0xB8	; 184
     9f2:	3e e1       	ldi	r19, 0x1E	; 30
     9f4:	41 e2       	ldi	r20, 0x21	; 33
     9f6:	51 e4       	ldi	r21, 0x41	; 65
     9f8:	0e 94 8f 12 	call	0x251e	; 0x251e <__divsf3>
     9fc:	9b 01       	movw	r18, r22
     9fe:	ac 01       	movw	r20, r24
     a00:	60 e0       	ldi	r22, 0x00	; 0
     a02:	70 e0       	ldi	r23, 0x00	; 0
     a04:	88 ec       	ldi	r24, 0xC8	; 200
     a06:	92 e4       	ldi	r25, 0x42	; 66
     a08:	0e 94 26 12 	call	0x244c	; 0x244c <__subsf3>
     a0c:	60 93 2f 07 	sts	0x072F, r22
     a10:	70 93 30 07 	sts	0x0730, r23
     a14:	80 93 31 07 	sts	0x0731, r24
     a18:	90 93 32 07 	sts	0x0732, r25
     a1c:	11 c0       	rjmp	.+34     	; 0xa40 <StateofCharge+0x190>
			}
		}else if(batt1_voltage <= 0x64){
			percent = -1;
     a1e:	80 e0       	ldi	r24, 0x00	; 0
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	a0 e8       	ldi	r26, 0x80	; 128
     a24:	bf eb       	ldi	r27, 0xBF	; 191
     a26:	04 c0       	rjmp	.+8      	; 0xa30 <StateofCharge+0x180>
		}else if(  ((batt1_voltage > 0x7E)&&isCharging) || ((!isCharging)&&(batt1_voltage > 0x77)) ){
			percent = 108;
     a28:	80 e0       	ldi	r24, 0x00	; 0
     a2a:	90 e0       	ldi	r25, 0x00	; 0
     a2c:	a8 ed       	ldi	r26, 0xD8	; 216
     a2e:	b2 e4       	ldi	r27, 0x42	; 66
     a30:	80 93 2f 07 	sts	0x072F, r24
     a34:	90 93 30 07 	sts	0x0730, r25
     a38:	a0 93 31 07 	sts	0x0731, r26
     a3c:	b0 93 32 07 	sts	0x0732, r27
		}
	}
	
	if(solar1_current < 0xFF && solar1_current > 0x00){
     a40:	80 91 70 09 	lds	r24, 0x0970
     a44:	81 50       	subi	r24, 0x01	; 1
     a46:	8e 3f       	cpi	r24, 0xFE	; 254
     a48:	28 f4       	brcc	.+10     	; 0xa54 <StateofCharge+0x1a4>
		antioptimizer++;
     a4a:	80 91 06 03 	lds	r24, 0x0306
     a4e:	8f 5f       	subi	r24, 0xFF	; 255
     a50:	80 93 06 03 	sts	0x0306, r24
	}
	
	
}
     a54:	cf 91       	pop	r28
     a56:	08 95       	ret

00000a58 <assign_charge_fit>:



/* Assigns values to the Fourier coefficients of the charge approximation */
void assign_charge_fit( void ) {
  charge_max_time = 10188;
     a58:	80 e0       	ldi	r24, 0x00	; 0
     a5a:	90 e3       	ldi	r25, 0x30	; 48
     a5c:	af e1       	ldi	r26, 0x1F	; 31
     a5e:	b6 e4       	ldi	r27, 0x46	; 70
     a60:	80 93 76 09 	sts	0x0976, r24
     a64:	90 93 77 09 	sts	0x0977, r25
     a68:	a0 93 78 09 	sts	0x0978, r26
     a6c:	b0 93 79 09 	sts	0x0979, r27
  // x is normalized by mean 13.13 and std 0.1754
  p1 = 18.57;
     a70:	8c e5       	ldi	r24, 0x5C	; 92
     a72:	9f e8       	ldi	r25, 0x8F	; 143
     a74:	a4 e9       	ldi	r26, 0x94	; 148
     a76:	b1 e4       	ldi	r27, 0x41	; 65
     a78:	80 93 48 09 	sts	0x0948, r24
     a7c:	90 93 49 09 	sts	0x0949, r25
     a80:	a0 93 4a 09 	sts	0x094A, r26
     a84:	b0 93 4b 09 	sts	0x094B, r27
  p2 = 184.8;
     a88:	8d ec       	ldi	r24, 0xCD	; 205
     a8a:	9c ec       	ldi	r25, 0xCC	; 204
     a8c:	a8 e3       	ldi	r26, 0x38	; 56
     a8e:	b3 e4       	ldi	r27, 0x43	; 67
     a90:	80 93 25 03 	sts	0x0325, r24
     a94:	90 93 26 03 	sts	0x0326, r25
     a98:	a0 93 27 03 	sts	0x0327, r26
     a9c:	b0 93 28 03 	sts	0x0328, r27
  p3 = 663.6;
     aa0:	86 e6       	ldi	r24, 0x66	; 102
     aa2:	96 ee       	ldi	r25, 0xE6	; 230
     aa4:	a5 e2       	ldi	r26, 0x25	; 37
     aa6:	b4 e4       	ldi	r27, 0x44	; 68
     aa8:	80 93 8f 0d 	sts	0x0D8F, r24
     aac:	90 93 90 0d 	sts	0x0D90, r25
     ab0:	a0 93 91 0d 	sts	0x0D91, r26
     ab4:	b0 93 92 0d 	sts	0x0D92, r27
  p4 = 838.6;
     ab8:	86 e6       	ldi	r24, 0x66	; 102
     aba:	96 ea       	ldi	r25, 0xA6	; 166
     abc:	a1 e5       	ldi	r26, 0x51	; 81
     abe:	b4 e4       	ldi	r27, 0x44	; 68
     ac0:	80 93 ab 0d 	sts	0x0DAB, r24
     ac4:	90 93 ac 0d 	sts	0x0DAC, r25
     ac8:	a0 93 ad 0d 	sts	0x0DAD, r26
     acc:	b0 93 ae 0d 	sts	0x0DAE, r27
  //where x is normalized by mean 13.7 and std 0.1558
  q1 = 78.49;
     ad0:	81 ee       	ldi	r24, 0xE1	; 225
     ad2:	9a ef       	ldi	r25, 0xFA	; 250
     ad4:	ac e9       	ldi	r26, 0x9C	; 156
     ad6:	b2 e4       	ldi	r27, 0x42	; 66
     ad8:	80 93 6a 09 	sts	0x096A, r24
     adc:	90 93 6b 09 	sts	0x096B, r25
     ae0:	a0 93 6c 09 	sts	0x096C, r26
     ae4:	b0 93 6d 09 	sts	0x096D, r27
  q2 = 543.1;
     ae8:	86 e6       	ldi	r24, 0x66	; 102
     aea:	96 ec       	ldi	r25, 0xC6	; 198
     aec:	a7 e0       	ldi	r26, 0x07	; 7
     aee:	b4 e4       	ldi	r27, 0x44	; 68
     af0:	80 93 28 07 	sts	0x0728, r24
     af4:	90 93 29 07 	sts	0x0729, r25
     af8:	a0 93 2a 07 	sts	0x072A, r26
     afc:	b0 93 2b 07 	sts	0x072B, r27
  q3 = 2427;
     b00:	80 e0       	ldi	r24, 0x00	; 0
     b02:	90 eb       	ldi	r25, 0xB0	; 176
     b04:	a7 e1       	ldi	r26, 0x17	; 23
     b06:	b5 e4       	ldi	r27, 0x45	; 69
     b08:	80 93 66 09 	sts	0x0966, r24
     b0c:	90 93 67 09 	sts	0x0967, r25
     b10:	a0 93 68 09 	sts	0x0968, r26
     b14:	b0 93 69 09 	sts	0x0969, r27
  q4 = 5587;
     b18:	80 e0       	ldi	r24, 0x00	; 0
     b1a:	98 e9       	ldi	r25, 0x98	; 152
     b1c:	ae ea       	ldi	r26, 0xAE	; 174
     b1e:	b5 e4       	ldi	r27, 0x45	; 69
     b20:	80 93 a0 0d 	sts	0x0DA0, r24
     b24:	90 93 a1 0d 	sts	0x0DA1, r25
     b28:	a0 93 a2 0d 	sts	0x0DA2, r26
     b2c:	b0 93 a3 0d 	sts	0x0DA3, r27
     b30:	08 95       	ret

00000b32 <assign_discharge_fit>:
}

/* Assigns values to the Fourier coefficients of the discharge approximation */

void assign_discharge_fit( void ) {
  discharge_max_time = 17547;
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	96 e1       	ldi	r25, 0x16	; 22
     b36:	a9 e8       	ldi	r26, 0x89	; 137
     b38:	b6 e4       	ldi	r27, 0x46	; 70
     b3a:	80 93 3d 07 	sts	0x073D, r24
     b3e:	90 93 3e 07 	sts	0x073E, r25
     b42:	a0 93 3f 07 	sts	0x073F, r26
     b46:	b0 93 40 07 	sts	0x0740, r27
  f0 = -1.543291233254410E4;
     b4a:	88 eb       	ldi	r24, 0xB8	; 184
     b4c:	93 ec       	ldi	r25, 0xC3	; 195
     b4e:	90 93 8c 0d 	sts	0x0D8C, r25
     b52:	80 93 8b 0d 	sts	0x0D8B, r24
  f1 = -1.819810644993805E4;
     b56:	8a ee       	ldi	r24, 0xEA	; 234
     b58:	98 eb       	ldi	r25, 0xB8	; 184
     b5a:	90 93 96 0d 	sts	0x0D96, r25
     b5e:	80 93 95 0d 	sts	0x0D95, r24
  b1 = -2.548949173344369E4;
     b62:	8f e6       	ldi	r24, 0x6F	; 111
     b64:	9c e9       	ldi	r25, 0x9C	; 156
     b66:	90 93 2d 07 	sts	0x072D, r25
     b6a:	80 93 2c 07 	sts	0x072C, r24
  f2 = 1.141365113433748E4;
     b6e:	85 e9       	ldi	r24, 0x95	; 149
     b70:	9c e2       	ldi	r25, 0x2C	; 44
     b72:	90 93 5f 09 	sts	0x095F, r25
     b76:	80 93 5e 09 	sts	0x095E, r24
  b2 = -2.190399298389397E4;
     b7a:	81 e7       	ldi	r24, 0x71	; 113
     b7c:	9a ea       	ldi	r25, 0xAA	; 170
     b7e:	90 93 23 03 	sts	0x0323, r25
     b82:	80 93 22 03 	sts	0x0322, r24
  f3 = 1.453849538420288E4;
     b86:	8a ec       	ldi	r24, 0xCA	; 202
     b88:	98 e3       	ldi	r25, 0x38	; 56
     b8a:	90 93 53 09 	sts	0x0953, r25
     b8e:	80 93 52 09 	sts	0x0952, r24
  b3 = 7.700208204268025E2;
     b92:	82 e0       	ldi	r24, 0x02	; 2
     b94:	93 e0       	ldi	r25, 0x03	; 3
     b96:	90 93 8e 0d 	sts	0x0D8E, r25
     b9a:	80 93 8d 0d 	sts	0x0D8D, r24
  f4 = 1.965482651710955E3;
     b9e:	8d ea       	ldi	r24, 0xAD	; 173
     ba0:	97 e0       	ldi	r25, 0x07	; 7
     ba2:	90 93 94 0d 	sts	0x0D94, r25
     ba6:	80 93 93 0d 	sts	0x0D93, r24
  b4 = 5.504490550919407E3;
     baa:	80 e8       	ldi	r24, 0x80	; 128
     bac:	95 e1       	ldi	r25, 0x15	; 21
     bae:	90 93 47 07 	sts	0x0747, r25
     bb2:	80 93 46 07 	sts	0x0746, r24
  f5 = -9.466488439471518E2;
     bb6:	8e e4       	ldi	r24, 0x4E	; 78
     bb8:	9c ef       	ldi	r25, 0xFC	; 252
     bba:	90 93 45 07 	sts	0x0745, r25
     bbe:	80 93 44 07 	sts	0x0744, r24
  b5 = 8.270458368650347E2;
     bc2:	8b e3       	ldi	r24, 0x3B	; 59
     bc4:	93 e0       	ldi	r25, 0x03	; 3
     bc6:	90 93 8a 0d 	sts	0x0D8A, r25
     bca:	80 93 89 0d 	sts	0x0D89, r24
  w = 2.725333178515558;
     bce:	8c ed       	ldi	r24, 0xDC	; 220
     bd0:	9b e6       	ldi	r25, 0x6B	; 107
     bd2:	ae e2       	ldi	r26, 0x2E	; 46
     bd4:	b0 e4       	ldi	r27, 0x40	; 64
     bd6:	80 93 33 07 	sts	0x0733, r24
     bda:	90 93 34 07 	sts	0x0734, r25
     bde:	a0 93 35 07 	sts	0x0735, r26
     be2:	b0 93 36 07 	sts	0x0736, r27
  
  h0 = 2.979485572689352E8;
     be6:	80 e8       	ldi	r24, 0x80	; 128
     be8:	95 e5       	ldi	r25, 0x55	; 85
     bea:	a2 ec       	ldi	r26, 0xC2	; 194
     bec:	b1 e1       	ldi	r27, 0x11	; 17
     bee:	80 93 5a 09 	sts	0x095A, r24
     bf2:	90 93 5b 09 	sts	0x095B, r25
     bf6:	a0 93 5c 09 	sts	0x095C, r26
     bfa:	b0 93 5d 09 	sts	0x095D, r27
  h1 = 2.088787459098652E8;
     bfe:	80 ea       	ldi	r24, 0xA0	; 160
     c00:	9c e3       	ldi	r25, 0x3C	; 60
     c02:	a3 e7       	ldi	r26, 0x73	; 115
     c04:	bc e0       	ldi	r27, 0x0C	; 12
     c06:	80 93 2d 03 	sts	0x032D, r24
     c0a:	90 93 2e 03 	sts	0x032E, r25
     c0e:	a0 93 2f 03 	sts	0x032F, r26
     c12:	b0 93 30 03 	sts	0x0330, r27
  g1 = 4.359717315569648E8;
     c16:	80 ea       	ldi	r24, 0xA0	; 160
     c18:	96 e6       	ldi	r25, 0x66	; 102
     c1a:	ac ef       	ldi	r26, 0xFC	; 252
     c1c:	b9 e1       	ldi	r27, 0x19	; 25
     c1e:	80 93 32 03 	sts	0x0332, r24
     c22:	90 93 33 03 	sts	0x0333, r25
     c26:	a0 93 34 03 	sts	0x0334, r26
     c2a:	b0 93 35 03 	sts	0x0335, r27
  h2 =  -1.569778955752849E8;
     c2e:	80 e2       	ldi	r24, 0x20	; 32
     c30:	95 eb       	ldi	r25, 0xB5	; 181
     c32:	a4 ea       	ldi	r26, 0xA4	; 164
     c34:	b6 ef       	ldi	r27, 0xF6	; 246
     c36:	80 93 55 09 	sts	0x0955, r24
     c3a:	90 93 56 09 	sts	0x0956, r25
     c3e:	a0 93 57 09 	sts	0x0957, r26
     c42:	b0 93 58 09 	sts	0x0958, r27
  g2 =  1.969854815603661E8;
     c46:	80 e9       	ldi	r24, 0x90	; 144
     c48:	92 ec       	ldi	r25, 0xC2	; 194
     c4a:	ad eb       	ldi	r26, 0xBD	; 189
     c4c:	bb e0       	ldi	r27, 0x0B	; 11
     c4e:	80 93 4d 09 	sts	0x094D, r24
     c52:	90 93 4e 09 	sts	0x094E, r25
     c56:	a0 93 4f 09 	sts	0x094F, r26
     c5a:	b0 93 50 09 	sts	0x0950, r27
  h3 =  -7.513816845838763E7;
     c5e:	88 e8       	ldi	r24, 0x88	; 136
     c60:	9b e7       	ldi	r25, 0x7B	; 123
     c62:	a5 e8       	ldi	r26, 0x85	; 133
     c64:	bb ef       	ldi	r27, 0xFB	; 251
     c66:	80 93 97 0d 	sts	0x0D97, r24
     c6a:	90 93 98 0d 	sts	0x0D98, r25
     c6e:	a0 93 99 0d 	sts	0x0D99, r26
     c72:	b0 93 9a 0d 	sts	0x0D9A, r27
  g3 =  -1.633385950799686E7;
     c76:	8c ed       	ldi	r24, 0xDC	; 220
     c78:	93 ec       	ldi	r25, 0xC3	; 195
     c7a:	a6 e0       	ldi	r26, 0x06	; 6
     c7c:	bf ef       	ldi	r27, 0xFF	; 255
     c7e:	80 93 1e 03 	sts	0x031E, r24
     c82:	90 93 1f 03 	sts	0x031F, r25
     c86:	a0 93 20 03 	sts	0x0320, r26
     c8a:	b0 93 21 03 	sts	0x0321, r27
  h4 =   -2.642581886559125E6;
     c8e:	8a e6       	ldi	r24, 0x6A	; 106
     c90:	9d ea       	ldi	r25, 0xAD	; 173
     c92:	a7 ed       	ldi	r26, 0xD7	; 215
     c94:	bf ef       	ldi	r27, 0xFF	; 255
     c96:	80 93 7f 0d 	sts	0x0D7F, r24
     c9a:	90 93 80 0d 	sts	0x0D80, r25
     c9e:	a0 93 81 0d 	sts	0x0D81, r26
     ca2:	b0 93 82 0d 	sts	0x0D82, r27
  g4 =   -1.016608352073227E7;
     ca6:	8c eb       	ldi	r24, 0xBC	; 188
     ca8:	90 ee       	ldi	r25, 0xE0	; 224
     caa:	a4 e6       	ldi	r26, 0x64	; 100
     cac:	bf ef       	ldi	r27, 0xFF	; 255
     cae:	80 93 09 03 	sts	0x0309, r24
     cb2:	90 93 0a 03 	sts	0x030A, r25
     cb6:	a0 93 0b 03 	sts	0x030B, r26
     cba:	b0 93 0c 03 	sts	0x030C, r27
  w2 =  0.364797662747743;
     cbe:	82 ec       	ldi	r24, 0xC2	; 194
     cc0:	96 ec       	ldi	r25, 0xC6	; 198
     cc2:	aa eb       	ldi	r26, 0xBA	; 186
     cc4:	be e3       	ldi	r27, 0x3E	; 62
     cc6:	80 93 7b 0b 	sts	0x0B7B, r24
     cca:	90 93 7c 0b 	sts	0x0B7C, r25
     cce:	a0 93 7d 0b 	sts	0x0B7D, r26
     cd2:	b0 93 7e 0b 	sts	0x0B7E, r27
     cd6:	08 95       	ret

00000cd8 <initialize>:
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       6     );  // Fake Data
}

void initialize( void )
{
     cd8:	df 92       	push	r13
     cda:	ef 92       	push	r14
     cdc:	ff 92       	push	r15
     cde:	0f 93       	push	r16
     ce0:	1f 93       	push	r17
     ce2:	cf 93       	push	r28
     ce4:	df 93       	push	r29
   // pin initialization
  DDRA  = 0b11111111;
     ce6:	1f ef       	ldi	r17, 0xFF	; 255
     ce8:	1a bb       	out	0x1a, r17	; 26
  PORTA = 0b00000111;
     cea:	87 e0       	ldi	r24, 0x07	; 7
     cec:	8b bb       	out	0x1b, r24	; 27

  DDRB  = 0b11111111;
     cee:	17 bb       	out	0x17, r17	; 23
  PORTB = 0b11100000;
     cf0:	80 ee       	ldi	r24, 0xE0	; 224
     cf2:	88 bb       	out	0x18, r24	; 24

  DDRC  = 0b11111111;
     cf4:	14 bb       	out	0x14, r17	; 20
  PORTC = 0b11111111;
     cf6:	15 bb       	out	0x15, r17	; 21

  DDRD  = 0b11111011;
     cf8:	8b ef       	ldi	r24, 0xFB	; 251
     cfa:	81 bb       	out	0x11, r24	; 17
  PORTD = 0b11110000;
     cfc:	80 ef       	ldi	r24, 0xF0	; 240
     cfe:	82 bb       	out	0x12, r24	; 18

  DDRE  = 0b11111110;
     d00:	8e ef       	ldi	r24, 0xFE	; 254
     d02:	82 b9       	out	0x02, r24	; 2
  PORTE = 0b00000000;
     d04:	13 b8       	out	0x03, r1	; 3

  DDRF  = //0b11110000;
     d06:	10 93 61 00 	sts	0x0061, r17
  0b11111111;	//testing
  PORTF = 0b11111111;
     d0a:	10 93 62 00 	sts	0x0062, r17

  DDRG  = 0b00011111;
     d0e:	8f e1       	ldi	r24, 0x1F	; 31
     d10:	80 93 64 00 	sts	0x0064, r24
  PORTG = 0b00000100;
     d14:	34 e0       	ldi	r19, 0x04	; 4
     d16:	f3 2e       	mov	r15, r19
     d18:	f0 92 65 00 	sts	0x0065, r15
  
  
  // use timer0_counter to get 144 / 144 = 1 Hz

  // enable clear on match interrupt
  OCR0 = 144; //144; //71;
     d1c:	80 e9       	ldi	r24, 0x90	; 144
     d1e:	81 bf       	out	0x31, r24	; 49

  // enable clear on match mode, set prescalar to 1024
  TCCR0 |= ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );	// prescalar mode 1024
     d20:	83 b7       	in	r24, 0x33	; 51
     d22:	8f 60       	ori	r24, 0x0F	; 15
     d24:	83 bf       	out	0x33, r24	; 51
	//TCCR0 = ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );
  
  TCNT0 = 0;
     d26:	12 be       	out	0x32, r1	; 50

  //Enable the interrupt to fire on overflow
  //TIMSK |= (1 << OCIE0);
  TIMSK |= (1 << OCIE0);
     d28:	87 b7       	in	r24, 0x37	; 55
     d2a:	82 60       	ori	r24, 0x02	; 2
     d2c:	87 bf       	out	0x37, r24	; 55

  sei();
     d2e:	78 94       	sei
  period of interrupts = 28800 / 14400 Hz = 2 s/interrupt
  use timer1_counter to get a total period of 2*65535 =  s (24 hours is 86400 seconds)
  */
  
  // Enable clear on match interrupt for the 16 bit timer/counter 1, register A
  OCR1A = 28800;		//28800 corresponds to 2 seconds
     d30:	80 e8       	ldi	r24, 0x80	; 128
     d32:	90 e7       	ldi	r25, 0x70	; 112
     d34:	9b bd       	out	0x2b, r25	; 43
     d36:	8a bd       	out	0x2a, r24	; 42

  // Enable clear on match mode, set prescalar to 1024.
  // CS[2:0] = 101 (1024 prescalar)
  // WGM[3:0] = 0100 (Clear Timer on Compare (CTC) when timer matches OCR1A)
  
  TCCR1B = ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS10 );
     d38:	8d e0       	ldi	r24, 0x0D	; 13
     d3a:	8e bd       	out	0x2e, r24	; 46
  // Explicit Default Defs
  // TCCR1A |= 0;
  TCNT1 = 0;
     d3c:	1d bc       	out	0x2d, r1	; 45
     d3e:	1c bc       	out	0x2c, r1	; 44
  
  TIMSK |= (1 << OCIE1A);
     d40:	87 b7       	in	r24, 0x37	; 55
     d42:	80 61       	ori	r24, 0x10	; 16
     d44:	87 bf       	out	0x37, r24	; 55
  
  timer1_counter[0] = CYCLE_COUNTER;	//CYCLE_COUNTER   = 900 for 2 seconds interrupt handler = 1800 secs (30 minutes)
     d46:	01 e0       	ldi	r16, 0x01	; 1
     d48:	00 93 9c 0d 	sts	0x0D9C, r16
  timer1_counter[1] = CYCLE_COUNTER_2;	//CYCLE_COUNTER_2 = 300 for 2 seconds interrupt handler = 600 secs  (10 minutes)
     d4c:	8c e2       	ldi	r24, 0x2C	; 44
     d4e:	80 93 9d 0d 	sts	0x0D9D, r24
  //---------------------------------------------------------------------  
  // End of timer 1 Setup
  //--------------------------------------------------------------------- 
  
  // communication
  uart_init();
     d52:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <uart_init>

  // for use in debugging
  // stdout = stdin = stderr = &uart_str;

  tel_packet_size[0] = 0;
     d56:	10 92 2a 03 	sts	0x032A, r1
     d5a:	10 92 29 03 	sts	0x0329, r1
  tel_packet_size[1] = 0;
     d5e:	10 92 2c 03 	sts	0x032C, r1
     d62:	10 92 2b 03 	sts	0x032B, r1
  tel_packet_index[0] = 0;
     d66:	10 92 41 07 	sts	0x0741, r1
  tel_packet_index[1] = 0;
     d6a:	10 92 42 07 	sts	0x0742, r1
  uart_vcp_buff[0] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     d6e:	8a e0       	ldi	r24, 0x0A	; 10
     d70:	90 e0       	ldi	r25, 0x00	; 0
     d72:	0e 94 d5 13 	call	0x27aa	; 0x27aa <malloc>
     d76:	d8 2e       	mov	r13, r24
     d78:	e9 2e       	mov	r14, r25
     d7a:	e4 ea       	ldi	r30, 0xA4	; 164
     d7c:	fd e0       	ldi	r31, 0x0D	; 13
     d7e:	80 83       	st	Z, r24
     d80:	91 83       	std	Z+1, r25	; 0x01
  uart_vcp_buff[1] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     d82:	8a e0       	ldi	r24, 0x0A	; 10
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	0e 94 d5 13 	call	0x27aa	; 0x27aa <malloc>
     d8a:	c6 ea       	ldi	r28, 0xA6	; 166
     d8c:	dd e0       	ldi	r29, 0x0D	; 13
     d8e:	88 83       	st	Y, r24
     d90:	99 83       	std	Y+1, r25	; 0x01
  vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     d92:	4f ef       	ldi	r20, 0xFF	; 255
     d94:	50 e0       	ldi	r21, 0x00	; 0
     d96:	61 e8       	ldi	r22, 0x81	; 129
     d98:	7b e0       	ldi	r23, 0x0B	; 11
     d9a:	8d 2d       	mov	r24, r13
     d9c:	9e 2d       	mov	r25, r14
     d9e:	0e 94 0b 0b 	call	0x1616	; 0x1616 <vcpptr_init>
  vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     da2:	4f ef       	ldi	r20, 0xFF	; 255
     da4:	50 e0       	ldi	r21, 0x00	; 0
     da6:	60 e8       	ldi	r22, 0x80	; 128
     da8:	7c e0       	ldi	r23, 0x0C	; 12
     daa:	88 81       	ld	r24, Y
     dac:	99 81       	ldd	r25, Y+1	; 0x01
     dae:	0e 94 0b 0b 	call	0x1616	; 0x1616 <vcpptr_init>

  rx_flag[0] = 0;
     db2:	10 92 a9 0d 	sts	0x0DA9, r1
  rx_flag[1] = 0;
     db6:	10 92 aa 0d 	sts	0x0DAA, r1

  // svit
  initialize_svit();
     dba:	0e 94 44 01 	call	0x288	; 0x288 <initialize_svit>

  // rev up those interrupts
  sei();
     dbe:	78 94       	sei

  //ADC conversions
  adc_flag = 1;
     dc0:	00 93 47 09 	sts	0x0947, r16
	adc_component = 0;
     dc4:	10 92 37 03 	sts	0x0337, r1
	adc_sensor_type = ADC_INIT;//get default case on first interation as to not enter switch
     dc8:	f0 92 54 09 	sts	0x0954, r15
  ADC_high = 0;
     dcc:	10 92 65 09 	sts	0x0965, r1

  V_upper_val_change = 0;
     dd0:	10 92 7f 0b 	sts	0x0B7F, r1
  I_upper_val_change = 0;
     dd4:	10 92 7a 0b 	sts	0x0B7A, r1

  //---------------------------------------------------------------------  
  // SOC Initializations
  //--------------------------------------------------------------------- 
  // and shunt and safe transmit flags
  safe_mode = 0;
     dd8:	10 92 51 09 	sts	0x0951, r1
  transmit_safe = 0;
     ddc:	10 92 4c 09 	sts	0x094C, r1
  transmit_shunt = 0;
     de0:	10 92 88 0d 	sts	0x0D88, r1
  been_to_safe = 0;
     de4:	10 92 31 03 	sts	0x0331, r1
  been_to_shunt = 0;
     de8:	10 92 71 09 	sts	0x0971, r1
  assign_charge_fit();
     dec:	0e 94 2c 05 	call	0xa58	; 0xa58 <assign_charge_fit>
  assign_discharge_fit();
     df0:	0e 94 99 05 	call	0xb32	; 0xb32 <assign_discharge_fit>
  
  // First get battery voltage so that the SoC can
  // accurately determine whether batteries are charging or discharging
  batt1_voltage = 0xff;
     df4:	10 93 6f 09 	sts	0x096F, r17
  batt2_voltage = 0xff;
     df8:	10 93 80 0b 	sts	0x0B80, r17
  charging = 0xff;
     dfc:	10 93 38 07 	sts	0x0738, r17
  chargeforward = 0;
     e00:	10 92 9f 0d 	sts	0x0D9F, r1
  chargebackward = 0;
     e04:	10 92 36 03 	sts	0x0336, r1
  debug = 0;
     e08:	10 92 37 07 	sts	0x0737, r1
  debug2 = 0;
     e0c:	10 92 43 07 	sts	0x0743, r1
  percent = 0;
     e10:	10 92 2f 07 	sts	0x072F, r1
     e14:	10 92 30 07 	sts	0x0730, r1
     e18:	10 92 31 07 	sts	0x0731, r1
     e1c:	10 92 32 07 	sts	0x0732, r1
  soc = 0;
     e20:	10 92 ad 0f 	sts	0x0FAD, r1
  high = 0;
     e24:	10 92 60 09 	sts	0x0960, r1
  low = 0;
     e28:	10 92 6e 09 	sts	0x096E, r1
  limit_check_overriden = 0; // Initially limit checking is NOT OVERRIDEN
     e2c:	10 92 2e 07 	sts	0x072E, r1
  isCharging = 0;
     e30:	10 92 a8 0d 	sts	0x0DA8, r1
  hasCheckedCurr = 0;
     e34:	10 92 59 09 	sts	0x0959, r1
  //--------------------------------------------------------------------- 

  //---------------------------------------------------------------------  
  // Timer Initializations
  //---------------------------------------------------------------------
  cdh_heartbeat_flag = 0;	//Default: do not have flag to restart components on
     e38:	10 92 24 03 	sts	0x0324, r1
  rad_torq_flag = 1;		//Indicates need to delay radio/torquer on signals later
     e3c:	00 93 0d 03 	sts	0x030D, r16
  SVIT_t *component; 	// Initialize Radios to be OFF
  component = &svit[components[RADIO_1]];
     e40:	a0 91 19 03 	lds	r26, 0x0319
     e44:	cc e1       	ldi	r28, 0x1C	; 28
     e46:	ca 9f       	mul	r28, r26
     e48:	d0 01       	movw	r26, r0
     e4a:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     e4c:	a8 5c       	subi	r26, 0xC8	; 200
     e4e:	bc 4f       	sbci	r27, 0xFC	; 252
     e50:	11 96       	adiw	r26, 0x01	; 1
     e52:	8c 91       	ld	r24, X
     e54:	0e 94 42 09 	call	0x1284	; 0x1284 <switch_off>
  component = &svit[components[RADIO_2]];
     e58:	e0 91 1a 03 	lds	r30, 0x031A
     e5c:	ce 9f       	mul	r28, r30
     e5e:	f0 01       	movw	r30, r0
     e60:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     e62:	e8 5c       	subi	r30, 0xC8	; 200
     e64:	fc 4f       	sbci	r31, 0xFC	; 252
     e66:	81 81       	ldd	r24, Z+1	; 0x01
     e68:	0e 94 42 09 	call	0x1284	; 0x1284 <switch_off>
  component = &svit[TORQUER_1];	// Initialize Torque Coils to be OFF
  component->switch_state = SW_OFF;
     e6c:	10 92 16 05 	sts	0x0516, r1
  component = &svit[TORQUER_2];
  component->switch_state = SW_OFF;
     e70:	10 92 32 05 	sts	0x0532, r1
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
     e74:	10 92 4e 05 	sts	0x054E, r1
  torquer_off(TORQUER_1);
     e78:	81 e1       	ldi	r24, 0x11	; 17
     e7a:	0e 94 c8 08 	call	0x1190	; 0x1190 <torquer_off>
  torquer_off(TORQUER_2);
     e7e:	82 e1       	ldi	r24, 0x12	; 18
     e80:	0e 94 c8 08 	call	0x1190	; 0x1190 <torquer_off>
  torquer_off(TORQUER_3);
     e84:	83 e1       	ldi	r24, 0x13	; 19
  //---------------------------------------------------------------------  
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}
     e86:	df 91       	pop	r29
     e88:	cf 91       	pop	r28
     e8a:	1f 91       	pop	r17
     e8c:	0f 91       	pop	r16
     e8e:	ff 90       	pop	r15
     e90:	ef 90       	pop	r14
     e92:	df 90       	pop	r13
  component->switch_state = SW_OFF;
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
  torquer_off(TORQUER_1);
  torquer_off(TORQUER_2);
  torquer_off(TORQUER_3);
     e94:	0c 94 c8 08 	jmp	0x1190	; 0x1190 <torquer_off>

00000e98 <compareVoltage>:
void compareVoltage( void ) {
  SVIT_t *component;
  //component = &svit[BATTERY_1_b];
  //chargebackward = average_samples( component->I_samples );
  component = &svit[BATTERY_1];
  chargeforward= average_samples( component->I_samples );
     e98:	89 e7       	ldi	r24, 0x79	; 121
     e9a:	95 e0       	ldi	r25, 0x05	; 5
     e9c:	0e 94 85 09 	call	0x130a	; 0x130a <average_samples>
     ea0:	80 93 9f 0d 	sts	0x0D9F, r24
  if (chargeforward > 2){
     ea4:	83 30       	cpi	r24, 0x03	; 3
     ea6:	10 f0       	brcs	.+4      	; 0xeac <compareVoltage+0x14>
    charging = 0xdd;//discharging
     ea8:	8d ed       	ldi	r24, 0xDD	; 221
     eaa:	01 c0       	rjmp	.+2      	; 0xeae <compareVoltage+0x16>
    }
  else{
    charging = 0xcc;
     eac:	8c ec       	ldi	r24, 0xCC	; 204
     eae:	80 93 38 07 	sts	0x0738, r24
     eb2:	08 95       	ret

00000eb4 <limit_check>:
we should at least get the framework set up for limit checking on arbitrary values.
The power board should have upper and lower limits for vsense and csense data, 
and turn off components if their voltage/current is too high. ONLY CHECKS
BATTERY 1 VOLTAGE LINE RIGHT NOW.
*/
void limit_check( void ) {
     eb4:	cf 92       	push	r12
     eb6:	df 92       	push	r13
     eb8:	ef 92       	push	r14
     eba:	ff 92       	push	r15
     ebc:	0f 93       	push	r16
     ebe:	1f 93       	push	r17
     ec0:	cf 93       	push	r28
     ec2:	df 93       	push	r29
	unsigned char sw;
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
     ec4:	c0 90 2f 07 	lds	r12, 0x072F
     ec8:	d0 90 30 07 	lds	r13, 0x0730
     ecc:	e0 90 31 07 	lds	r14, 0x0731
     ed0:	f0 90 32 07 	lds	r15, 0x0732
     ed4:	20 e0       	ldi	r18, 0x00	; 0
     ed6:	30 e0       	ldi	r19, 0x00	; 0
     ed8:	a9 01       	movw	r20, r18
     eda:	c7 01       	movw	r24, r14
     edc:	b6 01       	movw	r22, r12
     ede:	0e 94 8b 12 	call	0x2516	; 0x2516 <__cmpsf2>
     ee2:	87 ff       	sbrs	r24, 7
     ee4:	4c c0       	rjmp	.+152    	; 0xf7e <limit_check+0xca>
     ee6:	29 e2       	ldi	r18, 0x29	; 41
     ee8:	3c e5       	ldi	r19, 0x5C	; 92
     eea:	4f e0       	ldi	r20, 0x0F	; 15
     eec:	5f eb       	ldi	r21, 0xBF	; 191
     eee:	c7 01       	movw	r24, r14
     ef0:	b6 01       	movw	r22, r12
     ef2:	0e 94 8b 12 	call	0x2516	; 0x2516 <__cmpsf2>
     ef6:	87 ff       	sbrs	r24, 7
     ef8:	0a c0       	rjmp	.+20     	; 0xf0e <limit_check+0x5a>
     efa:	25 e8       	ldi	r18, 0x85	; 133
     efc:	3b ee       	ldi	r19, 0xEB	; 235
     efe:	41 e1       	ldi	r20, 0x11	; 17
     f00:	5f eb       	ldi	r21, 0xBF	; 191
     f02:	c7 01       	movw	r24, r14
     f04:	b6 01       	movw	r22, r12
     f06:	0e 94 a9 13 	call	0x2752	; 0x2752 <__gesf2>
     f0a:	18 16       	cp	r1, r24
     f0c:	c4 f1       	brlt	.+112    	; 0xf7e <limit_check+0xca>
		safe_mode = 1;
     f0e:	81 e0       	ldi	r24, 0x01	; 1
     f10:	80 93 51 09 	sts	0x0951, r24
     f14:	0e e0       	ldi	r16, 0x0E	; 14
     f16:	13 e0       	ldi	r17, 0x03	; 3
		for (sw = 0; sw < sizeof(components); sw++) {
			component = &svit[components[sw]];
     f18:	4c e1       	ldi	r20, 0x1C	; 28
     f1a:	f4 2e       	mov	r15, r20
     f1c:	f8 01       	movw	r30, r16
     f1e:	c1 91       	ld	r28, Z+
     f20:	8f 01       	movw	r16, r30
     f22:	fc 9e       	mul	r15, r28
     f24:	e0 01       	movw	r28, r0
     f26:	11 24       	eor	r1, r1
     f28:	c8 5c       	subi	r28, 0xC8	; 200
     f2a:	dc 4f       	sbci	r29, 0xFC	; 252
			switch_off( component->switch_num );
     f2c:	89 81       	ldd	r24, Y+1	; 0x01
     f2e:	0e 94 42 09 	call	0x1284	; 0x1284 <switch_off>
			component->switch_state = SW_OFF;
     f32:	1a 82       	std	Y+2, r1	; 0x02
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
		safe_mode = 1;
		for (sw = 0; sw < sizeof(components); sw++) {
     f34:	f3 e0       	ldi	r31, 0x03	; 3
     f36:	0e 31       	cpi	r16, 0x1E	; 30
     f38:	1f 07       	cpc	r17, r31
     f3a:	81 f7       	brne	.-32     	; 0xf1c <limit_check+0x68>
			component = &svit[components[sw]];
			switch_off( component->switch_num );
			component->switch_state = SW_OFF;
		}
		component = &svit[TORQUER_1];
		component->switch_state = SW_OFF;
     f3c:	10 92 16 05 	sts	0x0516, r1
		component = &svit[TORQUER_2];
		component->switch_state = SW_OFF;
     f40:	10 92 32 05 	sts	0x0532, r1
		component = &svit[TORQUER_3];
		component->switch_state = SW_OFF;
     f44:	10 92 4e 05 	sts	0x054E, r1
		torquer_off(TORQUER_1);
     f48:	81 e1       	ldi	r24, 0x11	; 17
     f4a:	0e 94 c8 08 	call	0x1190	; 0x1190 <torquer_off>
		torquer_off(TORQUER_2);
     f4e:	82 e1       	ldi	r24, 0x12	; 18
     f50:	0e 94 c8 08 	call	0x1190	; 0x1190 <torquer_off>
		torquer_off(TORQUER_3);
     f54:	83 e1       	ldi	r24, 0x13	; 19
     f56:	0e 94 c8 08 	call	0x1190	; 0x1190 <torquer_off>
		// Only transmit once
		if (!transmit_safe && !been_to_safe) { 
     f5a:	80 91 4c 09 	lds	r24, 0x094C
     f5e:	81 11       	cpse	r24, r1
     f60:	08 c0       	rjmp	.+16     	; 0xf72 <limit_check+0xbe>
     f62:	80 91 31 03 	lds	r24, 0x0331
     f66:	81 11       	cpse	r24, r1
     f68:	04 c0       	rjmp	.+8      	; 0xf72 <limit_check+0xbe>
			transmit_packet( 0, VCP_ACK, SAFE_MODE);
     f6a:	40 e0       	ldi	r20, 0x00	; 0
     f6c:	62 e0       	ldi	r22, 0x02	; 2
     f6e:	0e 94 79 11 	call	0x22f2	; 0x22f2 <transmit_packet>
			transmit_safe = 1;
		}
		else {}
		been_to_safe = 1;
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	80 93 31 03 	sts	0x0331, r24
		transmit_safe = 1;
     f78:	80 93 4c 09 	sts	0x094C, r24
     f7c:	28 c0       	rjmp	.+80     	; 0xfce <limit_check+0x11a>
	}
	else if (percent > SHUNT_MODE  && isCharging) {
     f7e:	20 e0       	ldi	r18, 0x00	; 0
     f80:	30 e0       	ldi	r19, 0x00	; 0
     f82:	48 ec       	ldi	r20, 0xC8	; 200
     f84:	52 e4       	ldi	r21, 0x42	; 66
     f86:	c7 01       	movw	r24, r14
     f88:	b6 01       	movw	r22, r12
     f8a:	0e 94 a9 13 	call	0x2752	; 0x2752 <__gesf2>
     f8e:	18 16       	cp	r1, r24
     f90:	f4 f4       	brge	.+60     	; 0xfce <limit_check+0x11a>
     f92:	80 91 a8 0d 	lds	r24, 0x0DA8
     f96:	88 23       	and	r24, r24
     f98:	d1 f0       	breq	.+52     	; 0xfce <limit_check+0x11a>
	    safe_mode = 0;
     f9a:	10 92 51 09 	sts	0x0951, r1
		// turn on the maestro and send ack_command w/ value of SHUNT_MODE
		component = &svit[MAESTRO];
		switch_on( component->switch_num );
     f9e:	80 91 a5 04 	lds	r24, 0x04A5
     fa2:	0e 94 ff 08 	call	0x11fe	; 0x11fe <switch_on>
		component->switch_state = SW_ON;
     fa6:	81 e0       	ldi	r24, 0x01	; 1
     fa8:	80 93 a6 04 	sts	0x04A6, r24
		// Only transmit once
		if (!transmit_shunt && !been_to_shunt) {
     fac:	80 91 88 0d 	lds	r24, 0x0D88
     fb0:	81 11       	cpse	r24, r1
     fb2:	08 c0       	rjmp	.+16     	; 0xfc4 <limit_check+0x110>
     fb4:	80 91 71 09 	lds	r24, 0x0971
     fb8:	81 11       	cpse	r24, r1
     fba:	04 c0       	rjmp	.+8      	; 0xfc4 <limit_check+0x110>
			transmit_packet( 0, VCP_ACK, SHUNT_MODE);
     fbc:	44 e6       	ldi	r20, 0x64	; 100
     fbe:	62 e0       	ldi	r22, 0x02	; 2
     fc0:	0e 94 79 11 	call	0x22f2	; 0x22f2 <transmit_packet>
		}
		else {}	
		been_to_shunt = 1;
     fc4:	81 e0       	ldi	r24, 0x01	; 1
     fc6:	80 93 71 09 	sts	0x0971, r24
		transmit_shunt = 1;	
     fca:	80 93 88 0d 	sts	0x0D88, r24
	}
	else {} // To avoid annoying compile warning 
}
     fce:	df 91       	pop	r29
     fd0:	cf 91       	pop	r28
     fd2:	1f 91       	pop	r17
     fd4:	0f 91       	pop	r16
     fd6:	ff 90       	pop	r15
     fd8:	ef 90       	pop	r14
     fda:	df 90       	pop	r13
     fdc:	cf 90       	pop	r12
     fde:	08 95       	ret

00000fe0 <main>:
}

// MAIN
int main( void ) 
{  
  initialize();
     fe0:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <initialize>
  //fprintf( stdout, "uart initialized\n" );
	
  //Testing
  cntr = 0;
     fe4:	10 92 46 09 	sts	0x0946, r1

  while(1)
  {
	  
	cntr = 1 - cntr; //Testing
     fe8:	11 e0       	ldi	r17, 0x01	; 1
	
    if ( timer0_counter[1] == 0 )
    {
        timer0_counter[1] = 199;
     fea:	c7 ec       	ldi	r28, 0xC7	; 199
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     fec:	dc e2       	ldi	r29, 0x2C	; 44
  cntr = 0;

  while(1)
  {
	  
	cntr = 1 - cntr; //Testing
     fee:	80 91 46 09 	lds	r24, 0x0946
     ff2:	91 2f       	mov	r25, r17
     ff4:	98 1b       	sub	r25, r24
     ff6:	90 93 46 09 	sts	0x0946, r25
	
    if ( timer0_counter[1] == 0 )
     ffa:	80 91 79 0b 	lds	r24, 0x0B79
     ffe:	81 11       	cpse	r24, r1
    1000:	07 c0       	rjmp	.+14     	; 0x1010 <main+0x30>
    {
        timer0_counter[1] = 199;
    1002:	c0 93 79 0b 	sts	0x0B79, r28
        transmit_packet( 1, VCP_POWER_TELEMETRY, 0);
    1006:	40 e0       	ldi	r20, 0x00	; 0
    1008:	60 e0       	ldi	r22, 0x00	; 0
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	0e 94 79 11 	call	0x22f2	; 0x22f2 <transmit_packet>
    }
	  if ( timer0_counter[0] == 0 )
    1010:	80 91 78 0b 	lds	r24, 0x0B78
    1014:	81 11       	cpse	r24, r1
    1016:	06 c0       	rjmp	.+12     	; 0x1024 <main+0x44>
    {
        timer0_counter[0] = 199;
    1018:	c0 93 78 0b 	sts	0x0B78, r28
        transmit_packet( 0, VCP_POWER_TELEMETRY, 0);
    101c:	40 e0       	ldi	r20, 0x00	; 0
    101e:	60 e0       	ldi	r22, 0x00	; 0
    1020:	0e 94 79 11 	call	0x22f2	; 0x22f2 <transmit_packet>
    }
	  if ( rx_flag[0] > 0 )
    1024:	80 91 a9 0d 	lds	r24, 0x0DA9
    1028:	88 23       	and	r24, r24
    102a:	c9 f0       	breq	.+50     	; 0x105e <main+0x7e>
    {
        rx_flag[0]--;
    102c:	80 91 a9 0d 	lds	r24, 0x0DA9
    1030:	81 50       	subi	r24, 0x01	; 1
    1032:	80 93 a9 0d 	sts	0x0DA9, r24
        receive_message( 0, uart_vcp_buff[0]->message, uart_vcp_buff[0]->index );
    1036:	e0 91 a4 0d 	lds	r30, 0x0DA4
    103a:	f0 91 a5 0d 	lds	r31, 0x0DA5
    103e:	61 81       	ldd	r22, Z+1	; 0x01
    1040:	72 81       	ldd	r23, Z+2	; 0x02
    1042:	47 81       	ldd	r20, Z+7	; 0x07
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	0e 94 af 03 	call	0x75e	; 0x75e <receive_message>
        vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
    104a:	4f ef       	ldi	r20, 0xFF	; 255
    104c:	50 e0       	ldi	r21, 0x00	; 0
    104e:	61 e8       	ldi	r22, 0x81	; 129
    1050:	7b e0       	ldi	r23, 0x0B	; 11
    1052:	80 91 a4 0d 	lds	r24, 0x0DA4
    1056:	90 91 a5 0d 	lds	r25, 0x0DA5
    105a:	0e 94 0b 0b 	call	0x1616	; 0x1616 <vcpptr_init>
    }
	  if ( rx_flag[1] > 0 )
    105e:	80 91 aa 0d 	lds	r24, 0x0DAA
    1062:	88 23       	and	r24, r24
    1064:	c9 f0       	breq	.+50     	; 0x1098 <main+0xb8>
    {
        rx_flag[1]--;
    1066:	80 91 aa 0d 	lds	r24, 0x0DAA
    106a:	81 50       	subi	r24, 0x01	; 1
    106c:	80 93 aa 0d 	sts	0x0DAA, r24
        receive_message( 1, uart_vcp_buff[1]->message, uart_vcp_buff[1]->index );
    1070:	e0 91 a6 0d 	lds	r30, 0x0DA6
    1074:	f0 91 a7 0d 	lds	r31, 0x0DA7
    1078:	61 81       	ldd	r22, Z+1	; 0x01
    107a:	72 81       	ldd	r23, Z+2	; 0x02
    107c:	47 81       	ldd	r20, Z+7	; 0x07
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	0e 94 af 03 	call	0x75e	; 0x75e <receive_message>
        vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
    1084:	4f ef       	ldi	r20, 0xFF	; 255
    1086:	50 e0       	ldi	r21, 0x00	; 0
    1088:	60 e8       	ldi	r22, 0x80	; 128
    108a:	7c e0       	ldi	r23, 0x0C	; 12
    108c:	80 91 a6 0d 	lds	r24, 0x0DA6
    1090:	90 91 a7 0d 	lds	r25, 0x0DA7
    1094:	0e 94 0b 0b 	call	0x1616	; 0x1616 <vcpptr_init>
    }
    if (adc_flag == 1)
    1098:	80 91 47 09 	lds	r24, 0x0947
    109c:	81 30       	cpi	r24, 0x01	; 1
    109e:	91 f4       	brne	.+36     	; 0x10c4 <main+0xe4>
    {
        adc_flag = 0;
    10a0:	10 92 47 09 	sts	0x0947, r1
        read_VIT();
    10a4:	0e 94 bc 09 	call	0x1378	; 0x1378 <read_VIT>
		//calcSOC();
		StateofCharge();
    10a8:	0e 94 58 04 	call	0x8b0	; 0x8b0 <StateofCharge>

		//Manual Override on Limit Checking: The power board must be able to receive a 
		//command to disable and/or change the limits in the limit checking code
		if (!limit_check_overriden) {
    10ac:	80 91 2e 07 	lds	r24, 0x072E
    10b0:	81 11       	cpse	r24, r1
    10b2:	02 c0       	rjmp	.+4      	; 0x10b8 <main+0xd8>
			limit_check(); // First determine if voltage is within valid range, then switch
    10b4:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <limit_check>
		}

		if ( adc_component == 23 ) 
    10b8:	80 91 37 03 	lds	r24, 0x0337
    10bc:	87 31       	cpi	r24, 0x17	; 23
    10be:	11 f4       	brne	.+4      	; 0x10c4 <main+0xe4>
      	{ //23ish anything after battery values are calculated
  			  compareVoltage();
    10c0:	0e 94 4c 07 	call	0xe98	; 0xe98 <compareVoltage>
	   	}
    }	
	
	//Restart all board components if CDH-IB heartbeat timeout
	if (cdh_heartbeat_flag == 1){
    10c4:	80 91 24 03 	lds	r24, 0x0324
    10c8:	81 30       	cpi	r24, 0x01	; 1
    10ca:	09 f0       	breq	.+2      	; 0x10ce <main+0xee>
    10cc:	90 cf       	rjmp	.-224    	; 0xfee <main+0xe>
		//Restart all components
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
    10ce:	10 92 24 03 	sts	0x0324, r1
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
    10d2:	d0 93 9d 0d 	sts	0x0D9D, r29
    10d6:	8b cf       	rjmp	.-234    	; 0xfee <main+0xe>

000010d8 <torquer_off.part.0>:
void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
  {
    case TORQUER_1:
      CLR( PORTC, 0 );
    10d8:	a8 98       	cbi	0x15, 0	; 21
	  CLR( PORTG, 1 );
    10da:	e5 e6       	ldi	r30, 0x65	; 101
    10dc:	f0 e0       	ldi	r31, 0x00	; 0
    10de:	80 81       	ld	r24, Z
    10e0:	8d 7f       	andi	r24, 0xFD	; 253
    10e2:	80 83       	st	Z, r24
    10e4:	08 95       	ret

000010e6 <set_mux_sel>:
#include "mcupwr-Defs.h"


void set_mux_sel( uint8_t mux_num, uint8_t mux_sel )
{
  switch( mux_num )
    10e6:	81 30       	cpi	r24, 0x01	; 1
    10e8:	f9 f0       	breq	.+62     	; 0x1128 <__stack+0x29>
    10ea:	20 f0       	brcs	.+8      	; 0x10f4 <set_mux_sel+0xe>
    10ec:	82 30       	cpi	r24, 0x02	; 2
    10ee:	09 f0       	breq	.+2      	; 0x10f2 <set_mux_sel+0xc>
    10f0:	4e c0       	rjmp	.+156    	; 0x118e <__stack+0x8f>
    10f2:	34 c0       	rjmp	.+104    	; 0x115c <__stack+0x5d>
  {
    case MUX0:
      READ( mux_sel, 4 ) ? SET( PORTA, 7 ) : CLR( PORTA, 7 );
    10f4:	64 ff       	sbrs	r22, 4
    10f6:	02 c0       	rjmp	.+4      	; 0x10fc <set_mux_sel+0x16>
    10f8:	df 9a       	sbi	0x1b, 7	; 27
    10fa:	01 c0       	rjmp	.+2      	; 0x10fe <set_mux_sel+0x18>
    10fc:	df 98       	cbi	0x1b, 7	; 27
      READ( mux_sel, 3 ) ? SET( PORTA, 6 ) : CLR( PORTA, 6 );
    10fe:	63 ff       	sbrs	r22, 3
    1100:	02 c0       	rjmp	.+4      	; 0x1106 <__stack+0x7>
    1102:	de 9a       	sbi	0x1b, 6	; 27
    1104:	01 c0       	rjmp	.+2      	; 0x1108 <__stack+0x9>
    1106:	de 98       	cbi	0x1b, 6	; 27
      READ( mux_sel, 2 ) ? SET( PORTA, 5 ) : CLR( PORTA, 5 );
    1108:	62 ff       	sbrs	r22, 2
    110a:	02 c0       	rjmp	.+4      	; 0x1110 <__stack+0x11>
    110c:	dd 9a       	sbi	0x1b, 5	; 27
    110e:	01 c0       	rjmp	.+2      	; 0x1112 <__stack+0x13>
    1110:	dd 98       	cbi	0x1b, 5	; 27
      READ( mux_sel, 1 ) ? SET( PORTA, 4 ) : CLR( PORTA, 4 );
    1112:	61 ff       	sbrs	r22, 1
    1114:	02 c0       	rjmp	.+4      	; 0x111a <__stack+0x1b>
    1116:	dc 9a       	sbi	0x1b, 4	; 27
    1118:	01 c0       	rjmp	.+2      	; 0x111c <__stack+0x1d>
    111a:	dc 98       	cbi	0x1b, 4	; 27
      READ( mux_sel, 0 ) ? SET( PORTA, 3 ) : CLR( PORTA, 3 );
    111c:	60 ff       	sbrs	r22, 0
    111e:	02 c0       	rjmp	.+4      	; 0x1124 <__stack+0x25>
    1120:	db 9a       	sbi	0x1b, 3	; 27
    1122:	08 95       	ret
    1124:	db 98       	cbi	0x1b, 3	; 27
    1126:	08 95       	ret

      break;

    case MUX1:
      READ( mux_sel, 4 ) ? SET( PORTB, 0 ) : CLR( PORTB, 0 );
    1128:	64 ff       	sbrs	r22, 4
    112a:	02 c0       	rjmp	.+4      	; 0x1130 <__stack+0x31>
    112c:	c0 9a       	sbi	0x18, 0	; 24
    112e:	01 c0       	rjmp	.+2      	; 0x1132 <__stack+0x33>
    1130:	c0 98       	cbi	0x18, 0	; 24
      READ( mux_sel, 3 ) ? SET( PORTB, 1 ) : CLR( PORTB, 1 );
    1132:	63 ff       	sbrs	r22, 3
    1134:	02 c0       	rjmp	.+4      	; 0x113a <__stack+0x3b>
    1136:	c1 9a       	sbi	0x18, 1	; 24
    1138:	01 c0       	rjmp	.+2      	; 0x113c <__stack+0x3d>
    113a:	c1 98       	cbi	0x18, 1	; 24
      READ( mux_sel, 2 ) ? SET( PORTB, 2 ) : CLR( PORTB, 2 );
    113c:	62 ff       	sbrs	r22, 2
    113e:	02 c0       	rjmp	.+4      	; 0x1144 <__stack+0x45>
    1140:	c2 9a       	sbi	0x18, 2	; 24
    1142:	01 c0       	rjmp	.+2      	; 0x1146 <__stack+0x47>
    1144:	c2 98       	cbi	0x18, 2	; 24
      READ( mux_sel, 1 ) ? SET( PORTB, 3 ) : CLR( PORTB, 3 );
    1146:	61 ff       	sbrs	r22, 1
    1148:	02 c0       	rjmp	.+4      	; 0x114e <__stack+0x4f>
    114a:	c3 9a       	sbi	0x18, 3	; 24
    114c:	01 c0       	rjmp	.+2      	; 0x1150 <__stack+0x51>
    114e:	c3 98       	cbi	0x18, 3	; 24
      READ( mux_sel, 0 ) ? SET( PORTB, 4 ) : CLR( PORTB, 4 );
    1150:	60 ff       	sbrs	r22, 0
    1152:	02 c0       	rjmp	.+4      	; 0x1158 <__stack+0x59>
    1154:	c4 9a       	sbi	0x18, 4	; 24
    1156:	08 95       	ret
    1158:	c4 98       	cbi	0x18, 4	; 24
    115a:	08 95       	ret

      break;

    case MUX2:
      READ( mux_sel, 4 ) ? SET( PORTE, 3 ) : CLR( PORTE, 3 );
    115c:	64 ff       	sbrs	r22, 4
    115e:	02 c0       	rjmp	.+4      	; 0x1164 <__stack+0x65>
    1160:	1b 9a       	sbi	0x03, 3	; 3
    1162:	01 c0       	rjmp	.+2      	; 0x1166 <__stack+0x67>
    1164:	1b 98       	cbi	0x03, 3	; 3
      READ( mux_sel, 3 ) ? SET( PORTE, 4 ) : CLR( PORTE, 4 );
    1166:	63 ff       	sbrs	r22, 3
    1168:	02 c0       	rjmp	.+4      	; 0x116e <__stack+0x6f>
    116a:	1c 9a       	sbi	0x03, 4	; 3
    116c:	01 c0       	rjmp	.+2      	; 0x1170 <__stack+0x71>
    116e:	1c 98       	cbi	0x03, 4	; 3
      READ( mux_sel, 2 ) ? SET( PORTE, 5 ) : CLR( PORTE, 5 );
    1170:	62 ff       	sbrs	r22, 2
    1172:	02 c0       	rjmp	.+4      	; 0x1178 <__stack+0x79>
    1174:	1d 9a       	sbi	0x03, 5	; 3
    1176:	01 c0       	rjmp	.+2      	; 0x117a <__stack+0x7b>
    1178:	1d 98       	cbi	0x03, 5	; 3
      READ( mux_sel, 1 ) ? SET( PORTE, 6 ) : CLR( PORTE, 6 );
    117a:	61 ff       	sbrs	r22, 1
    117c:	02 c0       	rjmp	.+4      	; 0x1182 <__stack+0x83>
    117e:	1e 9a       	sbi	0x03, 6	; 3
    1180:	01 c0       	rjmp	.+2      	; 0x1184 <__stack+0x85>
    1182:	1e 98       	cbi	0x03, 6	; 3
      READ( mux_sel, 0 ) ? SET( PORTE, 7 ) : CLR( PORTE, 7 );
    1184:	60 ff       	sbrs	r22, 0
    1186:	02 c0       	rjmp	.+4      	; 0x118c <__stack+0x8d>
    1188:	1f 9a       	sbi	0x03, 7	; 3
    118a:	08 95       	ret
    118c:	1f 98       	cbi	0x03, 7	; 3
    118e:	08 95       	ret

00001190 <torquer_off>:
  }
}

void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
    1190:	82 31       	cpi	r24, 0x12	; 18
    1192:	31 f0       	breq	.+12     	; 0x11a0 <torquer_off+0x10>
    1194:	83 31       	cpi	r24, 0x13	; 19
    1196:	59 f0       	breq	.+22     	; 0x11ae <torquer_off+0x1e>
    1198:	81 31       	cpi	r24, 0x11	; 17
    119a:	99 f4       	brne	.+38     	; 0x11c2 <torquer_off+0x32>
    119c:	0c 94 6c 08 	jmp	0x10d8	; 0x10d8 <torquer_off.part.0>
      CLR( PORTC, 0 );
	  CLR( PORTG, 1 );
      break;

    case TORQUER_2:
      CLR( PORTG, 0 );
    11a0:	80 91 65 00 	lds	r24, 0x0065
    11a4:	8e 7f       	andi	r24, 0xFE	; 254
    11a6:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTD, 0 );
    11aa:	90 98       	cbi	0x12, 0	; 18
      break;
    11ac:	08 95       	ret

    case TORQUER_3:
      CLR( PORTG, 3 );
    11ae:	80 91 65 00 	lds	r24, 0x0065
    11b2:	87 7f       	andi	r24, 0xF7	; 247
    11b4:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTG, 4 );
    11b8:	80 91 65 00 	lds	r24, 0x0065
    11bc:	8f 7e       	andi	r24, 0xEF	; 239
    11be:	80 93 65 00 	sts	0x0065, r24
    11c2:	08 95       	ret

000011c4 <torquer_on>:
  }  
}

void torquer_on( uint8_t torquer_num )
{
  switch( torquer_num )
    11c4:	82 31       	cpi	r24, 0x12	; 18
    11c6:	49 f0       	breq	.+18     	; 0x11da <torquer_on+0x16>
    11c8:	83 31       	cpi	r24, 0x13	; 19
    11ca:	71 f0       	breq	.+28     	; 0x11e8 <torquer_on+0x24>
    11cc:	81 31       	cpi	r24, 0x11	; 17
    11ce:	b1 f4       	brne	.+44     	; 0x11fc <torquer_on+0x38>
  {
    case TORQUER_1:
      SET( PORTC, 0 );
    11d0:	a8 9a       	sbi	0x15, 0	; 21
	  SET( PORTG, 1 );
    11d2:	80 91 65 00 	lds	r24, 0x0065
    11d6:	82 60       	ori	r24, 0x02	; 2
    11d8:	0f c0       	rjmp	.+30     	; 0x11f8 <torquer_on+0x34>
      break;

    case TORQUER_2:
      SET( PORTG, 0 );
    11da:	80 91 65 00 	lds	r24, 0x0065
    11de:	81 60       	ori	r24, 0x01	; 1
    11e0:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTD, 0 );
    11e4:	90 9a       	sbi	0x12, 0	; 18
      break;
    11e6:	08 95       	ret

    case TORQUER_3:
      SET( PORTG, 3 );
    11e8:	80 91 65 00 	lds	r24, 0x0065
    11ec:	88 60       	ori	r24, 0x08	; 8
    11ee:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTG, 4 );
    11f2:	80 91 65 00 	lds	r24, 0x0065
    11f6:	80 61       	ori	r24, 0x10	; 16
    11f8:	80 93 65 00 	sts	0x0065, r24
    11fc:	08 95       	ret

000011fe <switch_on>:
  }
}

void switch_on( uint8_t switch_num )
{
  switch ( switch_num )
    11fe:	88 30       	cpi	r24, 0x08	; 8
    1200:	59 f1       	breq	.+86     	; 0x1258 <switch_on+0x5a>
    1202:	68 f4       	brcc	.+26     	; 0x121e <switch_on+0x20>
    1204:	84 30       	cpi	r24, 0x04	; 4
    1206:	01 f1       	breq	.+64     	; 0x1248 <switch_on+0x4a>
    1208:	30 f4       	brcc	.+12     	; 0x1216 <switch_on+0x18>
    120a:	82 30       	cpi	r24, 0x02	; 2
    120c:	c9 f0       	breq	.+50     	; 0x1240 <switch_on+0x42>
    120e:	d0 f4       	brcc	.+52     	; 0x1244 <switch_on+0x46>
    1210:	81 30       	cpi	r24, 0x01	; 1
    1212:	b9 f5       	brne	.+110    	; 0x1282 <switch_on+0x84>
    1214:	13 c0       	rjmp	.+38     	; 0x123c <switch_on+0x3e>
    1216:	86 30       	cpi	r24, 0x06	; 6
    1218:	d9 f0       	breq	.+54     	; 0x1250 <switch_on+0x52>
    121a:	e0 f4       	brcc	.+56     	; 0x1254 <switch_on+0x56>
    121c:	17 c0       	rjmp	.+46     	; 0x124c <switch_on+0x4e>
    121e:	8c 30       	cpi	r24, 0x0C	; 12
    1220:	39 f1       	breq	.+78     	; 0x1270 <switch_on+0x72>
    1222:	20 f4       	brcc	.+8      	; 0x122c <switch_on+0x2e>
    1224:	8a 30       	cpi	r24, 0x0A	; 10
    1226:	01 f1       	breq	.+64     	; 0x1268 <switch_on+0x6a>
    1228:	08 f5       	brcc	.+66     	; 0x126c <switch_on+0x6e>
    122a:	18 c0       	rjmp	.+48     	; 0x125c <switch_on+0x5e>
    122c:	8e 30       	cpi	r24, 0x0E	; 14
    122e:	21 f1       	breq	.+72     	; 0x1278 <switch_on+0x7a>
    1230:	08 f1       	brcs	.+66     	; 0x1274 <switch_on+0x76>
    1232:	8f 30       	cpi	r24, 0x0F	; 15
    1234:	19 f1       	breq	.+70     	; 0x127c <switch_on+0x7e>
    1236:	80 31       	cpi	r24, 0x10	; 16
    1238:	21 f5       	brne	.+72     	; 0x1282 <switch_on+0x84>
    123a:	22 c0       	rjmp	.+68     	; 0x1280 <switch_on+0x82>
  {
    case 1:
      SET( PORTA, 0 );
    123c:	d8 9a       	sbi	0x1b, 0	; 27
      break;
    123e:	08 95       	ret

    case 2:
      SET( PORTA, 1 );
    1240:	d9 9a       	sbi	0x1b, 1	; 27
      break;
    1242:	08 95       	ret

    case 3:
      SET( PORTA, 2 );
    1244:	da 9a       	sbi	0x1b, 2	; 27
      break;
    1246:	08 95       	ret

    case 4:
      SET( PORTB, 5 );
    1248:	c5 9a       	sbi	0x18, 5	; 24
      break;
    124a:	08 95       	ret

    case 5:
      SET( PORTB, 6 );
    124c:	c6 9a       	sbi	0x18, 6	; 24
      break;
    124e:	08 95       	ret

    case 6:
      SET( PORTB, 7 );
    1250:	c7 9a       	sbi	0x18, 7	; 24
      break;
    1252:	08 95       	ret

    case 7:
      SET( PORTD, 4 );
    1254:	94 9a       	sbi	0x12, 4	; 18
      break;
    1256:	08 95       	ret

    case 8:
      SET( PORTD, 5 );
    1258:	95 9a       	sbi	0x12, 5	; 18
      break;
    125a:	08 95       	ret

    case 9:
      SET( PORTG, 2 );
    125c:	80 91 65 00 	lds	r24, 0x0065
    1260:	84 60       	ori	r24, 0x04	; 4
    1262:	80 93 65 00 	sts	0x0065, r24
      break;
    1266:	08 95       	ret

    case 10: 
      SET( PORTC, 7 );
    1268:	af 9a       	sbi	0x15, 7	; 21
      break;
    126a:	08 95       	ret

    case 11:
      SET( PORTC, 6 );
    126c:	ae 9a       	sbi	0x15, 6	; 21
      break;
    126e:	08 95       	ret

    case 12:
      SET( PORTC, 5 );
    1270:	ad 9a       	sbi	0x15, 5	; 21
      break;
    1272:	08 95       	ret

    case 13:
      SET( PORTC, 4 );
    1274:	ac 9a       	sbi	0x15, 4	; 21
      break;
    1276:	08 95       	ret

    case 14:
      SET( PORTC, 3 );
    1278:	ab 9a       	sbi	0x15, 3	; 21
      break;
    127a:	08 95       	ret

    case 15:
      SET( PORTC, 2 );
    127c:	aa 9a       	sbi	0x15, 2	; 21
      break;
    127e:	08 95       	ret

    case 16:
      SET( PORTC, 1 );
    1280:	a9 9a       	sbi	0x15, 1	; 21
    1282:	08 95       	ret

00001284 <switch_off>:
  }
}

void switch_off( uint8_t switch_num )
{
  switch ( switch_num )
    1284:	88 30       	cpi	r24, 0x08	; 8
    1286:	59 f1       	breq	.+86     	; 0x12de <switch_off+0x5a>
    1288:	68 f4       	brcc	.+26     	; 0x12a4 <switch_off+0x20>
    128a:	84 30       	cpi	r24, 0x04	; 4
    128c:	01 f1       	breq	.+64     	; 0x12ce <switch_off+0x4a>
    128e:	30 f4       	brcc	.+12     	; 0x129c <switch_off+0x18>
    1290:	82 30       	cpi	r24, 0x02	; 2
    1292:	c9 f0       	breq	.+50     	; 0x12c6 <switch_off+0x42>
    1294:	d0 f4       	brcc	.+52     	; 0x12ca <switch_off+0x46>
    1296:	81 30       	cpi	r24, 0x01	; 1
    1298:	b9 f5       	brne	.+110    	; 0x1308 <switch_off+0x84>
    129a:	13 c0       	rjmp	.+38     	; 0x12c2 <switch_off+0x3e>
    129c:	86 30       	cpi	r24, 0x06	; 6
    129e:	d9 f0       	breq	.+54     	; 0x12d6 <switch_off+0x52>
    12a0:	e0 f4       	brcc	.+56     	; 0x12da <switch_off+0x56>
    12a2:	17 c0       	rjmp	.+46     	; 0x12d2 <switch_off+0x4e>
    12a4:	8c 30       	cpi	r24, 0x0C	; 12
    12a6:	39 f1       	breq	.+78     	; 0x12f6 <switch_off+0x72>
    12a8:	20 f4       	brcc	.+8      	; 0x12b2 <switch_off+0x2e>
    12aa:	8a 30       	cpi	r24, 0x0A	; 10
    12ac:	01 f1       	breq	.+64     	; 0x12ee <switch_off+0x6a>
    12ae:	08 f5       	brcc	.+66     	; 0x12f2 <switch_off+0x6e>
    12b0:	18 c0       	rjmp	.+48     	; 0x12e2 <switch_off+0x5e>
    12b2:	8e 30       	cpi	r24, 0x0E	; 14
    12b4:	21 f1       	breq	.+72     	; 0x12fe <switch_off+0x7a>
    12b6:	08 f1       	brcs	.+66     	; 0x12fa <switch_off+0x76>
    12b8:	8f 30       	cpi	r24, 0x0F	; 15
    12ba:	19 f1       	breq	.+70     	; 0x1302 <switch_off+0x7e>
    12bc:	80 31       	cpi	r24, 0x10	; 16
    12be:	21 f5       	brne	.+72     	; 0x1308 <switch_off+0x84>
    12c0:	22 c0       	rjmp	.+68     	; 0x1306 <switch_off+0x82>
  {
    case 1:
      CLR( PORTA, 0 );
    12c2:	d8 98       	cbi	0x1b, 0	; 27
      break;
    12c4:	08 95       	ret

    case 2:
      CLR( PORTA, 1 );
    12c6:	d9 98       	cbi	0x1b, 1	; 27
      break;
    12c8:	08 95       	ret

    case 3:
      CLR( PORTA, 2 );
    12ca:	da 98       	cbi	0x1b, 2	; 27
      break;
    12cc:	08 95       	ret

    case 4:
      CLR( PORTB, 5 );
    12ce:	c5 98       	cbi	0x18, 5	; 24
      break;
    12d0:	08 95       	ret

    case 5:
      CLR( PORTB, 6 );
    12d2:	c6 98       	cbi	0x18, 6	; 24
      break;
    12d4:	08 95       	ret

    case 6:
      CLR( PORTB, 7 );
    12d6:	c7 98       	cbi	0x18, 7	; 24
      break;
    12d8:	08 95       	ret

    case 7:
      CLR( PORTD, 4 );
    12da:	94 98       	cbi	0x12, 4	; 18
      break;
    12dc:	08 95       	ret

    case 8:
      CLR( PORTD, 5 );
    12de:	95 98       	cbi	0x12, 5	; 18
      break;
    12e0:	08 95       	ret

    case 9:
      CLR( PORTG, 2 );
    12e2:	80 91 65 00 	lds	r24, 0x0065
    12e6:	8b 7f       	andi	r24, 0xFB	; 251
    12e8:	80 93 65 00 	sts	0x0065, r24
      break;
    12ec:	08 95       	ret

    case 10: 
      CLR( PORTC, 7 );
    12ee:	af 98       	cbi	0x15, 7	; 21
      break;
    12f0:	08 95       	ret

    case 11:
      CLR( PORTC, 6 );
    12f2:	ae 98       	cbi	0x15, 6	; 21
      break;
    12f4:	08 95       	ret

    case 12:
      CLR( PORTC, 5 );
    12f6:	ad 98       	cbi	0x15, 5	; 21
      break;
    12f8:	08 95       	ret

    case 13:
      CLR( PORTC, 4 );
    12fa:	ac 98       	cbi	0x15, 4	; 21
      break;
    12fc:	08 95       	ret

    case 14:
      CLR( PORTC, 3 );
    12fe:	ab 98       	cbi	0x15, 3	; 21
      break;
    1300:	08 95       	ret

    case 15:
      CLR( PORTC, 2 );
    1302:	aa 98       	cbi	0x15, 2	; 21
      break;
    1304:	08 95       	ret

    case 16:
      CLR( PORTC, 1 );
    1306:	a9 98       	cbi	0x15, 1	; 21
    1308:	08 95       	ret

0000130a <average_samples>:
    return  average_samples( component->I_samples );
  }
}

uint8_t average_samples( uint8_t samples[NUM_SAMPLES] )
{
    130a:	fc 01       	movw	r30, r24
  uint8_t average = 0;
  uint16_t sum = 0;

  for(uint8_t avg_index = 0; avg_index < NUM_SAMPLES; avg_index++)
    sum += samples[avg_index];
    130c:	21 81       	ldd	r18, Z+1	; 0x01
    130e:	80 81       	ld	r24, Z
    1310:	90 e0       	ldi	r25, 0x00	; 0
    1312:	82 0f       	add	r24, r18
    1314:	91 1d       	adc	r25, r1
    1316:	22 81       	ldd	r18, Z+2	; 0x02
    1318:	82 0f       	add	r24, r18
    131a:	91 1d       	adc	r25, r1

  average = sum / NUM_SAMPLES;
    131c:	63 e0       	ldi	r22, 0x03	; 3
    131e:	70 e0       	ldi	r23, 0x00	; 0
    1320:	0e 94 ad 13 	call	0x275a	; 0x275a <__udivmodhi4>
    1324:	86 2f       	mov	r24, r22

  return average;
}
    1326:	08 95       	ret

00001328 <SVIT_check_I_critical>:
}

uint8_t SVIT_check_I_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1328:	9c e1       	ldi	r25, 0x1C	; 28
    132a:	89 9f       	mul	r24, r25
    132c:	f0 01       	movw	r30, r0
    132e:	11 24       	eor	r1, r1
    1330:	e8 5c       	subi	r30, 0xC8	; 200
    1332:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->I_critical_value != 0 )
    1334:	85 89       	ldd	r24, Z+21	; 0x15
    1336:	88 23       	and	r24, r24
    1338:	11 f0       	breq	.+4      	; 0x133e <SVIT_check_I_critical+0x16>
  {
    temp= component->I_critical_value;
    component->I_critical_value = 0;
    133a:	15 8a       	std	Z+21, r1	; 0x15
    133c:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->I_samples );
    133e:	cf 01       	movw	r24, r30
    1340:	41 96       	adiw	r24, 0x11	; 17
    1342:	0c 94 85 09 	jmp	0x130a	; 0x130a <average_samples>

00001346 <SVIT_check_V_critical>:
}

uint8_t SVIT_check_V_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1346:	9c e1       	ldi	r25, 0x1C	; 28
    1348:	89 9f       	mul	r24, r25
    134a:	f0 01       	movw	r30, r0
    134c:	11 24       	eor	r1, r1
    134e:	e8 5c       	subi	r30, 0xC8	; 200
    1350:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->V_critical_value != 0 )
    1352:	84 85       	ldd	r24, Z+12	; 0x0c
    1354:	88 23       	and	r24, r24
    1356:	11 f0       	breq	.+4      	; 0x135c <SVIT_check_V_critical+0x16>
  {
    temp= component->V_critical_value;
    component->V_critical_value = 0;
    1358:	14 86       	std	Z+12, r1	; 0x0c
    135a:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->V_samples );
    135c:	cf 01       	movw	r24, r30
    135e:	08 96       	adiw	r24, 0x08	; 8
    1360:	0c 94 85 09 	jmp	0x130a	; 0x130a <average_samples>

00001364 <perform_ADC>:
}

void perform_ADC( uint8_t mux_num )
{
  // set Vref to AVCC and set the ADC channel to the correct pin ( mux_num )
  ADMUX = (1 << ADLAR) | ( 1 << REFS0 );
    1364:	90 e6       	ldi	r25, 0x60	; 96
    1366:	97 b9       	out	0x07, r25	; 7
  ADMUX &= ~0x3;
    1368:	97 b1       	in	r25, 0x07	; 7
    136a:	9c 7f       	andi	r25, 0xFC	; 252
    136c:	97 b9       	out	0x07, r25	; 7
  ADMUX |= mux_num;
    136e:	97 b1       	in	r25, 0x07	; 7
    1370:	98 2b       	or	r25, r24
    1372:	97 b9       	out	0x07, r25	; 7

  // signal ADC to start a new conversion
  ADCSRA |= ( 1 << ADSC );
    1374:	36 9a       	sbi	0x06, 6	; 6
    1376:	08 95       	ret

00001378 <read_VIT>:

  // when the conversion finishes, the result is stored in ADCL and ADCH
}

void read_VIT( void )
{
    1378:	1f 93       	push	r17
    137a:	cf 93       	push	r28
    137c:	df 93       	push	r29
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type ){
    137e:	80 91 54 09 	lds	r24, 0x0954
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1382:	c0 91 37 03 	lds	r28, 0x0337
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type ){
    1386:	82 30       	cpi	r24, 0x02	; 2
    1388:	09 f4       	brne	.+2      	; 0x138c <read_VIT+0x14>
    138a:	6a c0       	rjmp	.+212    	; 0x1460 <read_VIT+0xe8>
    138c:	20 f4       	brcc	.+8      	; 0x1396 <read_VIT+0x1e>
    138e:	81 30       	cpi	r24, 0x01	; 1
    1390:	09 f0       	breq	.+2      	; 0x1394 <read_VIT+0x1c>
    1392:	01 c1       	rjmp	.+514    	; 0x1596 <read_VIT+0x21e>
    1394:	07 c0       	rjmp	.+14     	; 0x13a4 <read_VIT+0x2c>
    1396:	83 30       	cpi	r24, 0x03	; 3
    1398:	09 f4       	brne	.+2      	; 0x139c <read_VIT+0x24>
    139a:	c1 c0       	rjmp	.+386    	; 0x151e <read_VIT+0x1a6>
    139c:	84 30       	cpi	r24, 0x04	; 4
    139e:	09 f0       	breq	.+2      	; 0x13a2 <read_VIT+0x2a>
    13a0:	fa c0       	rjmp	.+500    	; 0x1596 <read_VIT+0x21e>
    13a2:	e5 c0       	rjmp	.+458    	; 0x156e <read_VIT+0x1f6>
		case ADC_VOLTAGE:
			component = &svit[adc_component];
    13a4:	8c e1       	ldi	r24, 0x1C	; 28
    13a6:	c8 9f       	mul	r28, r24
    13a8:	e0 01       	movw	r28, r0
    13aa:	11 24       	eor	r1, r1
    13ac:	c8 5c       	subi	r28, 0xC8	; 200
    13ae:	dc 4f       	sbci	r29, 0xFC	; 252
			sample_index = component->V_sample_index;
			component->V_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    13b0:	2b 85       	ldd	r18, Y+11	; 0x0b
    13b2:	30 e0       	ldi	r19, 0x00	; 0
    13b4:	c9 01       	movw	r24, r18
    13b6:	01 96       	adiw	r24, 0x01	; 1
    13b8:	63 e0       	ldi	r22, 0x03	; 3
    13ba:	70 e0       	ldi	r23, 0x00	; 0
    13bc:	0e 94 c1 13 	call	0x2782	; 0x2782 <__divmodhi4>
    13c0:	8b 87       	std	Y+11, r24	; 0x0b

			// SoC: If component is a battery, store in different global variable
			if (component->name == BATTERY_1) {
    13c2:	98 81       	ld	r25, Y
    13c4:	94 31       	cpi	r25, 0x14	; 20
    13c6:	89 f4       	brne	.+34     	; 0x13ea <read_VIT+0x72>
				batt1_voltage = ADC_high;
    13c8:	80 91 65 09 	lds	r24, 0x0965
    13cc:	80 93 6f 09 	sts	0x096F, r24
				batt1_voltageLow = ADC_low;
    13d0:	80 91 9e 0d 	lds	r24, 0x0D9E
    13d4:	80 93 83 0d 	sts	0x0D83, r24
				high = ADC_high;
    13d8:	80 91 65 09 	lds	r24, 0x0965
    13dc:	80 93 60 09 	sts	0x0960, r24
				low = ADC_low;
    13e0:	80 91 9e 0d 	lds	r24, 0x0D9E
    13e4:	80 93 6e 09 	sts	0x096E, r24
    13e8:	06 c0       	rjmp	.+12     	; 0x13f6 <read_VIT+0x7e>
				//debug = adc_component;
			}
			else if (component->name == BATTERY_2) {
    13ea:	95 31       	cpi	r25, 0x15	; 21
    13ec:	21 f4       	brne	.+8      	; 0x13f6 <read_VIT+0x7e>
				batt2_voltage = ADC_high;
    13ee:	80 91 65 09 	lds	r24, 0x0965
    13f2:	80 93 80 0b 	sts	0x0B80, r24
			}
			component->V_samples[sample_index] = ADC_high;
    13f6:	80 91 65 09 	lds	r24, 0x0965
    13fa:	fe 01       	movw	r30, r28
    13fc:	e2 0f       	add	r30, r18
    13fe:	f3 1f       	adc	r31, r19
    1400:	80 87       	std	Z+8, r24	; 0x08
            
			//OverVoltage
	  		if ( ( ADC_high > component->V_upper_limit ) && ( component->force_on != 1 ) ){
    1402:	20 91 65 09 	lds	r18, 0x0965
    1406:	8e 81       	ldd	r24, Y+6	; 0x06
    1408:	82 17       	cp	r24, r18
    140a:	20 f4       	brcc	.+8      	; 0x1414 <read_VIT+0x9c>
    140c:	8b 81       	ldd	r24, Y+3	; 0x03
    140e:	81 30       	cpi	r24, 0x01	; 1
    1410:	09 f0       	breq	.+2      	; 0x1414 <read_VIT+0x9c>
    1412:	08 c0       	rjmp	.+16     	; 0x1424 <read_VIT+0xac>
  				}
				component->switch_state = SW_OFF;
				component->V_critical_value = ADC_high;
			}
			//UnderVoltage
			else if((ADC_high < component->V_lower_limit) && component->switch_state){
    1414:	20 91 65 09 	lds	r18, 0x0965
    1418:	8f 81       	ldd	r24, Y+7	; 0x07
    141a:	28 17       	cp	r18, r24
    141c:	d8 f4       	brcc	.+54     	; 0x1454 <read_VIT+0xdc>
    141e:	8a 81       	ldd	r24, Y+2	; 0x02
    1420:	88 23       	and	r24, r24
    1422:	c1 f0       	breq	.+48     	; 0x1454 <read_VIT+0xdc>
				if ( component->switch_num != SW_NULL ){
    1424:	89 81       	ldd	r24, Y+1	; 0x01
    1426:	8f 3f       	cpi	r24, 0xFF	; 255
    1428:	19 f0       	breq	.+6      	; 0x1430 <read_VIT+0xb8>
					switch_off( component->switch_num );
    142a:	0e 94 42 09 	call	0x1284	; 0x1284 <switch_off>
    142e:	0e c0       	rjmp	.+28     	; 0x144c <read_VIT+0xd4>
				}else {
					switch ( component->name ){
    1430:	92 31       	cpi	r25, 0x12	; 18
    1432:	39 f0       	breq	.+14     	; 0x1442 <read_VIT+0xca>
    1434:	93 31       	cpi	r25, 0x13	; 19
    1436:	39 f0       	breq	.+14     	; 0x1446 <read_VIT+0xce>
    1438:	91 31       	cpi	r25, 0x11	; 17
    143a:	41 f4       	brne	.+16     	; 0x144c <read_VIT+0xd4>
    143c:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <torquer_off.part.0>
    1440:	05 c0       	rjmp	.+10     	; 0x144c <read_VIT+0xd4>
						case TORQUER_1:
							torquer_off( TORQUER_1 );
							break;
						case TORQUER_2:
							torquer_off( TORQUER_2 );
    1442:	82 e1       	ldi	r24, 0x12	; 18
    1444:	01 c0       	rjmp	.+2      	; 0x1448 <read_VIT+0xd0>
							break;
						case TORQUER_3:
							torquer_off( TORQUER_3 );
    1446:	83 e1       	ldi	r24, 0x13	; 19
    1448:	0e 94 c8 08 	call	0x1190	; 0x1190 <torquer_off>
							break;
						default:
							break;
					}
				}
				component->switch_state = SW_OFF;
    144c:	1a 82       	std	Y+2, r1	; 0x02
				component->V_critical_value = ADC_high;
    144e:	80 91 65 09 	lds	r24, 0x0965
    1452:	8c 87       	std	Y+12, r24	; 0x0c
			}
			adc_sensor_type = ADC_CURRENT;
    1454:	82 e0       	ldi	r24, 0x02	; 2
    1456:	80 93 54 09 	sts	0x0954, r24

		    //perform next ADC conversion
		    mux_num = component->I_mux_num;
    145a:	1d 85       	ldd	r17, Y+13	; 0x0d
		    mux_sel = component->I_mux_sel;
		    set_mux_sel( mux_num, mux_sel );
    145c:	6e 85       	ldd	r22, Y+14	; 0x0e
    145e:	92 c0       	rjmp	.+292    	; 0x1584 <read_VIT+0x20c>
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1460:	9c e1       	ldi	r25, 0x1C	; 28
    1462:	c9 9f       	mul	r28, r25
    1464:	e0 01       	movw	r28, r0
    1466:	11 24       	eor	r1, r1
    1468:	c8 5c       	subi	r28, 0xC8	; 200
    146a:	dc 4f       	sbci	r29, 0xFC	; 252
	  	sample_index = component->I_sample_index;
	  	component->I_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    146c:	2c 89       	ldd	r18, Y+20	; 0x14
    146e:	30 e0       	ldi	r19, 0x00	; 0
    1470:	c9 01       	movw	r24, r18
    1472:	01 96       	adiw	r24, 0x01	; 1
    1474:	63 e0       	ldi	r22, 0x03	; 3
    1476:	70 e0       	ldi	r23, 0x00	; 0
    1478:	0e 94 c1 13 	call	0x2782	; 0x2782 <__divmodhi4>
    147c:	8c 8b       	std	Y+20, r24	; 0x14
		// SoC hardcode backward current
//		if (adc_component == BATTERY_1_b) {
			//debug = 5;
		//}
		
		if(component->name == SOLAR_1){
    147e:	98 81       	ld	r25, Y
    1480:	97 31       	cpi	r25, 0x17	; 23
    1482:	39 f4       	brne	.+14     	; 0x1492 <read_VIT+0x11a>
			solar1_current = ADC_high;
    1484:	80 91 65 09 	lds	r24, 0x0965
    1488:	80 93 70 09 	sts	0x0970, r24
			hasCheckedCurr = 1;
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	80 93 59 09 	sts	0x0959, r24
		}

	  	component->I_samples[sample_index] = ADC_high;
    1492:	80 91 65 09 	lds	r24, 0x0965
    1496:	fe 01       	movw	r30, r28
    1498:	e2 0f       	add	r30, r18
    149a:	f3 1f       	adc	r31, r19
    149c:	81 8b       	std	Z+17, r24	; 0x11
    
	    if ( ( ADC_high > component->I_upper_limit ) && ( component->force_on != 1 ) )
    149e:	20 91 65 09 	lds	r18, 0x0965
    14a2:	8f 85       	ldd	r24, Y+15	; 0x0f
    14a4:	82 17       	cp	r24, r18
    14a6:	d8 f4       	brcc	.+54     	; 0x14de <read_VIT+0x166>
    14a8:	8b 81       	ldd	r24, Y+3	; 0x03
    14aa:	81 30       	cpi	r24, 0x01	; 1
    14ac:	c1 f0       	breq	.+48     	; 0x14de <read_VIT+0x166>
	  	{
	  		if ( component->switch_num != SW_NULL )
    14ae:	89 81       	ldd	r24, Y+1	; 0x01
    14b0:	8f 3f       	cpi	r24, 0xFF	; 255
    14b2:	19 f0       	breq	.+6      	; 0x14ba <read_VIT+0x142>
	  		{
	  		  switch_off( component->switch_num );
    14b4:	0e 94 42 09 	call	0x1284	; 0x1284 <switch_off>
    14b8:	0e c0       	rjmp	.+28     	; 0x14d6 <read_VIT+0x15e>
	  		}
	  		else
	  		{
	  		  switch ( component->name )
    14ba:	92 31       	cpi	r25, 0x12	; 18
    14bc:	39 f0       	breq	.+14     	; 0x14cc <read_VIT+0x154>
    14be:	93 31       	cpi	r25, 0x13	; 19
    14c0:	39 f0       	breq	.+14     	; 0x14d0 <read_VIT+0x158>
    14c2:	91 31       	cpi	r25, 0x11	; 17
    14c4:	41 f4       	brne	.+16     	; 0x14d6 <read_VIT+0x15e>
    14c6:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <torquer_off.part.0>
    14ca:	05 c0       	rjmp	.+10     	; 0x14d6 <read_VIT+0x15e>
		  	  {
  		  		case TORQUER_1:
	  	  		  torquer_off( TORQUER_1 );
		    		  break;
			    	case TORQUER_2:
			  	    torquer_off( TORQUER_2 );
    14cc:	82 e1       	ldi	r24, 0x12	; 18
    14ce:	01 c0       	rjmp	.+2      	; 0x14d2 <read_VIT+0x15a>
			  	    break;
  		  		case TORQUER_3:
	  	  		  torquer_off( TORQUER_3 );
    14d0:	83 e1       	ldi	r24, 0x13	; 19
    14d2:	0e 94 c8 08 	call	0x1190	; 0x1190 <torquer_off>
		    		  break;
			     	default:
				      break;
			    }
			  }
			  component->switch_state = 0;
    14d6:	1a 82       	std	Y+2, r1	; 0x02
        component->I_critical_value = ADC_high;
    14d8:	80 91 65 09 	lds	r24, 0x0965
    14dc:	8d 8b       	std	Y+21, r24	; 0x15
		  }
      //perform next ADC conversion
      mux_num = component->T_mux_num;
    14de:	1e 89       	ldd	r17, Y+22	; 0x16
      if( mux_num != MUX_NULL )
    14e0:	13 30       	cpi	r17, 0x03	; 3
    14e2:	29 f0       	breq	.+10     	; 0x14ee <read_VIT+0x176>
      {
		    adc_sensor_type = ADC_TEMPERATURE;
    14e4:	83 e0       	ldi	r24, 0x03	; 3
    14e6:	80 93 54 09 	sts	0x0954, r24
        mux_sel = component->T_mux_sel;        
    14ea:	6f 89       	ldd	r22, Y+23	; 0x17
    14ec:	4b c0       	rjmp	.+150    	; 0x1584 <read_VIT+0x20c>
		  }
      else
      {
        adc_sensor_type = ADC_VOLTAGE;
    14ee:	81 e0       	ldi	r24, 0x01	; 1
    14f0:	80 93 54 09 	sts	0x0954, r24
		    adc_component = ( adc_component + 1 ) % SVIT_SZ;
    14f4:	80 91 37 03 	lds	r24, 0x0337
    14f8:	90 e0       	ldi	r25, 0x00	; 0
    14fa:	01 96       	adiw	r24, 0x01	; 1
    14fc:	64 e2       	ldi	r22, 0x24	; 36
    14fe:	70 e0       	ldi	r23, 0x00	; 0
    1500:	0e 94 c1 13 	call	0x2782	; 0x2782 <__divmodhi4>
    1504:	80 93 37 03 	sts	0x0337, r24
        component = &svit[adc_component];
    1508:	2c e1       	ldi	r18, 0x1C	; 28
    150a:	28 9f       	mul	r18, r24
    150c:	f0 01       	movw	r30, r0
    150e:	29 9f       	mul	r18, r25
    1510:	f0 0d       	add	r31, r0
    1512:	11 24       	eor	r1, r1
    1514:	e8 5c       	subi	r30, 0xC8	; 200
    1516:	fc 4f       	sbci	r31, 0xFC	; 252
        mux_num = component->V_mux_num;
    1518:	14 81       	ldd	r17, Z+4	; 0x04
        mux_sel = component->V_mux_sel;
    151a:	65 81       	ldd	r22, Z+5	; 0x05
    151c:	33 c0       	rjmp	.+102    	; 0x1584 <read_VIT+0x20c>
      break;
    //-------------------------------------------------------------------
    // Measure temperature
    //-------------------------------------------------------------------
	  case ADC_TEMPERATURE:
		  component = &svit[adc_component];
    151e:	d0 e0       	ldi	r29, 0x00	; 0
    1520:	4c e1       	ldi	r20, 0x1C	; 28
    1522:	4c 9f       	mul	r20, r28
    1524:	f0 01       	movw	r30, r0
    1526:	4d 9f       	mul	r20, r29
    1528:	f0 0d       	add	r31, r0
    152a:	11 24       	eor	r1, r1
    152c:	e8 5c       	subi	r30, 0xC8	; 200
    152e:	fc 4f       	sbci	r31, 0xFC	; 252
		  sample_index = component->T_sample_index;
		  component->T_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    1530:	23 8d       	ldd	r18, Z+27	; 0x1b
    1532:	30 e0       	ldi	r19, 0x00	; 0
    1534:	c9 01       	movw	r24, r18
    1536:	01 96       	adiw	r24, 0x01	; 1
    1538:	63 e0       	ldi	r22, 0x03	; 3
    153a:	70 e0       	ldi	r23, 0x00	; 0
    153c:	0e 94 c1 13 	call	0x2782	; 0x2782 <__divmodhi4>
    1540:	83 8f       	std	Z+27, r24	; 0x1b
		  component->T_samples[sample_index] = ADC_high;
    1542:	80 91 65 09 	lds	r24, 0x0965
    1546:	e2 0f       	add	r30, r18
    1548:	f3 1f       	adc	r31, r19
    154a:	80 8f       	std	Z+24, r24	; 0x18
      //perform next ADC conversion
  	  adc_sensor_type = ADC_VOLTAGE;
    154c:	81 e0       	ldi	r24, 0x01	; 1
    154e:	80 93 54 09 	sts	0x0954, r24
		  adc_component = ( adc_component + 1 ) % SVIT_SZ;
    1552:	ce 01       	movw	r24, r28
    1554:	01 96       	adiw	r24, 0x01	; 1
    1556:	64 e2       	ldi	r22, 0x24	; 36
    1558:	70 e0       	ldi	r23, 0x00	; 0
    155a:	0e 94 c1 13 	call	0x2782	; 0x2782 <__divmodhi4>
    155e:	80 93 37 03 	sts	0x0337, r24
      component = &svit[adc_component];
    1562:	48 9f       	mul	r20, r24
    1564:	f0 01       	movw	r30, r0
    1566:	49 9f       	mul	r20, r25
    1568:	f0 0d       	add	r31, r0
    156a:	11 24       	eor	r1, r1
    156c:	1d c0       	rjmp	.+58     	; 0x15a8 <read_VIT+0x230>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
		  break;
    case ADC_INIT:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    156e:	81 e0       	ldi	r24, 0x01	; 1
    1570:	80 93 54 09 	sts	0x0954, r24
      component = &svit[adc_component];
    1574:	9c e1       	ldi	r25, 0x1C	; 28
    1576:	c9 9f       	mul	r28, r25
    1578:	e0 01       	movw	r28, r0
    157a:	11 24       	eor	r1, r1
    157c:	c8 5c       	subi	r28, 0xC8	; 200
    157e:	dc 4f       	sbci	r29, 0xFC	; 252
      mux_num = component->V_mux_num;
    1580:	1c 81       	ldd	r17, Y+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    1582:	6d 81       	ldd	r22, Y+5	; 0x05
    1584:	81 2f       	mov	r24, r17
    1586:	0e 94 73 08 	call	0x10e6	; 0x10e6 <set_mux_sel>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    158a:	83 e3       	ldi	r24, 0x33	; 51
    158c:	93 e7       	ldi	r25, 0x73	; 115
    158e:	01 97       	sbiw	r24, 0x01	; 1
    1590:	f1 f7       	brne	.-4      	; 0x158e <read_VIT+0x216>
      //_delay_us(1);
	  //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
    1592:	81 2f       	mov	r24, r17
    1594:	15 c0       	rjmp	.+42     	; 0x15c0 <read_VIT+0x248>
      break;
	  default:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	80 93 54 09 	sts	0x0954, r24
      component = &svit[adc_component];
    159c:	e0 91 37 03 	lds	r30, 0x0337
    15a0:	9c e1       	ldi	r25, 0x1C	; 28
    15a2:	e9 9f       	mul	r30, r25
    15a4:	f0 01       	movw	r30, r0
    15a6:	11 24       	eor	r1, r1
    15a8:	e8 5c       	subi	r30, 0xC8	; 200
    15aa:	fc 4f       	sbci	r31, 0xFC	; 252
      mux_num = component->V_mux_num;
    15ac:	c4 81       	ldd	r28, Z+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    15ae:	65 81       	ldd	r22, Z+5	; 0x05
    15b0:	8c 2f       	mov	r24, r28
    15b2:	0e 94 73 08 	call	0x10e6	; 0x10e6 <set_mux_sel>
    15b6:	83 e3       	ldi	r24, 0x33	; 51
    15b8:	93 e7       	ldi	r25, 0x73	; 115
    15ba:	01 97       	sbiw	r24, 0x01	; 1
    15bc:	f1 f7       	brne	.-4      	; 0x15ba <read_VIT+0x242>
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    15be:	8c 2f       	mov	r24, r28
      break;
  } 
}
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	1f 91       	pop	r17
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    15c6:	0c 94 b2 09 	jmp	0x1364	; 0x1364 <perform_ADC>

000015ca <uart_init>:
{
  #if F_CPU < 2000000UL && defined(U2X)
  UCSR0A = UCSR1A = _BV(U2X); /* improve baud rate error by using 2x clk */
  UBRR0L = UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  #else
  UBRR0L = UBRR1L = 7;//(F_CPU / (16UL * UART_BAUD)) - 1;//7;
    15ca:	87 e0       	ldi	r24, 0x07	; 7
    15cc:	80 93 99 00 	sts	0x0099, r24
    15d0:	89 b9       	out	0x09, r24	; 9
  #endif
  UCSR0B = _BV(TXEN0) | _BV(RXEN0); /* tx/rx enable */
    15d2:	88 e1       	ldi	r24, 0x18	; 24
    15d4:	8a b9       	out	0x0a, r24	; 10
  UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
    15d6:	ea e9       	ldi	r30, 0x9A	; 154
    15d8:	f0 e0       	ldi	r31, 0x00	; 0
    15da:	80 83       	st	Z, r24


  UCSR1B = UCSR1B | _BV(TXCIE1);
    15dc:	80 81       	ld	r24, Z
    15de:	80 64       	ori	r24, 0x40	; 64
    15e0:	80 83       	st	Z, r24
  UCSR1B = UCSR1B | _BV(RXCIE1);
    15e2:	80 81       	ld	r24, Z
    15e4:	80 68       	ori	r24, 0x80	; 128
    15e6:	80 83       	st	Z, r24
  UCSR0B = UCSR0B | _BV(TXCIE0);
    15e8:	56 9a       	sbi	0x0a, 6	; 10
  UCSR0B = UCSR0B | _BV(RXCIE0);
    15ea:	57 9a       	sbi	0x0a, 7	; 10
    15ec:	08 95       	ret

000015ee <append_crc16>:
 * Adds a byte of data into the crc calculation using
 * the table above.
 */
void append_crc16(uint8 byte, uint16ptr crc)
{
	*crc = ((*crc) >> 8) ^ ccitt_crc16[((*crc) ^ (byte)) & 0xff];
    15ee:	fb 01       	movw	r30, r22
    15f0:	20 81       	ld	r18, Z
    15f2:	31 81       	ldd	r19, Z+1	; 0x01
    15f4:	f9 01       	movw	r30, r18
    15f6:	e8 27       	eor	r30, r24
    15f8:	ff 27       	eor	r31, r31
    15fa:	ee 0f       	add	r30, r30
    15fc:	ff 1f       	adc	r31, r31
    15fe:	ea 5f       	subi	r30, 0xFA	; 250
    1600:	fe 4f       	sbci	r31, 0xFE	; 254
    1602:	23 2f       	mov	r18, r19
    1604:	33 27       	eor	r19, r19
    1606:	80 81       	ld	r24, Z
    1608:	91 81       	ldd	r25, Z+1	; 0x01
    160a:	82 27       	eor	r24, r18
    160c:	93 27       	eor	r25, r19
    160e:	fb 01       	movw	r30, r22
    1610:	91 83       	std	Z+1, r25	; 0x01
    1612:	80 83       	st	Z, r24
    1614:	08 95       	ret

00001616 <vcpptr_init>:
// Parameters: 
// vcp_ptrbuffer	*buff -					Pointer to the vcp buffer structure
// uint8			*message_buffer -		Pointer to the allocated data buffer
// uint16			message_buffer_size -	Size of the allocated data buffer
void vcpptr_init(vcp_ptrbuffer *buff, uint8 *message_buffer, uint16 message_buffer_size)
{
    1616:	fc 01       	movw	r30, r24
	buff->address =	0;
    1618:	10 82       	st	Z, r1
	buff->message =	message_buffer;
    161a:	72 83       	std	Z+2, r23	; 0x02
    161c:	61 83       	std	Z+1, r22	; 0x01
	buff->size =	message_buffer_size;
    161e:	56 83       	std	Z+6, r21	; 0x06
    1620:	45 83       	std	Z+5, r20	; 0x05
	buff->index	=	0;
    1622:	10 86       	std	Z+8, r1	; 0x08
    1624:	17 82       	std	Z+7, r1	; 0x07
	buff->crc =		CRC16_INIT_VALUE;
    1626:	14 82       	std	Z+4, r1	; 0x04
    1628:	13 82       	std	Z+3, r1	; 0x03
	buff->status =	VCP_IDLE;
    162a:	11 86       	std	Z+9, r1	; 0x09
    162c:	08 95       	ret

0000162e <Create_VCP_frame>:
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
    162e:	4f 92       	push	r4
    1630:	5f 92       	push	r5
    1632:	6f 92       	push	r6
    1634:	7f 92       	push	r7
    1636:	8f 92       	push	r8
    1638:	9f 92       	push	r9
    163a:	af 92       	push	r10
    163c:	bf 92       	push	r11
    163e:	cf 92       	push	r12
    1640:	df 92       	push	r13
    1642:	ef 92       	push	r14
    1644:	ff 92       	push	r15
    1646:	0f 93       	push	r16
    1648:	1f 93       	push	r17
    164a:	cf 93       	push	r28
    164c:	df 93       	push	r29
    164e:	00 d0       	rcall	.+0      	; 0x1650 <Create_VCP_frame+0x22>
    1650:	1f 92       	push	r1
    1652:	cd b7       	in	r28, 0x3d	; 61
    1654:	de b7       	in	r29, 0x3e	; 62
    1656:	6c 01       	movw	r12, r24
    1658:	5b 01       	movw	r10, r22
    165a:	79 01       	movw	r14, r18
	uint16_t crc = CRC16_INIT_VALUE;
    165c:	1a 82       	std	Y+2, r1	; 0x02
    165e:	19 82       	std	Y+1, r1	; 0x01
	uint16_t src_index = 0;
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
    1660:	00 97       	sbiw	r24, 0x00	; 0
    1662:	09 f4       	brne	.+2      	; 0x1666 <Create_VCP_frame+0x38>
    1664:	58 c0       	rjmp	.+176    	; 0x1716 <Create_VCP_frame+0xe8>
    1666:	21 15       	cp	r18, r1
    1668:	31 05       	cpc	r19, r1
    166a:	09 f4       	brne	.+2      	; 0x166e <Create_VCP_frame+0x40>
    166c:	54 c0       	rjmp	.+168    	; 0x1716 <Create_VCP_frame+0xe8>
		return VCP_NULL_ERR;

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
    166e:	4c 30       	cpi	r20, 0x0C	; 12
    1670:	18 f0       	brcs	.+6      	; 0x1678 <Create_VCP_frame+0x4a>
    1672:	48 33       	cpi	r20, 0x38	; 56
    1674:	09 f0       	breq	.+2      	; 0x1678 <Create_VCP_frame+0x4a>
    1676:	51 c0       	rjmp	.+162    	; 0x171a <Create_VCP_frame+0xec>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    1678:	44 24       	eor	r4, r4
    167a:	43 94       	inc	r4
    167c:	51 2c       	mov	r5, r1
    167e:	4c 0e       	add	r4, r28
    1680:	5d 1e       	adc	r5, r29
    1682:	b2 01       	movw	r22, r4
    1684:	84 2f       	mov	r24, r20
    1686:	4b 83       	std	Y+3, r20	; 0x03
    1688:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <append_crc16>
// uint8ptr		dst -		Pointer to the destination buffer
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
    168c:	37 01       	movw	r6, r14
    168e:	60 0e       	add	r6, r16
    1690:	71 1e       	adc	r7, r17
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    1692:	47 01       	movw	r8, r14
    1694:	07 c0       	rjmp	.+14     	; 0x16a4 <Create_VCP_frame+0x76>
	  append_crc16(src[src_index], &crc);
    1696:	b2 01       	movw	r22, r4
    1698:	f4 01       	movw	r30, r8
    169a:	81 91       	ld	r24, Z+
    169c:	4f 01       	movw	r8, r30
    169e:	4b 83       	std	Y+3, r20	; 0x03
    16a0:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <append_crc16>
    16a4:	4b 81       	ldd	r20, Y+3	; 0x03
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    16a6:	86 14       	cp	r8, r6
    16a8:	97 04       	cpc	r9, r7
    16aa:	a9 f7       	brne	.-22     	; 0x1696 <Create_VCP_frame+0x68>
	  append_crc16(src[src_index], &crc);
	
	// Add CRC to the end of the source buffer
	src[src_index++] = ((crc >> 8) & 0xFF);
    16ac:	89 81       	ldd	r24, Y+1	; 0x01
    16ae:	9a 81       	ldd	r25, Y+2	; 0x02
    16b0:	f7 01       	movw	r30, r14
    16b2:	e0 0f       	add	r30, r16
    16b4:	f1 1f       	adc	r31, r17
    16b6:	90 83       	st	Z, r25
	src[src_index++] = (crc & 0xFF);
    16b8:	81 83       	std	Z+1, r24	; 0x01
    16ba:	0e 5f       	subi	r16, 0xFE	; 254
    16bc:	1f 4f       	sbci	r17, 0xFF	; 255
	payload_size = src_index;
	
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
    16be:	80 ec       	ldi	r24, 0xC0	; 192
    16c0:	f6 01       	movw	r30, r12
    16c2:	80 83       	st	Z, r24
	// then insert VCP address
	dst[dst_index++] =					addr;
    16c4:	41 83       	std	Z+1, r20	; 0x01
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    16c6:	d7 01       	movw	r26, r14
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
    16c8:	42 e0       	ldi	r20, 0x02	; 2
    16ca:	50 e0       	ldi	r21, 0x00	; 0
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    16cc:	2d ed       	ldi	r18, 0xDD	; 221
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
    16ce:	3b ed       	ldi	r19, 0xDB	; 219
			dst[dst_index++] =			TFEND;
    16d0:	6c ed       	ldi	r22, 0xDC	; 220
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    16d2:	0f c0       	rjmp	.+30     	; 0x16f2 <Create_VCP_frame+0xc4>
	{
		if (src[src_index] == FEND)
    16d4:	8d 91       	ld	r24, X+
    16d6:	80 3c       	cpi	r24, 0xC0	; 192
    16d8:	19 f4       	brne	.+6      	; 0x16e0 <Create_VCP_frame+0xb2>
		{
			dst[dst_index++] =			FESC;
    16da:	30 83       	st	Z, r19
			dst[dst_index++] =			TFEND;
    16dc:	61 83       	std	Z+1, r22	; 0x01
    16de:	04 c0       	rjmp	.+8      	; 0x16e8 <Create_VCP_frame+0xba>
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
    16e0:	80 83       	st	Z, r24
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
    16e2:	8b 3d       	cpi	r24, 0xDB	; 219
    16e4:	21 f4       	brne	.+8      	; 0x16ee <Create_VCP_frame+0xc0>
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    16e6:	21 83       	std	Z+1, r18	; 0x01
    16e8:	4e 5f       	subi	r20, 0xFE	; 254
    16ea:	5f 4f       	sbci	r21, 0xFF	; 255
    16ec:	02 c0       	rjmp	.+4      	; 0x16f2 <Create_VCP_frame+0xc4>
		}
		else
		{
			dst[dst_index++] =			src[src_index];
    16ee:	4f 5f       	subi	r20, 0xFF	; 255
    16f0:	5f 4f       	sbci	r21, 0xFF	; 255
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    16f2:	cd 01       	movw	r24, r26
    16f4:	8e 19       	sub	r24, r14
    16f6:	9f 09       	sbc	r25, r15
    16f8:	f6 01       	movw	r30, r12
    16fa:	e4 0f       	add	r30, r20
    16fc:	f5 1f       	adc	r31, r21
    16fe:	80 17       	cp	r24, r16
    1700:	91 07       	cpc	r25, r17
    1702:	40 f3       	brcs	.-48     	; 0x16d4 <Create_VCP_frame+0xa6>
		//if (dst_index >= *dst_size - 1)
			//return VCP_OVR_ERR;
	}
	
	// End the frame with FEND
	dst[dst_index++] =					FEND;
    1704:	80 ec       	ldi	r24, 0xC0	; 192
    1706:	80 83       	st	Z, r24
    1708:	4f 5f       	subi	r20, 0xFF	; 255
    170a:	5f 4f       	sbci	r21, 0xFF	; 255
	
	// Save the frame size
	*dst_size = dst_index;
    170c:	f5 01       	movw	r30, r10
    170e:	51 83       	std	Z+1, r21	; 0x01
    1710:	40 83       	st	Z, r20
	
	// All good
	return VCP_TERM;
    1712:	81 e0       	ldi	r24, 0x01	; 1
    1714:	03 c0       	rjmp	.+6      	; 0x171c <Create_VCP_frame+0xee>
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
		return VCP_NULL_ERR;
    1716:	85 e0       	ldi	r24, 0x05	; 5
    1718:	01 c0       	rjmp	.+2      	; 0x171c <Create_VCP_frame+0xee>

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
		return VCP_ADDR_ERR;
    171a:	86 e0       	ldi	r24, 0x06	; 6
	// Save the frame size
	*dst_size = dst_index;
	
	// All good
	return VCP_TERM;
}
    171c:	0f 90       	pop	r0
    171e:	0f 90       	pop	r0
    1720:	0f 90       	pop	r0
    1722:	df 91       	pop	r29
    1724:	cf 91       	pop	r28
    1726:	1f 91       	pop	r17
    1728:	0f 91       	pop	r16
    172a:	ff 90       	pop	r15
    172c:	ef 90       	pop	r14
    172e:	df 90       	pop	r13
    1730:	cf 90       	pop	r12
    1732:	bf 90       	pop	r11
    1734:	af 90       	pop	r10
    1736:	9f 90       	pop	r9
    1738:	8f 90       	pop	r8
    173a:	7f 90       	pop	r7
    173c:	6f 90       	pop	r6
    173e:	5f 90       	pop	r5
    1740:	4f 90       	pop	r4
    1742:	08 95       	ret

00001744 <Receive_VCP_byte>:
// and return VCP status.
// Parameters:
// vcp_ptrbuffer	*buff -	Pointer to the vcp buffer structure
// uint8			byte -	received byte
uint8_t Receive_VCP_byte(vcp_ptrbuffer *buff, uint8 byte)
{
    1744:	cf 92       	push	r12
    1746:	df 92       	push	r13
    1748:	ef 92       	push	r14
    174a:	ff 92       	push	r15
    174c:	0f 93       	push	r16
    174e:	1f 93       	push	r17
    1750:	cf 93       	push	r28
    1752:	df 93       	push	r29
    1754:	ec 01       	movw	r28, r24
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
    1756:	29 81       	ldd	r18, Y+1	; 0x01
    1758:	3a 81       	ldd	r19, Y+2	; 0x02
    175a:	21 15       	cp	r18, r1
    175c:	31 05       	cpc	r19, r1
    175e:	09 f4       	brne	.+2      	; 0x1762 <Receive_VCP_byte+0x1e>
    1760:	84 c0       	rjmp	.+264    	; 0x186a <Receive_VCP_byte+0x126>
		return VCP_NULL_ERR;
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
    1762:	8f 81       	ldd	r24, Y+7	; 0x07
    1764:	98 85       	ldd	r25, Y+8	; 0x08
    1766:	4d 81       	ldd	r20, Y+5	; 0x05
    1768:	5e 81       	ldd	r21, Y+6	; 0x06
    176a:	41 50       	subi	r20, 0x01	; 1
    176c:	51 09       	sbc	r21, r1
    176e:	84 17       	cp	r24, r20
    1770:	95 07       	cpc	r25, r21
    1772:	08 f0       	brcs	.+2      	; 0x1776 <Receive_VCP_byte+0x32>
    1774:	7c c0       	rjmp	.+248    	; 0x186e <Receive_VCP_byte+0x12a>
		return VCP_OVR_ERR;
	
	// State Machine
	switch (buff->status)
    1776:	49 85       	ldd	r20, Y+9	; 0x09
    1778:	42 30       	cpi	r20, 0x02	; 2
    177a:	39 f1       	breq	.+78     	; 0x17ca <Receive_VCP_byte+0x86>
    177c:	18 f4       	brcc	.+6      	; 0x1784 <Receive_VCP_byte+0x40>
    177e:	44 23       	and	r20, r20
    1780:	31 f0       	breq	.+12     	; 0x178e <Receive_VCP_byte+0x4a>
    1782:	38 c0       	rjmp	.+112    	; 0x17f4 <Receive_VCP_byte+0xb0>
    1784:	40 31       	cpi	r20, 0x10	; 16
    1786:	31 f0       	breq	.+12     	; 0x1794 <Receive_VCP_byte+0x50>
    1788:	40 32       	cpi	r20, 0x20	; 32
    178a:	a1 f5       	brne	.+104    	; 0x17f4 <Receive_VCP_byte+0xb0>
    178c:	0a c0       	rjmp	.+20     	; 0x17a2 <Receive_VCP_byte+0x5e>
	{
		case VCP_IDLE:										
			if (byte == FEND)
    178e:	60 3c       	cpi	r22, 0xC0	; 192
    1790:	91 f5       	brne	.+100    	; 0x17f6 <Receive_VCP_byte+0xb2>
    1792:	0d c0       	rjmp	.+26     	; 0x17ae <Receive_VCP_byte+0x6a>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
    1794:	6c 30       	cpi	r22, 0x0C	; 12
    1796:	18 f0       	brcs	.+6      	; 0x179e <Receive_VCP_byte+0x5a>
    1798:	68 33       	cpi	r22, 0x38	; 56
    179a:	09 f0       	breq	.+2      	; 0x179e <Receive_VCP_byte+0x5a>
    179c:	6a c0       	rjmp	.+212    	; 0x1872 <Receive_VCP_byte+0x12e>
				return VCP_ADDR_ERR;
			else
			{
				buff->address = byte;
    179e:	68 83       	st	Y, r22
    17a0:	26 c0       	rjmp	.+76     	; 0x17ee <Receive_VCP_byte+0xaa>
				buff->status = VCP_RECEIVING;
			}	
			break;
		case VCP_RECEIVING:
			if (byte == FEND)
    17a2:	60 3c       	cpi	r22, 0xC0	; 192
    17a4:	31 f4       	brne	.+12     	; 0x17b2 <Receive_VCP_byte+0x6e>
			{
				if (buff->index > 0)
    17a6:	89 2b       	or	r24, r25
    17a8:	11 f0       	breq	.+4      	; 0x17ae <Receive_VCP_byte+0x6a>
					// Done
					buff->status = VCP_TERM;
    17aa:	81 e0       	ldi	r24, 0x01	; 1
    17ac:	21 c0       	rjmp	.+66     	; 0x17f0 <Receive_VCP_byte+0xac>
				else
					// No data between FENDs - assume lost sync and start over
					buff->status = VCP_ADDRESS;
    17ae:	80 e1       	ldi	r24, 0x10	; 16
    17b0:	1f c0       	rjmp	.+62     	; 0x17f0 <Receive_VCP_byte+0xac>
			}
			else if (byte == FESC)
    17b2:	6b 3d       	cpi	r22, 0xDB	; 219
    17b4:	11 f4       	brne	.+4      	; 0x17ba <Receive_VCP_byte+0x76>
				buff->status = VCP_ESC;
    17b6:	82 e0       	ldi	r24, 0x02	; 2
    17b8:	1b c0       	rjmp	.+54     	; 0x17f0 <Receive_VCP_byte+0xac>
			else
			{
				buff->message[(buff->index)++] = byte;	
    17ba:	f9 01       	movw	r30, r18
    17bc:	e8 0f       	add	r30, r24
    17be:	f9 1f       	adc	r31, r25
    17c0:	60 83       	st	Z, r22
    17c2:	01 96       	adiw	r24, 0x01	; 1
    17c4:	98 87       	std	Y+8, r25	; 0x08
    17c6:	8f 83       	std	Y+7, r24	; 0x07
    17c8:	16 c0       	rjmp	.+44     	; 0x17f6 <Receive_VCP_byte+0xb2>
			}						
			break;
		case VCP_ESC:
			if (byte == TFEND)
    17ca:	6c 3d       	cpi	r22, 0xDC	; 220
    17cc:	29 f4       	brne	.+10     	; 0x17d8 <Receive_VCP_byte+0x94>
			{
				buff->message[(buff->index)++] = FEND;
    17ce:	f9 01       	movw	r30, r18
    17d0:	e8 0f       	add	r30, r24
    17d2:	f9 1f       	adc	r31, r25
    17d4:	40 ec       	ldi	r20, 0xC0	; 192
    17d6:	07 c0       	rjmp	.+14     	; 0x17e6 <Receive_VCP_byte+0xa2>
				buff->status = VCP_RECEIVING;
			}
			else if (byte == TFESC)
    17d8:	6d 3d       	cpi	r22, 0xDD	; 221
    17da:	09 f0       	breq	.+2      	; 0x17de <Receive_VCP_byte+0x9a>
    17dc:	4c c0       	rjmp	.+152    	; 0x1876 <Receive_VCP_byte+0x132>
			{
				buff->message[(buff->index)++] = FESC;
    17de:	f9 01       	movw	r30, r18
    17e0:	e8 0f       	add	r30, r24
    17e2:	f9 1f       	adc	r31, r25
    17e4:	4b ed       	ldi	r20, 0xDB	; 219
    17e6:	40 83       	st	Z, r20
    17e8:	01 96       	adiw	r24, 0x01	; 1
    17ea:	98 87       	std	Y+8, r25	; 0x08
    17ec:	8f 83       	std	Y+7, r24	; 0x07
				buff->status = VCP_RECEIVING;
    17ee:	80 e2       	ldi	r24, 0x20	; 32
    17f0:	89 87       	std	Y+9, r24	; 0x09
    17f2:	01 c0       	rjmp	.+2      	; 0x17f6 <Receive_VCP_byte+0xb2>
			}
			else
				return VCP_ESC_ERR;	
			break;
		default:
			buff->status = VCP_IDLE;
    17f4:	19 86       	std	Y+9, r1	; 0x09
			break; 
	}
	
	// End of frame
	if (buff->status == VCP_TERM)
    17f6:	89 85       	ldd	r24, Y+9	; 0x09
    17f8:	81 30       	cpi	r24, 0x01	; 1
    17fa:	11 f0       	breq	.+4      	; 0x1800 <Receive_VCP_byte+0xbc>
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
    17fc:	89 85       	ldd	r24, Y+9	; 0x09
    17fe:	3c c0       	rjmp	.+120    	; 0x1878 <Receive_VCP_byte+0x134>
	
	// End of frame
	if (buff->status == VCP_TERM)
	{
		// Message CRC is last 2 bytes 
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
    1800:	89 81       	ldd	r24, Y+1	; 0x01
    1802:	9a 81       	ldd	r25, Y+2	; 0x02
    1804:	4f 81       	ldd	r20, Y+7	; 0x07
    1806:	58 85       	ldd	r21, Y+8	; 0x08
    1808:	84 0f       	add	r24, r20
    180a:	95 1f       	adc	r25, r21
    180c:	fc 01       	movw	r30, r24
    180e:	32 97       	sbiw	r30, 0x02	; 2
    1810:	30 81       	ld	r19, Z
    1812:	20 e0       	ldi	r18, 0x00	; 0
    1814:	fc 01       	movw	r30, r24
    1816:	31 97       	sbiw	r30, 0x01	; 1
    1818:	80 81       	ld	r24, Z
    181a:	69 01       	movw	r12, r18
    181c:	c8 0e       	add	r12, r24
    181e:	d1 1c       	adc	r13, r1
		// Remove CRC bytes from the message
		buff->index -= 2;
    1820:	42 50       	subi	r20, 0x02	; 2
    1822:	51 09       	sbc	r21, r1
    1824:	58 87       	std	Y+8, r21	; 0x08
    1826:	4f 83       	std	Y+7, r20	; 0x07
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
    1828:	7e 01       	movw	r14, r28
    182a:	83 e0       	ldi	r24, 0x03	; 3
    182c:	e8 0e       	add	r14, r24
    182e:	f1 1c       	adc	r15, r1
    1830:	b7 01       	movw	r22, r14
    1832:	88 81       	ld	r24, Y
    1834:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <append_crc16>
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    1838:	00 e0       	ldi	r16, 0x00	; 0
    183a:	10 e0       	ldi	r17, 0x00	; 0
    183c:	0a c0       	rjmp	.+20     	; 0x1852 <Receive_VCP_byte+0x10e>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
    183e:	e9 81       	ldd	r30, Y+1	; 0x01
    1840:	fa 81       	ldd	r31, Y+2	; 0x02
    1842:	e0 0f       	add	r30, r16
    1844:	f1 1f       	adc	r31, r17
    1846:	b7 01       	movw	r22, r14
    1848:	80 81       	ld	r24, Z
    184a:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <append_crc16>
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
		// Remove CRC bytes from the message
		buff->index -= 2;
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    184e:	0f 5f       	subi	r16, 0xFF	; 255
    1850:	1f 4f       	sbci	r17, 0xFF	; 255
    1852:	8f 81       	ldd	r24, Y+7	; 0x07
    1854:	98 85       	ldd	r25, Y+8	; 0x08
    1856:	08 17       	cp	r16, r24
    1858:	19 07       	cpc	r17, r25
    185a:	88 f3       	brcs	.-30     	; 0x183e <Receive_VCP_byte+0xfa>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
		}
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
    185c:	8b 81       	ldd	r24, Y+3	; 0x03
    185e:	9c 81       	ldd	r25, Y+4	; 0x04
    1860:	8c 15       	cp	r24, r12
    1862:	9d 05       	cpc	r25, r13
    1864:	59 f2       	breq	.-106    	; 0x17fc <Receive_VCP_byte+0xb8>
			return VCP_CRC_ERR;
    1866:	84 e0       	ldi	r24, 0x04	; 4
    1868:	07 c0       	rjmp	.+14     	; 0x1878 <Receive_VCP_byte+0x134>
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
		return VCP_NULL_ERR;
    186a:	85 e0       	ldi	r24, 0x05	; 5
    186c:	05 c0       	rjmp	.+10     	; 0x1878 <Receive_VCP_byte+0x134>
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
		return VCP_OVR_ERR;
    186e:	83 e0       	ldi	r24, 0x03	; 3
    1870:	03 c0       	rjmp	.+6      	; 0x1878 <Receive_VCP_byte+0x134>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
				return VCP_ADDR_ERR;
    1872:	86 e0       	ldi	r24, 0x06	; 6
    1874:	01 c0       	rjmp	.+2      	; 0x1878 <Receive_VCP_byte+0x134>
			{
				buff->message[(buff->index)++] = FESC;
				buff->status = VCP_RECEIVING;
			}
			else
				return VCP_ESC_ERR;	
    1876:	87 e0       	ldi	r24, 0x07	; 7
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
}
    1878:	df 91       	pop	r29
    187a:	cf 91       	pop	r28
    187c:	1f 91       	pop	r17
    187e:	0f 91       	pop	r16
    1880:	ff 90       	pop	r15
    1882:	ef 90       	pop	r14
    1884:	df 90       	pop	r13
    1886:	cf 90       	pop	r12
    1888:	08 95       	ret

0000188a <tx_put_byte.part.0>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    return;
  if( tel_packet_index[uart] < tel_packet_size[uart] )
    188a:	28 2f       	mov	r18, r24
    188c:	30 e0       	ldi	r19, 0x00	; 0
    188e:	f9 01       	movw	r30, r18
    1890:	ef 5b       	subi	r30, 0xBF	; 191
    1892:	f8 4f       	sbci	r31, 0xF8	; 248
    1894:	60 81       	ld	r22, Z
    1896:	d9 01       	movw	r26, r18
    1898:	aa 0f       	add	r26, r26
    189a:	bb 1f       	adc	r27, r27
    189c:	a7 5d       	subi	r26, 0xD7	; 215
    189e:	bc 4f       	sbci	r27, 0xFC	; 252
    18a0:	4d 91       	ld	r20, X+
    18a2:	5c 91       	ld	r21, X
    18a4:	70 e0       	ldi	r23, 0x00	; 0
    18a6:	64 17       	cp	r22, r20
    18a8:	75 07       	cpc	r23, r21
    18aa:	10 f5       	brcc	.+68     	; 0x18f0 <tx_put_byte.part.0+0x66>
  {
      if ( uart == 0 )
    18ac:	81 11       	cpse	r24, r1
    18ae:	0e c0       	rjmp	.+28     	; 0x18cc <tx_put_byte.part.0+0x42>
      UDR0 = tel_packet[uart][tel_packet_index[uart]++];
    18b0:	80 81       	ld	r24, Z
    18b2:	9f ef       	ldi	r25, 0xFF	; 255
    18b4:	92 9f       	mul	r25, r18
    18b6:	d0 01       	movw	r26, r0
    18b8:	93 9f       	mul	r25, r19
    18ba:	b0 0d       	add	r27, r0
    18bc:	11 24       	eor	r1, r1
    18be:	a8 0f       	add	r26, r24
    18c0:	b1 1d       	adc	r27, r1
    18c2:	a8 5b       	subi	r26, 0xB8	; 184
    18c4:	b8 4f       	sbci	r27, 0xF8	; 248
    18c6:	9c 91       	ld	r25, X
    18c8:	9c b9       	out	0x0c, r25	; 12
    18ca:	10 c0       	rjmp	.+32     	; 0x18ec <tx_put_byte.part.0+0x62>
    else if ( uart == 1 )
    18cc:	81 30       	cpi	r24, 0x01	; 1
    18ce:	81 f4       	brne	.+32     	; 0x18f0 <tx_put_byte.part.0+0x66>
      UDR1 = tel_packet[uart][tel_packet_index[uart]++];
    18d0:	80 81       	ld	r24, Z
    18d2:	9f ef       	ldi	r25, 0xFF	; 255
    18d4:	92 9f       	mul	r25, r18
    18d6:	d0 01       	movw	r26, r0
    18d8:	93 9f       	mul	r25, r19
    18da:	b0 0d       	add	r27, r0
    18dc:	11 24       	eor	r1, r1
    18de:	a8 0f       	add	r26, r24
    18e0:	b1 1d       	adc	r27, r1
    18e2:	a8 5b       	subi	r26, 0xB8	; 184
    18e4:	b8 4f       	sbci	r27, 0xF8	; 248
    18e6:	9c 91       	ld	r25, X
    18e8:	90 93 9c 00 	sts	0x009C, r25
    18ec:	8f 5f       	subi	r24, 0xFF	; 255
    18ee:	80 83       	st	Z, r24
    18f0:	08 95       	ret

000018f2 <__vector_15>:

uint16_t overflow_counter0 = 0;

// ISR(TIMER0_COMP_vect)
ISR(TIMER0_COMP_vect)
{
    18f2:	1f 92       	push	r1
    18f4:	0f 92       	push	r0
    18f6:	0f b6       	in	r0, 0x3f	; 63
    18f8:	0f 92       	push	r0
    18fa:	11 24       	eor	r1, r1
    18fc:	8f 93       	push	r24
    18fe:	9f 93       	push	r25
	overflow_counter0 = overflow_counter0 + 1;
    1900:	80 91 07 03 	lds	r24, 0x0307
    1904:	90 91 08 03 	lds	r25, 0x0308
    1908:	01 96       	adiw	r24, 0x01	; 1
    190a:	90 93 08 03 	sts	0x0308, r25
    190e:	80 93 07 03 	sts	0x0307, r24
	
	if(overflow_counter0 >= 100){
    1912:	84 36       	cpi	r24, 0x64	; 100
    1914:	91 05       	cpc	r25, r1
    1916:	48 f0       	brcs	.+18     	; 0x192a <__vector_15+0x38>
		PORTF ^= 0xFF;
    1918:	80 91 62 00 	lds	r24, 0x0062
    191c:	80 95       	com	r24
    191e:	80 93 62 00 	sts	0x0062, r24
		overflow_counter0 = 0;
    1922:	10 92 08 03 	sts	0x0308, r1
    1926:	10 92 07 03 	sts	0x0307, r1
	//if (cntr == 0)
	//	PORTC |= 0x01;
	//else
	//	PORTC &= 0xFE;
	//_delay_ms(500);
}
    192a:	9f 91       	pop	r25
    192c:	8f 91       	pop	r24
    192e:	0f 90       	pop	r0
    1930:	0f be       	out	0x3f, r0	; 63
    1932:	0f 90       	pop	r0
    1934:	1f 90       	pop	r1
    1936:	18 95       	reti

00001938 <__vector_12>:

/* Timer 1(A) routine */
//2s per interrupt
ISR(TIMER1_COMPA_vect)		//Handle Radio & Torquer 30 min delays here; handle 10 min CDH-IB no heartbeat restart
{
    1938:	1f 92       	push	r1
    193a:	0f 92       	push	r0
    193c:	0f b6       	in	r0, 0x3f	; 63
    193e:	0f 92       	push	r0
    1940:	11 24       	eor	r1, r1
    1942:	0b b6       	in	r0, 0x3b	; 59
    1944:	0f 92       	push	r0
    1946:	2f 93       	push	r18
    1948:	3f 93       	push	r19
    194a:	4f 93       	push	r20
    194c:	5f 93       	push	r21
    194e:	6f 93       	push	r22
    1950:	7f 93       	push	r23
    1952:	8f 93       	push	r24
    1954:	9f 93       	push	r25
    1956:	af 93       	push	r26
    1958:	bf 93       	push	r27
    195a:	cf 93       	push	r28
    195c:	ef 93       	push	r30
    195e:	ff 93       	push	r31
	SVIT_t *component;
	
	//Testing that ISR fires
	//PORTF ^= 0xFF;
		
	if (timer1_counter[0] <= 0	  &&     rad_torq_flag){	//provides 30 minute delay			
    1960:	80 91 9c 0d 	lds	r24, 0x0D9C
    1964:	81 11       	cpse	r24, r1
    1966:	30 c0       	rjmp	.+96     	; 0x19c8 <__vector_12+0x90>
    1968:	80 91 0d 03 	lds	r24, 0x030D
    196c:	88 23       	and	r24, r24
    196e:	61 f1       	breq	.+88     	; 0x19c8 <__vector_12+0x90>
	//if ( receive_flag == 1){		//If message is received, reset timer1_counter[0] to CYCLE_COUNTER
	    timer1_counter[0] = CYCLE_COUNTER;
    1970:	c1 e0       	ldi	r28, 0x01	; 1
    1972:	c0 93 9c 0d 	sts	0x0D9C, r28
		//PORTF ^= 0xFF;	//LED for STK testing
		//PORTC ^= 0x01;
		
		//Turn on radios
		component = &svit[RADIO_1];
		switch_on( component->switch_num );
    1976:	80 91 6d 04 	lds	r24, 0x046D
    197a:	0e 94 ff 08 	call	0x11fe	; 0x11fe <switch_on>
		component->switch_state = SW_ON;
    197e:	c0 93 6e 04 	sts	0x046E, r28
		component = &svit[RADIO_2];
		switch_on( component->switch_num );
    1982:	80 91 89 04 	lds	r24, 0x0489
    1986:	0e 94 ff 08 	call	0x11fe	; 0x11fe <switch_on>
		component->switch_state = SW_ON;
    198a:	c0 93 8a 04 	sts	0x048A, r28
		
		//Turn on torque coils			
		component = &svit[TORQUER_1];
		switch_on( component->switch_num );
    198e:	80 91 15 05 	lds	r24, 0x0515
    1992:	0e 94 ff 08 	call	0x11fe	; 0x11fe <switch_on>
		component->switch_state = SW_ON;
    1996:	c0 93 16 05 	sts	0x0516, r28
		component = &svit[TORQUER_2];
		switch_on( component->switch_num );
    199a:	80 91 31 05 	lds	r24, 0x0531
    199e:	0e 94 ff 08 	call	0x11fe	; 0x11fe <switch_on>
		component->switch_state = SW_ON;
    19a2:	c0 93 32 05 	sts	0x0532, r28
		component = &svit[TORQUER_3];
		switch_on( component->switch_num );
    19a6:	80 91 4d 05 	lds	r24, 0x054D
    19aa:	0e 94 ff 08 	call	0x11fe	; 0x11fe <switch_on>
		component->switch_state = SW_ON;
    19ae:	c0 93 4e 05 	sts	0x054E, r28
		torquer_on(TORQUER_1);
    19b2:	81 e1       	ldi	r24, 0x11	; 17
    19b4:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <torquer_on>
		torquer_on(TORQUER_2);
    19b8:	82 e1       	ldi	r24, 0x12	; 18
    19ba:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <torquer_on>
		torquer_on(TORQUER_3);
    19be:	83 e1       	ldi	r24, 0x13	; 19
    19c0:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <torquer_on>
		
		//Don't reexecute this code
		rad_torq_flag = 0;
    19c4:	10 92 0d 03 	sts	0x030D, r1
	}
	
	if (timer1_counter[1] <= 0   &&   !cdh_heartbeat_flag){		//If heartbeat timer 1 has expired AND we haven't already ordered a restart
    19c8:	80 91 9d 0d 	lds	r24, 0x0D9D
    19cc:	81 11       	cpse	r24, r1
    19ce:	07 c0       	rjmp	.+14     	; 0x19de <__vector_12+0xa6>
    19d0:	80 91 24 03 	lds	r24, 0x0324
    19d4:	81 11       	cpse	r24, r1
    19d6:	03 c0       	rjmp	.+6      	; 0x19de <__vector_12+0xa6>
		//Order full component restart
		cdh_heartbeat_flag = 1;
    19d8:	81 e0       	ldi	r24, 0x01	; 1
    19da:	80 93 24 03 	sts	0x0324, r24
		
	}
	
	//else{
		//_delay_ms(500);
		--timer1_counter[0];
    19de:	80 91 9c 0d 	lds	r24, 0x0D9C
    19e2:	81 50       	subi	r24, 0x01	; 1
    19e4:	80 93 9c 0d 	sts	0x0D9C, r24
		--timer1_counter[1];
    19e8:	80 91 9d 0d 	lds	r24, 0x0D9D
    19ec:	81 50       	subi	r24, 0x01	; 1
    19ee:	80 93 9d 0d 	sts	0x0D9D, r24
	//}
}
    19f2:	ff 91       	pop	r31
    19f4:	ef 91       	pop	r30
    19f6:	cf 91       	pop	r28
    19f8:	bf 91       	pop	r27
    19fa:	af 91       	pop	r26
    19fc:	9f 91       	pop	r25
    19fe:	8f 91       	pop	r24
    1a00:	7f 91       	pop	r23
    1a02:	6f 91       	pop	r22
    1a04:	5f 91       	pop	r21
    1a06:	4f 91       	pop	r20
    1a08:	3f 91       	pop	r19
    1a0a:	2f 91       	pop	r18
    1a0c:	0f 90       	pop	r0
    1a0e:	0b be       	out	0x3b, r0	; 59
    1a10:	0f 90       	pop	r0
    1a12:	0f be       	out	0x3f, r0	; 63
    1a14:	0f 90       	pop	r0
    1a16:	1f 90       	pop	r1
    1a18:	18 95       	reti

00001a1a <__vector_32>:

ISR(USART1_TX_vect)
{
    1a1a:	1f 92       	push	r1
    1a1c:	0f 92       	push	r0
    1a1e:	0f b6       	in	r0, 0x3f	; 63
    1a20:	0f 92       	push	r0
    1a22:	11 24       	eor	r1, r1
    1a24:	0b b6       	in	r0, 0x3b	; 59
    1a26:	0f 92       	push	r0
    1a28:	2f 93       	push	r18
    1a2a:	3f 93       	push	r19
    1a2c:	4f 93       	push	r20
    1a2e:	5f 93       	push	r21
    1a30:	6f 93       	push	r22
    1a32:	7f 93       	push	r23
    1a34:	8f 93       	push	r24
    1a36:	9f 93       	push	r25
    1a38:	af 93       	push	r26
    1a3a:	bf 93       	push	r27
    1a3c:	ef 93       	push	r30
    1a3e:	ff 93       	push	r31
    1a40:	81 e0       	ldi	r24, 0x01	; 1
    1a42:	0e 94 45 0c 	call	0x188a	; 0x188a <tx_put_byte.part.0>
  tx_put_byte( 1 );
}
    1a46:	ff 91       	pop	r31
    1a48:	ef 91       	pop	r30
    1a4a:	bf 91       	pop	r27
    1a4c:	af 91       	pop	r26
    1a4e:	9f 91       	pop	r25
    1a50:	8f 91       	pop	r24
    1a52:	7f 91       	pop	r23
    1a54:	6f 91       	pop	r22
    1a56:	5f 91       	pop	r21
    1a58:	4f 91       	pop	r20
    1a5a:	3f 91       	pop	r19
    1a5c:	2f 91       	pop	r18
    1a5e:	0f 90       	pop	r0
    1a60:	0b be       	out	0x3b, r0	; 59
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63
    1a66:	0f 90       	pop	r0
    1a68:	1f 90       	pop	r1
    1a6a:	18 95       	reti

00001a6c <__vector_30>:

ISR(USART1_RX_vect)
{
    1a6c:	1f 92       	push	r1
    1a6e:	0f 92       	push	r0
    1a70:	0f b6       	in	r0, 0x3f	; 63
    1a72:	0f 92       	push	r0
    1a74:	11 24       	eor	r1, r1
    1a76:	0b b6       	in	r0, 0x3b	; 59
    1a78:	0f 92       	push	r0
    1a7a:	2f 93       	push	r18
    1a7c:	3f 93       	push	r19
    1a7e:	4f 93       	push	r20
    1a80:	5f 93       	push	r21
    1a82:	6f 93       	push	r22
    1a84:	7f 93       	push	r23
    1a86:	8f 93       	push	r24
    1a88:	9f 93       	push	r25
    1a8a:	af 93       	push	r26
    1a8c:	bf 93       	push	r27
    1a8e:	ef 93       	push	r30
    1a90:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[1], UDR1 ) == VCP_TERM )
    1a92:	60 91 9c 00 	lds	r22, 0x009C
    1a96:	80 91 a6 0d 	lds	r24, 0x0DA6
    1a9a:	90 91 a7 0d 	lds	r25, 0x0DA7
    1a9e:	0e 94 a2 0b 	call	0x1744	; 0x1744 <Receive_VCP_byte>
    1aa2:	81 30       	cpi	r24, 0x01	; 1
    1aa4:	29 f4       	brne	.+10     	; 0x1ab0 <__vector_30+0x44>
  {
    rx_flag[1]++;
    1aa6:	80 91 aa 0d 	lds	r24, 0x0DAA
    1aaa:	8f 5f       	subi	r24, 0xFF	; 255
    1aac:	80 93 aa 0d 	sts	0x0DAA, r24
  }
}
    1ab0:	ff 91       	pop	r31
    1ab2:	ef 91       	pop	r30
    1ab4:	bf 91       	pop	r27
    1ab6:	af 91       	pop	r26
    1ab8:	9f 91       	pop	r25
    1aba:	8f 91       	pop	r24
    1abc:	7f 91       	pop	r23
    1abe:	6f 91       	pop	r22
    1ac0:	5f 91       	pop	r21
    1ac2:	4f 91       	pop	r20
    1ac4:	3f 91       	pop	r19
    1ac6:	2f 91       	pop	r18
    1ac8:	0f 90       	pop	r0
    1aca:	0b be       	out	0x3b, r0	; 59
    1acc:	0f 90       	pop	r0
    1ace:	0f be       	out	0x3f, r0	; 63
    1ad0:	0f 90       	pop	r0
    1ad2:	1f 90       	pop	r1
    1ad4:	18 95       	reti

00001ad6 <__vector_21>:

ISR ( ADC_vect )
{
    1ad6:	1f 92       	push	r1
    1ad8:	0f 92       	push	r0
    1ada:	0f b6       	in	r0, 0x3f	; 63
    1adc:	0f 92       	push	r0
    1ade:	11 24       	eor	r1, r1
    1ae0:	8f 93       	push	r24
  ADC_low = ADCL;	// Left adjusted; read 2 LSB then 8 MSB
    1ae2:	84 b1       	in	r24, 0x04	; 4
    1ae4:	80 93 9e 0d 	sts	0x0D9E, r24
  ADC_high = ADCH;
    1ae8:	85 b1       	in	r24, 0x05	; 5
    1aea:	80 93 65 09 	sts	0x0965, r24
  adc_flag = 1;
    1aee:	81 e0       	ldi	r24, 0x01	; 1
    1af0:	80 93 47 09 	sts	0x0947, r24
}
    1af4:	8f 91       	pop	r24
    1af6:	0f 90       	pop	r0
    1af8:	0f be       	out	0x3f, r0	; 63
    1afa:	0f 90       	pop	r0
    1afc:	1f 90       	pop	r1
    1afe:	18 95       	reti

00001b00 <__vector_20>:

ISR( USART0_TX_vect )
{
    1b00:	1f 92       	push	r1
    1b02:	0f 92       	push	r0
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	0f 92       	push	r0
    1b08:	11 24       	eor	r1, r1
    1b0a:	0b b6       	in	r0, 0x3b	; 59
    1b0c:	0f 92       	push	r0
    1b0e:	2f 93       	push	r18
    1b10:	3f 93       	push	r19
    1b12:	4f 93       	push	r20
    1b14:	5f 93       	push	r21
    1b16:	6f 93       	push	r22
    1b18:	7f 93       	push	r23
    1b1a:	8f 93       	push	r24
    1b1c:	9f 93       	push	r25
    1b1e:	af 93       	push	r26
    1b20:	bf 93       	push	r27
    1b22:	ef 93       	push	r30
    1b24:	ff 93       	push	r31
    1b26:	80 e0       	ldi	r24, 0x00	; 0
    1b28:	0e 94 45 0c 	call	0x188a	; 0x188a <tx_put_byte.part.0>
  tx_put_byte( 0 );
}
    1b2c:	ff 91       	pop	r31
    1b2e:	ef 91       	pop	r30
    1b30:	bf 91       	pop	r27
    1b32:	af 91       	pop	r26
    1b34:	9f 91       	pop	r25
    1b36:	8f 91       	pop	r24
    1b38:	7f 91       	pop	r23
    1b3a:	6f 91       	pop	r22
    1b3c:	5f 91       	pop	r21
    1b3e:	4f 91       	pop	r20
    1b40:	3f 91       	pop	r19
    1b42:	2f 91       	pop	r18
    1b44:	0f 90       	pop	r0
    1b46:	0b be       	out	0x3b, r0	; 59
    1b48:	0f 90       	pop	r0
    1b4a:	0f be       	out	0x3f, r0	; 63
    1b4c:	0f 90       	pop	r0
    1b4e:	1f 90       	pop	r1
    1b50:	18 95       	reti

00001b52 <__vector_18>:

ISR( USART0_RX_vect )
{
    1b52:	1f 92       	push	r1
    1b54:	0f 92       	push	r0
    1b56:	0f b6       	in	r0, 0x3f	; 63
    1b58:	0f 92       	push	r0
    1b5a:	11 24       	eor	r1, r1
    1b5c:	0b b6       	in	r0, 0x3b	; 59
    1b5e:	0f 92       	push	r0
    1b60:	2f 93       	push	r18
    1b62:	3f 93       	push	r19
    1b64:	4f 93       	push	r20
    1b66:	5f 93       	push	r21
    1b68:	6f 93       	push	r22
    1b6a:	7f 93       	push	r23
    1b6c:	8f 93       	push	r24
    1b6e:	9f 93       	push	r25
    1b70:	af 93       	push	r26
    1b72:	bf 93       	push	r27
    1b74:	ef 93       	push	r30
    1b76:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[0], UDR0 ) == VCP_TERM )
    1b78:	6c b1       	in	r22, 0x0c	; 12
    1b7a:	80 91 a4 0d 	lds	r24, 0x0DA4
    1b7e:	90 91 a5 0d 	lds	r25, 0x0DA5
    1b82:	0e 94 a2 0b 	call	0x1744	; 0x1744 <Receive_VCP_byte>
    1b86:	81 30       	cpi	r24, 0x01	; 1
    1b88:	29 f4       	brne	.+10     	; 0x1b94 <__vector_18+0x42>
  {
    rx_flag[0]++;
    1b8a:	80 91 a9 0d 	lds	r24, 0x0DA9
    1b8e:	8f 5f       	subi	r24, 0xFF	; 255
    1b90:	80 93 a9 0d 	sts	0x0DA9, r24
  }
}
    1b94:	ff 91       	pop	r31
    1b96:	ef 91       	pop	r30
    1b98:	bf 91       	pop	r27
    1b9a:	af 91       	pop	r26
    1b9c:	9f 91       	pop	r25
    1b9e:	8f 91       	pop	r24
    1ba0:	7f 91       	pop	r23
    1ba2:	6f 91       	pop	r22
    1ba4:	5f 91       	pop	r21
    1ba6:	4f 91       	pop	r20
    1ba8:	3f 91       	pop	r19
    1baa:	2f 91       	pop	r18
    1bac:	0f 90       	pop	r0
    1bae:	0b be       	out	0x3b, r0	; 59
    1bb0:	0f 90       	pop	r0
    1bb2:	0f be       	out	0x3f, r0	; 63
    1bb4:	0f 90       	pop	r0
    1bb6:	1f 90       	pop	r1
    1bb8:	18 95       	reti

00001bba <tx_put_byte>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    1bba:	82 30       	cpi	r24, 0x02	; 2
    1bbc:	10 f4       	brcc	.+4      	; 0x1bc2 <tx_put_byte+0x8>
    1bbe:	0c 94 45 0c 	jmp	0x188a	; 0x188a <tx_put_byte.part.0>
    1bc2:	08 95       	ret

00001bc4 <construct_telemetry_packet>:
  }
}


void construct_telemetry_packet( uint8_t* packet_payload )
{
    1bc4:	2f 92       	push	r2
    1bc6:	3f 92       	push	r3
    1bc8:	4f 92       	push	r4
    1bca:	5f 92       	push	r5
    1bcc:	6f 92       	push	r6
    1bce:	7f 92       	push	r7
    1bd0:	8f 92       	push	r8
    1bd2:	9f 92       	push	r9
    1bd4:	af 92       	push	r10
    1bd6:	bf 92       	push	r11
    1bd8:	cf 92       	push	r12
    1bda:	df 92       	push	r13
    1bdc:	ef 92       	push	r14
    1bde:	ff 92       	push	r15
    1be0:	0f 93       	push	r16
    1be2:	1f 93       	push	r17
    1be4:	cf 93       	push	r28
    1be6:	df 93       	push	r29
    1be8:	cd b7       	in	r28, 0x3d	; 61
    1bea:	de b7       	in	r29, 0x3e	; 62
    1bec:	28 97       	sbiw	r28, 0x08	; 8
    1bee:	0f b6       	in	r0, 0x3f	; 63
    1bf0:	f8 94       	cli
    1bf2:	de bf       	out	0x3e, r29	; 62
    1bf4:	0f be       	out	0x3f, r0	; 63
    1bf6:	cd bf       	out	0x3d, r28	; 61
    1bf8:	98 87       	std	Y+8, r25	; 0x08
    1bfa:	8f 83       	std	Y+7, r24	; 0x07
  packet_payload[0] = VCP_POWER_TELEMETRY;
    1bfc:	dc 01       	movw	r26, r24
    1bfe:	1c 92       	st	X, r1
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
    1c00:	30 91 52 04 	lds	r19, 0x0452
    1c04:	33 0f       	add	r19, r19
                  ( svit[RADIO_1].switch_state << 2 )    |
    1c06:	80 91 6e 04 	lds	r24, 0x046E
    1c0a:	b4 e0       	ldi	r27, 0x04	; 4
    1c0c:	8b 9f       	mul	r24, r27
    1c0e:	c0 01       	movw	r24, r0
    1c10:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1c12:	38 2b       	or	r19, r24
    1c14:	80 91 36 04 	lds	r24, 0x0436
    1c18:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
    1c1a:	80 91 8a 04 	lds	r24, 0x048A
    1c1e:	e8 e0       	ldi	r30, 0x08	; 8
    1c20:	8e 9f       	mul	r24, r30
    1c22:	c0 01       	movw	r24, r0
    1c24:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1c26:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
    1c28:	80 91 de 04 	lds	r24, 0x04DE
    1c2c:	f0 e1       	ldi	r31, 0x10	; 16
    1c2e:	8f 9f       	mul	r24, r31
    1c30:	c0 01       	movw	r24, r0
    1c32:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1c34:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;
    1c36:	80 91 fa 04 	lds	r24, 0x04FA
    1c3a:	20 e2       	ldi	r18, 0x20	; 32
    1c3c:	82 9f       	mul	r24, r18
    1c3e:	c0 01       	movw	r24, r0
    1c40:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1c42:	38 2b       	or	r19, r24
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
    1c44:	40 91 32 05 	lds	r20, 0x0532
    1c48:	44 0f       	add	r20, r20
                  ( svit[TORQUER_3].switch_state << 2 ) |
    1c4a:	80 91 4e 05 	lds	r24, 0x054E
    1c4e:	54 e0       	ldi	r21, 0x04	; 4
    1c50:	85 9f       	mul	r24, r21
    1c52:	c0 01       	movw	r24, r0
    1c54:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1c56:	48 2b       	or	r20, r24
    1c58:	80 91 16 05 	lds	r24, 0x0516
    1c5c:	48 2b       	or	r20, r24
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );
    1c5e:	e6 ea       	ldi	r30, 0xA6	; 166
    1c60:	f4 e0       	ldi	r31, 0x04	; 4
    1c62:	80 81       	ld	r24, Z
    1c64:	a8 e0       	ldi	r26, 0x08	; 8
    1c66:	8a 9f       	mul	r24, r26
    1c68:	c0 01       	movw	r24, r0
    1c6a:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1c6c:	48 2b       	or	r20, r24
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
    1c6e:	20 91 56 03 	lds	r18, 0x0356
    1c72:	22 0f       	add	r18, r18
                  ( svit[FC_5V].switch_state << 2 )        |
    1c74:	80 91 72 03 	lds	r24, 0x0372
    1c78:	b4 e0       	ldi	r27, 0x04	; 4
    1c7a:	8b 9f       	mul	r24, r27
    1c7c:	c0 01       	movw	r24, r0
    1c7e:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1c80:	28 2b       	or	r18, r24
    1c82:	80 91 3a 03 	lds	r24, 0x033A
    1c86:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
    1c88:	80 91 aa 03 	lds	r24, 0x03AA
    1c8c:	58 e0       	ldi	r21, 0x08	; 8
    1c8e:	85 9f       	mul	r24, r21
    1c90:	c0 01       	movw	r24, r0
    1c92:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1c94:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
    1c96:	80 91 c6 03 	lds	r24, 0x03C6
    1c9a:	a0 e1       	ldi	r26, 0x10	; 16
    1c9c:	8a 9f       	mul	r24, r26
    1c9e:	c0 01       	movw	r24, r0
    1ca0:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1ca2:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
    1ca4:	80 91 e2 03 	lds	r24, 0x03E2
    1ca8:	b0 e2       	ldi	r27, 0x20	; 32
    1caa:	8b 9f       	mul	r24, r27
    1cac:	c0 01       	movw	r24, r0
    1cae:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1cb0:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
    1cb2:	80 91 fe 03 	lds	r24, 0x03FE
    1cb6:	50 e4       	ldi	r21, 0x40	; 64
    1cb8:	85 9f       	mul	r24, r21
    1cba:	c0 01       	movw	r24, r0
    1cbc:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1cbe:	28 2b       	or	r18, r24
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;
    1cc0:	80 91 1a 04 	lds	r24, 0x041A
    1cc4:	a0 e8       	ldi	r26, 0x80	; 128
    1cc6:	8a 9f       	mul	r24, r26
    1cc8:	c0 01       	movw	r24, r0
    1cca:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1ccc:	28 2b       	or	r18, r24
  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );

  packet_payload[1] = on_off_state0;
    1cce:	af 81       	ldd	r26, Y+7	; 0x07
    1cd0:	b8 85       	ldd	r27, Y+8	; 0x08
    1cd2:	11 96       	adiw	r26, 0x01	; 1
    1cd4:	2c 93       	st	X, r18
    1cd6:	11 97       	sbiw	r26, 0x01	; 1
  packet_payload[2] = on_off_state1;
    1cd8:	12 96       	adiw	r26, 0x02	; 2
    1cda:	3c 93       	st	X, r19
    1cdc:	12 97       	sbiw	r26, 0x02	; 2
  packet_payload[3] = on_off_state2;
    1cde:	13 96       	adiw	r26, 0x03	; 3
    1ce0:	4c 93       	st	X, r20
    1ce2:	13 97       	sbiw	r26, 0x03	; 3
  packet_payload[4] = 0x99;
    1ce4:	89 e9       	ldi	r24, 0x99	; 153
    1ce6:	14 96       	adiw	r26, 0x04	; 4
    1ce8:	8c 93       	st	X, r24
    1cea:	14 97       	sbiw	r26, 0x04	; 4
  packet_payload[5] = svit[MAESTRO].switch_state;
    1cec:	80 81       	ld	r24, Z
    1cee:	15 96       	adiw	r26, 0x05	; 5
    1cf0:	8c 93       	st	X, r24

  // voltage values (raw ADC output)
  packet_payload[6]  = SVIT_check_V_critical( svit[SPECTROMETER].name );
    1cf2:	28 e3       	ldi	r18, 0x38	; 56
    1cf4:	62 2e       	mov	r6, r18
    1cf6:	23 e0       	ldi	r18, 0x03	; 3
    1cf8:	72 2e       	mov	r7, r18
    1cfa:	f3 01       	movw	r30, r6
    1cfc:	80 81       	ld	r24, Z
    1cfe:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1d02:	af 81       	ldd	r26, Y+7	; 0x07
    1d04:	b8 85       	ldd	r27, Y+8	; 0x08
    1d06:	16 96       	adiw	r26, 0x06	; 6
    1d08:	8c 93       	st	X, r24
  packet_payload[7]  = SVIT_check_V_critical( svit[STAR_TRACKER].name );
    1d0a:	34 e5       	ldi	r19, 0x54	; 84
    1d0c:	83 2e       	mov	r8, r19
    1d0e:	33 e0       	ldi	r19, 0x03	; 3
    1d10:	93 2e       	mov	r9, r19
    1d12:	f4 01       	movw	r30, r8
    1d14:	80 81       	ld	r24, Z
    1d16:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1d1a:	af 81       	ldd	r26, Y+7	; 0x07
    1d1c:	b8 85       	ldd	r27, Y+8	; 0x08
    1d1e:	17 96       	adiw	r26, 0x07	; 7
    1d20:	8c 93       	st	X, r24
  packet_payload[8]  = SVIT_check_V_critical( svit[FC_5V].name );
    1d22:	40 e7       	ldi	r20, 0x70	; 112
    1d24:	a4 2e       	mov	r10, r20
    1d26:	43 e0       	ldi	r20, 0x03	; 3
    1d28:	b4 2e       	mov	r11, r20
    1d2a:	f5 01       	movw	r30, r10
    1d2c:	80 81       	ld	r24, Z
    1d2e:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1d32:	af 81       	ldd	r26, Y+7	; 0x07
    1d34:	b8 85       	ldd	r27, Y+8	; 0x08
    1d36:	18 96       	adiw	r26, 0x08	; 8
    1d38:	8c 93       	st	X, r24
  packet_payload[9]  = SVIT_check_V_critical( svit[FC_3_3V].name );
    1d3a:	5c e8       	ldi	r21, 0x8C	; 140
    1d3c:	c5 2e       	mov	r12, r21
    1d3e:	53 e0       	ldi	r21, 0x03	; 3
    1d40:	d5 2e       	mov	r13, r21
    1d42:	f6 01       	movw	r30, r12
    1d44:	80 81       	ld	r24, Z
    1d46:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1d4a:	af 81       	ldd	r26, Y+7	; 0x07
    1d4c:	b8 85       	ldd	r27, Y+8	; 0x08
    1d4e:	19 96       	adiw	r26, 0x09	; 9
    1d50:	8c 93       	st	X, r24
  packet_payload[10] = SVIT_check_V_critical( svit[GPS_1].name );
    1d52:	68 ea       	ldi	r22, 0xA8	; 168
    1d54:	e6 2e       	mov	r14, r22
    1d56:	63 e0       	ldi	r22, 0x03	; 3
    1d58:	f6 2e       	mov	r15, r22
    1d5a:	f7 01       	movw	r30, r14
    1d5c:	80 81       	ld	r24, Z
    1d5e:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1d62:	af 81       	ldd	r26, Y+7	; 0x07
    1d64:	b8 85       	ldd	r27, Y+8	; 0x08
    1d66:	1a 96       	adiw	r26, 0x0a	; 10
    1d68:	8c 93       	st	X, r24
  packet_payload[11] = SVIT_check_V_critical( svit[CDH_IB].name );
    1d6a:	00 ee       	ldi	r16, 0xE0	; 224
    1d6c:	13 e0       	ldi	r17, 0x03	; 3
    1d6e:	f8 01       	movw	r30, r16
    1d70:	80 81       	ld	r24, Z
    1d72:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1d76:	af 81       	ldd	r26, Y+7	; 0x07
    1d78:	b8 85       	ldd	r27, Y+8	; 0x08
    1d7a:	1b 96       	adiw	r26, 0x0b	; 11
    1d7c:	8c 93       	st	X, r24
  packet_payload[12] = SVIT_check_V_critical( svit[HEATER_1].name );
    1d7e:	ec ef       	ldi	r30, 0xFC	; 252
    1d80:	f3 e0       	ldi	r31, 0x03	; 3
    1d82:	80 81       	ld	r24, Z
    1d84:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1d88:	af 81       	ldd	r26, Y+7	; 0x07
    1d8a:	b8 85       	ldd	r27, Y+8	; 0x08
    1d8c:	1c 96       	adiw	r26, 0x0c	; 12
    1d8e:	8c 93       	st	X, r24
  packet_payload[13] = SVIT_check_V_critical( svit[HEATER_2].name );
    1d90:	78 e1       	ldi	r23, 0x18	; 24
    1d92:	47 2e       	mov	r4, r23
    1d94:	74 e0       	ldi	r23, 0x04	; 4
    1d96:	57 2e       	mov	r5, r23
    1d98:	f2 01       	movw	r30, r4
    1d9a:	80 81       	ld	r24, Z
    1d9c:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1da0:	af 81       	ldd	r26, Y+7	; 0x07
    1da2:	b8 85       	ldd	r27, Y+8	; 0x08
    1da4:	1d 96       	adiw	r26, 0x0d	; 13
    1da6:	8c 93       	st	X, r24
  packet_payload[14] = SVIT_check_V_critical( svit[CMG].name );
    1da8:	e4 e3       	ldi	r30, 0x34	; 52
    1daa:	2e 2e       	mov	r2, r30
    1dac:	e4 e0       	ldi	r30, 0x04	; 4
    1dae:	3e 2e       	mov	r3, r30
    1db0:	f1 01       	movw	r30, r2
    1db2:	80 81       	ld	r24, Z
    1db4:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1db8:	af 81       	ldd	r26, Y+7	; 0x07
    1dba:	b8 85       	ldd	r27, Y+8	; 0x08
    1dbc:	1e 96       	adiw	r26, 0x0e	; 14
    1dbe:	8c 93       	st	X, r24
  packet_payload[15] = SVIT_check_V_critical( svit[SUN_SENSOR].name );
    1dc0:	20 e5       	ldi	r18, 0x50	; 80
    1dc2:	34 e0       	ldi	r19, 0x04	; 4
    1dc4:	f9 01       	movw	r30, r18
    1dc6:	80 81       	ld	r24, Z
    1dc8:	29 83       	std	Y+1, r18	; 0x01
    1dca:	3a 83       	std	Y+2, r19	; 0x02
    1dcc:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1dd0:	af 81       	ldd	r26, Y+7	; 0x07
    1dd2:	b8 85       	ldd	r27, Y+8	; 0x08
    1dd4:	1f 96       	adiw	r26, 0x0f	; 15
    1dd6:	8c 93       	st	X, r24
  packet_payload[16] = SVIT_check_V_critical( svit[RADIO_1].name );
    1dd8:	4c e6       	ldi	r20, 0x6C	; 108
    1dda:	54 e0       	ldi	r21, 0x04	; 4
    1ddc:	fa 01       	movw	r30, r20
    1dde:	80 81       	ld	r24, Z
    1de0:	4b 83       	std	Y+3, r20	; 0x03
    1de2:	5c 83       	std	Y+4, r21	; 0x04
    1de4:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1de8:	af 81       	ldd	r26, Y+7	; 0x07
    1dea:	b8 85       	ldd	r27, Y+8	; 0x08
    1dec:	50 96       	adiw	r26, 0x10	; 16
    1dee:	8c 93       	st	X, r24
  packet_payload[17] = SVIT_check_V_critical( svit[RADIO_2].name );
    1df0:	68 e8       	ldi	r22, 0x88	; 136
    1df2:	74 e0       	ldi	r23, 0x04	; 4
    1df4:	fb 01       	movw	r30, r22
    1df6:	80 81       	ld	r24, Z
    1df8:	6d 83       	std	Y+5, r22	; 0x05
    1dfa:	7e 83       	std	Y+6, r23	; 0x06
    1dfc:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1e00:	af 81       	ldd	r26, Y+7	; 0x07
    1e02:	b8 85       	ldd	r27, Y+8	; 0x08
    1e04:	51 96       	adiw	r26, 0x11	; 17
    1e06:	8c 93       	st	X, r24
  packet_payload[18] = SVIT_check_V_critical( svit[FOG_15V].name );
    1e08:	ec ed       	ldi	r30, 0xDC	; 220
    1e0a:	f4 e0       	ldi	r31, 0x04	; 4
    1e0c:	80 81       	ld	r24, Z
    1e0e:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1e12:	af 81       	ldd	r26, Y+7	; 0x07
    1e14:	b8 85       	ldd	r27, Y+8	; 0x08
    1e16:	52 96       	adiw	r26, 0x12	; 18
    1e18:	8c 93       	st	X, r24
  packet_payload[19] = SVIT_check_V_critical( svit[FOG_5V].name );
    1e1a:	e8 ef       	ldi	r30, 0xF8	; 248
    1e1c:	f4 e0       	ldi	r31, 0x04	; 4
    1e1e:	80 81       	ld	r24, Z
    1e20:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1e24:	af 81       	ldd	r26, Y+7	; 0x07
    1e26:	b8 85       	ldd	r27, Y+8	; 0x08
    1e28:	53 96       	adiw	r26, 0x13	; 19
    1e2a:	8c 93       	st	X, r24
  packet_payload[20] = SVIT_check_V_critical( svit[TORQUER_1].name );
    1e2c:	e4 e1       	ldi	r30, 0x14	; 20
    1e2e:	f5 e0       	ldi	r31, 0x05	; 5
    1e30:	80 81       	ld	r24, Z
    1e32:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1e36:	af 81       	ldd	r26, Y+7	; 0x07
    1e38:	b8 85       	ldd	r27, Y+8	; 0x08
    1e3a:	54 96       	adiw	r26, 0x14	; 20
    1e3c:	8c 93       	st	X, r24
  packet_payload[21] = SVIT_check_V_critical( svit[TORQUER_2].name );
    1e3e:	e0 e3       	ldi	r30, 0x30	; 48
    1e40:	f5 e0       	ldi	r31, 0x05	; 5
    1e42:	80 81       	ld	r24, Z
    1e44:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1e48:	af 81       	ldd	r26, Y+7	; 0x07
    1e4a:	b8 85       	ldd	r27, Y+8	; 0x08
    1e4c:	55 96       	adiw	r26, 0x15	; 21
    1e4e:	8c 93       	st	X, r24
  packet_payload[22] = SVIT_check_V_critical( svit[TORQUER_3].name );
    1e50:	ec e4       	ldi	r30, 0x4C	; 76
    1e52:	f5 e0       	ldi	r31, 0x05	; 5
    1e54:	80 81       	ld	r24, Z
    1e56:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1e5a:	af 81       	ldd	r26, Y+7	; 0x07
    1e5c:	b8 85       	ldd	r27, Y+8	; 0x08
    1e5e:	56 96       	adiw	r26, 0x16	; 22
    1e60:	8c 93       	st	X, r24
  packet_payload[23] = SVIT_check_V_critical( svit[BATTERY_1].name );
    1e62:	e8 e6       	ldi	r30, 0x68	; 104
    1e64:	f5 e0       	ldi	r31, 0x05	; 5
    1e66:	80 81       	ld	r24, Z
    1e68:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1e6c:	af 81       	ldd	r26, Y+7	; 0x07
    1e6e:	b8 85       	ldd	r27, Y+8	; 0x08
    1e70:	57 96       	adiw	r26, 0x17	; 23
    1e72:	8c 93       	st	X, r24
  packet_payload[24] = SVIT_check_V_critical( svit[BATTERY_2].name );
    1e74:	e4 e8       	ldi	r30, 0x84	; 132
    1e76:	f5 e0       	ldi	r31, 0x05	; 5
    1e78:	80 81       	ld	r24, Z
    1e7a:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1e7e:	af 81       	ldd	r26, Y+7	; 0x07
    1e80:	b8 85       	ldd	r27, Y+8	; 0x08
    1e82:	58 96       	adiw	r26, 0x18	; 24
    1e84:	8c 93       	st	X, r24
  packet_payload[25] = SVIT_check_V_critical( svit[SOLAR_FULL].name );
    1e86:	e0 ea       	ldi	r30, 0xA0	; 160
    1e88:	f5 e0       	ldi	r31, 0x05	; 5
    1e8a:	80 81       	ld	r24, Z
    1e8c:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1e90:	af 81       	ldd	r26, Y+7	; 0x07
    1e92:	b8 85       	ldd	r27, Y+8	; 0x08
    1e94:	59 96       	adiw	r26, 0x19	; 25
    1e96:	8c 93       	st	X, r24
  packet_payload[26] = SVIT_check_V_critical( svit[SOLAR_1].name );
    1e98:	ec eb       	ldi	r30, 0xBC	; 188
    1e9a:	f5 e0       	ldi	r31, 0x05	; 5
    1e9c:	80 81       	ld	r24, Z
    1e9e:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1ea2:	af 81       	ldd	r26, Y+7	; 0x07
    1ea4:	b8 85       	ldd	r27, Y+8	; 0x08
    1ea6:	5a 96       	adiw	r26, 0x1a	; 26
    1ea8:	8c 93       	st	X, r24
  packet_payload[27] = SVIT_check_V_critical( svit[SOLAR_2].name );
    1eaa:	e8 ed       	ldi	r30, 0xD8	; 216
    1eac:	f5 e0       	ldi	r31, 0x05	; 5
    1eae:	80 81       	ld	r24, Z
    1eb0:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1eb4:	af 81       	ldd	r26, Y+7	; 0x07
    1eb6:	b8 85       	ldd	r27, Y+8	; 0x08
    1eb8:	5b 96       	adiw	r26, 0x1b	; 27
    1eba:	8c 93       	st	X, r24
  packet_payload[28] = SVIT_check_V_critical( svit[SOLAR_3].name );
    1ebc:	e4 ef       	ldi	r30, 0xF4	; 244
    1ebe:	f5 e0       	ldi	r31, 0x05	; 5
    1ec0:	80 81       	ld	r24, Z
    1ec2:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1ec6:	af 81       	ldd	r26, Y+7	; 0x07
    1ec8:	b8 85       	ldd	r27, Y+8	; 0x08
    1eca:	5c 96       	adiw	r26, 0x1c	; 28
    1ecc:	8c 93       	st	X, r24
  packet_payload[29] = SVIT_check_V_critical( svit[SOLAR_4].name );
    1ece:	e0 e1       	ldi	r30, 0x10	; 16
    1ed0:	f6 e0       	ldi	r31, 0x06	; 6
    1ed2:	80 81       	ld	r24, Z
    1ed4:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1ed8:	af 81       	ldd	r26, Y+7	; 0x07
    1eda:	b8 85       	ldd	r27, Y+8	; 0x08
    1edc:	5d 96       	adiw	r26, 0x1d	; 29
    1ede:	8c 93       	st	X, r24
  packet_payload[30] = SVIT_check_V_critical( svit[SOLAR_5].name );
    1ee0:	ec e2       	ldi	r30, 0x2C	; 44
    1ee2:	f6 e0       	ldi	r31, 0x06	; 6
    1ee4:	80 81       	ld	r24, Z
    1ee6:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1eea:	af 81       	ldd	r26, Y+7	; 0x07
    1eec:	b8 85       	ldd	r27, Y+8	; 0x08
    1eee:	5e 96       	adiw	r26, 0x1e	; 30
    1ef0:	8c 93       	st	X, r24
  packet_payload[31] = SVIT_check_V_critical( svit[SOLAR_6].name );
    1ef2:	e8 e4       	ldi	r30, 0x48	; 72
    1ef4:	f6 e0       	ldi	r31, 0x06	; 6
    1ef6:	80 81       	ld	r24, Z
    1ef8:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1efc:	af 81       	ldd	r26, Y+7	; 0x07
    1efe:	b8 85       	ldd	r27, Y+8	; 0x08
    1f00:	5f 96       	adiw	r26, 0x1f	; 31
    1f02:	8c 93       	st	X, r24
  packet_payload[32] = SVIT_check_V_critical( svit[SOLAR_7].name );
    1f04:	e4 e6       	ldi	r30, 0x64	; 100
    1f06:	f6 e0       	ldi	r31, 0x06	; 6
    1f08:	80 81       	ld	r24, Z
    1f0a:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1f0e:	af 81       	ldd	r26, Y+7	; 0x07
    1f10:	b8 85       	ldd	r27, Y+8	; 0x08
    1f12:	90 96       	adiw	r26, 0x20	; 32
    1f14:	8c 93       	st	X, r24
  packet_payload[33] = SVIT_check_V_critical( svit[SOLAR_8].name );
    1f16:	e0 e8       	ldi	r30, 0x80	; 128
    1f18:	f6 e0       	ldi	r31, 0x06	; 6
    1f1a:	80 81       	ld	r24, Z
    1f1c:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1f20:	af 81       	ldd	r26, Y+7	; 0x07
    1f22:	b8 85       	ldd	r27, Y+8	; 0x08
    1f24:	91 96       	adiw	r26, 0x21	; 33
    1f26:	8c 93       	st	X, r24
  packet_payload[34] = SVIT_check_V_critical( svit[SOLAR_9].name );
    1f28:	ec e9       	ldi	r30, 0x9C	; 156
    1f2a:	f6 e0       	ldi	r31, 0x06	; 6
    1f2c:	80 81       	ld	r24, Z
    1f2e:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1f32:	af 81       	ldd	r26, Y+7	; 0x07
    1f34:	b8 85       	ldd	r27, Y+8	; 0x08
    1f36:	92 96       	adiw	r26, 0x22	; 34
    1f38:	8c 93       	st	X, r24
  packet_payload[35] = SVIT_check_V_critical( svit[SOLAR_10].name );
    1f3a:	e8 eb       	ldi	r30, 0xB8	; 184
    1f3c:	f6 e0       	ldi	r31, 0x06	; 6
    1f3e:	80 81       	ld	r24, Z
    1f40:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1f44:	af 81       	ldd	r26, Y+7	; 0x07
    1f46:	b8 85       	ldd	r27, Y+8	; 0x08
    1f48:	93 96       	adiw	r26, 0x23	; 35
    1f4a:	8c 93       	st	X, r24
  packet_payload[36] = SVIT_check_V_critical( svit[SOLAR_11].name );
    1f4c:	e4 ed       	ldi	r30, 0xD4	; 212
    1f4e:	f6 e0       	ldi	r31, 0x06	; 6
    1f50:	80 81       	ld	r24, Z
    1f52:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1f56:	af 81       	ldd	r26, Y+7	; 0x07
    1f58:	b8 85       	ldd	r27, Y+8	; 0x08
    1f5a:	94 96       	adiw	r26, 0x24	; 36
    1f5c:	8c 93       	st	X, r24
  packet_payload[37] = SVIT_check_V_critical( svit[SOLAR_12].name );
    1f5e:	e0 ef       	ldi	r30, 0xF0	; 240
    1f60:	f6 e0       	ldi	r31, 0x06	; 6
    1f62:	80 81       	ld	r24, Z
    1f64:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1f68:	af 81       	ldd	r26, Y+7	; 0x07
    1f6a:	b8 85       	ldd	r27, Y+8	; 0x08
    1f6c:	95 96       	adiw	r26, 0x25	; 37
    1f6e:	8c 93       	st	X, r24
  packet_payload[38] = SVIT_check_V_critical( svit[POWER_BOARD].name );
    1f70:	80 91 0c 07 	lds	r24, 0x070C
    1f74:	0e 94 a3 09 	call	0x1346	; 0x1346 <SVIT_check_V_critical>
    1f78:	ef 81       	ldd	r30, Y+7	; 0x07
    1f7a:	f8 85       	ldd	r31, Y+8	; 0x08
    1f7c:	86 a3       	std	Z+38, r24	; 0x26
  //uint8_t voltage_error1;
  //uint8_t voltage_error2;
  //uint8_t voltage_error3;
  //uint8_t voltage_error4;
 
  packet_payload[39] = 0;
    1f7e:	17 a2       	std	Z+39, r1	; 0x27
  packet_payload[40] = 0;
    1f80:	10 a6       	std	Z+40, r1	; 0x28
  packet_payload[41] = 0;
    1f82:	11 a6       	std	Z+41, r1	; 0x29
  packet_payload[42] = 0;
    1f84:	12 a6       	std	Z+42, r1	; 0x2a
  packet_payload[43] = 0;
    1f86:	13 a6       	std	Z+43, r1	; 0x2b

  // current values (raw ADC output)
  packet_payload[44] = SVIT_check_I_critical( svit[SPECTROMETER].name );
    1f88:	d3 01       	movw	r26, r6
    1f8a:	8c 91       	ld	r24, X
    1f8c:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    1f90:	ef 81       	ldd	r30, Y+7	; 0x07
    1f92:	f8 85       	ldd	r31, Y+8	; 0x08
    1f94:	84 a7       	std	Z+44, r24	; 0x2c
  packet_payload[45] = SVIT_check_I_critical( svit[STAR_TRACKER].name );
    1f96:	d4 01       	movw	r26, r8
    1f98:	8c 91       	ld	r24, X
    1f9a:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    1f9e:	ef 81       	ldd	r30, Y+7	; 0x07
    1fa0:	f8 85       	ldd	r31, Y+8	; 0x08
    1fa2:	85 a7       	std	Z+45, r24	; 0x2d
  packet_payload[46] = SVIT_check_I_critical( svit[FC_5V].name );
    1fa4:	d5 01       	movw	r26, r10
    1fa6:	8c 91       	ld	r24, X
    1fa8:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    1fac:	ef 81       	ldd	r30, Y+7	; 0x07
    1fae:	f8 85       	ldd	r31, Y+8	; 0x08
    1fb0:	86 a7       	std	Z+46, r24	; 0x2e
  packet_payload[47] = SVIT_check_I_critical( svit[FC_3_3V].name );
    1fb2:	d6 01       	movw	r26, r12
    1fb4:	8c 91       	ld	r24, X
    1fb6:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    1fba:	ef 81       	ldd	r30, Y+7	; 0x07
    1fbc:	f8 85       	ldd	r31, Y+8	; 0x08
    1fbe:	87 a7       	std	Z+47, r24	; 0x2f
  packet_payload[48] = SVIT_check_I_critical( svit[GPS_1].name );
    1fc0:	d7 01       	movw	r26, r14
    1fc2:	8c 91       	ld	r24, X
    1fc4:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    1fc8:	ef 81       	ldd	r30, Y+7	; 0x07
    1fca:	f8 85       	ldd	r31, Y+8	; 0x08
    1fcc:	80 ab       	std	Z+48, r24	; 0x30
  packet_payload[49] = SVIT_check_I_critical( svit[CDH_IB].name );
    1fce:	d8 01       	movw	r26, r16
    1fd0:	8c 91       	ld	r24, X
    1fd2:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    1fd6:	ef 81       	ldd	r30, Y+7	; 0x07
    1fd8:	f8 85       	ldd	r31, Y+8	; 0x08
    1fda:	81 ab       	std	Z+49, r24	; 0x31
  packet_payload[50] = SVIT_check_I_critical( svit[HEATER_1].name );
    1fdc:	ac ef       	ldi	r26, 0xFC	; 252
    1fde:	b3 e0       	ldi	r27, 0x03	; 3
    1fe0:	8c 91       	ld	r24, X
    1fe2:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    1fe6:	ef 81       	ldd	r30, Y+7	; 0x07
    1fe8:	f8 85       	ldd	r31, Y+8	; 0x08
    1fea:	82 ab       	std	Z+50, r24	; 0x32
  packet_payload[51] = SVIT_check_I_critical( svit[HEATER_2].name );
    1fec:	d2 01       	movw	r26, r4
    1fee:	8c 91       	ld	r24, X
    1ff0:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    1ff4:	ef 81       	ldd	r30, Y+7	; 0x07
    1ff6:	f8 85       	ldd	r31, Y+8	; 0x08
    1ff8:	83 ab       	std	Z+51, r24	; 0x33
  packet_payload[52] = SVIT_check_I_critical( svit[CMG].name );
    1ffa:	d1 01       	movw	r26, r2
    1ffc:	8c 91       	ld	r24, X
    1ffe:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2002:	ef 81       	ldd	r30, Y+7	; 0x07
    2004:	f8 85       	ldd	r31, Y+8	; 0x08
    2006:	84 ab       	std	Z+52, r24	; 0x34
  packet_payload[53] = SVIT_check_I_critical( svit[SUN_SENSOR].name );
    2008:	29 81       	ldd	r18, Y+1	; 0x01
    200a:	3a 81       	ldd	r19, Y+2	; 0x02
    200c:	d9 01       	movw	r26, r18
    200e:	8c 91       	ld	r24, X
    2010:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2014:	ef 81       	ldd	r30, Y+7	; 0x07
    2016:	f8 85       	ldd	r31, Y+8	; 0x08
    2018:	85 ab       	std	Z+53, r24	; 0x35
  packet_payload[54] = SVIT_check_I_critical( svit[RADIO_1].name );
    201a:	4b 81       	ldd	r20, Y+3	; 0x03
    201c:	5c 81       	ldd	r21, Y+4	; 0x04
    201e:	da 01       	movw	r26, r20
    2020:	8c 91       	ld	r24, X
    2022:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2026:	ef 81       	ldd	r30, Y+7	; 0x07
    2028:	f8 85       	ldd	r31, Y+8	; 0x08
    202a:	86 ab       	std	Z+54, r24	; 0x36
  packet_payload[55] = SVIT_check_I_critical( svit[RADIO_2].name );
    202c:	6d 81       	ldd	r22, Y+5	; 0x05
    202e:	7e 81       	ldd	r23, Y+6	; 0x06
    2030:	db 01       	movw	r26, r22
    2032:	8c 91       	ld	r24, X
    2034:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2038:	ef 81       	ldd	r30, Y+7	; 0x07
    203a:	f8 85       	ldd	r31, Y+8	; 0x08
    203c:	87 ab       	std	Z+55, r24	; 0x37
  packet_payload[56] = SVIT_check_I_critical( svit[FOG_15V].name );
    203e:	ac ed       	ldi	r26, 0xDC	; 220
    2040:	b4 e0       	ldi	r27, 0x04	; 4
    2042:	8c 91       	ld	r24, X
    2044:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2048:	ef 81       	ldd	r30, Y+7	; 0x07
    204a:	f8 85       	ldd	r31, Y+8	; 0x08
    204c:	80 af       	std	Z+56, r24	; 0x38
  packet_payload[57] = SVIT_check_I_critical( svit[FOG_5V].name );
    204e:	a8 ef       	ldi	r26, 0xF8	; 248
    2050:	b4 e0       	ldi	r27, 0x04	; 4
    2052:	8c 91       	ld	r24, X
    2054:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2058:	ef 81       	ldd	r30, Y+7	; 0x07
    205a:	f8 85       	ldd	r31, Y+8	; 0x08
    205c:	81 af       	std	Z+57, r24	; 0x39
  packet_payload[58] = SVIT_check_I_critical( svit[TORQUER_1].name );
    205e:	a4 e1       	ldi	r26, 0x14	; 20
    2060:	b5 e0       	ldi	r27, 0x05	; 5
    2062:	8c 91       	ld	r24, X
    2064:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2068:	ef 81       	ldd	r30, Y+7	; 0x07
    206a:	f8 85       	ldd	r31, Y+8	; 0x08
    206c:	82 af       	std	Z+58, r24	; 0x3a
  packet_payload[59] = SVIT_check_I_critical( svit[TORQUER_2].name );
    206e:	a0 e3       	ldi	r26, 0x30	; 48
    2070:	b5 e0       	ldi	r27, 0x05	; 5
    2072:	8c 91       	ld	r24, X
    2074:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2078:	ef 81       	ldd	r30, Y+7	; 0x07
    207a:	f8 85       	ldd	r31, Y+8	; 0x08
    207c:	83 af       	std	Z+59, r24	; 0x3b
  packet_payload[60] = SVIT_check_I_critical( svit[TORQUER_3].name );
    207e:	ac e4       	ldi	r26, 0x4C	; 76
    2080:	b5 e0       	ldi	r27, 0x05	; 5
    2082:	8c 91       	ld	r24, X
    2084:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2088:	ef 81       	ldd	r30, Y+7	; 0x07
    208a:	f8 85       	ldd	r31, Y+8	; 0x08
    208c:	84 af       	std	Z+60, r24	; 0x3c
  packet_payload[61] = SVIT_check_I_critical( svit[BATTERY_1].name );
    208e:	a8 e6       	ldi	r26, 0x68	; 104
    2090:	b5 e0       	ldi	r27, 0x05	; 5
    2092:	8c 91       	ld	r24, X
    2094:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2098:	ef 81       	ldd	r30, Y+7	; 0x07
    209a:	f8 85       	ldd	r31, Y+8	; 0x08
    209c:	85 af       	std	Z+61, r24	; 0x3d
  packet_payload[62] = SVIT_check_I_critical( svit[BATTERY_2].name );
    209e:	a4 e8       	ldi	r26, 0x84	; 132
    20a0:	b5 e0       	ldi	r27, 0x05	; 5
    20a2:	8c 91       	ld	r24, X
    20a4:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    20a8:	ef 81       	ldd	r30, Y+7	; 0x07
    20aa:	f8 85       	ldd	r31, Y+8	; 0x08
    20ac:	86 af       	std	Z+62, r24	; 0x3e
  packet_payload[63] = SVIT_check_I_critical( svit[SOLAR_FULL].name );
    20ae:	a0 ea       	ldi	r26, 0xA0	; 160
    20b0:	b5 e0       	ldi	r27, 0x05	; 5
    20b2:	8c 91       	ld	r24, X
    20b4:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    20b8:	ef 81       	ldd	r30, Y+7	; 0x07
    20ba:	f8 85       	ldd	r31, Y+8	; 0x08
    20bc:	87 af       	std	Z+63, r24	; 0x3f
  packet_payload[64] = SVIT_check_I_critical( svit[SOLAR_1].name );
    20be:	ac eb       	ldi	r26, 0xBC	; 188
    20c0:	b5 e0       	ldi	r27, 0x05	; 5
    20c2:	8c 91       	ld	r24, X
    20c4:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    20c8:	ef 81       	ldd	r30, Y+7	; 0x07
    20ca:	f8 85       	ldd	r31, Y+8	; 0x08
    20cc:	e0 5c       	subi	r30, 0xC0	; 192
    20ce:	ff 4f       	sbci	r31, 0xFF	; 255
    20d0:	80 83       	st	Z, r24
  packet_payload[65] = SVIT_check_I_critical( svit[SOLAR_2].name );
    20d2:	e8 ed       	ldi	r30, 0xD8	; 216
    20d4:	f5 e0       	ldi	r31, 0x05	; 5
    20d6:	80 81       	ld	r24, Z
    20d8:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    20dc:	ef 81       	ldd	r30, Y+7	; 0x07
    20de:	f8 85       	ldd	r31, Y+8	; 0x08
    20e0:	ef 5b       	subi	r30, 0xBF	; 191
    20e2:	ff 4f       	sbci	r31, 0xFF	; 255
    20e4:	80 83       	st	Z, r24
  packet_payload[66] = SVIT_check_I_critical( svit[SOLAR_3].name );
    20e6:	a4 ef       	ldi	r26, 0xF4	; 244
    20e8:	b5 e0       	ldi	r27, 0x05	; 5
    20ea:	8c 91       	ld	r24, X
    20ec:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    20f0:	ef 81       	ldd	r30, Y+7	; 0x07
    20f2:	f8 85       	ldd	r31, Y+8	; 0x08
    20f4:	ee 5b       	subi	r30, 0xBE	; 190
    20f6:	ff 4f       	sbci	r31, 0xFF	; 255
    20f8:	80 83       	st	Z, r24
  packet_payload[67] = SVIT_check_I_critical( svit[SOLAR_4].name );
    20fa:	e0 e1       	ldi	r30, 0x10	; 16
    20fc:	f6 e0       	ldi	r31, 0x06	; 6
    20fe:	80 81       	ld	r24, Z
    2100:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2104:	ef 81       	ldd	r30, Y+7	; 0x07
    2106:	f8 85       	ldd	r31, Y+8	; 0x08
    2108:	ed 5b       	subi	r30, 0xBD	; 189
    210a:	ff 4f       	sbci	r31, 0xFF	; 255
    210c:	80 83       	st	Z, r24
  packet_payload[68] = SVIT_check_I_critical( svit[SOLAR_5].name );
    210e:	ac e2       	ldi	r26, 0x2C	; 44
    2110:	b6 e0       	ldi	r27, 0x06	; 6
    2112:	8c 91       	ld	r24, X
    2114:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2118:	ef 81       	ldd	r30, Y+7	; 0x07
    211a:	f8 85       	ldd	r31, Y+8	; 0x08
    211c:	ec 5b       	subi	r30, 0xBC	; 188
    211e:	ff 4f       	sbci	r31, 0xFF	; 255
    2120:	80 83       	st	Z, r24
  packet_payload[69] = SVIT_check_I_critical( svit[SOLAR_6].name );
    2122:	e8 e4       	ldi	r30, 0x48	; 72
    2124:	f6 e0       	ldi	r31, 0x06	; 6
    2126:	80 81       	ld	r24, Z
    2128:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    212c:	ef 81       	ldd	r30, Y+7	; 0x07
    212e:	f8 85       	ldd	r31, Y+8	; 0x08
    2130:	eb 5b       	subi	r30, 0xBB	; 187
    2132:	ff 4f       	sbci	r31, 0xFF	; 255
    2134:	80 83       	st	Z, r24
  packet_payload[70] = SVIT_check_I_critical( svit[SOLAR_7].name );
    2136:	a4 e6       	ldi	r26, 0x64	; 100
    2138:	b6 e0       	ldi	r27, 0x06	; 6
    213a:	8c 91       	ld	r24, X
    213c:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2140:	ef 81       	ldd	r30, Y+7	; 0x07
    2142:	f8 85       	ldd	r31, Y+8	; 0x08
    2144:	ea 5b       	subi	r30, 0xBA	; 186
    2146:	ff 4f       	sbci	r31, 0xFF	; 255
    2148:	80 83       	st	Z, r24
  packet_payload[71] = SVIT_check_I_critical( svit[SOLAR_8].name );
    214a:	e0 e8       	ldi	r30, 0x80	; 128
    214c:	f6 e0       	ldi	r31, 0x06	; 6
    214e:	80 81       	ld	r24, Z
    2150:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2154:	ef 81       	ldd	r30, Y+7	; 0x07
    2156:	f8 85       	ldd	r31, Y+8	; 0x08
    2158:	e9 5b       	subi	r30, 0xB9	; 185
    215a:	ff 4f       	sbci	r31, 0xFF	; 255
    215c:	80 83       	st	Z, r24
  packet_payload[72] = SVIT_check_I_critical( svit[SOLAR_9].name );
    215e:	ac e9       	ldi	r26, 0x9C	; 156
    2160:	b6 e0       	ldi	r27, 0x06	; 6
    2162:	8c 91       	ld	r24, X
    2164:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2168:	ef 81       	ldd	r30, Y+7	; 0x07
    216a:	f8 85       	ldd	r31, Y+8	; 0x08
    216c:	e8 5b       	subi	r30, 0xB8	; 184
    216e:	ff 4f       	sbci	r31, 0xFF	; 255
    2170:	80 83       	st	Z, r24
  packet_payload[73] = SVIT_check_I_critical( svit[SOLAR_10].name );
    2172:	e8 eb       	ldi	r30, 0xB8	; 184
    2174:	f6 e0       	ldi	r31, 0x06	; 6
    2176:	80 81       	ld	r24, Z
    2178:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    217c:	ef 81       	ldd	r30, Y+7	; 0x07
    217e:	f8 85       	ldd	r31, Y+8	; 0x08
    2180:	e7 5b       	subi	r30, 0xB7	; 183
    2182:	ff 4f       	sbci	r31, 0xFF	; 255
    2184:	80 83       	st	Z, r24
  packet_payload[74] = SVIT_check_I_critical( svit[SOLAR_11].name );
    2186:	a4 ed       	ldi	r26, 0xD4	; 212
    2188:	b6 e0       	ldi	r27, 0x06	; 6
    218a:	8c 91       	ld	r24, X
    218c:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    2190:	ef 81       	ldd	r30, Y+7	; 0x07
    2192:	f8 85       	ldd	r31, Y+8	; 0x08
    2194:	e6 5b       	subi	r30, 0xB6	; 182
    2196:	ff 4f       	sbci	r31, 0xFF	; 255
    2198:	80 83       	st	Z, r24
  packet_payload[75] = SVIT_check_I_critical( svit[SOLAR_12].name );
    219a:	e0 ef       	ldi	r30, 0xF0	; 240
    219c:	f6 e0       	ldi	r31, 0x06	; 6
    219e:	80 81       	ld	r24, Z
    21a0:	0e 94 94 09 	call	0x1328	; 0x1328 <SVIT_check_I_critical>
    21a4:	ef 81       	ldd	r30, Y+7	; 0x07
    21a6:	f8 85       	ldd	r31, Y+8	; 0x08
    21a8:	e5 5b       	subi	r30, 0xB5	; 181
    21aa:	ff 4f       	sbci	r31, 0xFF	; 255
    21ac:	80 83       	st	Z, r24
  packet_payload[76] = 0xFF;//SVIT_check_I_critical( svit[POWER_BOARD].name );
    21ae:	ef 81       	ldd	r30, Y+7	; 0x07
    21b0:	f8 85       	ldd	r31, Y+8	; 0x08
    21b2:	e4 5b       	subi	r30, 0xB4	; 180
    21b4:	ff 4f       	sbci	r31, 0xFF	; 255
    21b6:	8f ef       	ldi	r24, 0xFF	; 255
    21b8:	80 83       	st	Z, r24
  //uint8_t current_error1;
  //uint8_t current_error2;
  //uint8_t current_error3;
  //uint8_t current_error4;

  packet_payload[77] = batt1_voltage;//V_ack_change();
    21ba:	ef 81       	ldd	r30, Y+7	; 0x07
    21bc:	f8 85       	ldd	r31, Y+8	; 0x08
    21be:	e3 5b       	subi	r30, 0xB3	; 179
    21c0:	ff 4f       	sbci	r31, 0xFF	; 255
    21c2:	90 91 6f 09 	lds	r25, 0x096F
    21c6:	90 83       	st	Z, r25
  packet_payload[78] = soc;//soc;// I_ack_change();
    21c8:	ef 81       	ldd	r30, Y+7	; 0x07
    21ca:	f8 85       	ldd	r31, Y+8	; 0x08
    21cc:	e2 5b       	subi	r30, 0xB2	; 178
    21ce:	ff 4f       	sbci	r31, 0xFF	; 255
    21d0:	90 91 ad 0f 	lds	r25, 0x0FAD
    21d4:	90 83       	st	Z, r25
  packet_payload[79] = 0x00;//low >> 6;//safe_mode;
    21d6:	ef 81       	ldd	r30, Y+7	; 0x07
    21d8:	f8 85       	ldd	r31, Y+8	; 0x08
    21da:	e1 5b       	subi	r30, 0xB1	; 177
    21dc:	ff 4f       	sbci	r31, 0xFF	; 255
    21de:	10 82       	st	Z, r1
  packet_payload[80] = 0x00;//charging;
    21e0:	ef 81       	ldd	r30, Y+7	; 0x07
    21e2:	f8 85       	ldd	r31, Y+8	; 0x08
    21e4:	e0 5b       	subi	r30, 0xB0	; 176
    21e6:	ff 4f       	sbci	r31, 0xFF	; 255
    21e8:	10 82       	st	Z, r1
  packet_payload[81] = 0x00;//chargeforward;
    21ea:	ef 81       	ldd	r30, Y+7	; 0x07
    21ec:	f8 85       	ldd	r31, Y+8	; 0x08
    21ee:	ef 5a       	subi	r30, 0xAF	; 175
    21f0:	ff 4f       	sbci	r31, 0xFF	; 255
    21f2:	10 82       	st	Z, r1

  // temperature values (raw ADC output)
  packet_payload[82] = debug;//average_samples( svit[STAR_TRACKER].T_samples );
    21f4:	ef 81       	ldd	r30, Y+7	; 0x07
    21f6:	f8 85       	ldd	r31, Y+8	; 0x08
    21f8:	ee 5a       	subi	r30, 0xAE	; 174
    21fa:	ff 4f       	sbci	r31, 0xFF	; 255
    21fc:	90 91 37 07 	lds	r25, 0x0737
    2200:	90 83       	st	Z, r25
  packet_payload[83] = 0xFF;//average_samples( svit[BATTERY_1].T_samples );
    2202:	ef 81       	ldd	r30, Y+7	; 0x07
    2204:	f8 85       	ldd	r31, Y+8	; 0x08
    2206:	ed 5a       	subi	r30, 0xAD	; 173
    2208:	ff 4f       	sbci	r31, 0xFF	; 255
    220a:	80 83       	st	Z, r24
  packet_payload[84] = average_samples( svit[BATTERY_2].T_samples );
    220c:	8c e9       	ldi	r24, 0x9C	; 156
    220e:	95 e0       	ldi	r25, 0x05	; 5
    2210:	0e 94 85 09 	call	0x130a	; 0x130a <average_samples>
    2214:	ef 81       	ldd	r30, Y+7	; 0x07
    2216:	f8 85       	ldd	r31, Y+8	; 0x08
    2218:	ec 5a       	subi	r30, 0xAC	; 172
    221a:	ff 4f       	sbci	r31, 0xFF	; 255
    221c:	80 83       	st	Z, r24
  packet_payload[85] = average_samples( svit[SOLAR_1].T_samples );
    221e:	84 ed       	ldi	r24, 0xD4	; 212
    2220:	95 e0       	ldi	r25, 0x05	; 5
    2222:	0e 94 85 09 	call	0x130a	; 0x130a <average_samples>
    2226:	ef 81       	ldd	r30, Y+7	; 0x07
    2228:	f8 85       	ldd	r31, Y+8	; 0x08
    222a:	eb 5a       	subi	r30, 0xAB	; 171
    222c:	ff 4f       	sbci	r31, 0xFF	; 255
    222e:	80 83       	st	Z, r24
  packet_payload[86] = average_samples( svit[SOLAR_2].T_samples );
    2230:	80 ef       	ldi	r24, 0xF0	; 240
    2232:	95 e0       	ldi	r25, 0x05	; 5
    2234:	0e 94 85 09 	call	0x130a	; 0x130a <average_samples>
    2238:	ef 81       	ldd	r30, Y+7	; 0x07
    223a:	f8 85       	ldd	r31, Y+8	; 0x08
    223c:	ea 5a       	subi	r30, 0xAA	; 170
    223e:	ff 4f       	sbci	r31, 0xFF	; 255
    2240:	80 83       	st	Z, r24
  packet_payload[87] = average_samples( svit[SOLAR_3].T_samples );
    2242:	8c e0       	ldi	r24, 0x0C	; 12
    2244:	96 e0       	ldi	r25, 0x06	; 6
    2246:	0e 94 85 09 	call	0x130a	; 0x130a <average_samples>
    224a:	ef 81       	ldd	r30, Y+7	; 0x07
    224c:	f8 85       	ldd	r31, Y+8	; 0x08
    224e:	e9 5a       	subi	r30, 0xA9	; 169
    2250:	ff 4f       	sbci	r31, 0xFF	; 255
    2252:	80 83       	st	Z, r24
  packet_payload[88] = average_samples( svit[SOLAR_4].T_samples );
    2254:	88 e2       	ldi	r24, 0x28	; 40
    2256:	96 e0       	ldi	r25, 0x06	; 6
    2258:	0e 94 85 09 	call	0x130a	; 0x130a <average_samples>
    225c:	ef 81       	ldd	r30, Y+7	; 0x07
    225e:	f8 85       	ldd	r31, Y+8	; 0x08
    2260:	e8 5a       	subi	r30, 0xA8	; 168
    2262:	ff 4f       	sbci	r31, 0xFF	; 255
    2264:	80 83       	st	Z, r24
  packet_payload[89] = average_samples( svit[SOLAR_5].T_samples );
    2266:	84 e4       	ldi	r24, 0x44	; 68
    2268:	96 e0       	ldi	r25, 0x06	; 6
    226a:	0e 94 85 09 	call	0x130a	; 0x130a <average_samples>
    226e:	ef 81       	ldd	r30, Y+7	; 0x07
    2270:	f8 85       	ldd	r31, Y+8	; 0x08
    2272:	e7 5a       	subi	r30, 0xA7	; 167
    2274:	ff 4f       	sbci	r31, 0xFF	; 255
    2276:	80 83       	st	Z, r24
  packet_payload[90] = average_samples( svit[SOLAR_9].T_samples );
    2278:	84 eb       	ldi	r24, 0xB4	; 180
    227a:	96 e0       	ldi	r25, 0x06	; 6
    227c:	0e 94 85 09 	call	0x130a	; 0x130a <average_samples>
    2280:	ef 81       	ldd	r30, Y+7	; 0x07
    2282:	f8 85       	ldd	r31, Y+8	; 0x08
    2284:	e6 5a       	subi	r30, 0xA6	; 166
    2286:	ff 4f       	sbci	r31, 0xFF	; 255
    2288:	80 83       	st	Z, r24
  packet_payload[91] = average_samples( svit[POWER_BOARD].T_samples );
    228a:	84 e2       	ldi	r24, 0x24	; 36
    228c:	97 e0       	ldi	r25, 0x07	; 7
    228e:	0e 94 85 09 	call	0x130a	; 0x130a <average_samples>
    2292:	ef 81       	ldd	r30, Y+7	; 0x07
    2294:	f8 85       	ldd	r31, Y+8	; 0x08
    2296:	e5 5a       	subi	r30, 0xA5	; 165
    2298:	ff 4f       	sbci	r31, 0xFF	; 255
    229a:	80 83       	st	Z, r24

uint8_t V_ack_change( void )
{
  uint8_t temp;

  temp = V_upper_val_change;
    229c:	80 91 7f 0b 	lds	r24, 0x0B7F
  V_upper_val_change = 0;
    22a0:	10 92 7f 0b 	sts	0x0B7F, r1
  //uint8_t temperature_error1;
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
    22a4:	ef 81       	ldd	r30, Y+7	; 0x07
    22a6:	f8 85       	ldd	r31, Y+8	; 0x08
    22a8:	e4 5a       	subi	r30, 0xA4	; 164
    22aa:	ff 4f       	sbci	r31, 0xFF	; 255
    22ac:	80 83       	st	Z, r24

uint8_t I_ack_change( void )
{
  uint8_t temp;

  temp = I_upper_val_change;
    22ae:	80 91 7a 0b 	lds	r24, 0x0B7A
  I_upper_val_change = 0;
    22b2:	10 92 7a 0b 	sts	0x0B7A, r1
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
  packet_payload[93] = I_ack_change();
    22b6:	ef 81       	ldd	r30, Y+7	; 0x07
    22b8:	f8 85       	ldd	r31, Y+8	; 0x08
    22ba:	e3 5a       	subi	r30, 0xA3	; 163
    22bc:	ff 4f       	sbci	r31, 0xFF	; 255
    22be:	80 83       	st	Z, r24
}
    22c0:	28 96       	adiw	r28, 0x08	; 8
    22c2:	0f b6       	in	r0, 0x3f	; 63
    22c4:	f8 94       	cli
    22c6:	de bf       	out	0x3e, r29	; 62
    22c8:	0f be       	out	0x3f, r0	; 63
    22ca:	cd bf       	out	0x3d, r28	; 61
    22cc:	df 91       	pop	r29
    22ce:	cf 91       	pop	r28
    22d0:	1f 91       	pop	r17
    22d2:	0f 91       	pop	r16
    22d4:	ff 90       	pop	r15
    22d6:	ef 90       	pop	r14
    22d8:	df 90       	pop	r13
    22da:	cf 90       	pop	r12
    22dc:	bf 90       	pop	r11
    22de:	af 90       	pop	r10
    22e0:	9f 90       	pop	r9
    22e2:	8f 90       	pop	r8
    22e4:	7f 90       	pop	r7
    22e6:	6f 90       	pop	r6
    22e8:	5f 90       	pop	r5
    22ea:	4f 90       	pop	r4
    22ec:	3f 90       	pop	r3
    22ee:	2f 90       	pop	r2
    22f0:	08 95       	ret

000022f2 <transmit_packet>:

void transmit_packet( uint8_t uart, uint8_t packet_type, uint8_t ack_command )
{
    22f2:	6f 92       	push	r6
    22f4:	7f 92       	push	r7
    22f6:	8f 92       	push	r8
    22f8:	9f 92       	push	r9
    22fa:	bf 92       	push	r11
    22fc:	cf 92       	push	r12
    22fe:	df 92       	push	r13
    2300:	ef 92       	push	r14
    2302:	ff 92       	push	r15
    2304:	0f 93       	push	r16
    2306:	1f 93       	push	r17
    2308:	cf 93       	push	r28
    230a:	df 93       	push	r29
    230c:	b8 2e       	mov	r11, r24
  uint8_t VCP_tx_status;

  switch( packet_type )
    230e:	61 30       	cpi	r22, 0x01	; 1
    2310:	b9 f0       	breq	.+46     	; 0x2340 <transmit_packet+0x4e>
    2312:	20 f0       	brcs	.+8      	; 0x231c <transmit_packet+0x2a>
    2314:	62 30       	cpi	r22, 0x02	; 2
    2316:	09 f0       	breq	.+2      	; 0x231a <transmit_packet+0x28>
    2318:	8b c0       	rjmp	.+278    	; 0x2430 <transmit_packet+0x13e>
    231a:	22 c0       	rjmp	.+68     	; 0x2360 <transmit_packet+0x6e>
  {
    case VCP_POWER_TELEMETRY:
      construct_telemetry_packet( tel_packet_payload[uart] );
    231c:	c8 2f       	mov	r28, r24
    231e:	d0 e0       	ldi	r29, 0x00	; 0
    2320:	2f ef       	ldi	r18, 0xFF	; 255
    2322:	82 9f       	mul	r24, r18
    2324:	c0 01       	movw	r24, r0
    2326:	11 24       	eor	r1, r1
    2328:	81 55       	subi	r24, 0x51	; 81
    232a:	92 4f       	sbci	r25, 0xF2	; 242
    232c:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <construct_telemetry_packet>
      tel_packet_payload_size[uart] = 96;
    2330:	fe 01       	movw	r30, r28
    2332:	ee 0f       	add	r30, r30
    2334:	ff 1f       	adc	r31, r31
    2336:	e7 5c       	subi	r30, 0xC7	; 199
    2338:	f8 4f       	sbci	r31, 0xF8	; 248
    233a:	80 e6       	ldi	r24, 0x60	; 96
    233c:	90 e0       	ldi	r25, 0x00	; 0
    233e:	21 c0       	rjmp	.+66     	; 0x2382 <transmit_packet+0x90>
      break;
    case VCP_INVALID_COMMAND:
      tel_packet_payload[uart][0] = VCP_INVALID_COMMAND;
    2340:	e8 2f       	mov	r30, r24
    2342:	f0 e0       	ldi	r31, 0x00	; 0
    2344:	8f ef       	ldi	r24, 0xFF	; 255
    2346:	b8 9e       	mul	r11, r24
    2348:	d0 01       	movw	r26, r0
    234a:	11 24       	eor	r1, r1
    234c:	a1 55       	subi	r26, 0x51	; 81
    234e:	b2 4f       	sbci	r27, 0xF2	; 242
    2350:	6c 93       	st	X, r22
      tel_packet_payload_size[uart] = 1;
    2352:	ee 0f       	add	r30, r30
    2354:	ff 1f       	adc	r31, r31
    2356:	e7 5c       	subi	r30, 0xC7	; 199
    2358:	f8 4f       	sbci	r31, 0xF8	; 248
    235a:	81 e0       	ldi	r24, 0x01	; 1
    235c:	90 e0       	ldi	r25, 0x00	; 0
    235e:	11 c0       	rjmp	.+34     	; 0x2382 <transmit_packet+0x90>
      break;
    case VCP_ACK:
      tel_packet_payload[uart][0] = VCP_ACK;
    2360:	e8 2f       	mov	r30, r24
    2362:	f0 e0       	ldi	r31, 0x00	; 0
    2364:	2f ef       	ldi	r18, 0xFF	; 255
    2366:	82 9f       	mul	r24, r18
    2368:	d0 01       	movw	r26, r0
    236a:	11 24       	eor	r1, r1
    236c:	a1 55       	subi	r26, 0x51	; 81
    236e:	b2 4f       	sbci	r27, 0xF2	; 242
    2370:	6c 93       	st	X, r22
      tel_packet_payload[uart][1] = ack_command;
    2372:	11 96       	adiw	r26, 0x01	; 1
    2374:	4c 93       	st	X, r20
      tel_packet_payload_size[uart] = 2;
    2376:	ee 0f       	add	r30, r30
    2378:	ff 1f       	adc	r31, r31
    237a:	e7 5c       	subi	r30, 0xC7	; 199
    237c:	f8 4f       	sbci	r31, 0xF8	; 248
    237e:	82 e0       	ldi	r24, 0x02	; 2
    2380:	90 e0       	ldi	r25, 0x00	; 0
    2382:	91 83       	std	Z+1, r25	; 0x01
    2384:	80 83       	st	Z, r24
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2386:	8b 2c       	mov	r8, r11
    2388:	91 2c       	mov	r9, r1
    238a:	8f ef       	ldi	r24, 0xFF	; 255
    238c:	b8 9e       	mul	r11, r24
    238e:	70 01       	movw	r14, r0
    2390:	11 24       	eor	r1, r1
    2392:	e7 01       	movw	r28, r14
    2394:	c6 58       	subi	r28, 0x86	; 134
    2396:	d6 4f       	sbci	r29, 0xF6	; 246
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
    2398:	64 01       	movw	r12, r8
    239a:	cc 0c       	add	r12, r12
    239c:	dd 1c       	adc	r13, r13
    239e:	f6 01       	movw	r30, r12
    23a0:	e7 5c       	subi	r30, 0xC7	; 199
    23a2:	f8 4f       	sbci	r31, 0xF8	; 248
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    23a4:	00 81       	ld	r16, Z
    23a6:	11 81       	ldd	r17, Z+1	; 0x01
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
    23a8:	97 01       	movw	r18, r14
    23aa:	21 55       	subi	r18, 0x51	; 81
    23ac:	32 4f       	sbci	r19, 0xF2	; 242
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    23ae:	a4 e8       	ldi	r26, 0x84	; 132
    23b0:	6a 2e       	mov	r6, r26
    23b2:	ad e0       	ldi	r26, 0x0D	; 13
    23b4:	7a 2e       	mov	r7, r26
    23b6:	6c 0c       	add	r6, r12
    23b8:	7d 1c       	adc	r7, r13
    23ba:	41 e0       	ldi	r20, 0x01	; 1
    23bc:	b3 01       	movw	r22, r6
    23be:	ce 01       	movw	r24, r28
    23c0:	0e 94 17 0b 	call	0x162e	; 0x162e <Create_VCP_frame>
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
                  );

  // VCP frame creation was successful
  if ( VCP_tx_status == VCP_TERM )
    23c4:	81 30       	cpi	r24, 0x01	; 1
    23c6:	a1 f5       	brne	.+104    	; 0x2430 <transmit_packet+0x13e>
  {
    tel_packet_size[uart] = dest_size[uart];
    23c8:	f3 01       	movw	r30, r6
    23ca:	80 81       	ld	r24, Z
    23cc:	91 81       	ldd	r25, Z+1	; 0x01
    23ce:	f6 01       	movw	r30, r12
    23d0:	e7 5d       	subi	r30, 0xD7	; 215
    23d2:	fc 4f       	sbci	r31, 0xFC	; 252
    23d4:	91 83       	std	Z+1, r25	; 0x01
    23d6:	80 83       	st	Z, r24
    memcpy( tel_packet[uart], dest_data[uart], tel_packet_size[uart] );
    23d8:	80 81       	ld	r24, Z
    23da:	91 81       	ldd	r25, Z+1	; 0x01
    23dc:	97 01       	movw	r18, r14
    23de:	28 5b       	subi	r18, 0xB8	; 184
    23e0:	38 4f       	sbci	r19, 0xF8	; 248
    23e2:	ac 01       	movw	r20, r24
    23e4:	be 01       	movw	r22, r28
    23e6:	c9 01       	movw	r24, r18
    23e8:	0e 94 0f 15 	call	0x2a1e	; 0x2a1e <memcpy>
    tel_packet_index[uart] = 0;
    23ec:	f4 01       	movw	r30, r8
    23ee:	ef 5b       	subi	r30, 0xBF	; 191
    23f0:	f8 4f       	sbci	r31, 0xF8	; 248
    23f2:	10 82       	st	Z, r1
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
    23f4:	f1 e0       	ldi	r31, 0x01	; 1
    23f6:	bf 12       	cpse	r11, r31
    23f8:	06 c0       	rjmp	.+12     	; 0x2406 <transmit_packet+0x114>
    23fa:	80 91 9b 00 	lds	r24, 0x009B
    23fe:	88 23       	and	r24, r24
    2400:	b9 f0       	breq	.+46     	; 0x2430 <transmit_packet+0x13e>
      tx_put_byte( uart );
    2402:	81 e0       	ldi	r24, 0x01	; 1
    2404:	06 c0       	rjmp	.+12     	; 0x2412 <transmit_packet+0x120>
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
    2406:	b1 10       	cpse	r11, r1
    2408:	13 c0       	rjmp	.+38     	; 0x2430 <transmit_packet+0x13e>
    240a:	8b b1       	in	r24, 0x0b	; 11
    240c:	88 23       	and	r24, r24
    240e:	81 f0       	breq	.+32     	; 0x2430 <transmit_packet+0x13e>
      tx_put_byte( uart );
    2410:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    2412:	df 91       	pop	r29
    2414:	cf 91       	pop	r28
    2416:	1f 91       	pop	r17
    2418:	0f 91       	pop	r16
    241a:	ff 90       	pop	r15
    241c:	ef 90       	pop	r14
    241e:	df 90       	pop	r13
    2420:	cf 90       	pop	r12
    2422:	bf 90       	pop	r11
    2424:	9f 90       	pop	r9
    2426:	8f 90       	pop	r8
    2428:	7f 90       	pop	r7
    242a:	6f 90       	pop	r6
    tel_packet_index[uart] = 0;
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    242c:	0c 94 dd 0d 	jmp	0x1bba	; 0x1bba <tx_put_byte>
  }
}
    2430:	df 91       	pop	r29
    2432:	cf 91       	pop	r28
    2434:	1f 91       	pop	r17
    2436:	0f 91       	pop	r16
    2438:	ff 90       	pop	r15
    243a:	ef 90       	pop	r14
    243c:	df 90       	pop	r13
    243e:	cf 90       	pop	r12
    2440:	bf 90       	pop	r11
    2442:	9f 90       	pop	r9
    2444:	8f 90       	pop	r8
    2446:	7f 90       	pop	r7
    2448:	6f 90       	pop	r6
    244a:	08 95       	ret

0000244c <__subsf3>:
    244c:	50 58       	subi	r21, 0x80	; 128

0000244e <__addsf3>:
    244e:	bb 27       	eor	r27, r27
    2450:	aa 27       	eor	r26, r26
    2452:	0e d0       	rcall	.+28     	; 0x2470 <__addsf3x>
    2454:	44 c1       	rjmp	.+648    	; 0x26de <__fp_round>
    2456:	35 d1       	rcall	.+618    	; 0x26c2 <__fp_pscA>
    2458:	30 f0       	brcs	.+12     	; 0x2466 <__addsf3+0x18>
    245a:	3a d1       	rcall	.+628    	; 0x26d0 <__fp_pscB>
    245c:	20 f0       	brcs	.+8      	; 0x2466 <__addsf3+0x18>
    245e:	31 f4       	brne	.+12     	; 0x246c <__addsf3+0x1e>
    2460:	9f 3f       	cpi	r25, 0xFF	; 255
    2462:	11 f4       	brne	.+4      	; 0x2468 <__addsf3+0x1a>
    2464:	1e f4       	brtc	.+6      	; 0x246c <__addsf3+0x1e>
    2466:	2a c1       	rjmp	.+596    	; 0x26bc <__fp_nan>
    2468:	0e f4       	brtc	.+2      	; 0x246c <__addsf3+0x1e>
    246a:	e0 95       	com	r30
    246c:	e7 fb       	bst	r30, 7
    246e:	20 c1       	rjmp	.+576    	; 0x26b0 <__fp_inf>

00002470 <__addsf3x>:
    2470:	e9 2f       	mov	r30, r25
    2472:	46 d1       	rcall	.+652    	; 0x2700 <__fp_split3>
    2474:	80 f3       	brcs	.-32     	; 0x2456 <__addsf3+0x8>
    2476:	ba 17       	cp	r27, r26
    2478:	62 07       	cpc	r22, r18
    247a:	73 07       	cpc	r23, r19
    247c:	84 07       	cpc	r24, r20
    247e:	95 07       	cpc	r25, r21
    2480:	18 f0       	brcs	.+6      	; 0x2488 <__addsf3x+0x18>
    2482:	71 f4       	brne	.+28     	; 0x24a0 <__addsf3x+0x30>
    2484:	9e f5       	brtc	.+102    	; 0x24ec <__addsf3x+0x7c>
    2486:	5e c1       	rjmp	.+700    	; 0x2744 <__fp_zero>
    2488:	0e f4       	brtc	.+2      	; 0x248c <__addsf3x+0x1c>
    248a:	e0 95       	com	r30
    248c:	0b 2e       	mov	r0, r27
    248e:	ba 2f       	mov	r27, r26
    2490:	a0 2d       	mov	r26, r0
    2492:	0b 01       	movw	r0, r22
    2494:	b9 01       	movw	r22, r18
    2496:	90 01       	movw	r18, r0
    2498:	0c 01       	movw	r0, r24
    249a:	ca 01       	movw	r24, r20
    249c:	a0 01       	movw	r20, r0
    249e:	11 24       	eor	r1, r1
    24a0:	ff 27       	eor	r31, r31
    24a2:	59 1b       	sub	r21, r25
    24a4:	99 f0       	breq	.+38     	; 0x24cc <__addsf3x+0x5c>
    24a6:	59 3f       	cpi	r21, 0xF9	; 249
    24a8:	50 f4       	brcc	.+20     	; 0x24be <__addsf3x+0x4e>
    24aa:	50 3e       	cpi	r21, 0xE0	; 224
    24ac:	68 f1       	brcs	.+90     	; 0x2508 <__addsf3x+0x98>
    24ae:	1a 16       	cp	r1, r26
    24b0:	f0 40       	sbci	r31, 0x00	; 0
    24b2:	a2 2f       	mov	r26, r18
    24b4:	23 2f       	mov	r18, r19
    24b6:	34 2f       	mov	r19, r20
    24b8:	44 27       	eor	r20, r20
    24ba:	58 5f       	subi	r21, 0xF8	; 248
    24bc:	f3 cf       	rjmp	.-26     	; 0x24a4 <__addsf3x+0x34>
    24be:	46 95       	lsr	r20
    24c0:	37 95       	ror	r19
    24c2:	27 95       	ror	r18
    24c4:	a7 95       	ror	r26
    24c6:	f0 40       	sbci	r31, 0x00	; 0
    24c8:	53 95       	inc	r21
    24ca:	c9 f7       	brne	.-14     	; 0x24be <__addsf3x+0x4e>
    24cc:	7e f4       	brtc	.+30     	; 0x24ec <__addsf3x+0x7c>
    24ce:	1f 16       	cp	r1, r31
    24d0:	ba 0b       	sbc	r27, r26
    24d2:	62 0b       	sbc	r22, r18
    24d4:	73 0b       	sbc	r23, r19
    24d6:	84 0b       	sbc	r24, r20
    24d8:	ba f0       	brmi	.+46     	; 0x2508 <__addsf3x+0x98>
    24da:	91 50       	subi	r25, 0x01	; 1
    24dc:	a1 f0       	breq	.+40     	; 0x2506 <__addsf3x+0x96>
    24de:	ff 0f       	add	r31, r31
    24e0:	bb 1f       	adc	r27, r27
    24e2:	66 1f       	adc	r22, r22
    24e4:	77 1f       	adc	r23, r23
    24e6:	88 1f       	adc	r24, r24
    24e8:	c2 f7       	brpl	.-16     	; 0x24da <__addsf3x+0x6a>
    24ea:	0e c0       	rjmp	.+28     	; 0x2508 <__addsf3x+0x98>
    24ec:	ba 0f       	add	r27, r26
    24ee:	62 1f       	adc	r22, r18
    24f0:	73 1f       	adc	r23, r19
    24f2:	84 1f       	adc	r24, r20
    24f4:	48 f4       	brcc	.+18     	; 0x2508 <__addsf3x+0x98>
    24f6:	87 95       	ror	r24
    24f8:	77 95       	ror	r23
    24fa:	67 95       	ror	r22
    24fc:	b7 95       	ror	r27
    24fe:	f7 95       	ror	r31
    2500:	9e 3f       	cpi	r25, 0xFE	; 254
    2502:	08 f0       	brcs	.+2      	; 0x2506 <__addsf3x+0x96>
    2504:	b3 cf       	rjmp	.-154    	; 0x246c <__addsf3+0x1e>
    2506:	93 95       	inc	r25
    2508:	88 0f       	add	r24, r24
    250a:	08 f0       	brcs	.+2      	; 0x250e <__addsf3x+0x9e>
    250c:	99 27       	eor	r25, r25
    250e:	ee 0f       	add	r30, r30
    2510:	97 95       	ror	r25
    2512:	87 95       	ror	r24
    2514:	08 95       	ret

00002516 <__cmpsf2>:
    2516:	a8 d0       	rcall	.+336    	; 0x2668 <__fp_cmp>
    2518:	08 f4       	brcc	.+2      	; 0x251c <__cmpsf2+0x6>
    251a:	81 e0       	ldi	r24, 0x01	; 1
    251c:	08 95       	ret

0000251e <__divsf3>:
    251e:	0c d0       	rcall	.+24     	; 0x2538 <__divsf3x>
    2520:	de c0       	rjmp	.+444    	; 0x26de <__fp_round>
    2522:	d6 d0       	rcall	.+428    	; 0x26d0 <__fp_pscB>
    2524:	40 f0       	brcs	.+16     	; 0x2536 <__divsf3+0x18>
    2526:	cd d0       	rcall	.+410    	; 0x26c2 <__fp_pscA>
    2528:	30 f0       	brcs	.+12     	; 0x2536 <__divsf3+0x18>
    252a:	21 f4       	brne	.+8      	; 0x2534 <__divsf3+0x16>
    252c:	5f 3f       	cpi	r21, 0xFF	; 255
    252e:	19 f0       	breq	.+6      	; 0x2536 <__divsf3+0x18>
    2530:	bf c0       	rjmp	.+382    	; 0x26b0 <__fp_inf>
    2532:	51 11       	cpse	r21, r1
    2534:	08 c1       	rjmp	.+528    	; 0x2746 <__fp_szero>
    2536:	c2 c0       	rjmp	.+388    	; 0x26bc <__fp_nan>

00002538 <__divsf3x>:
    2538:	e3 d0       	rcall	.+454    	; 0x2700 <__fp_split3>
    253a:	98 f3       	brcs	.-26     	; 0x2522 <__divsf3+0x4>

0000253c <__divsf3_pse>:
    253c:	99 23       	and	r25, r25
    253e:	c9 f3       	breq	.-14     	; 0x2532 <__divsf3+0x14>
    2540:	55 23       	and	r21, r21
    2542:	b1 f3       	breq	.-20     	; 0x2530 <__divsf3+0x12>
    2544:	95 1b       	sub	r25, r21
    2546:	55 0b       	sbc	r21, r21
    2548:	bb 27       	eor	r27, r27
    254a:	aa 27       	eor	r26, r26
    254c:	62 17       	cp	r22, r18
    254e:	73 07       	cpc	r23, r19
    2550:	84 07       	cpc	r24, r20
    2552:	38 f0       	brcs	.+14     	; 0x2562 <__divsf3_pse+0x26>
    2554:	9f 5f       	subi	r25, 0xFF	; 255
    2556:	5f 4f       	sbci	r21, 0xFF	; 255
    2558:	22 0f       	add	r18, r18
    255a:	33 1f       	adc	r19, r19
    255c:	44 1f       	adc	r20, r20
    255e:	aa 1f       	adc	r26, r26
    2560:	a9 f3       	breq	.-22     	; 0x254c <__divsf3_pse+0x10>
    2562:	33 d0       	rcall	.+102    	; 0x25ca <__divsf3_pse+0x8e>
    2564:	0e 2e       	mov	r0, r30
    2566:	3a f0       	brmi	.+14     	; 0x2576 <__divsf3_pse+0x3a>
    2568:	e0 e8       	ldi	r30, 0x80	; 128
    256a:	30 d0       	rcall	.+96     	; 0x25cc <__divsf3_pse+0x90>
    256c:	91 50       	subi	r25, 0x01	; 1
    256e:	50 40       	sbci	r21, 0x00	; 0
    2570:	e6 95       	lsr	r30
    2572:	00 1c       	adc	r0, r0
    2574:	ca f7       	brpl	.-14     	; 0x2568 <__divsf3_pse+0x2c>
    2576:	29 d0       	rcall	.+82     	; 0x25ca <__divsf3_pse+0x8e>
    2578:	fe 2f       	mov	r31, r30
    257a:	27 d0       	rcall	.+78     	; 0x25ca <__divsf3_pse+0x8e>
    257c:	66 0f       	add	r22, r22
    257e:	77 1f       	adc	r23, r23
    2580:	88 1f       	adc	r24, r24
    2582:	bb 1f       	adc	r27, r27
    2584:	26 17       	cp	r18, r22
    2586:	37 07       	cpc	r19, r23
    2588:	48 07       	cpc	r20, r24
    258a:	ab 07       	cpc	r26, r27
    258c:	b0 e8       	ldi	r27, 0x80	; 128
    258e:	09 f0       	breq	.+2      	; 0x2592 <__divsf3_pse+0x56>
    2590:	bb 0b       	sbc	r27, r27
    2592:	80 2d       	mov	r24, r0
    2594:	bf 01       	movw	r22, r30
    2596:	ff 27       	eor	r31, r31
    2598:	93 58       	subi	r25, 0x83	; 131
    259a:	5f 4f       	sbci	r21, 0xFF	; 255
    259c:	2a f0       	brmi	.+10     	; 0x25a8 <__divsf3_pse+0x6c>
    259e:	9e 3f       	cpi	r25, 0xFE	; 254
    25a0:	51 05       	cpc	r21, r1
    25a2:	68 f0       	brcs	.+26     	; 0x25be <__divsf3_pse+0x82>
    25a4:	85 c0       	rjmp	.+266    	; 0x26b0 <__fp_inf>
    25a6:	cf c0       	rjmp	.+414    	; 0x2746 <__fp_szero>
    25a8:	5f 3f       	cpi	r21, 0xFF	; 255
    25aa:	ec f3       	brlt	.-6      	; 0x25a6 <__divsf3_pse+0x6a>
    25ac:	98 3e       	cpi	r25, 0xE8	; 232
    25ae:	dc f3       	brlt	.-10     	; 0x25a6 <__divsf3_pse+0x6a>
    25b0:	86 95       	lsr	r24
    25b2:	77 95       	ror	r23
    25b4:	67 95       	ror	r22
    25b6:	b7 95       	ror	r27
    25b8:	f7 95       	ror	r31
    25ba:	9f 5f       	subi	r25, 0xFF	; 255
    25bc:	c9 f7       	brne	.-14     	; 0x25b0 <__divsf3_pse+0x74>
    25be:	88 0f       	add	r24, r24
    25c0:	91 1d       	adc	r25, r1
    25c2:	96 95       	lsr	r25
    25c4:	87 95       	ror	r24
    25c6:	97 f9       	bld	r25, 7
    25c8:	08 95       	ret
    25ca:	e1 e0       	ldi	r30, 0x01	; 1
    25cc:	66 0f       	add	r22, r22
    25ce:	77 1f       	adc	r23, r23
    25d0:	88 1f       	adc	r24, r24
    25d2:	bb 1f       	adc	r27, r27
    25d4:	62 17       	cp	r22, r18
    25d6:	73 07       	cpc	r23, r19
    25d8:	84 07       	cpc	r24, r20
    25da:	ba 07       	cpc	r27, r26
    25dc:	20 f0       	brcs	.+8      	; 0x25e6 <__divsf3_pse+0xaa>
    25de:	62 1b       	sub	r22, r18
    25e0:	73 0b       	sbc	r23, r19
    25e2:	84 0b       	sbc	r24, r20
    25e4:	ba 0b       	sbc	r27, r26
    25e6:	ee 1f       	adc	r30, r30
    25e8:	88 f7       	brcc	.-30     	; 0x25cc <__divsf3_pse+0x90>
    25ea:	e0 95       	com	r30
    25ec:	08 95       	ret

000025ee <__floatunsisf>:
    25ee:	e8 94       	clt
    25f0:	09 c0       	rjmp	.+18     	; 0x2604 <__floatsisf+0x12>

000025f2 <__floatsisf>:
    25f2:	97 fb       	bst	r25, 7
    25f4:	3e f4       	brtc	.+14     	; 0x2604 <__floatsisf+0x12>
    25f6:	90 95       	com	r25
    25f8:	80 95       	com	r24
    25fa:	70 95       	com	r23
    25fc:	61 95       	neg	r22
    25fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2600:	8f 4f       	sbci	r24, 0xFF	; 255
    2602:	9f 4f       	sbci	r25, 0xFF	; 255
    2604:	99 23       	and	r25, r25
    2606:	a9 f0       	breq	.+42     	; 0x2632 <__floatsisf+0x40>
    2608:	f9 2f       	mov	r31, r25
    260a:	96 e9       	ldi	r25, 0x96	; 150
    260c:	bb 27       	eor	r27, r27
    260e:	93 95       	inc	r25
    2610:	f6 95       	lsr	r31
    2612:	87 95       	ror	r24
    2614:	77 95       	ror	r23
    2616:	67 95       	ror	r22
    2618:	b7 95       	ror	r27
    261a:	f1 11       	cpse	r31, r1
    261c:	f8 cf       	rjmp	.-16     	; 0x260e <__floatsisf+0x1c>
    261e:	fa f4       	brpl	.+62     	; 0x265e <__floatsisf+0x6c>
    2620:	bb 0f       	add	r27, r27
    2622:	11 f4       	brne	.+4      	; 0x2628 <__floatsisf+0x36>
    2624:	60 ff       	sbrs	r22, 0
    2626:	1b c0       	rjmp	.+54     	; 0x265e <__floatsisf+0x6c>
    2628:	6f 5f       	subi	r22, 0xFF	; 255
    262a:	7f 4f       	sbci	r23, 0xFF	; 255
    262c:	8f 4f       	sbci	r24, 0xFF	; 255
    262e:	9f 4f       	sbci	r25, 0xFF	; 255
    2630:	16 c0       	rjmp	.+44     	; 0x265e <__floatsisf+0x6c>
    2632:	88 23       	and	r24, r24
    2634:	11 f0       	breq	.+4      	; 0x263a <__floatsisf+0x48>
    2636:	96 e9       	ldi	r25, 0x96	; 150
    2638:	11 c0       	rjmp	.+34     	; 0x265c <__floatsisf+0x6a>
    263a:	77 23       	and	r23, r23
    263c:	21 f0       	breq	.+8      	; 0x2646 <__floatsisf+0x54>
    263e:	9e e8       	ldi	r25, 0x8E	; 142
    2640:	87 2f       	mov	r24, r23
    2642:	76 2f       	mov	r23, r22
    2644:	05 c0       	rjmp	.+10     	; 0x2650 <__floatsisf+0x5e>
    2646:	66 23       	and	r22, r22
    2648:	71 f0       	breq	.+28     	; 0x2666 <__floatsisf+0x74>
    264a:	96 e8       	ldi	r25, 0x86	; 134
    264c:	86 2f       	mov	r24, r22
    264e:	70 e0       	ldi	r23, 0x00	; 0
    2650:	60 e0       	ldi	r22, 0x00	; 0
    2652:	2a f0       	brmi	.+10     	; 0x265e <__floatsisf+0x6c>
    2654:	9a 95       	dec	r25
    2656:	66 0f       	add	r22, r22
    2658:	77 1f       	adc	r23, r23
    265a:	88 1f       	adc	r24, r24
    265c:	da f7       	brpl	.-10     	; 0x2654 <__floatsisf+0x62>
    265e:	88 0f       	add	r24, r24
    2660:	96 95       	lsr	r25
    2662:	87 95       	ror	r24
    2664:	97 f9       	bld	r25, 7
    2666:	08 95       	ret

00002668 <__fp_cmp>:
    2668:	99 0f       	add	r25, r25
    266a:	00 08       	sbc	r0, r0
    266c:	55 0f       	add	r21, r21
    266e:	aa 0b       	sbc	r26, r26
    2670:	e0 e8       	ldi	r30, 0x80	; 128
    2672:	fe ef       	ldi	r31, 0xFE	; 254
    2674:	16 16       	cp	r1, r22
    2676:	17 06       	cpc	r1, r23
    2678:	e8 07       	cpc	r30, r24
    267a:	f9 07       	cpc	r31, r25
    267c:	c0 f0       	brcs	.+48     	; 0x26ae <__fp_cmp+0x46>
    267e:	12 16       	cp	r1, r18
    2680:	13 06       	cpc	r1, r19
    2682:	e4 07       	cpc	r30, r20
    2684:	f5 07       	cpc	r31, r21
    2686:	98 f0       	brcs	.+38     	; 0x26ae <__fp_cmp+0x46>
    2688:	62 1b       	sub	r22, r18
    268a:	73 0b       	sbc	r23, r19
    268c:	84 0b       	sbc	r24, r20
    268e:	95 0b       	sbc	r25, r21
    2690:	39 f4       	brne	.+14     	; 0x26a0 <__fp_cmp+0x38>
    2692:	0a 26       	eor	r0, r26
    2694:	61 f0       	breq	.+24     	; 0x26ae <__fp_cmp+0x46>
    2696:	23 2b       	or	r18, r19
    2698:	24 2b       	or	r18, r20
    269a:	25 2b       	or	r18, r21
    269c:	21 f4       	brne	.+8      	; 0x26a6 <__fp_cmp+0x3e>
    269e:	08 95       	ret
    26a0:	0a 26       	eor	r0, r26
    26a2:	09 f4       	brne	.+2      	; 0x26a6 <__fp_cmp+0x3e>
    26a4:	a1 40       	sbci	r26, 0x01	; 1
    26a6:	a6 95       	lsr	r26
    26a8:	8f ef       	ldi	r24, 0xFF	; 255
    26aa:	81 1d       	adc	r24, r1
    26ac:	81 1d       	adc	r24, r1
    26ae:	08 95       	ret

000026b0 <__fp_inf>:
    26b0:	97 f9       	bld	r25, 7
    26b2:	9f 67       	ori	r25, 0x7F	; 127
    26b4:	80 e8       	ldi	r24, 0x80	; 128
    26b6:	70 e0       	ldi	r23, 0x00	; 0
    26b8:	60 e0       	ldi	r22, 0x00	; 0
    26ba:	08 95       	ret

000026bc <__fp_nan>:
    26bc:	9f ef       	ldi	r25, 0xFF	; 255
    26be:	80 ec       	ldi	r24, 0xC0	; 192
    26c0:	08 95       	ret

000026c2 <__fp_pscA>:
    26c2:	00 24       	eor	r0, r0
    26c4:	0a 94       	dec	r0
    26c6:	16 16       	cp	r1, r22
    26c8:	17 06       	cpc	r1, r23
    26ca:	18 06       	cpc	r1, r24
    26cc:	09 06       	cpc	r0, r25
    26ce:	08 95       	ret

000026d0 <__fp_pscB>:
    26d0:	00 24       	eor	r0, r0
    26d2:	0a 94       	dec	r0
    26d4:	12 16       	cp	r1, r18
    26d6:	13 06       	cpc	r1, r19
    26d8:	14 06       	cpc	r1, r20
    26da:	05 06       	cpc	r0, r21
    26dc:	08 95       	ret

000026de <__fp_round>:
    26de:	09 2e       	mov	r0, r25
    26e0:	03 94       	inc	r0
    26e2:	00 0c       	add	r0, r0
    26e4:	11 f4       	brne	.+4      	; 0x26ea <__fp_round+0xc>
    26e6:	88 23       	and	r24, r24
    26e8:	52 f0       	brmi	.+20     	; 0x26fe <__fp_round+0x20>
    26ea:	bb 0f       	add	r27, r27
    26ec:	40 f4       	brcc	.+16     	; 0x26fe <__fp_round+0x20>
    26ee:	bf 2b       	or	r27, r31
    26f0:	11 f4       	brne	.+4      	; 0x26f6 <__fp_round+0x18>
    26f2:	60 ff       	sbrs	r22, 0
    26f4:	04 c0       	rjmp	.+8      	; 0x26fe <__fp_round+0x20>
    26f6:	6f 5f       	subi	r22, 0xFF	; 255
    26f8:	7f 4f       	sbci	r23, 0xFF	; 255
    26fa:	8f 4f       	sbci	r24, 0xFF	; 255
    26fc:	9f 4f       	sbci	r25, 0xFF	; 255
    26fe:	08 95       	ret

00002700 <__fp_split3>:
    2700:	57 fd       	sbrc	r21, 7
    2702:	90 58       	subi	r25, 0x80	; 128
    2704:	44 0f       	add	r20, r20
    2706:	55 1f       	adc	r21, r21
    2708:	59 f0       	breq	.+22     	; 0x2720 <__fp_splitA+0x10>
    270a:	5f 3f       	cpi	r21, 0xFF	; 255
    270c:	71 f0       	breq	.+28     	; 0x272a <__fp_splitA+0x1a>
    270e:	47 95       	ror	r20

00002710 <__fp_splitA>:
    2710:	88 0f       	add	r24, r24
    2712:	97 fb       	bst	r25, 7
    2714:	99 1f       	adc	r25, r25
    2716:	61 f0       	breq	.+24     	; 0x2730 <__fp_splitA+0x20>
    2718:	9f 3f       	cpi	r25, 0xFF	; 255
    271a:	79 f0       	breq	.+30     	; 0x273a <__fp_splitA+0x2a>
    271c:	87 95       	ror	r24
    271e:	08 95       	ret
    2720:	12 16       	cp	r1, r18
    2722:	13 06       	cpc	r1, r19
    2724:	14 06       	cpc	r1, r20
    2726:	55 1f       	adc	r21, r21
    2728:	f2 cf       	rjmp	.-28     	; 0x270e <__fp_split3+0xe>
    272a:	46 95       	lsr	r20
    272c:	f1 df       	rcall	.-30     	; 0x2710 <__fp_splitA>
    272e:	08 c0       	rjmp	.+16     	; 0x2740 <__fp_splitA+0x30>
    2730:	16 16       	cp	r1, r22
    2732:	17 06       	cpc	r1, r23
    2734:	18 06       	cpc	r1, r24
    2736:	99 1f       	adc	r25, r25
    2738:	f1 cf       	rjmp	.-30     	; 0x271c <__fp_splitA+0xc>
    273a:	86 95       	lsr	r24
    273c:	71 05       	cpc	r23, r1
    273e:	61 05       	cpc	r22, r1
    2740:	08 94       	sec
    2742:	08 95       	ret

00002744 <__fp_zero>:
    2744:	e8 94       	clt

00002746 <__fp_szero>:
    2746:	bb 27       	eor	r27, r27
    2748:	66 27       	eor	r22, r22
    274a:	77 27       	eor	r23, r23
    274c:	cb 01       	movw	r24, r22
    274e:	97 f9       	bld	r25, 7
    2750:	08 95       	ret

00002752 <__gesf2>:
    2752:	8a df       	rcall	.-236    	; 0x2668 <__fp_cmp>
    2754:	08 f4       	brcc	.+2      	; 0x2758 <__gesf2+0x6>
    2756:	8f ef       	ldi	r24, 0xFF	; 255
    2758:	08 95       	ret

0000275a <__udivmodhi4>:
    275a:	aa 1b       	sub	r26, r26
    275c:	bb 1b       	sub	r27, r27
    275e:	51 e1       	ldi	r21, 0x11	; 17
    2760:	07 c0       	rjmp	.+14     	; 0x2770 <__udivmodhi4_ep>

00002762 <__udivmodhi4_loop>:
    2762:	aa 1f       	adc	r26, r26
    2764:	bb 1f       	adc	r27, r27
    2766:	a6 17       	cp	r26, r22
    2768:	b7 07       	cpc	r27, r23
    276a:	10 f0       	brcs	.+4      	; 0x2770 <__udivmodhi4_ep>
    276c:	a6 1b       	sub	r26, r22
    276e:	b7 0b       	sbc	r27, r23

00002770 <__udivmodhi4_ep>:
    2770:	88 1f       	adc	r24, r24
    2772:	99 1f       	adc	r25, r25
    2774:	5a 95       	dec	r21
    2776:	a9 f7       	brne	.-22     	; 0x2762 <__udivmodhi4_loop>
    2778:	80 95       	com	r24
    277a:	90 95       	com	r25
    277c:	bc 01       	movw	r22, r24
    277e:	cd 01       	movw	r24, r26
    2780:	08 95       	ret

00002782 <__divmodhi4>:
    2782:	97 fb       	bst	r25, 7
    2784:	07 2e       	mov	r0, r23
    2786:	16 f4       	brtc	.+4      	; 0x278c <__divmodhi4+0xa>
    2788:	00 94       	com	r0
    278a:	07 d0       	rcall	.+14     	; 0x279a <__divmodhi4_neg1>
    278c:	77 fd       	sbrc	r23, 7
    278e:	09 d0       	rcall	.+18     	; 0x27a2 <__divmodhi4_neg2>
    2790:	0e 94 ad 13 	call	0x275a	; 0x275a <__udivmodhi4>
    2794:	07 fc       	sbrc	r0, 7
    2796:	05 d0       	rcall	.+10     	; 0x27a2 <__divmodhi4_neg2>
    2798:	3e f4       	brtc	.+14     	; 0x27a8 <__divmodhi4_exit>

0000279a <__divmodhi4_neg1>:
    279a:	90 95       	com	r25
    279c:	81 95       	neg	r24
    279e:	9f 4f       	sbci	r25, 0xFF	; 255
    27a0:	08 95       	ret

000027a2 <__divmodhi4_neg2>:
    27a2:	70 95       	com	r23
    27a4:	61 95       	neg	r22
    27a6:	7f 4f       	sbci	r23, 0xFF	; 255

000027a8 <__divmodhi4_exit>:
    27a8:	08 95       	ret

000027aa <malloc>:
    27aa:	0f 93       	push	r16
    27ac:	1f 93       	push	r17
    27ae:	cf 93       	push	r28
    27b0:	df 93       	push	r29
    27b2:	82 30       	cpi	r24, 0x02	; 2
    27b4:	91 05       	cpc	r25, r1
    27b6:	10 f4       	brcc	.+4      	; 0x27bc <malloc+0x12>
    27b8:	82 e0       	ldi	r24, 0x02	; 2
    27ba:	90 e0       	ldi	r25, 0x00	; 0
    27bc:	e0 91 b0 0f 	lds	r30, 0x0FB0
    27c0:	f0 91 b1 0f 	lds	r31, 0x0FB1
    27c4:	20 e0       	ldi	r18, 0x00	; 0
    27c6:	30 e0       	ldi	r19, 0x00	; 0
    27c8:	c0 e0       	ldi	r28, 0x00	; 0
    27ca:	d0 e0       	ldi	r29, 0x00	; 0
    27cc:	23 c0       	rjmp	.+70     	; 0x2814 <malloc+0x6a>
    27ce:	40 81       	ld	r20, Z
    27d0:	51 81       	ldd	r21, Z+1	; 0x01
    27d2:	48 17       	cp	r20, r24
    27d4:	59 07       	cpc	r21, r25
    27d6:	a8 f0       	brcs	.+42     	; 0x2802 <malloc+0x58>
    27d8:	48 17       	cp	r20, r24
    27da:	59 07       	cpc	r21, r25
    27dc:	61 f4       	brne	.+24     	; 0x27f6 <malloc+0x4c>
    27de:	82 81       	ldd	r24, Z+2	; 0x02
    27e0:	93 81       	ldd	r25, Z+3	; 0x03
    27e2:	20 97       	sbiw	r28, 0x00	; 0
    27e4:	19 f0       	breq	.+6      	; 0x27ec <malloc+0x42>
    27e6:	9b 83       	std	Y+3, r25	; 0x03
    27e8:	8a 83       	std	Y+2, r24	; 0x02
    27ea:	2e c0       	rjmp	.+92     	; 0x2848 <malloc+0x9e>
    27ec:	90 93 b1 0f 	sts	0x0FB1, r25
    27f0:	80 93 b0 0f 	sts	0x0FB0, r24
    27f4:	29 c0       	rjmp	.+82     	; 0x2848 <malloc+0x9e>
    27f6:	21 15       	cp	r18, r1
    27f8:	31 05       	cpc	r19, r1
    27fa:	29 f0       	breq	.+10     	; 0x2806 <malloc+0x5c>
    27fc:	42 17       	cp	r20, r18
    27fe:	53 07       	cpc	r21, r19
    2800:	10 f0       	brcs	.+4      	; 0x2806 <malloc+0x5c>
    2802:	a9 01       	movw	r20, r18
    2804:	02 c0       	rjmp	.+4      	; 0x280a <malloc+0x60>
    2806:	be 01       	movw	r22, r28
    2808:	df 01       	movw	r26, r30
    280a:	02 81       	ldd	r16, Z+2	; 0x02
    280c:	13 81       	ldd	r17, Z+3	; 0x03
    280e:	ef 01       	movw	r28, r30
    2810:	9a 01       	movw	r18, r20
    2812:	f8 01       	movw	r30, r16
    2814:	30 97       	sbiw	r30, 0x00	; 0
    2816:	d9 f6       	brne	.-74     	; 0x27ce <malloc+0x24>
    2818:	21 15       	cp	r18, r1
    281a:	31 05       	cpc	r19, r1
    281c:	09 f1       	breq	.+66     	; 0x2860 <malloc+0xb6>
    281e:	28 1b       	sub	r18, r24
    2820:	39 0b       	sbc	r19, r25
    2822:	24 30       	cpi	r18, 0x04	; 4
    2824:	31 05       	cpc	r19, r1
    2826:	90 f4       	brcc	.+36     	; 0x284c <malloc+0xa2>
    2828:	12 96       	adiw	r26, 0x02	; 2
    282a:	8d 91       	ld	r24, X+
    282c:	9c 91       	ld	r25, X
    282e:	13 97       	sbiw	r26, 0x03	; 3
    2830:	61 15       	cp	r22, r1
    2832:	71 05       	cpc	r23, r1
    2834:	21 f0       	breq	.+8      	; 0x283e <malloc+0x94>
    2836:	fb 01       	movw	r30, r22
    2838:	93 83       	std	Z+3, r25	; 0x03
    283a:	82 83       	std	Z+2, r24	; 0x02
    283c:	04 c0       	rjmp	.+8      	; 0x2846 <malloc+0x9c>
    283e:	90 93 b1 0f 	sts	0x0FB1, r25
    2842:	80 93 b0 0f 	sts	0x0FB0, r24
    2846:	fd 01       	movw	r30, r26
    2848:	32 96       	adiw	r30, 0x02	; 2
    284a:	44 c0       	rjmp	.+136    	; 0x28d4 <malloc+0x12a>
    284c:	fd 01       	movw	r30, r26
    284e:	e2 0f       	add	r30, r18
    2850:	f3 1f       	adc	r31, r19
    2852:	81 93       	st	Z+, r24
    2854:	91 93       	st	Z+, r25
    2856:	22 50       	subi	r18, 0x02	; 2
    2858:	31 09       	sbc	r19, r1
    285a:	2d 93       	st	X+, r18
    285c:	3c 93       	st	X, r19
    285e:	3a c0       	rjmp	.+116    	; 0x28d4 <malloc+0x12a>
    2860:	20 91 ae 0f 	lds	r18, 0x0FAE
    2864:	30 91 af 0f 	lds	r19, 0x0FAF
    2868:	23 2b       	or	r18, r19
    286a:	41 f4       	brne	.+16     	; 0x287c <malloc+0xd2>
    286c:	20 91 02 01 	lds	r18, 0x0102
    2870:	30 91 03 01 	lds	r19, 0x0103
    2874:	30 93 af 0f 	sts	0x0FAF, r19
    2878:	20 93 ae 0f 	sts	0x0FAE, r18
    287c:	20 91 00 01 	lds	r18, 0x0100
    2880:	30 91 01 01 	lds	r19, 0x0101
    2884:	21 15       	cp	r18, r1
    2886:	31 05       	cpc	r19, r1
    2888:	41 f4       	brne	.+16     	; 0x289a <malloc+0xf0>
    288a:	2d b7       	in	r18, 0x3d	; 61
    288c:	3e b7       	in	r19, 0x3e	; 62
    288e:	40 91 04 01 	lds	r20, 0x0104
    2892:	50 91 05 01 	lds	r21, 0x0105
    2896:	24 1b       	sub	r18, r20
    2898:	35 0b       	sbc	r19, r21
    289a:	e0 91 ae 0f 	lds	r30, 0x0FAE
    289e:	f0 91 af 0f 	lds	r31, 0x0FAF
    28a2:	e2 17       	cp	r30, r18
    28a4:	f3 07       	cpc	r31, r19
    28a6:	a0 f4       	brcc	.+40     	; 0x28d0 <malloc+0x126>
    28a8:	2e 1b       	sub	r18, r30
    28aa:	3f 0b       	sbc	r19, r31
    28ac:	28 17       	cp	r18, r24
    28ae:	39 07       	cpc	r19, r25
    28b0:	78 f0       	brcs	.+30     	; 0x28d0 <malloc+0x126>
    28b2:	ac 01       	movw	r20, r24
    28b4:	4e 5f       	subi	r20, 0xFE	; 254
    28b6:	5f 4f       	sbci	r21, 0xFF	; 255
    28b8:	24 17       	cp	r18, r20
    28ba:	35 07       	cpc	r19, r21
    28bc:	48 f0       	brcs	.+18     	; 0x28d0 <malloc+0x126>
    28be:	4e 0f       	add	r20, r30
    28c0:	5f 1f       	adc	r21, r31
    28c2:	50 93 af 0f 	sts	0x0FAF, r21
    28c6:	40 93 ae 0f 	sts	0x0FAE, r20
    28ca:	81 93       	st	Z+, r24
    28cc:	91 93       	st	Z+, r25
    28ce:	02 c0       	rjmp	.+4      	; 0x28d4 <malloc+0x12a>
    28d0:	e0 e0       	ldi	r30, 0x00	; 0
    28d2:	f0 e0       	ldi	r31, 0x00	; 0
    28d4:	cf 01       	movw	r24, r30
    28d6:	df 91       	pop	r29
    28d8:	cf 91       	pop	r28
    28da:	1f 91       	pop	r17
    28dc:	0f 91       	pop	r16
    28de:	08 95       	ret

000028e0 <free>:
    28e0:	ef 92       	push	r14
    28e2:	ff 92       	push	r15
    28e4:	0f 93       	push	r16
    28e6:	1f 93       	push	r17
    28e8:	cf 93       	push	r28
    28ea:	df 93       	push	r29
    28ec:	00 97       	sbiw	r24, 0x00	; 0
    28ee:	09 f4       	brne	.+2      	; 0x28f2 <free+0x12>
    28f0:	8f c0       	rjmp	.+286    	; 0x2a10 <free+0x130>
    28f2:	dc 01       	movw	r26, r24
    28f4:	12 97       	sbiw	r26, 0x02	; 2
    28f6:	13 96       	adiw	r26, 0x03	; 3
    28f8:	1c 92       	st	X, r1
    28fa:	1e 92       	st	-X, r1
    28fc:	12 97       	sbiw	r26, 0x02	; 2
    28fe:	e0 90 b0 0f 	lds	r14, 0x0FB0
    2902:	f0 90 b1 0f 	lds	r15, 0x0FB1
    2906:	e1 14       	cp	r14, r1
    2908:	f1 04       	cpc	r15, r1
    290a:	89 f4       	brne	.+34     	; 0x292e <free+0x4e>
    290c:	2d 91       	ld	r18, X+
    290e:	3c 91       	ld	r19, X
    2910:	11 97       	sbiw	r26, 0x01	; 1
    2912:	28 0f       	add	r18, r24
    2914:	39 1f       	adc	r19, r25
    2916:	80 91 ae 0f 	lds	r24, 0x0FAE
    291a:	90 91 af 0f 	lds	r25, 0x0FAF
    291e:	82 17       	cp	r24, r18
    2920:	93 07       	cpc	r25, r19
    2922:	89 f5       	brne	.+98     	; 0x2986 <free+0xa6>
    2924:	b0 93 af 0f 	sts	0x0FAF, r27
    2928:	a0 93 ae 0f 	sts	0x0FAE, r26
    292c:	71 c0       	rjmp	.+226    	; 0x2a10 <free+0x130>
    292e:	e7 01       	movw	r28, r14
    2930:	20 e0       	ldi	r18, 0x00	; 0
    2932:	30 e0       	ldi	r19, 0x00	; 0
    2934:	01 c0       	rjmp	.+2      	; 0x2938 <free+0x58>
    2936:	ea 01       	movw	r28, r20
    2938:	ca 17       	cp	r28, r26
    293a:	db 07       	cpc	r29, r27
    293c:	38 f4       	brcc	.+14     	; 0x294c <free+0x6c>
    293e:	4a 81       	ldd	r20, Y+2	; 0x02
    2940:	5b 81       	ldd	r21, Y+3	; 0x03
    2942:	9e 01       	movw	r18, r28
    2944:	41 15       	cp	r20, r1
    2946:	51 05       	cpc	r21, r1
    2948:	b1 f7       	brne	.-20     	; 0x2936 <free+0x56>
    294a:	22 c0       	rjmp	.+68     	; 0x2990 <free+0xb0>
    294c:	bc 01       	movw	r22, r24
    294e:	62 50       	subi	r22, 0x02	; 2
    2950:	71 09       	sbc	r23, r1
    2952:	fb 01       	movw	r30, r22
    2954:	d3 83       	std	Z+3, r29	; 0x03
    2956:	c2 83       	std	Z+2, r28	; 0x02
    2958:	00 81       	ld	r16, Z
    295a:	11 81       	ldd	r17, Z+1	; 0x01
    295c:	ac 01       	movw	r20, r24
    295e:	40 0f       	add	r20, r16
    2960:	51 1f       	adc	r21, r17
    2962:	4c 17       	cp	r20, r28
    2964:	5d 07       	cpc	r21, r29
    2966:	61 f4       	brne	.+24     	; 0x2980 <free+0xa0>
    2968:	48 81       	ld	r20, Y
    296a:	59 81       	ldd	r21, Y+1	; 0x01
    296c:	40 0f       	add	r20, r16
    296e:	51 1f       	adc	r21, r17
    2970:	4e 5f       	subi	r20, 0xFE	; 254
    2972:	5f 4f       	sbci	r21, 0xFF	; 255
    2974:	51 83       	std	Z+1, r21	; 0x01
    2976:	40 83       	st	Z, r20
    2978:	4a 81       	ldd	r20, Y+2	; 0x02
    297a:	5b 81       	ldd	r21, Y+3	; 0x03
    297c:	53 83       	std	Z+3, r21	; 0x03
    297e:	42 83       	std	Z+2, r20	; 0x02
    2980:	21 15       	cp	r18, r1
    2982:	31 05       	cpc	r19, r1
    2984:	29 f4       	brne	.+10     	; 0x2990 <free+0xb0>
    2986:	b0 93 b1 0f 	sts	0x0FB1, r27
    298a:	a0 93 b0 0f 	sts	0x0FB0, r26
    298e:	40 c0       	rjmp	.+128    	; 0x2a10 <free+0x130>
    2990:	f9 01       	movw	r30, r18
    2992:	b3 83       	std	Z+3, r27	; 0x03
    2994:	a2 83       	std	Z+2, r26	; 0x02
    2996:	e9 01       	movw	r28, r18
    2998:	69 91       	ld	r22, Y+
    299a:	79 91       	ld	r23, Y+
    299c:	c6 0f       	add	r28, r22
    299e:	d7 1f       	adc	r29, r23
    29a0:	ac 17       	cp	r26, r28
    29a2:	bd 07       	cpc	r27, r29
    29a4:	79 f4       	brne	.+30     	; 0x29c4 <free+0xe4>
    29a6:	dc 01       	movw	r26, r24
    29a8:	5e 91       	ld	r21, -X
    29aa:	4e 91       	ld	r20, -X
    29ac:	46 0f       	add	r20, r22
    29ae:	57 1f       	adc	r21, r23
    29b0:	4e 5f       	subi	r20, 0xFE	; 254
    29b2:	5f 4f       	sbci	r21, 0xFF	; 255
    29b4:	51 83       	std	Z+1, r21	; 0x01
    29b6:	40 83       	st	Z, r20
    29b8:	12 96       	adiw	r26, 0x02	; 2
    29ba:	8d 91       	ld	r24, X+
    29bc:	9c 91       	ld	r25, X
    29be:	13 97       	sbiw	r26, 0x03	; 3
    29c0:	93 83       	std	Z+3, r25	; 0x03
    29c2:	82 83       	std	Z+2, r24	; 0x02
    29c4:	a0 e0       	ldi	r26, 0x00	; 0
    29c6:	b0 e0       	ldi	r27, 0x00	; 0
    29c8:	02 c0       	rjmp	.+4      	; 0x29ce <free+0xee>
    29ca:	d7 01       	movw	r26, r14
    29cc:	7c 01       	movw	r14, r24
    29ce:	f7 01       	movw	r30, r14
    29d0:	82 81       	ldd	r24, Z+2	; 0x02
    29d2:	93 81       	ldd	r25, Z+3	; 0x03
    29d4:	00 97       	sbiw	r24, 0x00	; 0
    29d6:	c9 f7       	brne	.-14     	; 0x29ca <free+0xea>
    29d8:	c7 01       	movw	r24, r14
    29da:	02 96       	adiw	r24, 0x02	; 2
    29dc:	20 81       	ld	r18, Z
    29de:	31 81       	ldd	r19, Z+1	; 0x01
    29e0:	82 0f       	add	r24, r18
    29e2:	93 1f       	adc	r25, r19
    29e4:	20 91 ae 0f 	lds	r18, 0x0FAE
    29e8:	30 91 af 0f 	lds	r19, 0x0FAF
    29ec:	28 17       	cp	r18, r24
    29ee:	39 07       	cpc	r19, r25
    29f0:	79 f4       	brne	.+30     	; 0x2a10 <free+0x130>
    29f2:	10 97       	sbiw	r26, 0x00	; 0
    29f4:	29 f4       	brne	.+10     	; 0x2a00 <free+0x120>
    29f6:	10 92 b1 0f 	sts	0x0FB1, r1
    29fa:	10 92 b0 0f 	sts	0x0FB0, r1
    29fe:	04 c0       	rjmp	.+8      	; 0x2a08 <free+0x128>
    2a00:	13 96       	adiw	r26, 0x03	; 3
    2a02:	1c 92       	st	X, r1
    2a04:	1e 92       	st	-X, r1
    2a06:	12 97       	sbiw	r26, 0x02	; 2
    2a08:	f0 92 af 0f 	sts	0x0FAF, r15
    2a0c:	e0 92 ae 0f 	sts	0x0FAE, r14
    2a10:	df 91       	pop	r29
    2a12:	cf 91       	pop	r28
    2a14:	1f 91       	pop	r17
    2a16:	0f 91       	pop	r16
    2a18:	ff 90       	pop	r15
    2a1a:	ef 90       	pop	r14
    2a1c:	08 95       	ret

00002a1e <memcpy>:
    2a1e:	fb 01       	movw	r30, r22
    2a20:	dc 01       	movw	r26, r24
    2a22:	02 c0       	rjmp	.+4      	; 0x2a28 <memcpy+0xa>
    2a24:	01 90       	ld	r0, Z+
    2a26:	0d 92       	st	X+, r0
    2a28:	41 50       	subi	r20, 0x01	; 1
    2a2a:	50 40       	sbci	r21, 0x00	; 0
    2a2c:	d8 f7       	brcc	.-10     	; 0x2a24 <memcpy+0x6>
    2a2e:	08 95       	ret

00002a30 <_exit>:
    2a30:	f8 94       	cli

00002a32 <__stop_program>:
    2a32:	ff cf       	rjmp	.-2      	; 0x2a32 <__stop_program>
