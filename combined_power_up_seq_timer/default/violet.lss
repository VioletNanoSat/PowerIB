
violet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000314  00800100  000027f4  00002888  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000027f4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c62  00800414  00800414  00002b9c  2**0
                  ALLOC
  3 .stab         00003ff0  00000000  00000000  00002b9c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000010d7  00000000  00000000  00006b8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00007c63  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000278  00000000  00000000  00007c92  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000501a  00000000  00000000  00007f0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001104  00000000  00000000  0000cf24  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000141b  00000000  00000000  0000e028  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000974  00000000  00000000  0000f444  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000ad8  00000000  00000000  0000fdb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002b8d  00000000  00000000  00010890  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000200  00000000  00000000  0001341d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
{
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
 * insert_str
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
{
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
		output[i] = input[i - start_index];

	return i;
}
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__vector_12>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 50 0b 	jmp	0x16a0	; 0x16a0 <__vector_15>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 89 0c 	jmp	0x1912	; 0x1912 <__vector_18>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 60 0c 	jmp	0x18c0	; 0x18c0 <__vector_20>
      54:	0c 94 4b 0c 	jmp	0x1896	; 0x1896 <__vector_21>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 16 0c 	jmp	0x182c	; 0x182c <__vector_30>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 ed 0b 	jmp	0x17da	; 0x17da <__vector_32>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	14 e0       	ldi	r17, 0x04	; 4
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e4 ef       	ldi	r30, 0xF4	; 244
      a0:	f7 e2       	ldi	r31, 0x27	; 39
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a4 31       	cpi	r26, 0x14	; 20
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	20 e1       	ldi	r18, 0x10	; 16
      b4:	a4 e1       	ldi	r26, 0x14	; 20
      b6:	b4 e0       	ldi	r27, 0x04	; 4
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a6 37       	cpi	r26, 0x76	; 118
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 d0 06 	call	0xda0	; 0xda0 <main>
      c6:	0c 94 f8 13 	jmp	0x27f0	; 0x27f0 <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <set_component>:
  else if (real < 11.2) {
	 real = 11.2;
  }
  
  //charging = 0xcc;
  if (charging == 0xdd) // change back to dd for tomorrow 
      ce:	8f 92       	push	r8
      d0:	af 92       	push	r10
      d2:	cf 92       	push	r12
      d4:	ef 92       	push	r14
      d6:	0f 93       	push	r16
      d8:	cf 93       	push	r28
      da:	df 93       	push	r29
      dc:	cd b7       	in	r28, 0x3d	; 61
      de:	de b7       	in	r29, 0x3e	; 62
      e0:	9a e1       	ldi	r25, 0x1A	; 26
  {
  	if (real > 12.43) 
      e2:	89 9f       	mul	r24, r25
      e4:	f0 01       	movw	r30, r0
      e6:	11 24       	eor	r1, r1
      e8:	ec 5b       	subi	r30, 0xBC	; 188
      ea:	fb 4f       	sbci	r31, 0xFB	; 251
      ec:	60 83       	st	Z, r22
      ee:	41 83       	std	Z+1, r20	; 0x01
      f0:	22 83       	std	Z+2, r18	; 0x02
      f2:	13 82       	std	Z+3, r1	; 0x03
      f4:	04 83       	std	Z+4, r16	; 0x04
      f6:	e5 82       	std	Z+5, r14	; 0x05
	{
      debug = 0x0A;
      f8:	c6 82       	std	Z+6, r12	; 0x06
      fa:	12 86       	std	Z+10, r1	; 0x0a
      fc:	13 86       	std	Z+11, r1	; 0x0b
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
      fe:	a4 86       	std	Z+12, r10	; 0x0c
     100:	85 86       	std	Z+13, r8	; 0x0d
     102:	8a 85       	ldd	r24, Y+10	; 0x0a
     104:	86 87       	std	Z+14, r24	; 0x0e
     106:	12 8a       	std	Z+18, r1	; 0x12
     108:	13 8a       	std	Z+19, r1	; 0x13
     10a:	8b 85       	ldd	r24, Y+11	; 0x0b
     10c:	84 8b       	std	Z+20, r24	; 0x14
     10e:	8c 85       	ldd	r24, Y+12	; 0x0c
     110:	85 8b       	std	Z+21, r24	; 0x15
     112:	11 8e       	std	Z+25, r1	; 0x19
     114:	df 91       	pop	r29
     116:	cf 91       	pop	r28
     118:	0f 91       	pop	r16
     11a:	ef 90       	pop	r14
     11c:	cf 90       	pop	r12
     11e:	af 90       	pop	r10
     120:	8f 90       	pop	r8
     122:	08 95       	ret

00000124 <initialize_svit>:
     124:	8f 92       	push	r8
     126:	af 92       	push	r10
     128:	cf 92       	push	r12
     12a:	ef 92       	push	r14
     12c:	ff 92       	push	r15
     12e:	0f 93       	push	r16
     130:	1f 93       	push	r17
     132:	cf 93       	push	r28
     134:	df 93       	push	r29
     136:	80 e6       	ldi	r24, 0x60	; 96
     138:	87 b9       	out	0x07, r24	; 7
     13a:	8f e8       	ldi	r24, 0x8F	; 143
     13c:	86 b9       	out	0x06, r24	; 6
     13e:	1f 92       	push	r1
     140:	d3 e0       	ldi	r29, 0x03	; 3
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     142:	df 93       	push	r29
     144:	c1 ee       	ldi	r28, 0xE1	; 225
     146:	cf 93       	push	r28
     148:	86 e0       	ldi	r24, 0x06	; 6
     14a:	88 2e       	mov	r8, r24
     14c:	a1 2c       	mov	r10, r1
     14e:	91 ee       	ldi	r25, 0xE1	; 225
     150:	c9 2e       	mov	r12, r25
     152:	2b e0       	ldi	r18, 0x0B	; 11
     154:	e2 2e       	mov	r14, r18
     156:	00 e0       	ldi	r16, 0x00	; 0
     158:	21 e0       	ldi	r18, 0x01	; 1
     15a:	47 e0       	ldi	r20, 0x07	; 7
     15c:	60 e0       	ldi	r22, 0x00	; 0
     15e:	80 e0       	ldi	r24, 0x00	; 0
     160:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     164:	87 e0       	ldi	r24, 0x07	; 7
     166:	8f 93       	push	r24
     168:	ff 24       	eor	r15, r15
     16a:	f3 94       	inc	r15
     16c:	ff 92       	push	r15
     16e:	cf 93       	push	r28
     170:	37 e0       	ldi	r19, 0x07	; 7
     172:	83 2e       	mov	r8, r19
     174:	47 e1       	ldi	r20, 0x17	; 23
     176:	e4 2e       	mov	r14, r20
     178:	21 e0       	ldi	r18, 0x01	; 1
     17a:	48 e0       	ldi	r20, 0x08	; 8
     17c:	61 e0       	ldi	r22, 0x01	; 1
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     17e:	81 e0       	ldi	r24, 0x01	; 1
     180:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     184:	1f 92       	push	r1
     186:	df 93       	push	r29
     188:	cf 93       	push	r28
     18a:	81 2c       	mov	r8, r1
     18c:	aa 24       	eor	r10, r10
     18e:	a3 94       	inc	r10
     190:	53 e1       	ldi	r21, 0x13	; 19
     192:	e5 2e       	mov	r14, r21
     194:	01 e0       	ldi	r16, 0x01	; 1
     196:	21 e0       	ldi	r18, 0x01	; 1
     198:	41 e0       	ldi	r20, 0x01	; 1
     19a:	62 e0       	ldi	r22, 0x02	; 2
     19c:	82 e0       	ldi	r24, 0x02	; 2
     19e:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1a2:	1f 92       	push	r1
     1a4:	df 93       	push	r29
     1a6:	cf 93       	push	r28
     1a8:	6e e0       	ldi	r22, 0x0E	; 14
     1aa:	86 2e       	mov	r8, r22
     1ac:	72 e0       	ldi	r23, 0x02	; 2
     1ae:	a7 2e       	mov	r10, r23
     1b0:	ed e0       	ldi	r30, 0x0D	; 13
     1b2:	ee 2e       	mov	r14, r30
     1b4:	02 e0       	ldi	r16, 0x02	; 2
     1b6:	21 e0       	ldi	r18, 0x01	; 1
     1b8:	41 e0       	ldi	r20, 0x01	; 1
     1ba:	63 e0       	ldi	r22, 0x03	; 3
     1bc:	83 e0       	ldi	r24, 0x03	; 3
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     1be:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1c2:	1f 92       	push	r1
     1c4:	df 93       	push	r29
     1c6:	cf 93       	push	r28
     1c8:	88 24       	eor	r8, r8
     1ca:	83 94       	inc	r8
     1cc:	aa 24       	eor	r10, r10
     1ce:	a3 94       	inc	r10
     1d0:	f5 e1       	ldi	r31, 0x15	; 21
     1d2:	ef 2e       	mov	r14, r31
     1d4:	01 e0       	ldi	r16, 0x01	; 1
     1d6:	21 e0       	ldi	r18, 0x01	; 1
     1d8:	42 e0       	ldi	r20, 0x02	; 2
     1da:	64 e0       	ldi	r22, 0x04	; 4
     1dc:	84 e0       	ldi	r24, 0x04	; 4
     1de:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1e2:	1f 92       	push	r1
     1e4:	df 93       	push	r29
     1e6:	cf 93       	push	r28
     1e8:	a2 e0       	ldi	r26, 0x02	; 2
     1ea:	8a 2e       	mov	r8, r26
     1ec:	ba e1       	ldi	r27, 0x1A	; 26
     1ee:	eb 2e       	mov	r14, r27
     1f0:	21 e0       	ldi	r18, 0x01	; 1
     1f2:	43 e0       	ldi	r20, 0x03	; 3
     1f4:	65 e0       	ldi	r22, 0x05	; 5
     1f6:	85 e0       	ldi	r24, 0x05	; 5
     1f8:	0e 94 67 00 	call	0xce	; 0xce <set_component>
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     1fc:	1f 92       	push	r1
     1fe:	df 93       	push	r29
     200:	cf 93       	push	r28
     202:	13 e0       	ldi	r17, 0x03	; 3
     204:	81 2e       	mov	r8, r17
     206:	8d e1       	ldi	r24, 0x1D	; 29
     208:	e8 2e       	mov	r14, r24
     20a:	21 e0       	ldi	r18, 0x01	; 1
     20c:	44 e0       	ldi	r20, 0x04	; 4
     20e:	66 e0       	ldi	r22, 0x06	; 6
     210:	86 e0       	ldi	r24, 0x06	; 6
     212:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     216:	1f 92       	push	r1
     218:	df 93       	push	r29
     21a:	cf 93       	push	r28
     21c:	9f e1       	ldi	r25, 0x1F	; 31
     21e:	89 2e       	mov	r8, r25
     220:	2e e0       	ldi	r18, 0x0E	; 14
     222:	e2 2e       	mov	r14, r18
     224:	21 e0       	ldi	r18, 0x01	; 1
     226:	45 e0       	ldi	r20, 0x05	; 5
     228:	67 e0       	ldi	r22, 0x07	; 7
     22a:	87 e0       	ldi	r24, 0x07	; 7
     22c:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     230:	1f 92       	push	r1
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     232:	df 93       	push	r29
     234:	cf 93       	push	r28
     236:	34 e0       	ldi	r19, 0x04	; 4
     238:	83 2e       	mov	r8, r19
     23a:	4b e1       	ldi	r20, 0x1B	; 27
     23c:	e4 2e       	mov	r14, r20
     23e:	21 e0       	ldi	r18, 0x01	; 1
     240:	46 e0       	ldi	r20, 0x06	; 6
     242:	68 e0       	ldi	r22, 0x08	; 8
     244:	88 e0       	ldi	r24, 0x08	; 8
     246:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     24a:	1f 92       	push	r1
     24c:	df 93       	push	r29
     24e:	cf 93       	push	r28
     250:	58 e0       	ldi	r21, 0x08	; 8
     252:	85 2e       	mov	r8, r21
     254:	6f e0       	ldi	r22, 0x0F	; 15
     256:	e6 2e       	mov	r14, r22
     258:	21 e0       	ldi	r18, 0x01	; 1
     25a:	49 e0       	ldi	r20, 0x09	; 9
     25c:	69 e0       	ldi	r22, 0x09	; 9
     25e:	89 e0       	ldi	r24, 0x09	; 9
     260:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     264:	1f 92       	push	r1
     266:	df 93       	push	r29
     268:	cf 93       	push	r28
     26a:	79 e0       	ldi	r23, 0x09	; 9
     26c:	87 2e       	mov	r8, r23
     26e:	e9 e1       	ldi	r30, 0x19	; 25
     270:	ee 2e       	mov	r14, r30
     272:	21 e0       	ldi	r18, 0x01	; 1
     274:	4a e0       	ldi	r20, 0x0A	; 10
     276:	6a e0       	ldi	r22, 0x0A	; 10
     278:	8a e0       	ldi	r24, 0x0A	; 10
     27a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     27e:	8d b7       	in	r24, 0x3d	; 61
     280:	9e b7       	in	r25, 0x3e	; 62
     282:	81 96       	adiw	r24, 0x21	; 33
     284:	0f b6       	in	r0, 0x3f	; 63
     286:	f8 94       	cli
     288:	9e bf       	out	0x3e, r25	; 62
     28a:	0f be       	out	0x3f, r0	; 63
     28c:	8d bf       	out	0x3d, r24	; 61
     28e:	1f 92       	push	r1
     290:	df 93       	push	r29
     292:	cf 93       	push	r28
     294:	fa e0       	ldi	r31, 0x0A	; 10
     296:	8f 2e       	mov	r8, r31
     298:	a8 e1       	ldi	r26, 0x18	; 24
     29a:	ea 2e       	mov	r14, r26
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	4b e0       	ldi	r20, 0x0B	; 11
     2a0:	6b e0       	ldi	r22, 0x0B	; 11
     2a2:	8b e0       	ldi	r24, 0x0B	; 11
     2a4:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2a8:	1f 92       	push	r1
     2aa:	df 93       	push	r29
     2ac:	cf 93       	push	r28
     2ae:	b0 e1       	ldi	r27, 0x10	; 16
     2b0:	8b 2e       	mov	r8, r27
     2b2:	11 e1       	ldi	r17, 0x11	; 17
     2b4:	e1 2e       	mov	r14, r17
     2b6:	20 e0       	ldi	r18, 0x00	; 0
     2b8:	4c e0       	ldi	r20, 0x0C	; 12
     2ba:	6c e0       	ldi	r22, 0x0C	; 12
     2bc:	8c e0       	ldi	r24, 0x0C	; 12
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2be:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	8f 93       	push	r24
     2c6:	12 e0       	ldi	r17, 0x02	; 2
     2c8:	1f 93       	push	r17
     2ca:	cf 93       	push	r28
     2cc:	8c e0       	ldi	r24, 0x0C	; 12
     2ce:	88 2e       	mov	r8, r24
     2d0:	96 e1       	ldi	r25, 0x16	; 22
     2d2:	e9 2e       	mov	r14, r25
     2d4:	21 e0       	ldi	r18, 0x01	; 1
     2d6:	4d e0       	ldi	r20, 0x0D	; 13
     2d8:	6d e0       	ldi	r22, 0x0D	; 13
     2da:	8d e0       	ldi	r24, 0x0D	; 13
     2dc:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2e0:	1f 92       	push	r1
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     2e2:	df 93       	push	r29
     2e4:	cf 93       	push	r28
     2e6:	26 e0       	ldi	r18, 0x06	; 6
     2e8:	82 2e       	mov	r8, r18
     2ea:	a1 2c       	mov	r10, r1
     2ec:	34 e0       	ldi	r19, 0x04	; 4
     2ee:	e3 2e       	mov	r14, r19
     2f0:	00 e0       	ldi	r16, 0x00	; 0
     2f2:	21 e0       	ldi	r18, 0x01	; 1
     2f4:	4e e0       	ldi	r20, 0x0E	; 14
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2f6:	6e e0       	ldi	r22, 0x0E	; 14
     2f8:	8e e0       	ldi	r24, 0x0E	; 14
     2fa:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2fe:	1f 92       	push	r1
     300:	df 93       	push	r29
     302:	cf 93       	push	r28
     304:	81 2c       	mov	r8, r1
     306:	43 e0       	ldi	r20, 0x03	; 3
     308:	a4 2e       	mov	r10, r20
     30a:	55 e1       	ldi	r21, 0x15	; 21
     30c:	e5 2e       	mov	r14, r21
     30e:	02 e0       	ldi	r16, 0x02	; 2
     310:	21 e0       	ldi	r18, 0x01	; 1
     312:	40 e1       	ldi	r20, 0x10	; 16
     314:	6f e0       	ldi	r22, 0x0F	; 15
     316:	8f e0       	ldi	r24, 0x0F	; 15
     318:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     31c:	1f 92       	push	r1
     31e:	df 93       	push	r29
     320:	cf 93       	push	r28
     322:	6d e0       	ldi	r22, 0x0D	; 13
     324:	86 2e       	mov	r8, r22
     326:	aa 24       	eor	r10, r10
     328:	a3 94       	inc	r10
     32a:	72 e1       	ldi	r23, 0x12	; 18
     32c:	e7 2e       	mov	r14, r23
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     32e:	01 e0       	ldi	r16, 0x01	; 1
     330:	21 e0       	ldi	r18, 0x01	; 1
     332:	4f e0       	ldi	r20, 0x0F	; 15
     334:	60 e1       	ldi	r22, 0x10	; 16
     336:	80 e1       	ldi	r24, 0x10	; 16
     338:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     33c:	1f 92       	push	r1
     33e:	df 93       	push	r29
     340:	cf 93       	push	r28
     342:	e5 e0       	ldi	r30, 0x05	; 5
     344:	8e 2e       	mov	r8, r30
     346:	fc e1       	ldi	r31, 0x1C	; 28
     348:	ef 2e       	mov	r14, r31
     34a:	20 e0       	ldi	r18, 0x00	; 0
     34c:	4f ef       	ldi	r20, 0xFF	; 255
     34e:	61 e1       	ldi	r22, 0x11	; 17
     350:	81 e1       	ldi	r24, 0x11	; 17
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     352:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     356:	1f 92       	push	r1
     358:	df 93       	push	r29
     35a:	cf 93       	push	r28
     35c:	a0 e1       	ldi	r26, 0x10	; 16
     35e:	8a 2e       	mov	r8, r26
     360:	b2 e0       	ldi	r27, 0x02	; 2
     362:	ab 2e       	mov	r10, r27
     364:	0f e0       	ldi	r16, 0x0F	; 15
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     366:	e0 2e       	mov	r14, r16
     368:	02 e0       	ldi	r16, 0x02	; 2
     36a:	20 e0       	ldi	r18, 0x00	; 0
     36c:	4f ef       	ldi	r20, 0xFF	; 255
     36e:	62 e1       	ldi	r22, 0x12	; 18
     370:	82 e1       	ldi	r24, 0x12	; 18
     372:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     376:	1f 92       	push	r1
     378:	df 93       	push	r29
     37a:	cf 93       	push	r28
     37c:	82 e1       	ldi	r24, 0x12	; 18
     37e:	88 2e       	mov	r8, r24
     380:	91 e1       	ldi	r25, 0x11	; 17
     382:	e9 2e       	mov	r14, r25
     384:	20 e0       	ldi	r18, 0x00	; 0
     386:	4f ef       	ldi	r20, 0xFF	; 255
     388:	63 e1       	ldi	r22, 0x13	; 19
     38a:	83 e1       	ldi	r24, 0x13	; 19
     38c:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     390:	89 e0       	ldi	r24, 0x09	; 9
     392:	8f 93       	push	r24
     394:	1f 93       	push	r17
     396:	cf 93       	push	r28
     398:	22 e0       	ldi	r18, 0x02	; 2
     39a:	82 2e       	mov	r8, r18
     39c:	a1 2c       	mov	r10, r1
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     39e:	ee 24       	eor	r14, r14
     3a0:	e3 94       	inc	r14
     3a2:	00 e0       	ldi	r16, 0x00	; 0
     3a4:	21 e0       	ldi	r18, 0x01	; 1
     3a6:	4f ef       	ldi	r20, 0xFF	; 255
     3a8:	64 e1       	ldi	r22, 0x14	; 20
     3aa:	84 e1       	ldi	r24, 0x14	; 20
     3ac:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     3b0:	8b e0       	ldi	r24, 0x0B	; 11
     3b2:	8f 93       	push	r24
     3b4:	1f 93       	push	r17
     3b6:	cf 93       	push	r28
     3b8:	3e e1       	ldi	r19, 0x1E	; 30
     3ba:	83 2e       	mov	r8, r19
     3bc:	42 e0       	ldi	r20, 0x02	; 2
     3be:	a4 2e       	mov	r10, r20
     3c0:	54 e1       	ldi	r21, 0x14	; 20
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     3c2:	e5 2e       	mov	r14, r21
     3c4:	02 e0       	ldi	r16, 0x02	; 2
     3c6:	21 e0       	ldi	r18, 0x01	; 1
     3c8:	4f ef       	ldi	r20, 0xFF	; 255
     3ca:	65 e1       	ldi	r22, 0x15	; 21
     3cc:	85 e1       	ldi	r24, 0x15	; 21
     3ce:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     3d2:	8d b7       	in	r24, 0x3d	; 61
     3d4:	9e b7       	in	r25, 0x3e	; 62
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     3d6:	81 96       	adiw	r24, 0x21	; 33
     3d8:	0f b6       	in	r0, 0x3f	; 63
     3da:	f8 94       	cli
     3dc:	9e bf       	out	0x3e, r25	; 62
     3de:	0f be       	out	0x3f, r0	; 63
     3e0:	8d bf       	out	0x3d, r24	; 61
     3e2:	1f 92       	push	r1
     3e4:	df 93       	push	r29
     3e6:	cf 93       	push	r28
     3e8:	63 e0       	ldi	r22, 0x03	; 3
     3ea:	86 2e       	mov	r8, r22
     3ec:	a1 2c       	mov	r10, r1
     3ee:	77 e0       	ldi	r23, 0x07	; 7
     3f0:	e7 2e       	mov	r14, r23
     3f2:	00 e0       	ldi	r16, 0x00	; 0
     3f4:	21 e0       	ldi	r18, 0x01	; 1
     3f6:	4f ef       	ldi	r20, 0xFF	; 255
     3f8:	66 e1       	ldi	r22, 0x16	; 22
     3fa:	86 e1       	ldi	r24, 0x16	; 22
     3fc:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     400:	1f 92       	push	r1
     402:	1f 93       	push	r17
     404:	cf 93       	push	r28
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     406:	e4 e1       	ldi	r30, 0x14	; 20
     408:	8e 2e       	mov	r8, r30
     40a:	f2 e1       	ldi	r31, 0x12	; 18
     40c:	ef 2e       	mov	r14, r31
     40e:	21 e0       	ldi	r18, 0x01	; 1
     410:	4f ef       	ldi	r20, 0xFF	; 255
     412:	67 e1       	ldi	r22, 0x17	; 23
     414:	87 e1       	ldi	r24, 0x17	; 23
     416:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     41a:	ff 92       	push	r15
     41c:	1f 93       	push	r17
     41e:	cf 93       	push	r28
     420:	a5 e1       	ldi	r26, 0x15	; 21
     422:	8a 2e       	mov	r8, r26
     424:	b3 e1       	ldi	r27, 0x13	; 19
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     426:	eb 2e       	mov	r14, r27
     428:	21 e0       	ldi	r18, 0x01	; 1
     42a:	4f ef       	ldi	r20, 0xFF	; 255
     42c:	68 e1       	ldi	r22, 0x18	; 24
     42e:	88 e1       	ldi	r24, 0x18	; 24
     430:	0e 94 67 00 	call	0xce	; 0xce <set_component>
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     434:	1f 93       	push	r17
     436:	1f 93       	push	r17
     438:	cf 93       	push	r28
     43a:	86 e1       	ldi	r24, 0x16	; 22
     43c:	88 2e       	mov	r8, r24
     43e:	9a e0       	ldi	r25, 0x0A	; 10
     440:	e9 2e       	mov	r14, r25
     442:	21 e0       	ldi	r18, 0x01	; 1
	}
    else 
	{
	  debug = 0x0B;
     444:	4f ef       	ldi	r20, 0xFF	; 255
     446:	69 e1       	ldi	r22, 0x19	; 25
     448:	89 e1       	ldi	r24, 0x19	; 25
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     44a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     44e:	df 93       	push	r29
     450:	1f 93       	push	r17
     452:	cf 93       	push	r28
     454:	27 e1       	ldi	r18, 0x17	; 23
     456:	82 2e       	mov	r8, r18
     458:	3f e0       	ldi	r19, 0x0F	; 15
     45a:	e3 2e       	mov	r14, r19
     45c:	21 e0       	ldi	r18, 0x01	; 1
     45e:	4f ef       	ldi	r20, 0xFF	; 255
     460:	6a e1       	ldi	r22, 0x1A	; 26
     462:	8a e1       	ldi	r24, 0x1A	; 26
     464:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     468:	84 e0       	ldi	r24, 0x04	; 4
     46a:	8f 93       	push	r24
     46c:	1f 93       	push	r17
     46e:	cf 93       	push	r28
     470:	48 e1       	ldi	r20, 0x18	; 24
     472:	84 2e       	mov	r8, r20
     474:	59 e0       	ldi	r21, 0x09	; 9
     476:	e5 2e       	mov	r14, r21
     478:	21 e0       	ldi	r18, 0x01	; 1
     47a:	4f ef       	ldi	r20, 0xFF	; 255
     47c:	6b e1       	ldi	r22, 0x1B	; 27
     47e:	8b e1       	ldi	r24, 0x1B	; 27
     480:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     484:	1f 92       	push	r1
     486:	df 93       	push	r29
     488:	cf 93       	push	r28
     48a:	69 e1       	ldi	r22, 0x19	; 25
     48c:	86 2e       	mov	r8, r22
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     48e:	7e e0       	ldi	r23, 0x0E	; 14
     490:	e7 2e       	mov	r14, r23
     492:	21 e0       	ldi	r18, 0x01	; 1
     494:	4f ef       	ldi	r20, 0xFF	; 255
     496:	6c e1       	ldi	r22, 0x1C	; 28
     498:	8c e1       	ldi	r24, 0x1C	; 28
     49a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     49e:	1f 92       	push	r1
     4a0:	df 93       	push	r29
     4a2:	cf 93       	push	r28
     4a4:	ea e1       	ldi	r30, 0x1A	; 26
     4a6:	8e 2e       	mov	r8, r30
     4a8:	f0 e1       	ldi	r31, 0x10	; 16
     4aa:	ef 2e       	mov	r14, r31
     4ac:	21 e0       	ldi	r18, 0x01	; 1
     4ae:	4f ef       	ldi	r20, 0xFF	; 255
     4b0:	6d e1       	ldi	r22, 0x1D	; 29
     4b2:	8d e1       	ldi	r24, 0x1D	; 29
     4b4:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4b8:	1f 92       	push	r1
     4ba:	df 93       	push	r29
     4bc:	cf 93       	push	r28
     4be:	ab e1       	ldi	r26, 0x1B	; 27
     4c0:	8a 2e       	mov	r8, r26
     4c2:	b8 e0       	ldi	r27, 0x08	; 8
     4c4:	eb 2e       	mov	r14, r27
     4c6:	21 e0       	ldi	r18, 0x01	; 1
     4c8:	4f ef       	ldi	r20, 0xFF	; 255
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     4ca:	6e e1       	ldi	r22, 0x1E	; 30
     4cc:	8e e1       	ldi	r24, 0x1E	; 30
     4ce:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4d2:	85 e0       	ldi	r24, 0x05	; 5
     4d4:	8f 93       	push	r24
     4d6:	1f 93       	push	r17
     4d8:	cf 93       	push	r28
     4da:	8c e1       	ldi	r24, 0x1C	; 28
     4dc:	88 2e       	mov	r8, r24
     4de:	9d e0       	ldi	r25, 0x0D	; 13
     4e0:	e9 2e       	mov	r14, r25
     4e2:	21 e0       	ldi	r18, 0x01	; 1
     4e4:	4f ef       	ldi	r20, 0xFF	; 255
     4e6:	6f e1       	ldi	r22, 0x1F	; 31
     4e8:	8f e1       	ldi	r24, 0x1F	; 31
     4ea:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4ee:	1f 92       	push	r1
     4f0:	df 93       	push	r29
     4f2:	cf 93       	push	r28
     4f4:	2d e1       	ldi	r18, 0x1D	; 29
     4f6:	82 2e       	mov	r8, r18
     4f8:	3c e0       	ldi	r19, 0x0C	; 12
     4fa:	e3 2e       	mov	r14, r19
     4fc:	21 e0       	ldi	r18, 0x01	; 1
     4fe:	4f ef       	ldi	r20, 0xFF	; 255
     500:	60 e2       	ldi	r22, 0x20	; 32
     502:	80 e2       	ldi	r24, 0x20	; 32
     504:	0e 94 67 00 	call	0xce	; 0xce <set_component>
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     508:	8d b7       	in	r24, 0x3d	; 61
     50a:	9e b7       	in	r25, 0x3e	; 62
     50c:	81 96       	adiw	r24, 0x21	; 33
     50e:	0f b6       	in	r0, 0x3f	; 63
     510:	f8 94       	cli
     512:	9e bf       	out	0x3e, r25	; 62
     514:	0f be       	out	0x3f, r0	; 63
     516:	8d bf       	out	0x3d, r24	; 61
     518:	1f 92       	push	r1
     51a:	df 93       	push	r29
     51c:	cf 93       	push	r28
     51e:	4e e1       	ldi	r20, 0x1E	; 30
     520:	84 2e       	mov	r8, r20
     522:	5b e0       	ldi	r21, 0x0B	; 11
     524:	e5 2e       	mov	r14, r21
     526:	21 e0       	ldi	r18, 0x01	; 1
     528:	4f ef       	ldi	r20, 0xFF	; 255
     52a:	61 e2       	ldi	r22, 0x21	; 33
     52c:	81 e2       	ldi	r24, 0x21	; 33
     52e:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     532:	1f 92       	push	r1
     534:	df 93       	push	r29
     536:	cf 93       	push	r28
     538:	6f e1       	ldi	r22, 0x1F	; 31
     53a:	86 2e       	mov	r8, r22
     53c:	71 e1       	ldi	r23, 0x11	; 17
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     53e:	e7 2e       	mov	r14, r23
     540:	21 e0       	ldi	r18, 0x01	; 1
     542:	4f ef       	ldi	r20, 0xFF	; 255
     544:	62 e2       	ldi	r22, 0x22	; 34
     546:	82 e2       	ldi	r24, 0x22	; 34
     548:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     54c:	86 e0       	ldi	r24, 0x06	; 6
     54e:	8f 93       	push	r24
     550:	1f 93       	push	r17
     552:	cf 93       	push	r28
     554:	81 2c       	mov	r8, r1
     556:	e5 e0       	ldi	r30, 0x05	; 5
     558:	ee 2e       	mov	r14, r30
     55a:	21 e0       	ldi	r18, 0x01	; 1
     55c:	4f ef       	ldi	r20, 0xFF	; 255
     55e:	63 e2       	ldi	r22, 0x23	; 35
     560:	83 e2       	ldi	r24, 0x23	; 35
     562:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     566:	8d b7       	in	r24, 0x3d	; 61
     568:	9e b7       	in	r25, 0x3e	; 62
     56a:	09 96       	adiw	r24, 0x09	; 9
     56c:	0f b6       	in	r0, 0x3f	; 63
     56e:	f8 94       	cli
     570:	9e bf       	out	0x3e, r25	; 62
     572:	0f be       	out	0x3f, r0	; 63
     574:	8d bf       	out	0x3d, r24	; 61
     576:	df 91       	pop	r29
     578:	cf 91       	pop	r28
     57a:	1f 91       	pop	r17
     57c:	0f 91       	pop	r16
     57e:	ff 90       	pop	r15
     580:	ef 90       	pop	r14
     582:	cf 90       	pop	r12
     584:	af 90       	pop	r10
     586:	8f 90       	pop	r8
     588:	08 95       	ret

0000058a <receive_message>:
     58a:	ff 92       	push	r15
     58c:	0f 93       	push	r16
     58e:	1f 93       	push	r17
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	f8 2e       	mov	r15, r24
     596:	fb 01       	movw	r30, r22
     598:	c1 81       	ldd	r28, Z+1	; 0x01
     59a:	90 81       	ld	r25, Z
     59c:	93 30       	cpi	r25, 0x03	; 3
     59e:	09 f4       	brne	.+2      	; 0x5a2 <receive_message+0x18>
     5a0:	5a c0       	rjmp	.+180    	; 0x656 <receive_message+0xcc>
     5a2:	30 f4       	brcc	.+12     	; 0x5b0 <receive_message+0x26>
     5a4:	0c 2f       	mov	r16, r28
     5a6:	10 e0       	ldi	r17, 0x00	; 0
     5a8:	91 30       	cpi	r25, 0x01	; 1
     5aa:	11 f1       	breq	.+68     	; 0x5f0 <receive_message+0x66>
     5ac:	90 f5       	brcc	.+100    	; 0x612 <receive_message+0x88>
     5ae:	0c c0       	rjmp	.+24     	; 0x5c8 <receive_message+0x3e>
     5b0:	95 30       	cpi	r25, 0x05	; 5
     5b2:	09 f4       	brne	.+2      	; 0x5b6 <receive_message+0x2c>
     5b4:	55 c0       	rjmp	.+170    	; 0x660 <receive_message+0xd6>
     5b6:	08 f4       	brcc	.+2      	; 0x5ba <receive_message+0x30>
     5b8:	50 c0       	rjmp	.+160    	; 0x65a <receive_message+0xd0>
     5ba:	96 30       	cpi	r25, 0x06	; 6
     5bc:	09 f4       	brne	.+2      	; 0x5c0 <receive_message+0x36>
     5be:	60 c0       	rjmp	.+192    	; 0x680 <receive_message+0xf6>
     5c0:	97 30       	cpi	r25, 0x07	; 7
     5c2:	09 f0       	breq	.+2      	; 0x5c6 <receive_message+0x3c>
     5c4:	7b c0       	rjmp	.+246    	; 0x6bc <receive_message+0x132>
     5c6:	6b c0       	rjmp	.+214    	; 0x69e <receive_message+0x114>
     5c8:	8c e2       	ldi	r24, 0x2C	; 44
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     5ca:	80 93 61 0e 	sts	0x0E61, r24
     5ce:	8a e1       	ldi	r24, 0x1A	; 26
     5d0:	80 9f       	mul	r24, r16
     5d2:	e0 01       	movw	r28, r0
     5d4:	81 9f       	mul	r24, r17
     5d6:	d0 0d       	add	r29, r0
     5d8:	11 24       	eor	r1, r1
     5da:	cc 5b       	subi	r28, 0xBC	; 188
     5dc:	db 4f       	sbci	r29, 0xFB	; 251
     5de:	89 81       	ldd	r24, Y+1	; 0x01
     5e0:	8f 3f       	cpi	r24, 0xFF	; 255
     5e2:	21 f0       	breq	.+8      	; 0x5ec <receive_message+0x62>
     5e4:	0e 94 df 07 	call	0xfbe	; 0xfbe <switch_on>
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	8a 83       	std	Y+2, r24	; 0x02
     5ec:	40 e0       	ldi	r20, 0x00	; 0
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     5ee:	0f c0       	rjmp	.+30     	; 0x60e <receive_message+0x84>
     5f0:	8a e1       	ldi	r24, 0x1A	; 26
     5f2:	80 9f       	mul	r24, r16
     5f4:	e0 01       	movw	r28, r0
     5f6:	81 9f       	mul	r24, r17
     5f8:	d0 0d       	add	r29, r0
     5fa:	11 24       	eor	r1, r1
     5fc:	cc 5b       	subi	r28, 0xBC	; 188
     5fe:	db 4f       	sbci	r29, 0xFB	; 251
     600:	89 81       	ldd	r24, Y+1	; 0x01
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     602:	8f 3f       	cpi	r24, 0xFF	; 255
     604:	19 f0       	breq	.+6      	; 0x60c <receive_message+0x82>
     606:	0e 94 22 08 	call	0x1044	; 0x1044 <switch_off>
     60a:	1a 82       	std	Y+2, r1	; 0x02
     60c:	41 e0       	ldi	r20, 0x01	; 1
     60e:	62 e0       	ldi	r22, 0x02	; 2
     610:	57 c0       	rjmp	.+174    	; 0x6c0 <receive_message+0x136>
     612:	8a e1       	ldi	r24, 0x1A	; 26
     614:	80 9f       	mul	r24, r16
     616:	e0 01       	movw	r28, r0
     618:	81 9f       	mul	r24, r17
     61a:	d0 0d       	add	r29, r0
     61c:	11 24       	eor	r1, r1
     61e:	cc 5b       	subi	r28, 0xBC	; 188
     620:	db 4f       	sbci	r29, 0xFB	; 251
     622:	89 81       	ldd	r24, Y+1	; 0x01
     624:	8f 3f       	cpi	r24, 0xFF	; 255
     626:	19 f0       	breq	.+6      	; 0x62e <receive_message+0xa4>
     628:	0e 94 22 08 	call	0x1044	; 0x1044 <switch_off>
     62c:	1a 82       	std	Y+2, r1	; 0x02
     62e:	85 e0       	ldi	r24, 0x05	; 5
     630:	8a 95       	dec	r24
     632:	f1 f7       	brne	.-4      	; 0x630 <receive_message+0xa6>
     634:	8a e1       	ldi	r24, 0x1A	; 26
     636:	80 9f       	mul	r24, r16
     638:	e0 01       	movw	r28, r0
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     63a:	81 9f       	mul	r24, r17
     63c:	d0 0d       	add	r29, r0
     63e:	11 24       	eor	r1, r1
     640:	cc 5b       	subi	r28, 0xBC	; 188
     642:	db 4f       	sbci	r29, 0xFB	; 251
     644:	89 81       	ldd	r24, Y+1	; 0x01
     646:	8f 3f       	cpi	r24, 0xFF	; 255
     648:	21 f0       	breq	.+8      	; 0x652 <receive_message+0xc8>
     64a:	0e 94 df 07 	call	0xfbe	; 0xfbe <switch_on>
     64e:	81 e0       	ldi	r24, 0x01	; 1
     650:	8a 83       	std	Y+2, r24	; 0x02
     652:	42 e0       	ldi	r20, 0x02	; 2
     654:	dc cf       	rjmp	.-72     	; 0x60e <receive_message+0x84>
     656:	43 e0       	ldi	r20, 0x03	; 3
     658:	da cf       	rjmp	.-76     	; 0x60e <receive_message+0x84>
     65a:	40 e0       	ldi	r20, 0x00	; 0
     65c:	60 e0       	ldi	r22, 0x00	; 0
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     65e:	30 c0       	rjmp	.+96     	; 0x6c0 <receive_message+0x136>
     660:	8a e1       	ldi	r24, 0x1A	; 26
     662:	c8 9f       	mul	r28, r24
     664:	e0 01       	movw	r28, r0
     666:	11 24       	eor	r1, r1
     668:	cc 5b       	subi	r28, 0xBC	; 188
     66a:	db 4f       	sbci	r29, 0xFB	; 251
     66c:	89 81       	ldd	r24, Y+1	; 0x01
     66e:	8f 3f       	cpi	r24, 0xFF	; 255
     670:	29 f0       	breq	.+10     	; 0x67c <receive_message+0xf2>
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     672:	0e 94 df 07 	call	0xfbe	; 0xfbe <switch_on>
     676:	81 e0       	ldi	r24, 0x01	; 1
     678:	8a 83       	std	Y+2, r24	; 0x02
     67a:	8b 83       	std	Y+3, r24	; 0x03
     67c:	45 e0       	ldi	r20, 0x05	; 5
     67e:	c7 cf       	rjmp	.-114    	; 0x60e <receive_message+0x84>
     680:	8a e1       	ldi	r24, 0x1A	; 26
     682:	c8 9f       	mul	r28, r24
     684:	e0 01       	movw	r28, r0
     686:	11 24       	eor	r1, r1
     688:	cc 5b       	subi	r28, 0xBC	; 188
     68a:	db 4f       	sbci	r29, 0xFB	; 251
     68c:	89 81       	ldd	r24, Y+1	; 0x01
     68e:	8f 3f       	cpi	r24, 0xFF	; 255
     690:	f9 f0       	breq	.+62     	; 0x6d0 <receive_message+0x146>
     692:	82 81       	ldd	r24, Z+2	; 0x02
     694:	8e 83       	std	Y+6, r24	; 0x06
     696:	82 81       	ldd	r24, Z+2	; 0x02
     698:	80 93 43 0c 	sts	0x0C43, r24
     69c:	19 c0       	rjmp	.+50     	; 0x6d0 <receive_message+0x146>
     69e:	8a e1       	ldi	r24, 0x1A	; 26
     6a0:	c8 9f       	mul	r28, r24
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6a2:	e0 01       	movw	r28, r0
     6a4:	11 24       	eor	r1, r1
     6a6:	cc 5b       	subi	r28, 0xBC	; 188
     6a8:	db 4f       	sbci	r29, 0xFB	; 251
     6aa:	89 81       	ldd	r24, Y+1	; 0x01
     6ac:	8f 3f       	cpi	r24, 0xFF	; 255
     6ae:	81 f0       	breq	.+32     	; 0x6d0 <receive_message+0x146>
     6b0:	82 81       	ldd	r24, Z+2	; 0x02
     6b2:	8e 87       	std	Y+14, r24	; 0x0e
     6b4:	82 81       	ldd	r24, Z+2	; 0x02
     6b6:	80 93 3e 0c 	sts	0x0C3E, r24
     6ba:	0a c0       	rjmp	.+20     	; 0x6d0 <receive_message+0x146>
     6bc:	40 e0       	ldi	r20, 0x00	; 0
     6be:	61 e0       	ldi	r22, 0x01	; 1
     6c0:	8f 2d       	mov	r24, r15
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     6c2:	df 91       	pop	r29
     6c4:	cf 91       	pop	r28
     6c6:	1f 91       	pop	r17
     6c8:	0f 91       	pop	r16
     6ca:	ff 90       	pop	r15
     6cc:	0c 94 59 10 	jmp	0x20b2	; 0x20b2 <transmit_packet>
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	1f 91       	pop	r17
     6d6:	0f 91       	pop	r16
     6d8:	ff 90       	pop	r15
     6da:	08 95       	ret

000006dc <StateofCharge>:
     6dc:	cf 93       	push	r28
     6de:	e0 91 33 0a 	lds	r30, 0x0A33
     6e2:	ef 3f       	cpi	r30, 0xFF	; 255
     6e4:	09 f4       	brne	.+2      	; 0x6e8 <StateofCharge+0xc>
     6e6:	93 c0       	rjmp	.+294    	; 0x80e <StateofCharge+0x132>
     6e8:	80 91 1d 0a 	lds	r24, 0x0A1D
     6ec:	88 23       	and	r24, r24
     6ee:	09 f4       	brne	.+2      	; 0x6f2 <StateofCharge+0x16>
     6f0:	8e c0       	rjmp	.+284    	; 0x80e <StateofCharge+0x132>
     6f2:	80 91 34 0a 	lds	r24, 0x0A34
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     6f6:	88 23       	and	r24, r24
     6f8:	21 f0       	breq	.+8      	; 0x702 <StateofCharge+0x26>
     6fa:	81 e0       	ldi	r24, 0x01	; 1
     6fc:	80 93 6c 0e 	sts	0x0E6C, r24
     700:	02 c0       	rjmp	.+4      	; 0x706 <StateofCharge+0x2a>
     702:	10 92 6c 0e 	sts	0x0E6C, r1
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
	}
  	percent = 100*(1 - batt_time/discharge_max_time);
     706:	8e 2f       	mov	r24, r30
     708:	85 56       	subi	r24, 0x65	; 101
     70a:	8a 31       	cpi	r24, 0x1A	; 26
     70c:	08 f0       	brcs	.+2      	; 0x710 <StateofCharge+0x34>
     70e:	6c c0       	rjmp	.+216    	; 0x7e8 <StateofCharge+0x10c>
     710:	c0 91 14 04 	lds	r28, 0x0414
     714:	8c 2f       	mov	r24, r28
     716:	8f 5f       	subi	r24, 0xFF	; 255
     718:	80 93 14 04 	sts	0x0414, r24
     71c:	80 91 6c 0e 	lds	r24, 0x0E6C
     720:	88 23       	and	r24, r24
     722:	e9 f1       	breq	.+122    	; 0x79e <StateofCharge+0xc2>
     724:	80 91 47 0e 	lds	r24, 0x0E47
     728:	ea 36       	cpi	r30, 0x6A	; 106
     72a:	20 f4       	brcc	.+8      	; 0x734 <StateofCharge+0x58>
     72c:	82 95       	swap	r24
     72e:	86 95       	lsr	r24
     730:	86 95       	lsr	r24
     732:	0b c0       	rjmp	.+22     	; 0x74a <StateofCharge+0x6e>
     734:	9e 2f       	mov	r25, r30
     736:	9a 56       	subi	r25, 0x6A	; 106
     738:	82 95       	swap	r24
     73a:	86 95       	lsr	r24
  }
  else 
  {
    float temp_real = 0;
    if (real < 13.35)
     73c:	86 95       	lsr	r24
     73e:	83 70       	andi	r24, 0x03	; 3
     740:	9a 30       	cpi	r25, 0x0A	; 10
     742:	10 f4       	brcc	.+4      	; 0x748 <StateofCharge+0x6c>
     744:	8f 5f       	subi	r24, 0xFF	; 255
     746:	01 c0       	rjmp	.+2      	; 0x74a <StateofCharge+0x6e>
     748:	8e 5f       	subi	r24, 0xFE	; 254
     74a:	83 70       	andi	r24, 0x03	; 3
     74c:	80 93 5f 0e 	sts	0x0E5F, r24
	{
	  debug = 0x0C;
     750:	f0 e0       	ldi	r31, 0x00	; 0
     752:	e5 56       	subi	r30, 0x65	; 101
     754:	f1 09       	sbc	r31, r1
	  // voltage is normalized by mean 13.13 and std 0.1754 (real - 13.13)/0.1754
	  temp_real = (real - 13.13)*5.701254;
     756:	ee 0f       	add	r30, r30
     758:	ff 1f       	adc	r31, r31
     75a:	ee 0f       	add	r30, r30
     75c:	ff 1f       	adc	r31, r31
     75e:	e8 0f       	add	r30, r24
     760:	f1 1d       	adc	r31, r1
     762:	ee 0f       	add	r30, r30
     764:	ff 1f       	adc	r31, r31
     766:	ea 5f       	subi	r30, 0xFA	; 250
     768:	fc 4f       	sbci	r31, 0xFC	; 252
     76a:	60 81       	ld	r22, Z
     76c:	71 81       	ldd	r23, Z+1	; 0x01
     76e:	6b 50       	subi	r22, 0x0B	; 11
     770:	71 09       	sbc	r23, r1
     772:	80 e0       	ldi	r24, 0x00	; 0
     774:	90 e0       	ldi	r25, 0x00	; 0
	  batt_time = p1*pow(temp_real,3) + p2*pow(temp_real,2) + p3*temp_real + p4;
     776:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__floatunsisf>
     77a:	28 eb       	ldi	r18, 0xB8	; 184
     77c:	3e e1       	ldi	r19, 0x1E	; 30
     77e:	49 e2       	ldi	r20, 0x29	; 41
     780:	51 e4       	ldi	r21, 0x41	; 65
     782:	0e 94 6f 11 	call	0x22de	; 0x22de <__divsf3>
     786:	60 93 f3 07 	sts	0x07F3, r22
     78a:	70 93 f4 07 	sts	0x07F4, r23
     78e:	80 93 f5 07 	sts	0x07F5, r24
     792:	90 93 f6 07 	sts	0x07F6, r25
     796:	c9 5f       	subi	r28, 0xF9	; 249
     798:	c0 93 14 04 	sts	0x0414, r28
     79c:	38 c0       	rjmp	.+112    	; 0x80e <StateofCharge+0x132>
     79e:	a7 e7       	ldi	r26, 0x77	; 119
     7a0:	b0 e0       	ldi	r27, 0x00	; 0
     7a2:	ae 1b       	sub	r26, r30
     7a4:	b1 09       	sbc	r27, r1
     7a6:	aa 0f       	add	r26, r26
     7a8:	bb 1f       	adc	r27, r27
     7aa:	ae 51       	subi	r26, 0x1E	; 30
     7ac:	bc 4f       	sbci	r27, 0xFC	; 252
     7ae:	6d 91       	ld	r22, X+
     7b0:	7c 91       	ld	r23, X
     7b2:	80 e0       	ldi	r24, 0x00	; 0
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__floatunsisf>
     7ba:	28 eb       	ldi	r18, 0xB8	; 184
     7bc:	3e e1       	ldi	r19, 0x1E	; 30
     7be:	41 e2       	ldi	r20, 0x21	; 33
     7c0:	51 e4       	ldi	r21, 0x41	; 65
     7c2:	0e 94 6f 11 	call	0x22de	; 0x22de <__divsf3>
     7c6:	9b 01       	movw	r18, r22
     7c8:	ac 01       	movw	r20, r24
     7ca:	60 e0       	ldi	r22, 0x00	; 0
     7cc:	70 e0       	ldi	r23, 0x00	; 0
     7ce:	88 ec       	ldi	r24, 0xC8	; 200
     7d0:	92 e4       	ldi	r25, 0x42	; 66
     7d2:	0e 94 06 11 	call	0x220c	; 0x220c <__subsf3>
     7d6:	60 93 f3 07 	sts	0x07F3, r22
     7da:	70 93 f4 07 	sts	0x07F4, r23
     7de:	80 93 f5 07 	sts	0x07F5, r24
     7e2:	90 93 f6 07 	sts	0x07F6, r25
     7e6:	13 c0       	rjmp	.+38     	; 0x80e <StateofCharge+0x132>
     7e8:	e5 36       	cpi	r30, 0x65	; 101
     7ea:	28 f4       	brcc	.+10     	; 0x7f6 <StateofCharge+0x11a>
     7ec:	80 e0       	ldi	r24, 0x00	; 0
     7ee:	90 e0       	ldi	r25, 0x00	; 0
     7f0:	a0 e8       	ldi	r26, 0x80	; 128
     7f2:	bf eb       	ldi	r27, 0xBF	; 191
     7f4:	04 c0       	rjmp	.+8      	; 0x7fe <StateofCharge+0x122>
     7f6:	80 e0       	ldi	r24, 0x00	; 0
     7f8:	90 e0       	ldi	r25, 0x00	; 0
     7fa:	a8 ed       	ldi	r26, 0xD8	; 216
     7fc:	b2 e4       	ldi	r27, 0x42	; 66
     7fe:	80 93 f3 07 	sts	0x07F3, r24
     802:	90 93 f4 07 	sts	0x07F4, r25
     806:	a0 93 f5 07 	sts	0x07F5, r26
     80a:	b0 93 f6 07 	sts	0x07F6, r27
     80e:	80 91 34 0a 	lds	r24, 0x0A34
	}
	else 
	{
	  debug = 0x0D;
     812:	81 50       	subi	r24, 0x01	; 1
     814:	8e 3f       	cpi	r24, 0xFE	; 254
	  // voltage is normalized by mean 13.7 and std 0.1558 (real - 13.7)/0.1558;
	  temp_real = (real - 13.7)*6.418485;
     816:	28 f4       	brcc	.+10     	; 0x822 <StateofCharge+0x146>
     818:	80 91 14 04 	lds	r24, 0x0414
     81c:	8f 5f       	subi	r24, 0xFF	; 255
     81e:	80 93 14 04 	sts	0x0414, r24
     822:	cf 91       	pop	r28
     824:	08 95       	ret

00000826 <assign_charge_fit>:
     826:	80 e0       	ldi	r24, 0x00	; 0
     828:	90 e3       	ldi	r25, 0x30	; 48
     82a:	af e1       	ldi	r26, 0x1F	; 31
     82c:	b6 e4       	ldi	r27, 0x46	; 70
     82e:	80 93 3a 0a 	sts	0x0A3A, r24
     832:	90 93 3b 0a 	sts	0x0A3B, r25
      batt_time = q1*pow(temp_real,3) + q2*pow(temp_real,2) + q3*temp_real + q4;
     836:	a0 93 3c 0a 	sts	0x0A3C, r26
     83a:	b0 93 3d 0a 	sts	0x0A3D, r27
     83e:	8c e5       	ldi	r24, 0x5C	; 92
     840:	9f e8       	ldi	r25, 0x8F	; 143
     842:	a4 e9       	ldi	r26, 0x94	; 148
     844:	b1 e4       	ldi	r27, 0x41	; 65
     846:	80 93 0c 0a 	sts	0x0A0C, r24
     84a:	90 93 0d 0a 	sts	0x0A0D, r25
     84e:	a0 93 0e 0a 	sts	0x0A0E, r26
     852:	b0 93 0f 0a 	sts	0x0A0F, r27
     856:	8d ec       	ldi	r24, 0xCD	; 205
     858:	9c ec       	ldi	r25, 0xCC	; 204
     85a:	a8 e3       	ldi	r26, 0x38	; 56
     85c:	b3 e4       	ldi	r27, 0x43	; 67
     85e:	80 93 31 04 	sts	0x0431, r24
     862:	90 93 32 04 	sts	0x0432, r25
     866:	a0 93 33 04 	sts	0x0433, r26
     86a:	b0 93 34 04 	sts	0x0434, r27
     86e:	86 e6       	ldi	r24, 0x66	; 102
     870:	96 ee       	ldi	r25, 0xE6	; 230
     872:	a5 e2       	ldi	r26, 0x25	; 37
     874:	b4 e4       	ldi	r27, 0x44	; 68
     876:	80 93 53 0e 	sts	0x0E53, r24
     87a:	90 93 54 0e 	sts	0x0E54, r25
     87e:	a0 93 55 0e 	sts	0x0E55, r26
     882:	b0 93 56 0e 	sts	0x0E56, r27
     886:	86 e6       	ldi	r24, 0x66	; 102
     888:	96 ea       	ldi	r25, 0xA6	; 166
     88a:	a1 e5       	ldi	r26, 0x51	; 81
     88c:	b4 e4       	ldi	r27, 0x44	; 68
     88e:	80 93 6f 0e 	sts	0x0E6F, r24
     892:	90 93 70 0e 	sts	0x0E70, r25
     896:	a0 93 71 0e 	sts	0x0E71, r26
     89a:	b0 93 72 0e 	sts	0x0E72, r27
     89e:	81 ee       	ldi	r24, 0xE1	; 225
     8a0:	9a ef       	ldi	r25, 0xFA	; 250
     8a2:	ac e9       	ldi	r26, 0x9C	; 156
     8a4:	b2 e4       	ldi	r27, 0x42	; 66
     8a6:	80 93 2e 0a 	sts	0x0A2E, r24
     8aa:	90 93 2f 0a 	sts	0x0A2F, r25
     8ae:	a0 93 30 0a 	sts	0x0A30, r26
     8b2:	b0 93 31 0a 	sts	0x0A31, r27
     8b6:	86 e6       	ldi	r24, 0x66	; 102
     8b8:	96 ec       	ldi	r25, 0xC6	; 198
     8ba:	a7 e0       	ldi	r26, 0x07	; 7
     8bc:	b4 e4       	ldi	r27, 0x44	; 68
     8be:	80 93 ec 07 	sts	0x07EC, r24
     8c2:	90 93 ed 07 	sts	0x07ED, r25
     8c6:	a0 93 ee 07 	sts	0x07EE, r26
     8ca:	b0 93 ef 07 	sts	0x07EF, r27
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	90 eb       	ldi	r25, 0xB0	; 176
     8d2:	a7 e1       	ldi	r26, 0x17	; 23
     8d4:	b5 e4       	ldi	r27, 0x45	; 69
     8d6:	80 93 2a 0a 	sts	0x0A2A, r24
     8da:	90 93 2b 0a 	sts	0x0A2B, r25
     8de:	a0 93 2c 0a 	sts	0x0A2C, r26
	}
  	percent = 100*(batt_time/charge_max_time);
     8e2:	b0 93 2d 0a 	sts	0x0A2D, r27
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	98 e9       	ldi	r25, 0x98	; 152
     8ea:	ae ea       	ldi	r26, 0xAE	; 174
     8ec:	b5 e4       	ldi	r27, 0x45	; 69
     8ee:	80 93 64 0e 	sts	0x0E64, r24
     8f2:	90 93 65 0e 	sts	0x0E65, r25
     8f6:	a0 93 66 0e 	sts	0x0E66, r26
     8fa:	b0 93 67 0e 	sts	0x0E67, r27
     8fe:	08 95       	ret

00000900 <assign_discharge_fit>:
     900:	80 e0       	ldi	r24, 0x00	; 0
     902:	96 e1       	ldi	r25, 0x16	; 22
     904:	a9 e8       	ldi	r26, 0x89	; 137
     906:	b6 e4       	ldi	r27, 0x46	; 70
     908:	80 93 01 08 	sts	0x0801, r24
     90c:	90 93 02 08 	sts	0x0802, r25
     910:	a0 93 03 08 	sts	0x0803, r26
     914:	b0 93 04 08 	sts	0x0804, r27
     918:	88 eb       	ldi	r24, 0xB8	; 184
     91a:	93 ec       	ldi	r25, 0xC3	; 195
     91c:	90 93 50 0e 	sts	0x0E50, r25
     920:	80 93 4f 0e 	sts	0x0E4F, r24
  }
  
  // Percent limiting for periodic function
  if (percent < 1) 
     924:	8a ee       	ldi	r24, 0xEA	; 234
     926:	98 eb       	ldi	r25, 0xB8	; 184
     928:	90 93 5a 0e 	sts	0x0E5A, r25
     92c:	80 93 59 0e 	sts	0x0E59, r24
     930:	8f e6       	ldi	r24, 0x6F	; 111
     932:	9c e9       	ldi	r25, 0x9C	; 156
     934:	90 93 f1 07 	sts	0x07F1, r25
     938:	80 93 f0 07 	sts	0x07F0, r24
     93c:	85 e9       	ldi	r24, 0x95	; 149
     93e:	9c e2       	ldi	r25, 0x2C	; 44
     940:	90 93 23 0a 	sts	0x0A23, r25
     944:	80 93 22 0a 	sts	0x0A22, r24
  { 
  	debug2 = 0xA0;
     948:	81 e7       	ldi	r24, 0x71	; 113
     94a:	9a ea       	ldi	r25, 0xAA	; 170
  	soc = 0; 
     94c:	90 93 2f 04 	sts	0x042F, r25
     950:	80 93 2e 04 	sts	0x042E, r24
  }
  else if (percent > 99) 
     954:	8a ec       	ldi	r24, 0xCA	; 202
     956:	98 e3       	ldi	r25, 0x38	; 56
     958:	90 93 17 0a 	sts	0x0A17, r25
     95c:	80 93 16 0a 	sts	0x0A16, r24
     960:	82 e0       	ldi	r24, 0x02	; 2
     962:	93 e0       	ldi	r25, 0x03	; 3
     964:	90 93 52 0e 	sts	0x0E52, r25
  { 
  	debug2 = 0xB0;
     968:	80 93 51 0e 	sts	0x0E51, r24
  	soc = 255;
     96c:	8d ea       	ldi	r24, 0xAD	; 173
     96e:	97 e0       	ldi	r25, 0x07	; 7
     970:	90 93 58 0e 	sts	0x0E58, r25
  }
  else { 
  	debug2 = 0xC0;
     974:	80 93 57 0e 	sts	0x0E57, r24
     978:	80 e8       	ldi	r24, 0x80	; 128
  	soc = (char)floor((int)(percent)); 
     97a:	95 e1       	ldi	r25, 0x15	; 21
     97c:	90 93 0b 08 	sts	0x080B, r25
     980:	80 93 0a 08 	sts	0x080A, r24
     984:	8e e4       	ldi	r24, 0x4E	; 78
     986:	9c ef       	ldi	r25, 0xFC	; 252
     988:	90 93 09 08 	sts	0x0809, r25
     98c:	80 93 08 08 	sts	0x0808, r24
     990:	8b e3       	ldi	r24, 0x3B	; 59
     992:	93 e0       	ldi	r25, 0x03	; 3
     994:	90 93 4e 0e 	sts	0x0E4E, r25
     998:	80 93 4d 0e 	sts	0x0E4D, r24
  }
}
     99c:	8c ed       	ldi	r24, 0xDC	; 220
     99e:	9b e6       	ldi	r25, 0x6B	; 107
     9a0:	ae e2       	ldi	r26, 0x2E	; 46
     9a2:	b0 e4       	ldi	r27, 0x40	; 64
     9a4:	80 93 f7 07 	sts	0x07F7, r24
     9a8:	90 93 f8 07 	sts	0x07F8, r25
     9ac:	a0 93 f9 07 	sts	0x07F9, r26
     9b0:	b0 93 fa 07 	sts	0x07FA, r27
     9b4:	80 e8       	ldi	r24, 0x80	; 128
     9b6:	95 e5       	ldi	r25, 0x55	; 85
     9b8:	a2 ec       	ldi	r26, 0xC2	; 194
     9ba:	b1 e1       	ldi	r27, 0x11	; 17
     9bc:	80 93 1e 0a 	sts	0x0A1E, r24
     9c0:	90 93 1f 0a 	sts	0x0A1F, r25
  b4 = 5.504490550919407E3;
  f5 = -9.466488439471518E2;
  b5 = 8.270458368650347E2;
  w = 2.725333178515558;
  
  h0 = 2.979485572689352E8;
     9c4:	a0 93 20 0a 	sts	0x0A20, r26
     9c8:	b0 93 21 0a 	sts	0x0A21, r27
  h1 = 2.088787459098652E8;
     9cc:	80 ea       	ldi	r24, 0xA0	; 160
     9ce:	9c e3       	ldi	r25, 0x3C	; 60
     9d0:	a3 e7       	ldi	r26, 0x73	; 115
     9d2:	bc e0       	ldi	r27, 0x0C	; 12
     9d4:	80 93 39 04 	sts	0x0439, r24
     9d8:	90 93 3a 04 	sts	0x043A, r25
     9dc:	a0 93 3b 04 	sts	0x043B, r26
     9e0:	b0 93 3c 04 	sts	0x043C, r27
  g1 = 4.359717315569648E8;
     9e4:	80 ea       	ldi	r24, 0xA0	; 160
     9e6:	96 e6       	ldi	r25, 0x66	; 102
     9e8:	ac ef       	ldi	r26, 0xFC	; 252
     9ea:	b9 e1       	ldi	r27, 0x19	; 25
     9ec:	80 93 3e 04 	sts	0x043E, r24
     9f0:	90 93 3f 04 	sts	0x043F, r25
     9f4:	a0 93 40 04 	sts	0x0440, r26
     9f8:	b0 93 41 04 	sts	0x0441, r27
  h2 =  -1.569778955752849E8;
     9fc:	80 e2       	ldi	r24, 0x20	; 32
     9fe:	95 eb       	ldi	r25, 0xB5	; 181
     a00:	a4 ea       	ldi	r26, 0xA4	; 164
     a02:	b6 ef       	ldi	r27, 0xF6	; 246
     a04:	80 93 19 0a 	sts	0x0A19, r24
     a08:	90 93 1a 0a 	sts	0x0A1A, r25
     a0c:	a0 93 1b 0a 	sts	0x0A1B, r26
     a10:	b0 93 1c 0a 	sts	0x0A1C, r27
  g2 =  1.969854815603661E8;
     a14:	80 e9       	ldi	r24, 0x90	; 144
     a16:	92 ec       	ldi	r25, 0xC2	; 194
     a18:	ad eb       	ldi	r26, 0xBD	; 189
     a1a:	bb e0       	ldi	r27, 0x0B	; 11
     a1c:	80 93 11 0a 	sts	0x0A11, r24
     a20:	90 93 12 0a 	sts	0x0A12, r25
     a24:	a0 93 13 0a 	sts	0x0A13, r26
     a28:	b0 93 14 0a 	sts	0x0A14, r27
  h3 =  -7.513816845838763E7;
     a2c:	88 e8       	ldi	r24, 0x88	; 136
     a2e:	9b e7       	ldi	r25, 0x7B	; 123
     a30:	a5 e8       	ldi	r26, 0x85	; 133
     a32:	bb ef       	ldi	r27, 0xFB	; 251
     a34:	80 93 5b 0e 	sts	0x0E5B, r24
     a38:	90 93 5c 0e 	sts	0x0E5C, r25
     a3c:	a0 93 5d 0e 	sts	0x0E5D, r26
     a40:	b0 93 5e 0e 	sts	0x0E5E, r27
  g3 =  -1.633385950799686E7;
     a44:	8c ed       	ldi	r24, 0xDC	; 220
     a46:	93 ec       	ldi	r25, 0xC3	; 195
     a48:	a6 e0       	ldi	r26, 0x06	; 6
     a4a:	bf ef       	ldi	r27, 0xFF	; 255
     a4c:	80 93 2a 04 	sts	0x042A, r24
     a50:	90 93 2b 04 	sts	0x042B, r25
     a54:	a0 93 2c 04 	sts	0x042C, r26
     a58:	b0 93 2d 04 	sts	0x042D, r27
  h4 =   -2.642581886559125E6;
     a5c:	8a e6       	ldi	r24, 0x6A	; 106
     a5e:	9d ea       	ldi	r25, 0xAD	; 173
     a60:	a7 ed       	ldi	r26, 0xD7	; 215
     a62:	bf ef       	ldi	r27, 0xFF	; 255
     a64:	80 93 43 0e 	sts	0x0E43, r24
     a68:	90 93 44 0e 	sts	0x0E44, r25
     a6c:	a0 93 45 0e 	sts	0x0E45, r26
     a70:	b0 93 46 0e 	sts	0x0E46, r27
  g4 =   -1.016608352073227E7;
     a74:	8c eb       	ldi	r24, 0xBC	; 188
     a76:	90 ee       	ldi	r25, 0xE0	; 224
     a78:	a4 e6       	ldi	r26, 0x64	; 100
     a7a:	bf ef       	ldi	r27, 0xFF	; 255
     a7c:	80 93 15 04 	sts	0x0415, r24
     a80:	90 93 16 04 	sts	0x0416, r25
     a84:	a0 93 17 04 	sts	0x0417, r26
     a88:	b0 93 18 04 	sts	0x0418, r27
  w2 =  0.364797662747743;
     a8c:	82 ec       	ldi	r24, 0xC2	; 194
     a8e:	96 ec       	ldi	r25, 0xC6	; 198
     a90:	aa eb       	ldi	r26, 0xBA	; 186
     a92:	be e3       	ldi	r27, 0x3E	; 62
     a94:	80 93 3f 0c 	sts	0x0C3F, r24
     a98:	90 93 40 0c 	sts	0x0C40, r25
     a9c:	a0 93 41 0c 	sts	0x0C41, r26
     aa0:	b0 93 42 0c 	sts	0x0C42, r27
     aa4:	08 95       	ret

00000aa6 <initialize>:
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE,    MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE,    MUX2    ,       6     );  // Fake Data
}

void initialize( void )
{
     aa6:	ef 92       	push	r14
     aa8:	ff 92       	push	r15
     aaa:	0f 93       	push	r16
     aac:	1f 93       	push	r17
     aae:	cf 93       	push	r28
     ab0:	df 93       	push	r29
   // pin initialization
  DDRA  = 0b11111111;
     ab2:	1f ef       	ldi	r17, 0xFF	; 255
     ab4:	1a bb       	out	0x1a, r17	; 26
  PORTA = 0b00000111;
     ab6:	87 e0       	ldi	r24, 0x07	; 7
     ab8:	8b bb       	out	0x1b, r24	; 27

  DDRB  = 0b11111111;
     aba:	17 bb       	out	0x17, r17	; 23
  PORTB = 0b11100000;
     abc:	80 ee       	ldi	r24, 0xE0	; 224
     abe:	88 bb       	out	0x18, r24	; 24

  DDRC  = 0b11111111;
     ac0:	14 bb       	out	0x14, r17	; 20
  PORTC = 0b11111111;
     ac2:	15 bb       	out	0x15, r17	; 21

  DDRD  = 0b11111011;
     ac4:	8b ef       	ldi	r24, 0xFB	; 251
     ac6:	81 bb       	out	0x11, r24	; 17
  PORTD = 0b11110000;
     ac8:	80 ef       	ldi	r24, 0xF0	; 240
     aca:	82 bb       	out	0x12, r24	; 18

  DDRE  = 0b11111110;
     acc:	9e ef       	ldi	r25, 0xFE	; 254
     ace:	92 b9       	out	0x02, r25	; 2
  PORTE = 0b00000000;
     ad0:	13 b8       	out	0x03, r1	; 3

  DDRF  = 0b11110000;
     ad2:	80 93 61 00 	sts	0x0061, r24
  //0b11111111;	//testing
  PORTF = 0b00000000;
     ad6:	10 92 62 00 	sts	0x0062, r1

  DDRG  = 0b00011111;
     ada:	8f e1       	ldi	r24, 0x1F	; 31
     adc:	80 93 64 00 	sts	0x0064, r24
  PORTG = 0b00000100;
     ae0:	04 e0       	ldi	r16, 0x04	; 4
     ae2:	00 93 65 00 	sts	0x0065, r16
  // compare value = 124
  // compare match interrupt freq = (14.7456 MHz / 1024 / 100) = 144 Hz
  // use timer0_counter to get 144 / 144 = 1 Hz

  // enable clear on match interrupt
  TIMSK = ( 1 << OCIE0 );
     ae6:	82 e0       	ldi	r24, 0x02	; 2
     ae8:	87 bf       	out	0x37, r24	; 55
  OCR0 = 71;
     aea:	87 e4       	ldi	r24, 0x47	; 71
     aec:	81 bf       	out	0x31, r24	; 49

  // enable clear on match mode, set prescalar to 1024
  TCCR0 = ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );
     aee:	8f e0       	ldi	r24, 0x0F	; 15
     af0:	83 bf       	out	0x33, r24	; 51

  timer0_counter[0] = 99;
     af2:	83 e6       	ldi	r24, 0x63	; 99
     af4:	80 93 3c 0c 	sts	0x0C3C, r24
  timer0_counter[1] = 199;
     af8:	87 ec       	ldi	r24, 0xC7	; 199
     afa:	80 93 3d 0c 	sts	0x0C3D, r24
  period of interrupts = 28800 / 14400 Hz = 2 s/interrupt
  use timer1_counter to get a total period of 2*65535 =  s (24 hours is 86400 seconds)
  */
  
  // Enable clear on match interrupt for the 16 bit timer/counter 1, register A
  OCR1A = 28800;		//28800 corresponds to 2 seconds
     afe:	80 e8       	ldi	r24, 0x80	; 128
     b00:	90 e7       	ldi	r25, 0x70	; 112
     b02:	9b bd       	out	0x2b, r25	; 43
     b04:	8a bd       	out	0x2a, r24	; 42

  // Enable clear on match mode, set prescalar to 1024.
  // CS[2:0] = 101 (1024 prescalar)
  // WGM[3:0] = 0100 (Clear Timer on Compare (CTC) when timer matches OCR1A)
  
  TCCR1B = ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS10 );
     b06:	8d e0       	ldi	r24, 0x0D	; 13
     b08:	8e bd       	out	0x2e, r24	; 46
  // Explicit Default Defs
  // TCCR1A |= 0;
  // TCNT1 = 0;
  timer1_counter[0] = CYCLE_COUNTER;	//CYCLE_COUNTER   = 900 for 2 seconds interrupt handler = 1800 secs (30 minutes)
     b0a:	84 e8       	ldi	r24, 0x84	; 132
     b0c:	80 93 60 0e 	sts	0x0E60, r24
  timer1_counter[1] = CYCLE_COUNTER_2;	//CYCLE_COUNTER_2 = 300 for 2 seconds interrupt handler = 600 secs  (10 minutes)
     b10:	8c e2       	ldi	r24, 0x2C	; 44
     b12:	80 93 61 0e 	sts	0x0E61, r24
  //---------------------------------------------------------------------  
  // End of timer 1 Setup
  //--------------------------------------------------------------------- 
  
  // communication
  uart_init();
     b16:	0e 94 bc 09 	call	0x1378	; 0x1378 <uart_init>

  // for use in debugging
  // stdout = stdin = stderr = &uart_str;

  tel_packet_size[0] = 0;
     b1a:	10 92 36 04 	sts	0x0436, r1
     b1e:	10 92 35 04 	sts	0x0435, r1
  tel_packet_size[1] = 0;
     b22:	10 92 38 04 	sts	0x0438, r1
     b26:	10 92 37 04 	sts	0x0437, r1
  tel_packet_index[0] = 0;
     b2a:	10 92 05 08 	sts	0x0805, r1
  tel_packet_index[1] = 0;
     b2e:	10 92 06 08 	sts	0x0806, r1
  uart_vcp_buff[0] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     b32:	8a e0       	ldi	r24, 0x0A	; 10
     b34:	90 e0       	ldi	r25, 0x00	; 0
     b36:	0e 94 b5 12 	call	0x256a	; 0x256a <malloc>
     b3a:	7c 01       	movw	r14, r24
     b3c:	e8 e6       	ldi	r30, 0x68	; 104
     b3e:	fe e0       	ldi	r31, 0x0E	; 14
     b40:	80 83       	st	Z, r24
     b42:	f1 82       	std	Z+1, r15	; 0x01
  uart_vcp_buff[1] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     b44:	8a e0       	ldi	r24, 0x0A	; 10
     b46:	90 e0       	ldi	r25, 0x00	; 0
     b48:	0e 94 b5 12 	call	0x256a	; 0x256a <malloc>
     b4c:	ca e6       	ldi	r28, 0x6A	; 106
     b4e:	de e0       	ldi	r29, 0x0E	; 14
     b50:	88 83       	st	Y, r24
     b52:	99 83       	std	Y+1, r25	; 0x01
  vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     b54:	4f ef       	ldi	r20, 0xFF	; 255
     b56:	50 e0       	ldi	r21, 0x00	; 0
     b58:	65 e4       	ldi	r22, 0x45	; 69
     b5a:	7c e0       	ldi	r23, 0x0C	; 12
     b5c:	c7 01       	movw	r24, r14
     b5e:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <vcpptr_init>
  vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     b62:	4f ef       	ldi	r20, 0xFF	; 255
     b64:	50 e0       	ldi	r21, 0x00	; 0
     b66:	64 e4       	ldi	r22, 0x44	; 68
     b68:	7d e0       	ldi	r23, 0x0D	; 13
     b6a:	88 81       	ld	r24, Y
     b6c:	99 81       	ldd	r25, Y+1	; 0x01
     b6e:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <vcpptr_init>

  rx_flag[0] = 0;
     b72:	10 92 6d 0e 	sts	0x0E6D, r1
  rx_flag[1] = 0;
     b76:	10 92 6e 0e 	sts	0x0E6E, r1

  // svit
  initialize_svit();
     b7a:	0e 94 92 00 	call	0x124	; 0x124 <initialize_svit>

  // rev up those interrupts
  sei();
     b7e:	78 94       	sei

  //ADC conversions
  adc_flag = 1;
     b80:	c1 e0       	ldi	r28, 0x01	; 1
     b82:	c0 93 0b 0a 	sts	0x0A0B, r28
	adc_component = 0;
     b86:	10 92 43 04 	sts	0x0443, r1
	adc_sensor_type = ADC_INIT;//get default case on first interation as to not enter switch
     b8a:	00 93 18 0a 	sts	0x0A18, r16
  ADC_high = 0;
     b8e:	10 92 29 0a 	sts	0x0A29, r1

  V_upper_val_change = 0;
     b92:	10 92 43 0c 	sts	0x0C43, r1
  I_upper_val_change = 0;
     b96:	10 92 3e 0c 	sts	0x0C3E, r1

  //---------------------------------------------------------------------  
  // SOC Initializations
  //--------------------------------------------------------------------- 
  // and shunt and safe transmit flags
  safe_mode = 0;
     b9a:	10 92 15 0a 	sts	0x0A15, r1
  transmit_safe = 0;
     b9e:	10 92 10 0a 	sts	0x0A10, r1
  transmit_shunt = 0;
     ba2:	10 92 4c 0e 	sts	0x0E4C, r1
  been_to_safe = 0;
     ba6:	10 92 3d 04 	sts	0x043D, r1
  been_to_shunt = 0;
     baa:	10 92 35 0a 	sts	0x0A35, r1
  assign_charge_fit();
     bae:	0e 94 13 04 	call	0x826	; 0x826 <assign_charge_fit>
  assign_discharge_fit();
     bb2:	0e 94 80 04 	call	0x900	; 0x900 <assign_discharge_fit>
  
  // First get battery voltage so that the SoC can
  // accurately determine whether batteries are charging or discharging
  batt1_voltage = 0xff;
     bb6:	10 93 33 0a 	sts	0x0A33, r17
  batt2_voltage = 0xff;
     bba:	10 93 44 0c 	sts	0x0C44, r17
  charging = 0xff;
     bbe:	10 93 fc 07 	sts	0x07FC, r17
  chargeforward = 0;
     bc2:	10 92 63 0e 	sts	0x0E63, r1
  chargebackward = 0;
     bc6:	10 92 42 04 	sts	0x0442, r1
  debug = 0;
     bca:	10 92 fb 07 	sts	0x07FB, r1
  debug2 = 0;
     bce:	10 92 07 08 	sts	0x0807, r1
  percent = 0;
     bd2:	10 92 f3 07 	sts	0x07F3, r1
     bd6:	10 92 f4 07 	sts	0x07F4, r1
     bda:	10 92 f5 07 	sts	0x07F5, r1
     bde:	10 92 f6 07 	sts	0x07F6, r1
  soc = 0;
     be2:	10 92 71 10 	sts	0x1071, r1
  high = 0;
     be6:	10 92 24 0a 	sts	0x0A24, r1
  low = 0;
     bea:	10 92 32 0a 	sts	0x0A32, r1
  limit_check_overriden = 0; // Initially limit checking is NOT OVERRIDEN
     bee:	10 92 f2 07 	sts	0x07F2, r1
  isCharging = 0;
     bf2:	10 92 6c 0e 	sts	0x0E6C, r1
  hasCheckedCurr = 0;
     bf6:	10 92 1d 0a 	sts	0x0A1D, r1
  //--------------------------------------------------------------------- 

  //---------------------------------------------------------------------  
  // Timer Initializations
  //---------------------------------------------------------------------
  cdh_heartbeat_flag = 0;	//Default: do not have flag to restart components on
     bfa:	10 92 30 04 	sts	0x0430, r1
  rad_torq_flag = 1;		//Indicates need to delay radio/torquer on signals later
     bfe:	c0 93 19 04 	sts	0x0419, r28
  SVIT_t *component; 	// Initialize Radios to be OFF
  component = &svit[components[RADIO_1]];
     c02:	a0 91 25 04 	lds	r26, 0x0425
     c06:	ca e1       	ldi	r28, 0x1A	; 26
     c08:	ca 9f       	mul	r28, r26
     c0a:	d0 01       	movw	r26, r0
     c0c:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     c0e:	ac 5b       	subi	r26, 0xBC	; 188
     c10:	bb 4f       	sbci	r27, 0xFB	; 251
     c12:	11 96       	adiw	r26, 0x01	; 1
     c14:	8c 91       	ld	r24, X
     c16:	0e 94 22 08 	call	0x1044	; 0x1044 <switch_off>
  component = &svit[components[RADIO_2]];
     c1a:	e0 91 26 04 	lds	r30, 0x0426
     c1e:	ce 9f       	mul	r28, r30
     c20:	f0 01       	movw	r30, r0
     c22:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     c24:	ec 5b       	subi	r30, 0xBC	; 188
     c26:	fb 4f       	sbci	r31, 0xFB	; 251
     c28:	81 81       	ldd	r24, Z+1	; 0x01
     c2a:	0e 94 22 08 	call	0x1044	; 0x1044 <switch_off>
  component = &svit[TORQUER_1];	// Initialize Torque Coils to be OFF
  component->switch_state = SW_OFF;
     c2e:	10 92 00 06 	sts	0x0600, r1
  component = &svit[TORQUER_2];
  component->switch_state = SW_OFF;
     c32:	10 92 1a 06 	sts	0x061A, r1
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
     c36:	10 92 34 06 	sts	0x0634, r1
  torquer_off(TORQUER_1);
     c3a:	81 e1       	ldi	r24, 0x11	; 17
     c3c:	0e 94 a8 07 	call	0xf50	; 0xf50 <torquer_off>
  torquer_off(TORQUER_2);
     c40:	82 e1       	ldi	r24, 0x12	; 18
     c42:	0e 94 a8 07 	call	0xf50	; 0xf50 <torquer_off>
  torquer_off(TORQUER_3);
     c46:	83 e1       	ldi	r24, 0x13	; 19
  //---------------------------------------------------------------------  
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}
     c48:	df 91       	pop	r29
     c4a:	cf 91       	pop	r28
     c4c:	1f 91       	pop	r17
     c4e:	0f 91       	pop	r16
     c50:	ff 90       	pop	r15
     c52:	ef 90       	pop	r14
  component->switch_state = SW_OFF;
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
  torquer_off(TORQUER_1);
  torquer_off(TORQUER_2);
  torquer_off(TORQUER_3);
     c54:	0c 94 a8 07 	jmp	0xf50	; 0xf50 <torquer_off>

00000c58 <compareVoltage>:
void compareVoltage( void ) {
  SVIT_t *component;
  //component = &svit[BATTERY_1_b];
  //chargebackward = average_samples( component->I_samples );
  component = &svit[BATTERY_1];
  chargeforward= average_samples( component->I_samples );
     c58:	8b e5       	ldi	r24, 0x5B	; 91
     c5a:	96 e0       	ldi	r25, 0x06	; 6
     c5c:	0e 94 65 08 	call	0x10ca	; 0x10ca <average_samples>
     c60:	80 93 63 0e 	sts	0x0E63, r24
  if (chargeforward > 2){
     c64:	83 30       	cpi	r24, 0x03	; 3
     c66:	10 f0       	brcs	.+4      	; 0xc6c <compareVoltage+0x14>
    charging = 0xdd;//discharging
     c68:	8d ed       	ldi	r24, 0xDD	; 221
     c6a:	01 c0       	rjmp	.+2      	; 0xc6e <compareVoltage+0x16>
    }
  else{
    charging = 0xcc;
     c6c:	8c ec       	ldi	r24, 0xCC	; 204
     c6e:	80 93 fc 07 	sts	0x07FC, r24
     c72:	08 95       	ret

00000c74 <limit_check>:
we should at least get the framework set up for limit checking on arbitrary values.
The power board should have upper and lower limits for vsense and csense data, 
and turn off components if their voltage/current is too high. ONLY CHECKS
BATTERY 1 VOLTAGE LINE RIGHT NOW.
*/
void limit_check( void ) {
     c74:	cf 92       	push	r12
     c76:	df 92       	push	r13
     c78:	ef 92       	push	r14
     c7a:	ff 92       	push	r15
     c7c:	0f 93       	push	r16
     c7e:	1f 93       	push	r17
     c80:	cf 93       	push	r28
     c82:	df 93       	push	r29
	unsigned char sw;
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
     c84:	c0 90 f3 07 	lds	r12, 0x07F3
     c88:	d0 90 f4 07 	lds	r13, 0x07F4
     c8c:	e0 90 f5 07 	lds	r14, 0x07F5
     c90:	f0 90 f6 07 	lds	r15, 0x07F6
     c94:	20 e0       	ldi	r18, 0x00	; 0
     c96:	30 e0       	ldi	r19, 0x00	; 0
     c98:	a9 01       	movw	r20, r18
     c9a:	c7 01       	movw	r24, r14
     c9c:	b6 01       	movw	r22, r12
     c9e:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__cmpsf2>
     ca2:	87 ff       	sbrs	r24, 7
     ca4:	4c c0       	rjmp	.+152    	; 0xd3e <limit_check+0xca>
     ca6:	29 e2       	ldi	r18, 0x29	; 41
     ca8:	3c e5       	ldi	r19, 0x5C	; 92
     caa:	4f e0       	ldi	r20, 0x0F	; 15
     cac:	5f eb       	ldi	r21, 0xBF	; 191
     cae:	c7 01       	movw	r24, r14
     cb0:	b6 01       	movw	r22, r12
     cb2:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__cmpsf2>
     cb6:	87 ff       	sbrs	r24, 7
     cb8:	0a c0       	rjmp	.+20     	; 0xcce <limit_check+0x5a>
     cba:	25 e8       	ldi	r18, 0x85	; 133
     cbc:	3b ee       	ldi	r19, 0xEB	; 235
     cbe:	41 e1       	ldi	r20, 0x11	; 17
     cc0:	5f eb       	ldi	r21, 0xBF	; 191
     cc2:	c7 01       	movw	r24, r14
     cc4:	b6 01       	movw	r22, r12
     cc6:	0e 94 89 12 	call	0x2512	; 0x2512 <__gesf2>
     cca:	18 16       	cp	r1, r24
     ccc:	c4 f1       	brlt	.+112    	; 0xd3e <limit_check+0xca>
		safe_mode = 1;
     cce:	81 e0       	ldi	r24, 0x01	; 1
     cd0:	80 93 15 0a 	sts	0x0A15, r24
     cd4:	0a e1       	ldi	r16, 0x1A	; 26
     cd6:	14 e0       	ldi	r17, 0x04	; 4
		for (sw = 0; sw < sizeof(components); sw++) {
			component = &svit[components[sw]];
     cd8:	ca e1       	ldi	r28, 0x1A	; 26
     cda:	fc 2e       	mov	r15, r28
     cdc:	f8 01       	movw	r30, r16
     cde:	c1 91       	ld	r28, Z+
     ce0:	8f 01       	movw	r16, r30
     ce2:	fc 9e       	mul	r15, r28
     ce4:	e0 01       	movw	r28, r0
     ce6:	11 24       	eor	r1, r1
     ce8:	cc 5b       	subi	r28, 0xBC	; 188
     cea:	db 4f       	sbci	r29, 0xFB	; 251
			switch_off( component->switch_num );
     cec:	89 81       	ldd	r24, Y+1	; 0x01
     cee:	0e 94 22 08 	call	0x1044	; 0x1044 <switch_off>
			component->switch_state = SW_OFF;
     cf2:	1a 82       	std	Y+2, r1	; 0x02
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
		safe_mode = 1;
		for (sw = 0; sw < sizeof(components); sw++) {
     cf4:	f4 e0       	ldi	r31, 0x04	; 4
     cf6:	0a 32       	cpi	r16, 0x2A	; 42
     cf8:	1f 07       	cpc	r17, r31
     cfa:	81 f7       	brne	.-32     	; 0xcdc <limit_check+0x68>
			component = &svit[components[sw]];
			switch_off( component->switch_num );
			component->switch_state = SW_OFF;
		}
		component = &svit[TORQUER_1];
		component->switch_state = SW_OFF;
     cfc:	10 92 00 06 	sts	0x0600, r1
		component = &svit[TORQUER_2];
		component->switch_state = SW_OFF;
     d00:	10 92 1a 06 	sts	0x061A, r1
		component = &svit[TORQUER_3];
		component->switch_state = SW_OFF;
     d04:	10 92 34 06 	sts	0x0634, r1
		torquer_off(TORQUER_1);
     d08:	81 e1       	ldi	r24, 0x11	; 17
     d0a:	0e 94 a8 07 	call	0xf50	; 0xf50 <torquer_off>
		torquer_off(TORQUER_2);
     d0e:	82 e1       	ldi	r24, 0x12	; 18
     d10:	0e 94 a8 07 	call	0xf50	; 0xf50 <torquer_off>
		torquer_off(TORQUER_3);
     d14:	83 e1       	ldi	r24, 0x13	; 19
     d16:	0e 94 a8 07 	call	0xf50	; 0xf50 <torquer_off>
		// Only transmit once
		if (!transmit_safe && !been_to_safe) { 
     d1a:	80 91 10 0a 	lds	r24, 0x0A10
     d1e:	81 11       	cpse	r24, r1
     d20:	08 c0       	rjmp	.+16     	; 0xd32 <limit_check+0xbe>
     d22:	80 91 3d 04 	lds	r24, 0x043D
     d26:	81 11       	cpse	r24, r1
     d28:	04 c0       	rjmp	.+8      	; 0xd32 <limit_check+0xbe>
			transmit_packet( 0, VCP_ACK, SAFE_MODE);
     d2a:	40 e0       	ldi	r20, 0x00	; 0
     d2c:	62 e0       	ldi	r22, 0x02	; 2
     d2e:	0e 94 59 10 	call	0x20b2	; 0x20b2 <transmit_packet>
			transmit_safe = 1;
		}
		else {}
		been_to_safe = 1;
     d32:	81 e0       	ldi	r24, 0x01	; 1
     d34:	80 93 3d 04 	sts	0x043D, r24
		transmit_safe = 1;
     d38:	80 93 10 0a 	sts	0x0A10, r24
     d3c:	28 c0       	rjmp	.+80     	; 0xd8e <limit_check+0x11a>
	}
	else if (percent > SHUNT_MODE  && isCharging) {
     d3e:	20 e0       	ldi	r18, 0x00	; 0
     d40:	30 e0       	ldi	r19, 0x00	; 0
     d42:	48 ec       	ldi	r20, 0xC8	; 200
     d44:	52 e4       	ldi	r21, 0x42	; 66
     d46:	c7 01       	movw	r24, r14
     d48:	b6 01       	movw	r22, r12
     d4a:	0e 94 89 12 	call	0x2512	; 0x2512 <__gesf2>
     d4e:	18 16       	cp	r1, r24
     d50:	f4 f4       	brge	.+60     	; 0xd8e <limit_check+0x11a>
     d52:	80 91 6c 0e 	lds	r24, 0x0E6C
     d56:	88 23       	and	r24, r24
     d58:	d1 f0       	breq	.+52     	; 0xd8e <limit_check+0x11a>
	    safe_mode = 0;
     d5a:	10 92 15 0a 	sts	0x0A15, r1
		// turn on the maestro and send ack_command w/ value of SHUNT_MODE
		component = &svit[MAESTRO];
		switch_on( component->switch_num );
     d5e:	80 91 97 05 	lds	r24, 0x0597
     d62:	0e 94 df 07 	call	0xfbe	; 0xfbe <switch_on>
		component->switch_state = SW_ON;
     d66:	81 e0       	ldi	r24, 0x01	; 1
     d68:	80 93 98 05 	sts	0x0598, r24
		// Only transmit once
		if (!transmit_shunt && !been_to_shunt) {
     d6c:	80 91 4c 0e 	lds	r24, 0x0E4C
     d70:	81 11       	cpse	r24, r1
     d72:	08 c0       	rjmp	.+16     	; 0xd84 <limit_check+0x110>
     d74:	80 91 35 0a 	lds	r24, 0x0A35
     d78:	81 11       	cpse	r24, r1
     d7a:	04 c0       	rjmp	.+8      	; 0xd84 <limit_check+0x110>
			transmit_packet( 0, VCP_ACK, SHUNT_MODE);
     d7c:	44 e6       	ldi	r20, 0x64	; 100
     d7e:	62 e0       	ldi	r22, 0x02	; 2
     d80:	0e 94 59 10 	call	0x20b2	; 0x20b2 <transmit_packet>
		}
		else {}	
		been_to_shunt = 1;
     d84:	81 e0       	ldi	r24, 0x01	; 1
     d86:	80 93 35 0a 	sts	0x0A35, r24
		transmit_shunt = 1;	
     d8a:	80 93 4c 0e 	sts	0x0E4C, r24
	}
	else {} // To avoid annoying compile warning 
}
     d8e:	df 91       	pop	r29
     d90:	cf 91       	pop	r28
     d92:	1f 91       	pop	r17
     d94:	0f 91       	pop	r16
     d96:	ff 90       	pop	r15
     d98:	ef 90       	pop	r14
     d9a:	df 90       	pop	r13
     d9c:	cf 90       	pop	r12
     d9e:	08 95       	ret

00000da0 <main>:


// MAIN
int main( void ) 
{  
  initialize();
     da0:	0e 94 53 05 	call	0xaa6	; 0xaa6 <initialize>
  //fprintf( stdout, "uart initialized\n" );
	
  //Testing
  cntr = 0;
     da4:	10 92 0a 0a 	sts	0x0A0A, r1

  while(1)
  {
	cntr = 1 - cntr; //Testing
     da8:	11 e0       	ldi	r17, 0x01	; 1
	
    if ( timer0_counter[1] == 0 )
    {
        timer0_counter[1] = 199;
     daa:	c7 ec       	ldi	r28, 0xC7	; 199
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     dac:	dc e2       	ldi	r29, 0x2C	; 44
  //Testing
  cntr = 0;

  while(1)
  {
	cntr = 1 - cntr; //Testing
     dae:	80 91 0a 0a 	lds	r24, 0x0A0A
     db2:	91 2f       	mov	r25, r17
     db4:	98 1b       	sub	r25, r24
     db6:	90 93 0a 0a 	sts	0x0A0A, r25
	
    if ( timer0_counter[1] == 0 )
     dba:	80 91 3d 0c 	lds	r24, 0x0C3D
     dbe:	81 11       	cpse	r24, r1
     dc0:	07 c0       	rjmp	.+14     	; 0xdd0 <main+0x30>
    {
        timer0_counter[1] = 199;
     dc2:	c0 93 3d 0c 	sts	0x0C3D, r28
        transmit_packet( 1, VCP_POWER_TELEMETRY, 0);
     dc6:	40 e0       	ldi	r20, 0x00	; 0
     dc8:	60 e0       	ldi	r22, 0x00	; 0
     dca:	81 e0       	ldi	r24, 0x01	; 1
     dcc:	0e 94 59 10 	call	0x20b2	; 0x20b2 <transmit_packet>
    }
	  if ( timer0_counter[0] == 0 )
     dd0:	80 91 3c 0c 	lds	r24, 0x0C3C
     dd4:	81 11       	cpse	r24, r1
     dd6:	06 c0       	rjmp	.+12     	; 0xde4 <main+0x44>
    {
        timer0_counter[0] = 199;
     dd8:	c0 93 3c 0c 	sts	0x0C3C, r28
        transmit_packet( 0, VCP_POWER_TELEMETRY, 0);
     ddc:	40 e0       	ldi	r20, 0x00	; 0
     dde:	60 e0       	ldi	r22, 0x00	; 0
     de0:	0e 94 59 10 	call	0x20b2	; 0x20b2 <transmit_packet>
    }
	  if ( rx_flag[0] > 0 )
     de4:	80 91 6d 0e 	lds	r24, 0x0E6D
     de8:	88 23       	and	r24, r24
     dea:	c9 f0       	breq	.+50     	; 0xe1e <main+0x7e>
    {
        rx_flag[0]--;
     dec:	80 91 6d 0e 	lds	r24, 0x0E6D
     df0:	81 50       	subi	r24, 0x01	; 1
     df2:	80 93 6d 0e 	sts	0x0E6D, r24
        receive_message( 0, uart_vcp_buff[0]->message, uart_vcp_buff[0]->index );
     df6:	e0 91 68 0e 	lds	r30, 0x0E68
     dfa:	f0 91 69 0e 	lds	r31, 0x0E69
     dfe:	61 81       	ldd	r22, Z+1	; 0x01
     e00:	72 81       	ldd	r23, Z+2	; 0x02
     e02:	47 81       	ldd	r20, Z+7	; 0x07
     e04:	80 e0       	ldi	r24, 0x00	; 0
     e06:	0e 94 c5 02 	call	0x58a	; 0x58a <receive_message>
        vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     e0a:	4f ef       	ldi	r20, 0xFF	; 255
     e0c:	50 e0       	ldi	r21, 0x00	; 0
     e0e:	65 e4       	ldi	r22, 0x45	; 69
     e10:	7c e0       	ldi	r23, 0x0C	; 12
     e12:	80 91 68 0e 	lds	r24, 0x0E68
     e16:	90 91 69 0e 	lds	r25, 0x0E69
     e1a:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <vcpptr_init>
    }
	  if ( rx_flag[1] > 0 )
     e1e:	80 91 6e 0e 	lds	r24, 0x0E6E
     e22:	88 23       	and	r24, r24
     e24:	c9 f0       	breq	.+50     	; 0xe58 <main+0xb8>
    {
        rx_flag[1]--;
     e26:	80 91 6e 0e 	lds	r24, 0x0E6E
     e2a:	81 50       	subi	r24, 0x01	; 1
     e2c:	80 93 6e 0e 	sts	0x0E6E, r24
        receive_message( 1, uart_vcp_buff[1]->message, uart_vcp_buff[1]->index );
     e30:	e0 91 6a 0e 	lds	r30, 0x0E6A
     e34:	f0 91 6b 0e 	lds	r31, 0x0E6B
     e38:	61 81       	ldd	r22, Z+1	; 0x01
     e3a:	72 81       	ldd	r23, Z+2	; 0x02
     e3c:	47 81       	ldd	r20, Z+7	; 0x07
     e3e:	81 e0       	ldi	r24, 0x01	; 1
     e40:	0e 94 c5 02 	call	0x58a	; 0x58a <receive_message>
        vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     e44:	4f ef       	ldi	r20, 0xFF	; 255
     e46:	50 e0       	ldi	r21, 0x00	; 0
     e48:	64 e4       	ldi	r22, 0x44	; 68
     e4a:	7d e0       	ldi	r23, 0x0D	; 13
     e4c:	80 91 6a 0e 	lds	r24, 0x0E6A
     e50:	90 91 6b 0e 	lds	r25, 0x0E6B
     e54:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <vcpptr_init>
    }
    if (adc_flag == 1)
     e58:	80 91 0b 0a 	lds	r24, 0x0A0B
     e5c:	81 30       	cpi	r24, 0x01	; 1
     e5e:	91 f4       	brne	.+36     	; 0xe84 <main+0xe4>
    {
        adc_flag = 0;
     e60:	10 92 0b 0a 	sts	0x0A0B, r1
        read_VIT();
     e64:	0e 94 9c 08 	call	0x1138	; 0x1138 <read_VIT>
		//calcSOC();
		StateofCharge();
     e68:	0e 94 6e 03 	call	0x6dc	; 0x6dc <StateofCharge>

		/*
		Manual Override on Limit Checking: The power board must be able to receive a 
		command to disable and/or change the limits in the limit checking code
		*/
		if (!limit_check_overriden) {
     e6c:	80 91 f2 07 	lds	r24, 0x07F2
     e70:	81 11       	cpse	r24, r1
     e72:	02 c0       	rjmp	.+4      	; 0xe78 <main+0xd8>
			limit_check(); // First determine if voltage is within valid range, then switch
     e74:	0e 94 3a 06 	call	0xc74	; 0xc74 <limit_check>
		}

		if ( adc_component == 23 ) 
     e78:	80 91 43 04 	lds	r24, 0x0443
     e7c:	87 31       	cpi	r24, 0x17	; 23
     e7e:	11 f4       	brne	.+4      	; 0xe84 <main+0xe4>
      	{ //23ish anything after battery values are calculated
  			  compareVoltage();
     e80:	0e 94 2c 06 	call	0xc58	; 0xc58 <compareVoltage>
	   	}
    }	
	
	//Restart all board components if CDH-IB heartbeat timeout
	if (cdh_heartbeat_flag == 1){
     e84:	80 91 30 04 	lds	r24, 0x0430
     e88:	81 30       	cpi	r24, 0x01	; 1
     e8a:	09 f0       	breq	.+2      	; 0xe8e <main+0xee>
     e8c:	90 cf       	rjmp	.-224    	; 0xdae <main+0xe>
		//Restart all components
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
     e8e:	10 92 30 04 	sts	0x0430, r1
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     e92:	d0 93 61 0e 	sts	0x0E61, r29
     e96:	8b cf       	rjmp	.-234    	; 0xdae <main+0xe>

00000e98 <torquer_off.part.0>:
void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
  {
    case TORQUER_1:
      CLR( PORTC, 0 );
     e98:	a8 98       	cbi	0x15, 0	; 21
	  CLR( PORTG, 1 );
     e9a:	e5 e6       	ldi	r30, 0x65	; 101
     e9c:	f0 e0       	ldi	r31, 0x00	; 0
     e9e:	80 81       	ld	r24, Z
     ea0:	8d 7f       	andi	r24, 0xFD	; 253
     ea2:	80 83       	st	Z, r24
     ea4:	08 95       	ret

00000ea6 <set_mux_sel>:
#include "mcupwr-Defs.h"


void set_mux_sel( uint8_t mux_num, uint8_t mux_sel )
{
  switch( mux_num )
     ea6:	81 30       	cpi	r24, 0x01	; 1
     ea8:	f9 f0       	breq	.+62     	; 0xee8 <set_mux_sel+0x42>
     eaa:	20 f0       	brcs	.+8      	; 0xeb4 <set_mux_sel+0xe>
     eac:	82 30       	cpi	r24, 0x02	; 2
     eae:	09 f0       	breq	.+2      	; 0xeb2 <set_mux_sel+0xc>
     eb0:	4e c0       	rjmp	.+156    	; 0xf4e <set_mux_sel+0xa8>
     eb2:	34 c0       	rjmp	.+104    	; 0xf1c <set_mux_sel+0x76>
  {
    case MUX0:
      READ( mux_sel, 4 ) ? SET( PORTA, 7 ) : CLR( PORTA, 7 );
     eb4:	64 ff       	sbrs	r22, 4
     eb6:	02 c0       	rjmp	.+4      	; 0xebc <set_mux_sel+0x16>
     eb8:	df 9a       	sbi	0x1b, 7	; 27
     eba:	01 c0       	rjmp	.+2      	; 0xebe <set_mux_sel+0x18>
     ebc:	df 98       	cbi	0x1b, 7	; 27
      READ( mux_sel, 3 ) ? SET( PORTA, 6 ) : CLR( PORTA, 6 );
     ebe:	63 ff       	sbrs	r22, 3
     ec0:	02 c0       	rjmp	.+4      	; 0xec6 <set_mux_sel+0x20>
     ec2:	de 9a       	sbi	0x1b, 6	; 27
     ec4:	01 c0       	rjmp	.+2      	; 0xec8 <set_mux_sel+0x22>
     ec6:	de 98       	cbi	0x1b, 6	; 27
      READ( mux_sel, 2 ) ? SET( PORTA, 5 ) : CLR( PORTA, 5 );
     ec8:	62 ff       	sbrs	r22, 2
     eca:	02 c0       	rjmp	.+4      	; 0xed0 <set_mux_sel+0x2a>
     ecc:	dd 9a       	sbi	0x1b, 5	; 27
     ece:	01 c0       	rjmp	.+2      	; 0xed2 <set_mux_sel+0x2c>
     ed0:	dd 98       	cbi	0x1b, 5	; 27
      READ( mux_sel, 1 ) ? SET( PORTA, 4 ) : CLR( PORTA, 4 );
     ed2:	61 ff       	sbrs	r22, 1
     ed4:	02 c0       	rjmp	.+4      	; 0xeda <set_mux_sel+0x34>
     ed6:	dc 9a       	sbi	0x1b, 4	; 27
     ed8:	01 c0       	rjmp	.+2      	; 0xedc <set_mux_sel+0x36>
     eda:	dc 98       	cbi	0x1b, 4	; 27
      READ( mux_sel, 0 ) ? SET( PORTA, 3 ) : CLR( PORTA, 3 );
     edc:	60 ff       	sbrs	r22, 0
     ede:	02 c0       	rjmp	.+4      	; 0xee4 <set_mux_sel+0x3e>
     ee0:	db 9a       	sbi	0x1b, 3	; 27
     ee2:	08 95       	ret
     ee4:	db 98       	cbi	0x1b, 3	; 27
     ee6:	08 95       	ret

      break;

    case MUX1:
      READ( mux_sel, 4 ) ? SET( PORTB, 0 ) : CLR( PORTB, 0 );
     ee8:	64 ff       	sbrs	r22, 4
     eea:	02 c0       	rjmp	.+4      	; 0xef0 <set_mux_sel+0x4a>
     eec:	c0 9a       	sbi	0x18, 0	; 24
     eee:	01 c0       	rjmp	.+2      	; 0xef2 <set_mux_sel+0x4c>
     ef0:	c0 98       	cbi	0x18, 0	; 24
      READ( mux_sel, 3 ) ? SET( PORTB, 1 ) : CLR( PORTB, 1 );
     ef2:	63 ff       	sbrs	r22, 3
     ef4:	02 c0       	rjmp	.+4      	; 0xefa <set_mux_sel+0x54>
     ef6:	c1 9a       	sbi	0x18, 1	; 24
     ef8:	01 c0       	rjmp	.+2      	; 0xefc <set_mux_sel+0x56>
     efa:	c1 98       	cbi	0x18, 1	; 24
      READ( mux_sel, 2 ) ? SET( PORTB, 2 ) : CLR( PORTB, 2 );
     efc:	62 ff       	sbrs	r22, 2
     efe:	02 c0       	rjmp	.+4      	; 0xf04 <set_mux_sel+0x5e>
     f00:	c2 9a       	sbi	0x18, 2	; 24
     f02:	01 c0       	rjmp	.+2      	; 0xf06 <set_mux_sel+0x60>
     f04:	c2 98       	cbi	0x18, 2	; 24
      READ( mux_sel, 1 ) ? SET( PORTB, 3 ) : CLR( PORTB, 3 );
     f06:	61 ff       	sbrs	r22, 1
     f08:	02 c0       	rjmp	.+4      	; 0xf0e <set_mux_sel+0x68>
     f0a:	c3 9a       	sbi	0x18, 3	; 24
     f0c:	01 c0       	rjmp	.+2      	; 0xf10 <set_mux_sel+0x6a>
     f0e:	c3 98       	cbi	0x18, 3	; 24
      READ( mux_sel, 0 ) ? SET( PORTB, 4 ) : CLR( PORTB, 4 );
     f10:	60 ff       	sbrs	r22, 0
     f12:	02 c0       	rjmp	.+4      	; 0xf18 <set_mux_sel+0x72>
     f14:	c4 9a       	sbi	0x18, 4	; 24
     f16:	08 95       	ret
     f18:	c4 98       	cbi	0x18, 4	; 24
     f1a:	08 95       	ret

      break;

    case MUX2:
      READ( mux_sel, 4 ) ? SET( PORTE, 3 ) : CLR( PORTE, 3 );
     f1c:	64 ff       	sbrs	r22, 4
     f1e:	02 c0       	rjmp	.+4      	; 0xf24 <set_mux_sel+0x7e>
     f20:	1b 9a       	sbi	0x03, 3	; 3
     f22:	01 c0       	rjmp	.+2      	; 0xf26 <set_mux_sel+0x80>
     f24:	1b 98       	cbi	0x03, 3	; 3
      READ( mux_sel, 3 ) ? SET( PORTE, 4 ) : CLR( PORTE, 4 );
     f26:	63 ff       	sbrs	r22, 3
     f28:	02 c0       	rjmp	.+4      	; 0xf2e <set_mux_sel+0x88>
     f2a:	1c 9a       	sbi	0x03, 4	; 3
     f2c:	01 c0       	rjmp	.+2      	; 0xf30 <set_mux_sel+0x8a>
     f2e:	1c 98       	cbi	0x03, 4	; 3
      READ( mux_sel, 2 ) ? SET( PORTE, 5 ) : CLR( PORTE, 5 );
     f30:	62 ff       	sbrs	r22, 2
     f32:	02 c0       	rjmp	.+4      	; 0xf38 <set_mux_sel+0x92>
     f34:	1d 9a       	sbi	0x03, 5	; 3
     f36:	01 c0       	rjmp	.+2      	; 0xf3a <set_mux_sel+0x94>
     f38:	1d 98       	cbi	0x03, 5	; 3
      READ( mux_sel, 1 ) ? SET( PORTE, 6 ) : CLR( PORTE, 6 );
     f3a:	61 ff       	sbrs	r22, 1
     f3c:	02 c0       	rjmp	.+4      	; 0xf42 <set_mux_sel+0x9c>
     f3e:	1e 9a       	sbi	0x03, 6	; 3
     f40:	01 c0       	rjmp	.+2      	; 0xf44 <set_mux_sel+0x9e>
     f42:	1e 98       	cbi	0x03, 6	; 3
      READ( mux_sel, 0 ) ? SET( PORTE, 7 ) : CLR( PORTE, 7 );
     f44:	60 ff       	sbrs	r22, 0
     f46:	02 c0       	rjmp	.+4      	; 0xf4c <set_mux_sel+0xa6>
     f48:	1f 9a       	sbi	0x03, 7	; 3
     f4a:	08 95       	ret
     f4c:	1f 98       	cbi	0x03, 7	; 3
     f4e:	08 95       	ret

00000f50 <torquer_off>:
  }
}

void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
     f50:	82 31       	cpi	r24, 0x12	; 18
     f52:	31 f0       	breq	.+12     	; 0xf60 <torquer_off+0x10>
     f54:	83 31       	cpi	r24, 0x13	; 19
     f56:	59 f0       	breq	.+22     	; 0xf6e <torquer_off+0x1e>
     f58:	81 31       	cpi	r24, 0x11	; 17
     f5a:	99 f4       	brne	.+38     	; 0xf82 <torquer_off+0x32>
     f5c:	0c 94 4c 07 	jmp	0xe98	; 0xe98 <torquer_off.part.0>
      CLR( PORTC, 0 );
	  CLR( PORTG, 1 );
      break;

    case TORQUER_2:
      CLR( PORTG, 0 );
     f60:	80 91 65 00 	lds	r24, 0x0065
     f64:	8e 7f       	andi	r24, 0xFE	; 254
     f66:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTD, 0 );
     f6a:	90 98       	cbi	0x12, 0	; 18
      break;
     f6c:	08 95       	ret

    case TORQUER_3:
      CLR( PORTG, 3 );
     f6e:	80 91 65 00 	lds	r24, 0x0065
     f72:	87 7f       	andi	r24, 0xF7	; 247
     f74:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTG, 4 );
     f78:	80 91 65 00 	lds	r24, 0x0065
     f7c:	8f 7e       	andi	r24, 0xEF	; 239
     f7e:	80 93 65 00 	sts	0x0065, r24
     f82:	08 95       	ret

00000f84 <torquer_on>:
  }  
}

void torquer_on( uint8_t torquer_num )
{
  switch( torquer_num )
     f84:	82 31       	cpi	r24, 0x12	; 18
     f86:	49 f0       	breq	.+18     	; 0xf9a <torquer_on+0x16>
     f88:	83 31       	cpi	r24, 0x13	; 19
     f8a:	71 f0       	breq	.+28     	; 0xfa8 <torquer_on+0x24>
     f8c:	81 31       	cpi	r24, 0x11	; 17
     f8e:	b1 f4       	brne	.+44     	; 0xfbc <torquer_on+0x38>
  {
    case TORQUER_1:
      SET( PORTC, 0 );
     f90:	a8 9a       	sbi	0x15, 0	; 21
	  SET( PORTG, 1 );
     f92:	80 91 65 00 	lds	r24, 0x0065
     f96:	82 60       	ori	r24, 0x02	; 2
     f98:	0f c0       	rjmp	.+30     	; 0xfb8 <torquer_on+0x34>
      break;

    case TORQUER_2:
      SET( PORTG, 0 );
     f9a:	80 91 65 00 	lds	r24, 0x0065
     f9e:	81 60       	ori	r24, 0x01	; 1
     fa0:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTD, 0 );
     fa4:	90 9a       	sbi	0x12, 0	; 18
      break;
     fa6:	08 95       	ret

    case TORQUER_3:
      SET( PORTG, 3 );
     fa8:	80 91 65 00 	lds	r24, 0x0065
     fac:	88 60       	ori	r24, 0x08	; 8
     fae:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTG, 4 );
     fb2:	80 91 65 00 	lds	r24, 0x0065
     fb6:	80 61       	ori	r24, 0x10	; 16
     fb8:	80 93 65 00 	sts	0x0065, r24
     fbc:	08 95       	ret

00000fbe <switch_on>:
  }
}

void switch_on( uint8_t switch_num )
{
  switch ( switch_num )
     fbe:	88 30       	cpi	r24, 0x08	; 8
     fc0:	59 f1       	breq	.+86     	; 0x1018 <switch_on+0x5a>
     fc2:	68 f4       	brcc	.+26     	; 0xfde <switch_on+0x20>
     fc4:	84 30       	cpi	r24, 0x04	; 4
     fc6:	01 f1       	breq	.+64     	; 0x1008 <switch_on+0x4a>
     fc8:	30 f4       	brcc	.+12     	; 0xfd6 <switch_on+0x18>
     fca:	82 30       	cpi	r24, 0x02	; 2
     fcc:	c9 f0       	breq	.+50     	; 0x1000 <switch_on+0x42>
     fce:	d0 f4       	brcc	.+52     	; 0x1004 <switch_on+0x46>
     fd0:	81 30       	cpi	r24, 0x01	; 1
     fd2:	b9 f5       	brne	.+110    	; 0x1042 <switch_on+0x84>
     fd4:	13 c0       	rjmp	.+38     	; 0xffc <switch_on+0x3e>
     fd6:	86 30       	cpi	r24, 0x06	; 6
     fd8:	d9 f0       	breq	.+54     	; 0x1010 <switch_on+0x52>
     fda:	e0 f4       	brcc	.+56     	; 0x1014 <switch_on+0x56>
     fdc:	17 c0       	rjmp	.+46     	; 0x100c <switch_on+0x4e>
     fde:	8c 30       	cpi	r24, 0x0C	; 12
     fe0:	39 f1       	breq	.+78     	; 0x1030 <switch_on+0x72>
     fe2:	20 f4       	brcc	.+8      	; 0xfec <switch_on+0x2e>
     fe4:	8a 30       	cpi	r24, 0x0A	; 10
     fe6:	01 f1       	breq	.+64     	; 0x1028 <switch_on+0x6a>
     fe8:	08 f5       	brcc	.+66     	; 0x102c <switch_on+0x6e>
     fea:	18 c0       	rjmp	.+48     	; 0x101c <switch_on+0x5e>
     fec:	8e 30       	cpi	r24, 0x0E	; 14
     fee:	21 f1       	breq	.+72     	; 0x1038 <switch_on+0x7a>
     ff0:	08 f1       	brcs	.+66     	; 0x1034 <switch_on+0x76>
     ff2:	8f 30       	cpi	r24, 0x0F	; 15
     ff4:	19 f1       	breq	.+70     	; 0x103c <switch_on+0x7e>
     ff6:	80 31       	cpi	r24, 0x10	; 16
     ff8:	21 f5       	brne	.+72     	; 0x1042 <switch_on+0x84>
     ffa:	22 c0       	rjmp	.+68     	; 0x1040 <switch_on+0x82>
  {
    case 1:
      SET( PORTA, 0 );
     ffc:	d8 9a       	sbi	0x1b, 0	; 27
      break;
     ffe:	08 95       	ret

    case 2:
      SET( PORTA, 1 );
    1000:	d9 9a       	sbi	0x1b, 1	; 27
      break;
    1002:	08 95       	ret

    case 3:
      SET( PORTA, 2 );
    1004:	da 9a       	sbi	0x1b, 2	; 27
      break;
    1006:	08 95       	ret

    case 4:
      SET( PORTB, 5 );
    1008:	c5 9a       	sbi	0x18, 5	; 24
      break;
    100a:	08 95       	ret

    case 5:
      SET( PORTB, 6 );
    100c:	c6 9a       	sbi	0x18, 6	; 24
      break;
    100e:	08 95       	ret

    case 6:
      SET( PORTB, 7 );
    1010:	c7 9a       	sbi	0x18, 7	; 24
      break;
    1012:	08 95       	ret

    case 7:
      SET( PORTD, 4 );
    1014:	94 9a       	sbi	0x12, 4	; 18
      break;
    1016:	08 95       	ret

    case 8:
      SET( PORTD, 5 );
    1018:	95 9a       	sbi	0x12, 5	; 18
      break;
    101a:	08 95       	ret

    case 9:
      SET( PORTG, 2 );
    101c:	80 91 65 00 	lds	r24, 0x0065
    1020:	84 60       	ori	r24, 0x04	; 4
    1022:	80 93 65 00 	sts	0x0065, r24
      break;
    1026:	08 95       	ret

    case 10: 
      SET( PORTC, 7 );
    1028:	af 9a       	sbi	0x15, 7	; 21
      break;
    102a:	08 95       	ret

    case 11:
      SET( PORTC, 6 );
    102c:	ae 9a       	sbi	0x15, 6	; 21
      break;
    102e:	08 95       	ret

    case 12:
      SET( PORTC, 5 );
    1030:	ad 9a       	sbi	0x15, 5	; 21
      break;
    1032:	08 95       	ret

    case 13:
      SET( PORTC, 4 );
    1034:	ac 9a       	sbi	0x15, 4	; 21
      break;
    1036:	08 95       	ret

    case 14:
      SET( PORTC, 3 );
    1038:	ab 9a       	sbi	0x15, 3	; 21
      break;
    103a:	08 95       	ret

    case 15:
      SET( PORTC, 2 );
    103c:	aa 9a       	sbi	0x15, 2	; 21
      break;
    103e:	08 95       	ret

    case 16:
      SET( PORTC, 1 );
    1040:	a9 9a       	sbi	0x15, 1	; 21
    1042:	08 95       	ret

00001044 <switch_off>:
  }
}

void switch_off( uint8_t switch_num )
{
  switch ( switch_num )
    1044:	88 30       	cpi	r24, 0x08	; 8
    1046:	59 f1       	breq	.+86     	; 0x109e <switch_off+0x5a>
    1048:	68 f4       	brcc	.+26     	; 0x1064 <switch_off+0x20>
    104a:	84 30       	cpi	r24, 0x04	; 4
    104c:	01 f1       	breq	.+64     	; 0x108e <switch_off+0x4a>
    104e:	30 f4       	brcc	.+12     	; 0x105c <switch_off+0x18>
    1050:	82 30       	cpi	r24, 0x02	; 2
    1052:	c9 f0       	breq	.+50     	; 0x1086 <switch_off+0x42>
    1054:	d0 f4       	brcc	.+52     	; 0x108a <switch_off+0x46>
    1056:	81 30       	cpi	r24, 0x01	; 1
    1058:	b9 f5       	brne	.+110    	; 0x10c8 <switch_off+0x84>
    105a:	13 c0       	rjmp	.+38     	; 0x1082 <switch_off+0x3e>
    105c:	86 30       	cpi	r24, 0x06	; 6
    105e:	d9 f0       	breq	.+54     	; 0x1096 <switch_off+0x52>
    1060:	e0 f4       	brcc	.+56     	; 0x109a <switch_off+0x56>
    1062:	17 c0       	rjmp	.+46     	; 0x1092 <switch_off+0x4e>
    1064:	8c 30       	cpi	r24, 0x0C	; 12
    1066:	39 f1       	breq	.+78     	; 0x10b6 <switch_off+0x72>
    1068:	20 f4       	brcc	.+8      	; 0x1072 <switch_off+0x2e>
    106a:	8a 30       	cpi	r24, 0x0A	; 10
    106c:	01 f1       	breq	.+64     	; 0x10ae <switch_off+0x6a>
    106e:	08 f5       	brcc	.+66     	; 0x10b2 <switch_off+0x6e>
    1070:	18 c0       	rjmp	.+48     	; 0x10a2 <switch_off+0x5e>
    1072:	8e 30       	cpi	r24, 0x0E	; 14
    1074:	21 f1       	breq	.+72     	; 0x10be <switch_off+0x7a>
    1076:	08 f1       	brcs	.+66     	; 0x10ba <switch_off+0x76>
    1078:	8f 30       	cpi	r24, 0x0F	; 15
    107a:	19 f1       	breq	.+70     	; 0x10c2 <switch_off+0x7e>
    107c:	80 31       	cpi	r24, 0x10	; 16
    107e:	21 f5       	brne	.+72     	; 0x10c8 <switch_off+0x84>
    1080:	22 c0       	rjmp	.+68     	; 0x10c6 <switch_off+0x82>
  {
    case 1:
      CLR( PORTA, 0 );
    1082:	d8 98       	cbi	0x1b, 0	; 27
      break;
    1084:	08 95       	ret

    case 2:
      CLR( PORTA, 1 );
    1086:	d9 98       	cbi	0x1b, 1	; 27
      break;
    1088:	08 95       	ret

    case 3:
      CLR( PORTA, 2 );
    108a:	da 98       	cbi	0x1b, 2	; 27
      break;
    108c:	08 95       	ret

    case 4:
      CLR( PORTB, 5 );
    108e:	c5 98       	cbi	0x18, 5	; 24
      break;
    1090:	08 95       	ret

    case 5:
      CLR( PORTB, 6 );
    1092:	c6 98       	cbi	0x18, 6	; 24
      break;
    1094:	08 95       	ret

    case 6:
      CLR( PORTB, 7 );
    1096:	c7 98       	cbi	0x18, 7	; 24
      break;
    1098:	08 95       	ret

    case 7:
      CLR( PORTD, 4 );
    109a:	94 98       	cbi	0x12, 4	; 18
      break;
    109c:	08 95       	ret

    case 8:
      CLR( PORTD, 5 );
    109e:	95 98       	cbi	0x12, 5	; 18
      break;
    10a0:	08 95       	ret

    case 9:
      CLR( PORTG, 2 );
    10a2:	80 91 65 00 	lds	r24, 0x0065
    10a6:	8b 7f       	andi	r24, 0xFB	; 251
    10a8:	80 93 65 00 	sts	0x0065, r24
      break;
    10ac:	08 95       	ret

    case 10: 
      CLR( PORTC, 7 );
    10ae:	af 98       	cbi	0x15, 7	; 21
      break;
    10b0:	08 95       	ret

    case 11:
      CLR( PORTC, 6 );
    10b2:	ae 98       	cbi	0x15, 6	; 21
      break;
    10b4:	08 95       	ret

    case 12:
      CLR( PORTC, 5 );
    10b6:	ad 98       	cbi	0x15, 5	; 21
      break;
    10b8:	08 95       	ret

    case 13:
      CLR( PORTC, 4 );
    10ba:	ac 98       	cbi	0x15, 4	; 21
      break;
    10bc:	08 95       	ret

    case 14:
      CLR( PORTC, 3 );
    10be:	ab 98       	cbi	0x15, 3	; 21
      break;
    10c0:	08 95       	ret

    case 15:
      CLR( PORTC, 2 );
    10c2:	aa 98       	cbi	0x15, 2	; 21
      break;
    10c4:	08 95       	ret

    case 16:
      CLR( PORTC, 1 );
    10c6:	a9 98       	cbi	0x15, 1	; 21
    10c8:	08 95       	ret

000010ca <average_samples>:
    return  average_samples( component->I_samples );
  }
}

uint8_t average_samples( uint8_t samples[NUM_SAMPLES] )
{
    10ca:	fc 01       	movw	r30, r24
  uint8_t average = 0;
  uint16_t sum = 0;

  for(uint8_t avg_index = 0; avg_index < NUM_SAMPLES; avg_index++)
    sum += samples[avg_index];
    10cc:	21 81       	ldd	r18, Z+1	; 0x01
    10ce:	80 81       	ld	r24, Z
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	82 0f       	add	r24, r18
    10d4:	91 1d       	adc	r25, r1
    10d6:	22 81       	ldd	r18, Z+2	; 0x02
    10d8:	82 0f       	add	r24, r18
    10da:	91 1d       	adc	r25, r1

  average = sum / NUM_SAMPLES;
    10dc:	63 e0       	ldi	r22, 0x03	; 3
    10de:	70 e0       	ldi	r23, 0x00	; 0
    10e0:	0e 94 8d 12 	call	0x251a	; 0x251a <__udivmodhi4>
    10e4:	86 2f       	mov	r24, r22

  return average;
}
    10e6:	08 95       	ret

000010e8 <SVIT_check_I_critical>:
}

uint8_t SVIT_check_I_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    10e8:	9a e1       	ldi	r25, 0x1A	; 26
    10ea:	89 9f       	mul	r24, r25
    10ec:	f0 01       	movw	r30, r0
    10ee:	11 24       	eor	r1, r1
    10f0:	ec 5b       	subi	r30, 0xBC	; 188
    10f2:	fb 4f       	sbci	r31, 0xFB	; 251
  if ( component->I_critical_value != 0 )
    10f4:	83 89       	ldd	r24, Z+19	; 0x13
    10f6:	88 23       	and	r24, r24
    10f8:	11 f0       	breq	.+4      	; 0x10fe <SVIT_check_I_critical+0x16>
  {
    temp= component->I_critical_value;
    component->I_critical_value = 0;
    10fa:	13 8a       	std	Z+19, r1	; 0x13
    10fc:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->I_samples );
    10fe:	cf 01       	movw	r24, r30
    1100:	0f 96       	adiw	r24, 0x0f	; 15
    1102:	0c 94 65 08 	jmp	0x10ca	; 0x10ca <average_samples>

00001106 <SVIT_check_V_critical>:
}

uint8_t SVIT_check_V_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1106:	9a e1       	ldi	r25, 0x1A	; 26
    1108:	89 9f       	mul	r24, r25
    110a:	f0 01       	movw	r30, r0
    110c:	11 24       	eor	r1, r1
    110e:	ec 5b       	subi	r30, 0xBC	; 188
    1110:	fb 4f       	sbci	r31, 0xFB	; 251
  if ( component->V_critical_value != 0 )
    1112:	83 85       	ldd	r24, Z+11	; 0x0b
    1114:	88 23       	and	r24, r24
    1116:	11 f0       	breq	.+4      	; 0x111c <SVIT_check_V_critical+0x16>
  {
    temp= component->V_critical_value;
    component->V_critical_value = 0;
    1118:	13 86       	std	Z+11, r1	; 0x0b
    111a:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->V_samples );
    111c:	cf 01       	movw	r24, r30
    111e:	07 96       	adiw	r24, 0x07	; 7
    1120:	0c 94 65 08 	jmp	0x10ca	; 0x10ca <average_samples>

00001124 <perform_ADC>:
}

void perform_ADC( uint8_t mux_num )
{
  // set Vref to AVCC and set the ADC channel to the correct pin ( mux_num )
  ADMUX = (1 << ADLAR) | ( 1 << REFS0 );
    1124:	90 e6       	ldi	r25, 0x60	; 96
    1126:	97 b9       	out	0x07, r25	; 7
  ADMUX &= ~0x3;
    1128:	97 b1       	in	r25, 0x07	; 7
    112a:	9c 7f       	andi	r25, 0xFC	; 252
    112c:	97 b9       	out	0x07, r25	; 7
  ADMUX |= mux_num;
    112e:	97 b1       	in	r25, 0x07	; 7
    1130:	98 2b       	or	r25, r24
    1132:	97 b9       	out	0x07, r25	; 7

  // signal ADC to start a new conversion
  ADCSRA |= ( 1 << ADSC );
    1134:	36 9a       	sbi	0x06, 6	; 6
    1136:	08 95       	ret

00001138 <read_VIT>:

  // when the conversion finishes, the result is stored in ADCL and ADCH
}

void read_VIT( void )
{
    1138:	1f 93       	push	r17
    113a:	cf 93       	push	r28
    113c:	df 93       	push	r29
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type )
    113e:	80 91 18 0a 	lds	r24, 0x0A18
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1142:	c0 91 43 04 	lds	r28, 0x0443
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type )
    1146:	82 30       	cpi	r24, 0x02	; 2
    1148:	09 f4       	brne	.+2      	; 0x114c <read_VIT+0x14>
    114a:	61 c0       	rjmp	.+194    	; 0x120e <read_VIT+0xd6>
    114c:	20 f4       	brcc	.+8      	; 0x1156 <read_VIT+0x1e>
    114e:	81 30       	cpi	r24, 0x01	; 1
    1150:	09 f0       	breq	.+2      	; 0x1154 <read_VIT+0x1c>
    1152:	f8 c0       	rjmp	.+496    	; 0x1344 <read_VIT+0x20c>
    1154:	07 c0       	rjmp	.+14     	; 0x1164 <read_VIT+0x2c>
    1156:	83 30       	cpi	r24, 0x03	; 3
    1158:	09 f4       	brne	.+2      	; 0x115c <read_VIT+0x24>
    115a:	b8 c0       	rjmp	.+368    	; 0x12cc <read_VIT+0x194>
    115c:	84 30       	cpi	r24, 0x04	; 4
    115e:	09 f0       	breq	.+2      	; 0x1162 <read_VIT+0x2a>
    1160:	f1 c0       	rjmp	.+482    	; 0x1344 <read_VIT+0x20c>
    1162:	dc c0       	rjmp	.+440    	; 0x131c <read_VIT+0x1e4>
  {
		case ADC_VOLTAGE:
			component = &svit[adc_component];
    1164:	8a e1       	ldi	r24, 0x1A	; 26
    1166:	c8 9f       	mul	r28, r24
    1168:	e0 01       	movw	r28, r0
    116a:	11 24       	eor	r1, r1
    116c:	cc 5b       	subi	r28, 0xBC	; 188
    116e:	db 4f       	sbci	r29, 0xFB	; 251
			sample_index = component->V_sample_index;
			component->V_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    1170:	2a 85       	ldd	r18, Y+10	; 0x0a
    1172:	30 e0       	ldi	r19, 0x00	; 0
    1174:	c9 01       	movw	r24, r18
    1176:	01 96       	adiw	r24, 0x01	; 1
    1178:	63 e0       	ldi	r22, 0x03	; 3
    117a:	70 e0       	ldi	r23, 0x00	; 0
    117c:	0e 94 a1 12 	call	0x2542	; 0x2542 <__divmodhi4>
    1180:	8a 87       	std	Y+10, r24	; 0x0a

			// SoC: If component is a battery, store in different global variable
			if (component->name == BATTERY_1) {
    1182:	98 81       	ld	r25, Y
    1184:	94 31       	cpi	r25, 0x14	; 20
    1186:	89 f4       	brne	.+34     	; 0x11aa <read_VIT+0x72>
				batt1_voltage = ADC_high;
    1188:	80 91 29 0a 	lds	r24, 0x0A29
    118c:	80 93 33 0a 	sts	0x0A33, r24
				batt1_voltageLow = ADC_low;
    1190:	80 91 62 0e 	lds	r24, 0x0E62
    1194:	80 93 47 0e 	sts	0x0E47, r24
				high = ADC_high;
    1198:	80 91 29 0a 	lds	r24, 0x0A29
    119c:	80 93 24 0a 	sts	0x0A24, r24
				low = ADC_low;
    11a0:	80 91 62 0e 	lds	r24, 0x0E62
    11a4:	80 93 32 0a 	sts	0x0A32, r24
    11a8:	06 c0       	rjmp	.+12     	; 0x11b6 <read_VIT+0x7e>
				//debug = adc_component;
			}
			else if (component->name == BATTERY_2) {
    11aa:	95 31       	cpi	r25, 0x15	; 21
    11ac:	21 f4       	brne	.+8      	; 0x11b6 <read_VIT+0x7e>
				batt2_voltage = ADC_high;
    11ae:	80 91 29 0a 	lds	r24, 0x0A29
    11b2:	80 93 44 0c 	sts	0x0C44, r24
			}
			component->V_samples[sample_index] = ADC_high;
    11b6:	80 91 29 0a 	lds	r24, 0x0A29
    11ba:	fe 01       	movw	r30, r28
    11bc:	e2 0f       	add	r30, r18
    11be:	f3 1f       	adc	r31, r19
    11c0:	87 83       	std	Z+7, r24	; 0x07
      
	  	if ( ( ADC_high > component->V_upper_limit ) && ( component->force_on != 1 ) )
    11c2:	20 91 29 0a 	lds	r18, 0x0A29
    11c6:	8e 81       	ldd	r24, Y+6	; 0x06
    11c8:	82 17       	cp	r24, r18
    11ca:	d8 f4       	brcc	.+54     	; 0x1202 <read_VIT+0xca>
    11cc:	8b 81       	ldd	r24, Y+3	; 0x03
    11ce:	81 30       	cpi	r24, 0x01	; 1
    11d0:	c1 f0       	breq	.+48     	; 0x1202 <read_VIT+0xca>
			{
				if ( component->switch_num != SW_NULL )
    11d2:	89 81       	ldd	r24, Y+1	; 0x01
    11d4:	8f 3f       	cpi	r24, 0xFF	; 255
    11d6:	19 f0       	breq	.+6      	; 0x11de <read_VIT+0xa6>
				{
			  	switch_off( component->switch_num );
    11d8:	0e 94 22 08 	call	0x1044	; 0x1044 <switch_off>
    11dc:	0e c0       	rjmp	.+28     	; 0x11fa <read_VIT+0xc2>
				}
		  	else
				{
			  	switch ( component->name )
    11de:	92 31       	cpi	r25, 0x12	; 18
    11e0:	39 f0       	breq	.+14     	; 0x11f0 <read_VIT+0xb8>
    11e2:	93 31       	cpi	r25, 0x13	; 19
    11e4:	39 f0       	breq	.+14     	; 0x11f4 <read_VIT+0xbc>
    11e6:	91 31       	cpi	r25, 0x11	; 17
    11e8:	41 f4       	brne	.+16     	; 0x11fa <read_VIT+0xc2>
    11ea:	0e 94 4c 07 	call	0xe98	; 0xe98 <torquer_off.part.0>
    11ee:	05 c0       	rjmp	.+10     	; 0x11fa <read_VIT+0xc2>
			  	{
						case TORQUER_1:
				  		torquer_off( TORQUER_1 );
				  		break;
					  case TORQUER_2:
	  			  	torquer_off( TORQUER_2 );
    11f0:	82 e1       	ldi	r24, 0x12	; 18
    11f2:	01 c0       	rjmp	.+2      	; 0x11f6 <read_VIT+0xbe>
		  		  	break;
			  		case TORQUER_3:
				    	torquer_off( TORQUER_3 );
    11f4:	83 e1       	ldi	r24, 0x13	; 19
    11f6:	0e 94 a8 07 	call	0xf50	; 0xf50 <torquer_off>
				    	break;
					  default:
				  	  break;
			    }
  			}
        component->switch_state = SW_OFF;
    11fa:	1a 82       	std	Y+2, r1	; 0x02
        component->V_critical_value = ADC_high;
    11fc:	80 91 29 0a 	lds	r24, 0x0A29
    1200:	8b 87       	std	Y+11, r24	; 0x0b
		  }
		  adc_sensor_type = ADC_CURRENT;
    1202:	82 e0       	ldi	r24, 0x02	; 2
    1204:	80 93 18 0a 	sts	0x0A18, r24

      //perform next ADC conversion
      mux_num = component->I_mux_num;
    1208:	1c 85       	ldd	r17, Y+12	; 0x0c
      mux_sel = component->I_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    120a:	6d 85       	ldd	r22, Y+13	; 0x0d
    120c:	92 c0       	rjmp	.+292    	; 0x1332 <read_VIT+0x1fa>
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    120e:	9a e1       	ldi	r25, 0x1A	; 26
    1210:	c9 9f       	mul	r28, r25
    1212:	e0 01       	movw	r28, r0
    1214:	11 24       	eor	r1, r1
    1216:	cc 5b       	subi	r28, 0xBC	; 188
    1218:	db 4f       	sbci	r29, 0xFB	; 251
	  	sample_index = component->I_sample_index;
	  	component->I_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    121a:	2a 89       	ldd	r18, Y+18	; 0x12
    121c:	30 e0       	ldi	r19, 0x00	; 0
    121e:	c9 01       	movw	r24, r18
    1220:	01 96       	adiw	r24, 0x01	; 1
    1222:	63 e0       	ldi	r22, 0x03	; 3
    1224:	70 e0       	ldi	r23, 0x00	; 0
    1226:	0e 94 a1 12 	call	0x2542	; 0x2542 <__divmodhi4>
    122a:	8a 8b       	std	Y+18, r24	; 0x12
		// SoC hardcode backward current
//		if (adc_component == BATTERY_1_b) {
			//debug = 5;
		//}
		
		if(component->name == SOLAR_1){
    122c:	98 81       	ld	r25, Y
    122e:	97 31       	cpi	r25, 0x17	; 23
    1230:	39 f4       	brne	.+14     	; 0x1240 <read_VIT+0x108>
			solar1_current = ADC_high;
    1232:	80 91 29 0a 	lds	r24, 0x0A29
    1236:	80 93 34 0a 	sts	0x0A34, r24
			hasCheckedCurr = 1;
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	80 93 1d 0a 	sts	0x0A1D, r24
		}

	  	component->I_samples[sample_index] = ADC_high;
    1240:	80 91 29 0a 	lds	r24, 0x0A29
    1244:	fe 01       	movw	r30, r28
    1246:	e2 0f       	add	r30, r18
    1248:	f3 1f       	adc	r31, r19
    124a:	87 87       	std	Z+15, r24	; 0x0f
    
	    if ( ( ADC_high > component->I_upper_limit ) && ( component->force_on != 1 ) )
    124c:	20 91 29 0a 	lds	r18, 0x0A29
    1250:	8e 85       	ldd	r24, Y+14	; 0x0e
    1252:	82 17       	cp	r24, r18
    1254:	d8 f4       	brcc	.+54     	; 0x128c <read_VIT+0x154>
    1256:	8b 81       	ldd	r24, Y+3	; 0x03
    1258:	81 30       	cpi	r24, 0x01	; 1
    125a:	c1 f0       	breq	.+48     	; 0x128c <read_VIT+0x154>
	  	{
	  		if ( component->switch_num != SW_NULL )
    125c:	89 81       	ldd	r24, Y+1	; 0x01
    125e:	8f 3f       	cpi	r24, 0xFF	; 255
    1260:	19 f0       	breq	.+6      	; 0x1268 <read_VIT+0x130>
	  		{
	  		  switch_off( component->switch_num );
    1262:	0e 94 22 08 	call	0x1044	; 0x1044 <switch_off>
    1266:	0e c0       	rjmp	.+28     	; 0x1284 <read_VIT+0x14c>
	  		}
	  		else
	  		{
	  		  switch ( component->name )
    1268:	92 31       	cpi	r25, 0x12	; 18
    126a:	39 f0       	breq	.+14     	; 0x127a <read_VIT+0x142>
    126c:	93 31       	cpi	r25, 0x13	; 19
    126e:	39 f0       	breq	.+14     	; 0x127e <read_VIT+0x146>
    1270:	91 31       	cpi	r25, 0x11	; 17
    1272:	41 f4       	brne	.+16     	; 0x1284 <read_VIT+0x14c>
    1274:	0e 94 4c 07 	call	0xe98	; 0xe98 <torquer_off.part.0>
    1278:	05 c0       	rjmp	.+10     	; 0x1284 <read_VIT+0x14c>
		  	  {
  		  		case TORQUER_1:
	  	  		  torquer_off( TORQUER_1 );
		    		  break;
			    	case TORQUER_2:
			  	    torquer_off( TORQUER_2 );
    127a:	82 e1       	ldi	r24, 0x12	; 18
    127c:	01 c0       	rjmp	.+2      	; 0x1280 <read_VIT+0x148>
			  	    break;
  		  		case TORQUER_3:
	  	  		  torquer_off( TORQUER_3 );
    127e:	83 e1       	ldi	r24, 0x13	; 19
    1280:	0e 94 a8 07 	call	0xf50	; 0xf50 <torquer_off>
		    		  break;
			     	default:
				      break;
			    }
			  }
			  component->switch_state = 0;
    1284:	1a 82       	std	Y+2, r1	; 0x02
        component->I_critical_value = ADC_high;
    1286:	80 91 29 0a 	lds	r24, 0x0A29
    128a:	8b 8b       	std	Y+19, r24	; 0x13
		  }
      //perform next ADC conversion
      mux_num = component->T_mux_num;
    128c:	1c 89       	ldd	r17, Y+20	; 0x14
      if( mux_num != MUX_NULL )
    128e:	13 30       	cpi	r17, 0x03	; 3
    1290:	29 f0       	breq	.+10     	; 0x129c <read_VIT+0x164>
      {
		    adc_sensor_type = ADC_TEMPERATURE;
    1292:	83 e0       	ldi	r24, 0x03	; 3
    1294:	80 93 18 0a 	sts	0x0A18, r24
        mux_sel = component->T_mux_sel;        
    1298:	6d 89       	ldd	r22, Y+21	; 0x15
    129a:	4b c0       	rjmp	.+150    	; 0x1332 <read_VIT+0x1fa>
		  }
      else
      {
        adc_sensor_type = ADC_VOLTAGE;
    129c:	81 e0       	ldi	r24, 0x01	; 1
    129e:	80 93 18 0a 	sts	0x0A18, r24
		    adc_component = ( adc_component + 1 ) % SVIT_SZ;
    12a2:	80 91 43 04 	lds	r24, 0x0443
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	01 96       	adiw	r24, 0x01	; 1
    12aa:	64 e2       	ldi	r22, 0x24	; 36
    12ac:	70 e0       	ldi	r23, 0x00	; 0
    12ae:	0e 94 a1 12 	call	0x2542	; 0x2542 <__divmodhi4>
    12b2:	80 93 43 04 	sts	0x0443, r24
        component = &svit[adc_component];
    12b6:	2a e1       	ldi	r18, 0x1A	; 26
    12b8:	28 9f       	mul	r18, r24
    12ba:	f0 01       	movw	r30, r0
    12bc:	29 9f       	mul	r18, r25
    12be:	f0 0d       	add	r31, r0
    12c0:	11 24       	eor	r1, r1
    12c2:	ec 5b       	subi	r30, 0xBC	; 188
    12c4:	fb 4f       	sbci	r31, 0xFB	; 251
        mux_num = component->V_mux_num;
    12c6:	14 81       	ldd	r17, Z+4	; 0x04
        mux_sel = component->V_mux_sel;
    12c8:	65 81       	ldd	r22, Z+5	; 0x05
    12ca:	33 c0       	rjmp	.+102    	; 0x1332 <read_VIT+0x1fa>
      break;
    //-------------------------------------------------------------------
    // Measure temperature
    //-------------------------------------------------------------------
	  case ADC_TEMPERATURE:
		  component = &svit[adc_component];
    12cc:	d0 e0       	ldi	r29, 0x00	; 0
    12ce:	4a e1       	ldi	r20, 0x1A	; 26
    12d0:	4c 9f       	mul	r20, r28
    12d2:	f0 01       	movw	r30, r0
    12d4:	4d 9f       	mul	r20, r29
    12d6:	f0 0d       	add	r31, r0
    12d8:	11 24       	eor	r1, r1
    12da:	ec 5b       	subi	r30, 0xBC	; 188
    12dc:	fb 4f       	sbci	r31, 0xFB	; 251
		  sample_index = component->T_sample_index;
		  component->T_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    12de:	21 8d       	ldd	r18, Z+25	; 0x19
    12e0:	30 e0       	ldi	r19, 0x00	; 0
    12e2:	c9 01       	movw	r24, r18
    12e4:	01 96       	adiw	r24, 0x01	; 1
    12e6:	63 e0       	ldi	r22, 0x03	; 3
    12e8:	70 e0       	ldi	r23, 0x00	; 0
    12ea:	0e 94 a1 12 	call	0x2542	; 0x2542 <__divmodhi4>
    12ee:	81 8f       	std	Z+25, r24	; 0x19
		  component->T_samples[sample_index] = ADC_high;
    12f0:	80 91 29 0a 	lds	r24, 0x0A29
    12f4:	e2 0f       	add	r30, r18
    12f6:	f3 1f       	adc	r31, r19
    12f8:	86 8b       	std	Z+22, r24	; 0x16
      //perform next ADC conversion
  	  adc_sensor_type = ADC_VOLTAGE;
    12fa:	81 e0       	ldi	r24, 0x01	; 1
    12fc:	80 93 18 0a 	sts	0x0A18, r24
		  adc_component = ( adc_component + 1 ) % SVIT_SZ;
    1300:	ce 01       	movw	r24, r28
    1302:	01 96       	adiw	r24, 0x01	; 1
    1304:	64 e2       	ldi	r22, 0x24	; 36
    1306:	70 e0       	ldi	r23, 0x00	; 0
    1308:	0e 94 a1 12 	call	0x2542	; 0x2542 <__divmodhi4>
    130c:	80 93 43 04 	sts	0x0443, r24
      component = &svit[adc_component];
    1310:	48 9f       	mul	r20, r24
    1312:	f0 01       	movw	r30, r0
    1314:	49 9f       	mul	r20, r25
    1316:	f0 0d       	add	r31, r0
    1318:	11 24       	eor	r1, r1
    131a:	1d c0       	rjmp	.+58     	; 0x1356 <read_VIT+0x21e>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
		  break;
    case ADC_INIT:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    131c:	81 e0       	ldi	r24, 0x01	; 1
    131e:	80 93 18 0a 	sts	0x0A18, r24
      component = &svit[adc_component];
    1322:	9a e1       	ldi	r25, 0x1A	; 26
    1324:	c9 9f       	mul	r28, r25
    1326:	e0 01       	movw	r28, r0
    1328:	11 24       	eor	r1, r1
    132a:	cc 5b       	subi	r28, 0xBC	; 188
    132c:	db 4f       	sbci	r29, 0xFB	; 251
      mux_num = component->V_mux_num;
    132e:	1c 81       	ldd	r17, Y+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    1330:	6d 81       	ldd	r22, Y+5	; 0x05
    1332:	81 2f       	mov	r24, r17
    1334:	0e 94 53 07 	call	0xea6	; 0xea6 <set_mux_sel>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1338:	83 e3       	ldi	r24, 0x33	; 51
    133a:	93 e7       	ldi	r25, 0x73	; 115
    133c:	01 97       	sbiw	r24, 0x01	; 1
    133e:	f1 f7       	brne	.-4      	; 0x133c <read_VIT+0x204>
      //_delay_us(1);
	  //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
    1340:	81 2f       	mov	r24, r17
    1342:	15 c0       	rjmp	.+42     	; 0x136e <read_VIT+0x236>
      break;
	  default:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    1344:	81 e0       	ldi	r24, 0x01	; 1
    1346:	80 93 18 0a 	sts	0x0A18, r24
      component = &svit[adc_component];
    134a:	e0 91 43 04 	lds	r30, 0x0443
    134e:	9a e1       	ldi	r25, 0x1A	; 26
    1350:	e9 9f       	mul	r30, r25
    1352:	f0 01       	movw	r30, r0
    1354:	11 24       	eor	r1, r1
    1356:	ec 5b       	subi	r30, 0xBC	; 188
    1358:	fb 4f       	sbci	r31, 0xFB	; 251
      mux_num = component->V_mux_num;
    135a:	c4 81       	ldd	r28, Z+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    135c:	65 81       	ldd	r22, Z+5	; 0x05
    135e:	8c 2f       	mov	r24, r28
    1360:	0e 94 53 07 	call	0xea6	; 0xea6 <set_mux_sel>
    1364:	83 e3       	ldi	r24, 0x33	; 51
    1366:	93 e7       	ldi	r25, 0x73	; 115
    1368:	01 97       	sbiw	r24, 0x01	; 1
    136a:	f1 f7       	brne	.-4      	; 0x1368 <read_VIT+0x230>
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    136c:	8c 2f       	mov	r24, r28
      break;
  } 
}
    136e:	df 91       	pop	r29
    1370:	cf 91       	pop	r28
    1372:	1f 91       	pop	r17
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    1374:	0c 94 92 08 	jmp	0x1124	; 0x1124 <perform_ADC>

00001378 <uart_init>:
{
  #if F_CPU < 2000000UL && defined(U2X)
  UCSR0A = UCSR1A = _BV(U2X); /* improve baud rate error by using 2x clk */
  UBRR0L = UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  #else
  UBRR0L = UBRR1L = 7;//(F_CPU / (16UL * UART_BAUD)) - 1;//7;
    1378:	87 e0       	ldi	r24, 0x07	; 7
    137a:	80 93 99 00 	sts	0x0099, r24
    137e:	89 b9       	out	0x09, r24	; 9
  #endif
  UCSR0B = _BV(TXEN0) | _BV(RXEN0); /* tx/rx enable */
    1380:	88 e1       	ldi	r24, 0x18	; 24
    1382:	8a b9       	out	0x0a, r24	; 10
  UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
    1384:	ea e9       	ldi	r30, 0x9A	; 154
    1386:	f0 e0       	ldi	r31, 0x00	; 0
    1388:	80 83       	st	Z, r24


  UCSR1B = UCSR1B | _BV(TXCIE1);
    138a:	80 81       	ld	r24, Z
    138c:	80 64       	ori	r24, 0x40	; 64
    138e:	80 83       	st	Z, r24
  UCSR1B = UCSR1B | _BV(RXCIE1);
    1390:	80 81       	ld	r24, Z
    1392:	80 68       	ori	r24, 0x80	; 128
    1394:	80 83       	st	Z, r24
  UCSR0B = UCSR0B | _BV(TXCIE0);
    1396:	56 9a       	sbi	0x0a, 6	; 10
  UCSR0B = UCSR0B | _BV(RXCIE0);
    1398:	57 9a       	sbi	0x0a, 7	; 10
    139a:	08 95       	ret

0000139c <append_crc16>:
 * Adds a byte of data into the crc calculation using
 * the table above.
 */
void append_crc16(uint8 byte, uint16ptr crc)
{
	*crc = ((*crc) >> 8) ^ ccitt_crc16[((*crc) ^ (byte)) & 0xff];
    139c:	fb 01       	movw	r30, r22
    139e:	20 81       	ld	r18, Z
    13a0:	31 81       	ldd	r19, Z+1	; 0x01
    13a2:	f9 01       	movw	r30, r18
    13a4:	e8 27       	eor	r30, r24
    13a6:	ff 27       	eor	r31, r31
    13a8:	ee 0f       	add	r30, r30
    13aa:	ff 1f       	adc	r31, r31
    13ac:	ea 5f       	subi	r30, 0xFA	; 250
    13ae:	fe 4f       	sbci	r31, 0xFE	; 254
    13b0:	23 2f       	mov	r18, r19
    13b2:	33 27       	eor	r19, r19
    13b4:	80 81       	ld	r24, Z
    13b6:	91 81       	ldd	r25, Z+1	; 0x01
    13b8:	82 27       	eor	r24, r18
    13ba:	93 27       	eor	r25, r19
    13bc:	fb 01       	movw	r30, r22
    13be:	91 83       	std	Z+1, r25	; 0x01
    13c0:	80 83       	st	Z, r24
    13c2:	08 95       	ret

000013c4 <vcpptr_init>:
// Parameters: 
// vcp_ptrbuffer	*buff -					Pointer to the vcp buffer structure
// uint8			*message_buffer -		Pointer to the allocated data buffer
// uint16			message_buffer_size -	Size of the allocated data buffer
void vcpptr_init(vcp_ptrbuffer *buff, uint8 *message_buffer, uint16 message_buffer_size)
{
    13c4:	fc 01       	movw	r30, r24
	buff->address =	0;
    13c6:	10 82       	st	Z, r1
	buff->message =	message_buffer;
    13c8:	72 83       	std	Z+2, r23	; 0x02
    13ca:	61 83       	std	Z+1, r22	; 0x01
	buff->size =	message_buffer_size;
    13cc:	56 83       	std	Z+6, r21	; 0x06
    13ce:	45 83       	std	Z+5, r20	; 0x05
	buff->index	=	0;
    13d0:	10 86       	std	Z+8, r1	; 0x08
    13d2:	17 82       	std	Z+7, r1	; 0x07
	buff->crc =		CRC16_INIT_VALUE;
    13d4:	14 82       	std	Z+4, r1	; 0x04
    13d6:	13 82       	std	Z+3, r1	; 0x03
	buff->status =	VCP_IDLE;
    13d8:	11 86       	std	Z+9, r1	; 0x09
    13da:	08 95       	ret

000013dc <Create_VCP_frame>:
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
    13dc:	4f 92       	push	r4
    13de:	5f 92       	push	r5
    13e0:	6f 92       	push	r6
    13e2:	7f 92       	push	r7
    13e4:	8f 92       	push	r8
    13e6:	9f 92       	push	r9
    13e8:	af 92       	push	r10
    13ea:	bf 92       	push	r11
    13ec:	cf 92       	push	r12
    13ee:	df 92       	push	r13
    13f0:	ef 92       	push	r14
    13f2:	ff 92       	push	r15
    13f4:	0f 93       	push	r16
    13f6:	1f 93       	push	r17
    13f8:	cf 93       	push	r28
    13fa:	df 93       	push	r29
    13fc:	00 d0       	rcall	.+0      	; 0x13fe <Create_VCP_frame+0x22>
    13fe:	1f 92       	push	r1
    1400:	cd b7       	in	r28, 0x3d	; 61
    1402:	de b7       	in	r29, 0x3e	; 62
    1404:	6c 01       	movw	r12, r24
    1406:	5b 01       	movw	r10, r22
    1408:	79 01       	movw	r14, r18
	uint16_t crc = CRC16_INIT_VALUE;
    140a:	1a 82       	std	Y+2, r1	; 0x02
    140c:	19 82       	std	Y+1, r1	; 0x01
	uint16_t src_index = 0;
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
    140e:	00 97       	sbiw	r24, 0x00	; 0
    1410:	09 f4       	brne	.+2      	; 0x1414 <Create_VCP_frame+0x38>
    1412:	58 c0       	rjmp	.+176    	; 0x14c4 <Create_VCP_frame+0xe8>
    1414:	21 15       	cp	r18, r1
    1416:	31 05       	cpc	r19, r1
    1418:	09 f4       	brne	.+2      	; 0x141c <Create_VCP_frame+0x40>
    141a:	54 c0       	rjmp	.+168    	; 0x14c4 <Create_VCP_frame+0xe8>
		return VCP_NULL_ERR;

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
    141c:	4c 30       	cpi	r20, 0x0C	; 12
    141e:	18 f0       	brcs	.+6      	; 0x1426 <Create_VCP_frame+0x4a>
    1420:	48 33       	cpi	r20, 0x38	; 56
    1422:	09 f0       	breq	.+2      	; 0x1426 <Create_VCP_frame+0x4a>
    1424:	51 c0       	rjmp	.+162    	; 0x14c8 <Create_VCP_frame+0xec>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    1426:	44 24       	eor	r4, r4
    1428:	43 94       	inc	r4
    142a:	51 2c       	mov	r5, r1
    142c:	4c 0e       	add	r4, r28
    142e:	5d 1e       	adc	r5, r29
    1430:	b2 01       	movw	r22, r4
    1432:	84 2f       	mov	r24, r20
    1434:	4b 83       	std	Y+3, r20	; 0x03
    1436:	0e 94 ce 09 	call	0x139c	; 0x139c <append_crc16>
// uint8ptr		dst -		Pointer to the destination buffer
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
    143a:	37 01       	movw	r6, r14
    143c:	60 0e       	add	r6, r16
    143e:	71 1e       	adc	r7, r17
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    1440:	47 01       	movw	r8, r14
    1442:	07 c0       	rjmp	.+14     	; 0x1452 <Create_VCP_frame+0x76>
	  append_crc16(src[src_index], &crc);
    1444:	b2 01       	movw	r22, r4
    1446:	f4 01       	movw	r30, r8
    1448:	81 91       	ld	r24, Z+
    144a:	4f 01       	movw	r8, r30
    144c:	4b 83       	std	Y+3, r20	; 0x03
    144e:	0e 94 ce 09 	call	0x139c	; 0x139c <append_crc16>
    1452:	4b 81       	ldd	r20, Y+3	; 0x03
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    1454:	86 14       	cp	r8, r6
    1456:	97 04       	cpc	r9, r7
    1458:	a9 f7       	brne	.-22     	; 0x1444 <Create_VCP_frame+0x68>
	  append_crc16(src[src_index], &crc);
	
	// Add CRC to the end of the source buffer
	src[src_index++] = ((crc >> 8) & 0xFF);
    145a:	89 81       	ldd	r24, Y+1	; 0x01
    145c:	9a 81       	ldd	r25, Y+2	; 0x02
    145e:	f7 01       	movw	r30, r14
    1460:	e0 0f       	add	r30, r16
    1462:	f1 1f       	adc	r31, r17
    1464:	90 83       	st	Z, r25
	src[src_index++] = (crc & 0xFF);
    1466:	81 83       	std	Z+1, r24	; 0x01
    1468:	0e 5f       	subi	r16, 0xFE	; 254
    146a:	1f 4f       	sbci	r17, 0xFF	; 255
	payload_size = src_index;
	
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
    146c:	80 ec       	ldi	r24, 0xC0	; 192
    146e:	f6 01       	movw	r30, r12
    1470:	80 83       	st	Z, r24
	// then insert VCP address
	dst[dst_index++] =					addr;
    1472:	41 83       	std	Z+1, r20	; 0x01
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1474:	d7 01       	movw	r26, r14
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
    1476:	42 e0       	ldi	r20, 0x02	; 2
    1478:	50 e0       	ldi	r21, 0x00	; 0
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    147a:	2d ed       	ldi	r18, 0xDD	; 221
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
    147c:	3b ed       	ldi	r19, 0xDB	; 219
			dst[dst_index++] =			TFEND;
    147e:	6c ed       	ldi	r22, 0xDC	; 220
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1480:	0f c0       	rjmp	.+30     	; 0x14a0 <Create_VCP_frame+0xc4>
	{
		if (src[src_index] == FEND)
    1482:	8d 91       	ld	r24, X+
    1484:	80 3c       	cpi	r24, 0xC0	; 192
    1486:	19 f4       	brne	.+6      	; 0x148e <Create_VCP_frame+0xb2>
		{
			dst[dst_index++] =			FESC;
    1488:	30 83       	st	Z, r19
			dst[dst_index++] =			TFEND;
    148a:	61 83       	std	Z+1, r22	; 0x01
    148c:	04 c0       	rjmp	.+8      	; 0x1496 <Create_VCP_frame+0xba>
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
    148e:	80 83       	st	Z, r24
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
    1490:	8b 3d       	cpi	r24, 0xDB	; 219
    1492:	21 f4       	brne	.+8      	; 0x149c <Create_VCP_frame+0xc0>
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    1494:	21 83       	std	Z+1, r18	; 0x01
    1496:	4e 5f       	subi	r20, 0xFE	; 254
    1498:	5f 4f       	sbci	r21, 0xFF	; 255
    149a:	02 c0       	rjmp	.+4      	; 0x14a0 <Create_VCP_frame+0xc4>
		}
		else
		{
			dst[dst_index++] =			src[src_index];
    149c:	4f 5f       	subi	r20, 0xFF	; 255
    149e:	5f 4f       	sbci	r21, 0xFF	; 255
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    14a0:	cd 01       	movw	r24, r26
    14a2:	8e 19       	sub	r24, r14
    14a4:	9f 09       	sbc	r25, r15
    14a6:	f6 01       	movw	r30, r12
    14a8:	e4 0f       	add	r30, r20
    14aa:	f5 1f       	adc	r31, r21
    14ac:	80 17       	cp	r24, r16
    14ae:	91 07       	cpc	r25, r17
    14b0:	40 f3       	brcs	.-48     	; 0x1482 <Create_VCP_frame+0xa6>
		//if (dst_index >= *dst_size - 1)
			//return VCP_OVR_ERR;
	}
	
	// End the frame with FEND
	dst[dst_index++] =					FEND;
    14b2:	80 ec       	ldi	r24, 0xC0	; 192
    14b4:	80 83       	st	Z, r24
    14b6:	4f 5f       	subi	r20, 0xFF	; 255
    14b8:	5f 4f       	sbci	r21, 0xFF	; 255
	
	// Save the frame size
	*dst_size = dst_index;
    14ba:	f5 01       	movw	r30, r10
    14bc:	51 83       	std	Z+1, r21	; 0x01
    14be:	40 83       	st	Z, r20
	
	// All good
	return VCP_TERM;
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	03 c0       	rjmp	.+6      	; 0x14ca <Create_VCP_frame+0xee>
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
		return VCP_NULL_ERR;
    14c4:	85 e0       	ldi	r24, 0x05	; 5
    14c6:	01 c0       	rjmp	.+2      	; 0x14ca <Create_VCP_frame+0xee>

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
		return VCP_ADDR_ERR;
    14c8:	86 e0       	ldi	r24, 0x06	; 6
	// Save the frame size
	*dst_size = dst_index;
	
	// All good
	return VCP_TERM;
}
    14ca:	0f 90       	pop	r0
    14cc:	0f 90       	pop	r0
    14ce:	0f 90       	pop	r0
    14d0:	df 91       	pop	r29
    14d2:	cf 91       	pop	r28
    14d4:	1f 91       	pop	r17
    14d6:	0f 91       	pop	r16
    14d8:	ff 90       	pop	r15
    14da:	ef 90       	pop	r14
    14dc:	df 90       	pop	r13
    14de:	cf 90       	pop	r12
    14e0:	bf 90       	pop	r11
    14e2:	af 90       	pop	r10
    14e4:	9f 90       	pop	r9
    14e6:	8f 90       	pop	r8
    14e8:	7f 90       	pop	r7
    14ea:	6f 90       	pop	r6
    14ec:	5f 90       	pop	r5
    14ee:	4f 90       	pop	r4
    14f0:	08 95       	ret

000014f2 <Receive_VCP_byte>:
// and return VCP status.
// Parameters:
// vcp_ptrbuffer	*buff -	Pointer to the vcp buffer structure
// uint8			byte -	received byte
uint8_t Receive_VCP_byte(vcp_ptrbuffer *buff, uint8 byte)
{
    14f2:	cf 92       	push	r12
    14f4:	df 92       	push	r13
    14f6:	ef 92       	push	r14
    14f8:	ff 92       	push	r15
    14fa:	0f 93       	push	r16
    14fc:	1f 93       	push	r17
    14fe:	cf 93       	push	r28
    1500:	df 93       	push	r29
    1502:	ec 01       	movw	r28, r24
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
    1504:	29 81       	ldd	r18, Y+1	; 0x01
    1506:	3a 81       	ldd	r19, Y+2	; 0x02
    1508:	21 15       	cp	r18, r1
    150a:	31 05       	cpc	r19, r1
    150c:	09 f4       	brne	.+2      	; 0x1510 <Receive_VCP_byte+0x1e>
    150e:	84 c0       	rjmp	.+264    	; 0x1618 <Receive_VCP_byte+0x126>
		return VCP_NULL_ERR;
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
    1510:	8f 81       	ldd	r24, Y+7	; 0x07
    1512:	98 85       	ldd	r25, Y+8	; 0x08
    1514:	4d 81       	ldd	r20, Y+5	; 0x05
    1516:	5e 81       	ldd	r21, Y+6	; 0x06
    1518:	41 50       	subi	r20, 0x01	; 1
    151a:	51 09       	sbc	r21, r1
    151c:	84 17       	cp	r24, r20
    151e:	95 07       	cpc	r25, r21
    1520:	08 f0       	brcs	.+2      	; 0x1524 <Receive_VCP_byte+0x32>
    1522:	7c c0       	rjmp	.+248    	; 0x161c <Receive_VCP_byte+0x12a>
		return VCP_OVR_ERR;
	
	// State Machine
	switch (buff->status)
    1524:	49 85       	ldd	r20, Y+9	; 0x09
    1526:	42 30       	cpi	r20, 0x02	; 2
    1528:	39 f1       	breq	.+78     	; 0x1578 <Receive_VCP_byte+0x86>
    152a:	18 f4       	brcc	.+6      	; 0x1532 <Receive_VCP_byte+0x40>
    152c:	44 23       	and	r20, r20
    152e:	31 f0       	breq	.+12     	; 0x153c <Receive_VCP_byte+0x4a>
    1530:	38 c0       	rjmp	.+112    	; 0x15a2 <Receive_VCP_byte+0xb0>
    1532:	40 31       	cpi	r20, 0x10	; 16
    1534:	31 f0       	breq	.+12     	; 0x1542 <Receive_VCP_byte+0x50>
    1536:	40 32       	cpi	r20, 0x20	; 32
    1538:	a1 f5       	brne	.+104    	; 0x15a2 <Receive_VCP_byte+0xb0>
    153a:	0a c0       	rjmp	.+20     	; 0x1550 <Receive_VCP_byte+0x5e>
	{
		case VCP_IDLE:										
			if (byte == FEND)
    153c:	60 3c       	cpi	r22, 0xC0	; 192
    153e:	91 f5       	brne	.+100    	; 0x15a4 <Receive_VCP_byte+0xb2>
    1540:	0d c0       	rjmp	.+26     	; 0x155c <Receive_VCP_byte+0x6a>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
    1542:	6c 30       	cpi	r22, 0x0C	; 12
    1544:	18 f0       	brcs	.+6      	; 0x154c <Receive_VCP_byte+0x5a>
    1546:	68 33       	cpi	r22, 0x38	; 56
    1548:	09 f0       	breq	.+2      	; 0x154c <Receive_VCP_byte+0x5a>
    154a:	6a c0       	rjmp	.+212    	; 0x1620 <Receive_VCP_byte+0x12e>
				return VCP_ADDR_ERR;
			else
			{
				buff->address = byte;
    154c:	68 83       	st	Y, r22
    154e:	26 c0       	rjmp	.+76     	; 0x159c <Receive_VCP_byte+0xaa>
				buff->status = VCP_RECEIVING;
			}	
			break;
		case VCP_RECEIVING:
			if (byte == FEND)
    1550:	60 3c       	cpi	r22, 0xC0	; 192
    1552:	31 f4       	brne	.+12     	; 0x1560 <Receive_VCP_byte+0x6e>
			{
				if (buff->index > 0)
    1554:	89 2b       	or	r24, r25
    1556:	11 f0       	breq	.+4      	; 0x155c <Receive_VCP_byte+0x6a>
					// Done
					buff->status = VCP_TERM;
    1558:	81 e0       	ldi	r24, 0x01	; 1
    155a:	21 c0       	rjmp	.+66     	; 0x159e <Receive_VCP_byte+0xac>
				else
					// No data between FENDs - assume lost sync and start over
					buff->status = VCP_ADDRESS;
    155c:	80 e1       	ldi	r24, 0x10	; 16
    155e:	1f c0       	rjmp	.+62     	; 0x159e <Receive_VCP_byte+0xac>
			}
			else if (byte == FESC)
    1560:	6b 3d       	cpi	r22, 0xDB	; 219
    1562:	11 f4       	brne	.+4      	; 0x1568 <Receive_VCP_byte+0x76>
				buff->status = VCP_ESC;
    1564:	82 e0       	ldi	r24, 0x02	; 2
    1566:	1b c0       	rjmp	.+54     	; 0x159e <Receive_VCP_byte+0xac>
			else
			{
				buff->message[(buff->index)++] = byte;	
    1568:	f9 01       	movw	r30, r18
    156a:	e8 0f       	add	r30, r24
    156c:	f9 1f       	adc	r31, r25
    156e:	60 83       	st	Z, r22
    1570:	01 96       	adiw	r24, 0x01	; 1
    1572:	98 87       	std	Y+8, r25	; 0x08
    1574:	8f 83       	std	Y+7, r24	; 0x07
    1576:	16 c0       	rjmp	.+44     	; 0x15a4 <Receive_VCP_byte+0xb2>
			}						
			break;
		case VCP_ESC:
			if (byte == TFEND)
    1578:	6c 3d       	cpi	r22, 0xDC	; 220
    157a:	29 f4       	brne	.+10     	; 0x1586 <Receive_VCP_byte+0x94>
			{
				buff->message[(buff->index)++] = FEND;
    157c:	f9 01       	movw	r30, r18
    157e:	e8 0f       	add	r30, r24
    1580:	f9 1f       	adc	r31, r25
    1582:	40 ec       	ldi	r20, 0xC0	; 192
    1584:	07 c0       	rjmp	.+14     	; 0x1594 <Receive_VCP_byte+0xa2>
				buff->status = VCP_RECEIVING;
			}
			else if (byte == TFESC)
    1586:	6d 3d       	cpi	r22, 0xDD	; 221
    1588:	09 f0       	breq	.+2      	; 0x158c <Receive_VCP_byte+0x9a>
    158a:	4c c0       	rjmp	.+152    	; 0x1624 <Receive_VCP_byte+0x132>
			{
				buff->message[(buff->index)++] = FESC;
    158c:	f9 01       	movw	r30, r18
    158e:	e8 0f       	add	r30, r24
    1590:	f9 1f       	adc	r31, r25
    1592:	4b ed       	ldi	r20, 0xDB	; 219
    1594:	40 83       	st	Z, r20
    1596:	01 96       	adiw	r24, 0x01	; 1
    1598:	98 87       	std	Y+8, r25	; 0x08
    159a:	8f 83       	std	Y+7, r24	; 0x07
				buff->status = VCP_RECEIVING;
    159c:	80 e2       	ldi	r24, 0x20	; 32
    159e:	89 87       	std	Y+9, r24	; 0x09
    15a0:	01 c0       	rjmp	.+2      	; 0x15a4 <Receive_VCP_byte+0xb2>
			}
			else
				return VCP_ESC_ERR;	
			break;
		default:
			buff->status = VCP_IDLE;
    15a2:	19 86       	std	Y+9, r1	; 0x09
			break; 
	}
	
	// End of frame
	if (buff->status == VCP_TERM)
    15a4:	89 85       	ldd	r24, Y+9	; 0x09
    15a6:	81 30       	cpi	r24, 0x01	; 1
    15a8:	11 f0       	breq	.+4      	; 0x15ae <Receive_VCP_byte+0xbc>
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
    15aa:	89 85       	ldd	r24, Y+9	; 0x09
    15ac:	3c c0       	rjmp	.+120    	; 0x1626 <Receive_VCP_byte+0x134>
	
	// End of frame
	if (buff->status == VCP_TERM)
	{
		// Message CRC is last 2 bytes 
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
    15ae:	89 81       	ldd	r24, Y+1	; 0x01
    15b0:	9a 81       	ldd	r25, Y+2	; 0x02
    15b2:	4f 81       	ldd	r20, Y+7	; 0x07
    15b4:	58 85       	ldd	r21, Y+8	; 0x08
    15b6:	84 0f       	add	r24, r20
    15b8:	95 1f       	adc	r25, r21
    15ba:	fc 01       	movw	r30, r24
    15bc:	32 97       	sbiw	r30, 0x02	; 2
    15be:	30 81       	ld	r19, Z
    15c0:	20 e0       	ldi	r18, 0x00	; 0
    15c2:	fc 01       	movw	r30, r24
    15c4:	31 97       	sbiw	r30, 0x01	; 1
    15c6:	80 81       	ld	r24, Z
    15c8:	69 01       	movw	r12, r18
    15ca:	c8 0e       	add	r12, r24
    15cc:	d1 1c       	adc	r13, r1
		// Remove CRC bytes from the message
		buff->index -= 2;
    15ce:	42 50       	subi	r20, 0x02	; 2
    15d0:	51 09       	sbc	r21, r1
    15d2:	58 87       	std	Y+8, r21	; 0x08
    15d4:	4f 83       	std	Y+7, r20	; 0x07
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
    15d6:	7e 01       	movw	r14, r28
    15d8:	83 e0       	ldi	r24, 0x03	; 3
    15da:	e8 0e       	add	r14, r24
    15dc:	f1 1c       	adc	r15, r1
    15de:	b7 01       	movw	r22, r14
    15e0:	88 81       	ld	r24, Y
    15e2:	0e 94 ce 09 	call	0x139c	; 0x139c <append_crc16>
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    15e6:	00 e0       	ldi	r16, 0x00	; 0
    15e8:	10 e0       	ldi	r17, 0x00	; 0
    15ea:	0a c0       	rjmp	.+20     	; 0x1600 <Receive_VCP_byte+0x10e>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
    15ec:	e9 81       	ldd	r30, Y+1	; 0x01
    15ee:	fa 81       	ldd	r31, Y+2	; 0x02
    15f0:	e0 0f       	add	r30, r16
    15f2:	f1 1f       	adc	r31, r17
    15f4:	b7 01       	movw	r22, r14
    15f6:	80 81       	ld	r24, Z
    15f8:	0e 94 ce 09 	call	0x139c	; 0x139c <append_crc16>
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
		// Remove CRC bytes from the message
		buff->index -= 2;
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    15fc:	0f 5f       	subi	r16, 0xFF	; 255
    15fe:	1f 4f       	sbci	r17, 0xFF	; 255
    1600:	8f 81       	ldd	r24, Y+7	; 0x07
    1602:	98 85       	ldd	r25, Y+8	; 0x08
    1604:	08 17       	cp	r16, r24
    1606:	19 07       	cpc	r17, r25
    1608:	88 f3       	brcs	.-30     	; 0x15ec <Receive_VCP_byte+0xfa>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
		}
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
    160a:	8b 81       	ldd	r24, Y+3	; 0x03
    160c:	9c 81       	ldd	r25, Y+4	; 0x04
    160e:	8c 15       	cp	r24, r12
    1610:	9d 05       	cpc	r25, r13
    1612:	59 f2       	breq	.-106    	; 0x15aa <Receive_VCP_byte+0xb8>
			return VCP_CRC_ERR;
    1614:	84 e0       	ldi	r24, 0x04	; 4
    1616:	07 c0       	rjmp	.+14     	; 0x1626 <Receive_VCP_byte+0x134>
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
		return VCP_NULL_ERR;
    1618:	85 e0       	ldi	r24, 0x05	; 5
    161a:	05 c0       	rjmp	.+10     	; 0x1626 <Receive_VCP_byte+0x134>
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
		return VCP_OVR_ERR;
    161c:	83 e0       	ldi	r24, 0x03	; 3
    161e:	03 c0       	rjmp	.+6      	; 0x1626 <Receive_VCP_byte+0x134>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
				return VCP_ADDR_ERR;
    1620:	86 e0       	ldi	r24, 0x06	; 6
    1622:	01 c0       	rjmp	.+2      	; 0x1626 <Receive_VCP_byte+0x134>
			{
				buff->message[(buff->index)++] = FESC;
				buff->status = VCP_RECEIVING;
			}
			else
				return VCP_ESC_ERR;	
    1624:	87 e0       	ldi	r24, 0x07	; 7
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
}
    1626:	df 91       	pop	r29
    1628:	cf 91       	pop	r28
    162a:	1f 91       	pop	r17
    162c:	0f 91       	pop	r16
    162e:	ff 90       	pop	r15
    1630:	ef 90       	pop	r14
    1632:	df 90       	pop	r13
    1634:	cf 90       	pop	r12
    1636:	08 95       	ret

00001638 <tx_put_byte.part.0>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    return;
  if( tel_packet_index[uart] < tel_packet_size[uart] )
    1638:	28 2f       	mov	r18, r24
    163a:	30 e0       	ldi	r19, 0x00	; 0
    163c:	f9 01       	movw	r30, r18
    163e:	eb 5f       	subi	r30, 0xFB	; 251
    1640:	f7 4f       	sbci	r31, 0xF7	; 247
    1642:	60 81       	ld	r22, Z
    1644:	d9 01       	movw	r26, r18
    1646:	aa 0f       	add	r26, r26
    1648:	bb 1f       	adc	r27, r27
    164a:	ab 5c       	subi	r26, 0xCB	; 203
    164c:	bb 4f       	sbci	r27, 0xFB	; 251
    164e:	4d 91       	ld	r20, X+
    1650:	5c 91       	ld	r21, X
    1652:	70 e0       	ldi	r23, 0x00	; 0
    1654:	64 17       	cp	r22, r20
    1656:	75 07       	cpc	r23, r21
    1658:	10 f5       	brcc	.+68     	; 0x169e <tx_put_byte.part.0+0x66>
  {
      if ( uart == 0 )
    165a:	81 11       	cpse	r24, r1
    165c:	0e c0       	rjmp	.+28     	; 0x167a <tx_put_byte.part.0+0x42>
      UDR0 = tel_packet[uart][tel_packet_index[uart]++];
    165e:	80 81       	ld	r24, Z
    1660:	9f ef       	ldi	r25, 0xFF	; 255
    1662:	92 9f       	mul	r25, r18
    1664:	d0 01       	movw	r26, r0
    1666:	93 9f       	mul	r25, r19
    1668:	b0 0d       	add	r27, r0
    166a:	11 24       	eor	r1, r1
    166c:	a8 0f       	add	r26, r24
    166e:	b1 1d       	adc	r27, r1
    1670:	a4 5f       	subi	r26, 0xF4	; 244
    1672:	b7 4f       	sbci	r27, 0xF7	; 247
    1674:	9c 91       	ld	r25, X
    1676:	9c b9       	out	0x0c, r25	; 12
    1678:	10 c0       	rjmp	.+32     	; 0x169a <tx_put_byte.part.0+0x62>
    else if ( uart == 1 )
    167a:	81 30       	cpi	r24, 0x01	; 1
    167c:	81 f4       	brne	.+32     	; 0x169e <tx_put_byte.part.0+0x66>
      UDR1 = tel_packet[uart][tel_packet_index[uart]++];
    167e:	80 81       	ld	r24, Z
    1680:	9f ef       	ldi	r25, 0xFF	; 255
    1682:	92 9f       	mul	r25, r18
    1684:	d0 01       	movw	r26, r0
    1686:	93 9f       	mul	r25, r19
    1688:	b0 0d       	add	r27, r0
    168a:	11 24       	eor	r1, r1
    168c:	a8 0f       	add	r26, r24
    168e:	b1 1d       	adc	r27, r1
    1690:	a4 5f       	subi	r26, 0xF4	; 244
    1692:	b7 4f       	sbci	r27, 0xF7	; 247
    1694:	9c 91       	ld	r25, X
    1696:	90 93 9c 00 	sts	0x009C, r25
    169a:	8f 5f       	subi	r24, 0xFF	; 255
    169c:	80 83       	st	Z, r24
    169e:	08 95       	ret

000016a0 <__vector_15>:
#include "vcp_library.h"
#include "crclib.h"
#include "uart.h"

ISR(TIMER0_COMP_vect)
{
    16a0:	1f 92       	push	r1
    16a2:	0f 92       	push	r0
    16a4:	0f b6       	in	r0, 0x3f	; 63
    16a6:	0f 92       	push	r0
    16a8:	11 24       	eor	r1, r1
    16aa:	8f 93       	push	r24
  if ( timer0_counter[0] > 0 )
    16ac:	80 91 3c 0c 	lds	r24, 0x0C3C
    16b0:	88 23       	and	r24, r24
    16b2:	29 f0       	breq	.+10     	; 0x16be <__vector_15+0x1e>
    --timer0_counter[0];
    16b4:	80 91 3c 0c 	lds	r24, 0x0C3C
    16b8:	81 50       	subi	r24, 0x01	; 1
    16ba:	80 93 3c 0c 	sts	0x0C3C, r24
  if ( timer0_counter[1] > 0 )
    16be:	80 91 3d 0c 	lds	r24, 0x0C3D
    16c2:	88 23       	and	r24, r24
    16c4:	29 f0       	breq	.+10     	; 0x16d0 <__vector_15+0x30>
    --timer0_counter[1];
    16c6:	80 91 3d 0c 	lds	r24, 0x0C3D
    16ca:	81 50       	subi	r24, 0x01	; 1
    16cc:	80 93 3d 0c 	sts	0x0C3D, r24
	//if (cntr == 0)
	//	PORTC |= 0x01;
	//else
	//	PORTC &= 0xFE;
	//_delay_ms(500);
}
    16d0:	8f 91       	pop	r24
    16d2:	0f 90       	pop	r0
    16d4:	0f be       	out	0x3f, r0	; 63
    16d6:	0f 90       	pop	r0
    16d8:	1f 90       	pop	r1
    16da:	18 95       	reti

000016dc <__vector_12>:

/* Timer 1(A) routine */
ISR(TIMER1_COMPA_vect)		//Handle Radio & Torquer 30 min delays here; handle 10 min CDH-IB no heartbeat restart
{
    16dc:	1f 92       	push	r1
    16de:	0f 92       	push	r0
    16e0:	0f b6       	in	r0, 0x3f	; 63
    16e2:	0f 92       	push	r0
    16e4:	11 24       	eor	r1, r1
    16e6:	0b b6       	in	r0, 0x3b	; 59
    16e8:	0f 92       	push	r0
    16ea:	2f 93       	push	r18
    16ec:	3f 93       	push	r19
    16ee:	4f 93       	push	r20
    16f0:	5f 93       	push	r21
    16f2:	6f 93       	push	r22
    16f4:	7f 93       	push	r23
    16f6:	8f 93       	push	r24
    16f8:	9f 93       	push	r25
    16fa:	af 93       	push	r26
    16fc:	bf 93       	push	r27
    16fe:	cf 93       	push	r28
    1700:	ef 93       	push	r30
    1702:	ff 93       	push	r31
	SVIT_t *component;
	
	//Testing
	//PORTC ^= 0xFF;
		
	if (timer1_counter[0] <= 0	  &&     rad_torq_flag){	//provides 30 minute delay			
    1704:	80 91 60 0e 	lds	r24, 0x0E60
    1708:	81 11       	cpse	r24, r1
    170a:	31 c0       	rjmp	.+98     	; 0x176e <__vector_12+0x92>
    170c:	80 91 19 04 	lds	r24, 0x0419
    1710:	88 23       	and	r24, r24
    1712:	69 f1       	breq	.+90     	; 0x176e <__vector_12+0x92>
	//if ( receive_flag == 1){		//If message is received, reset timer1_counter[0] to CYCLE_COUNTER
	    timer1_counter[0] = CYCLE_COUNTER;
    1714:	84 e8       	ldi	r24, 0x84	; 132
    1716:	80 93 60 0e 	sts	0x0E60, r24
		
		//CHECK: Should the ISR do this code or not?
		
		//Turn on radios
		component = &svit[RADIO_1];
		switch_on( component->switch_num );
    171a:	80 91 63 05 	lds	r24, 0x0563
    171e:	0e 94 df 07 	call	0xfbe	; 0xfbe <switch_on>
		component->switch_state = SW_ON;
    1722:	c1 e0       	ldi	r28, 0x01	; 1
    1724:	c0 93 64 05 	sts	0x0564, r28
		component = &svit[RADIO_2];
		switch_on( component->switch_num );
    1728:	80 91 7d 05 	lds	r24, 0x057D
    172c:	0e 94 df 07 	call	0xfbe	; 0xfbe <switch_on>
		component->switch_state = SW_ON;
    1730:	c0 93 7e 05 	sts	0x057E, r28
		
		//Turn on torque coils			
		component = &svit[TORQUER_1];
		switch_on( component->switch_num );
    1734:	80 91 ff 05 	lds	r24, 0x05FF
    1738:	0e 94 df 07 	call	0xfbe	; 0xfbe <switch_on>
		component->switch_state = SW_ON;
    173c:	c0 93 00 06 	sts	0x0600, r28
		component = &svit[TORQUER_2];
		switch_on( component->switch_num );
    1740:	80 91 19 06 	lds	r24, 0x0619
    1744:	0e 94 df 07 	call	0xfbe	; 0xfbe <switch_on>
		component->switch_state = SW_ON;
    1748:	c0 93 1a 06 	sts	0x061A, r28
		component = &svit[TORQUER_3];
		switch_on( component->switch_num );
    174c:	80 91 33 06 	lds	r24, 0x0633
    1750:	0e 94 df 07 	call	0xfbe	; 0xfbe <switch_on>
		component->switch_state = SW_ON;
    1754:	c0 93 34 06 	sts	0x0634, r28
		torquer_on(TORQUER_1);
    1758:	81 e1       	ldi	r24, 0x11	; 17
    175a:	0e 94 c2 07 	call	0xf84	; 0xf84 <torquer_on>
		torquer_on(TORQUER_2);
    175e:	82 e1       	ldi	r24, 0x12	; 18
    1760:	0e 94 c2 07 	call	0xf84	; 0xf84 <torquer_on>
		torquer_on(TORQUER_3);
    1764:	83 e1       	ldi	r24, 0x13	; 19
    1766:	0e 94 c2 07 	call	0xf84	; 0xf84 <torquer_on>
		
		//PORTC ^= 0x02;	//LED for STK testing
		//PORTC ^= 0x01;
		
		//Don't reexecute this code
		rad_torq_flag = 0;
    176a:	10 92 19 04 	sts	0x0419, r1
	}
	
	if (timer1_counter[1] <= 0   &&   !cdh_heartbeat_flag){		//If heartbeat timer 1 has expired AND we haven't already ordered a restart
    176e:	80 91 61 0e 	lds	r24, 0x0E61
    1772:	81 11       	cpse	r24, r1
    1774:	07 c0       	rjmp	.+14     	; 0x1784 <__vector_12+0xa8>
    1776:	80 91 30 04 	lds	r24, 0x0430
    177a:	81 11       	cpse	r24, r1
    177c:	03 c0       	rjmp	.+6      	; 0x1784 <__vector_12+0xa8>
		//Order full component restart
		cdh_heartbeat_flag = 1;
    177e:	81 e0       	ldi	r24, 0x01	; 1
    1780:	80 93 30 04 	sts	0x0430, r24
		
	}
	
	//else{
		PORTC ^= 0x01;		//LED for STK testing at PORTC0
    1784:	85 b3       	in	r24, 0x15	; 21
    1786:	91 e0       	ldi	r25, 0x01	; 1
    1788:	89 27       	eor	r24, r25
    178a:	85 bb       	out	0x15, r24	; 21
    178c:	2f ef       	ldi	r18, 0xFF	; 255
    178e:	8f e7       	ldi	r24, 0x7F	; 127
    1790:	96 e1       	ldi	r25, 0x16	; 22
    1792:	21 50       	subi	r18, 0x01	; 1
    1794:	80 40       	sbci	r24, 0x00	; 0
    1796:	90 40       	sbci	r25, 0x00	; 0
    1798:	e1 f7       	brne	.-8      	; 0x1792 <__vector_12+0xb6>
    179a:	00 c0       	rjmp	.+0      	; 0x179c <__vector_12+0xc0>
    179c:	00 00       	nop
		_delay_ms(500);
		--timer1_counter[0];
    179e:	80 91 60 0e 	lds	r24, 0x0E60
    17a2:	81 50       	subi	r24, 0x01	; 1
    17a4:	80 93 60 0e 	sts	0x0E60, r24
		--timer1_counter[1];
    17a8:	80 91 61 0e 	lds	r24, 0x0E61
    17ac:	81 50       	subi	r24, 0x01	; 1
    17ae:	80 93 61 0e 	sts	0x0E61, r24
	//}
}
    17b2:	ff 91       	pop	r31
    17b4:	ef 91       	pop	r30
    17b6:	cf 91       	pop	r28
    17b8:	bf 91       	pop	r27
    17ba:	af 91       	pop	r26
    17bc:	9f 91       	pop	r25
    17be:	8f 91       	pop	r24
    17c0:	7f 91       	pop	r23
    17c2:	6f 91       	pop	r22
    17c4:	5f 91       	pop	r21
    17c6:	4f 91       	pop	r20
    17c8:	3f 91       	pop	r19
    17ca:	2f 91       	pop	r18
    17cc:	0f 90       	pop	r0
    17ce:	0b be       	out	0x3b, r0	; 59
    17d0:	0f 90       	pop	r0
    17d2:	0f be       	out	0x3f, r0	; 63
    17d4:	0f 90       	pop	r0
    17d6:	1f 90       	pop	r1
    17d8:	18 95       	reti

000017da <__vector_32>:

ISR(USART1_TX_vect)
{
    17da:	1f 92       	push	r1
    17dc:	0f 92       	push	r0
    17de:	0f b6       	in	r0, 0x3f	; 63
    17e0:	0f 92       	push	r0
    17e2:	11 24       	eor	r1, r1
    17e4:	0b b6       	in	r0, 0x3b	; 59
    17e6:	0f 92       	push	r0
    17e8:	2f 93       	push	r18
    17ea:	3f 93       	push	r19
    17ec:	4f 93       	push	r20
    17ee:	5f 93       	push	r21
    17f0:	6f 93       	push	r22
    17f2:	7f 93       	push	r23
    17f4:	8f 93       	push	r24
    17f6:	9f 93       	push	r25
    17f8:	af 93       	push	r26
    17fa:	bf 93       	push	r27
    17fc:	ef 93       	push	r30
    17fe:	ff 93       	push	r31
    1800:	81 e0       	ldi	r24, 0x01	; 1
    1802:	0e 94 1c 0b 	call	0x1638	; 0x1638 <tx_put_byte.part.0>
  tx_put_byte( 1 );
}
    1806:	ff 91       	pop	r31
    1808:	ef 91       	pop	r30
    180a:	bf 91       	pop	r27
    180c:	af 91       	pop	r26
    180e:	9f 91       	pop	r25
    1810:	8f 91       	pop	r24
    1812:	7f 91       	pop	r23
    1814:	6f 91       	pop	r22
    1816:	5f 91       	pop	r21
    1818:	4f 91       	pop	r20
    181a:	3f 91       	pop	r19
    181c:	2f 91       	pop	r18
    181e:	0f 90       	pop	r0
    1820:	0b be       	out	0x3b, r0	; 59
    1822:	0f 90       	pop	r0
    1824:	0f be       	out	0x3f, r0	; 63
    1826:	0f 90       	pop	r0
    1828:	1f 90       	pop	r1
    182a:	18 95       	reti

0000182c <__vector_30>:

ISR(USART1_RX_vect)
{
    182c:	1f 92       	push	r1
    182e:	0f 92       	push	r0
    1830:	0f b6       	in	r0, 0x3f	; 63
    1832:	0f 92       	push	r0
    1834:	11 24       	eor	r1, r1
    1836:	0b b6       	in	r0, 0x3b	; 59
    1838:	0f 92       	push	r0
    183a:	2f 93       	push	r18
    183c:	3f 93       	push	r19
    183e:	4f 93       	push	r20
    1840:	5f 93       	push	r21
    1842:	6f 93       	push	r22
    1844:	7f 93       	push	r23
    1846:	8f 93       	push	r24
    1848:	9f 93       	push	r25
    184a:	af 93       	push	r26
    184c:	bf 93       	push	r27
    184e:	ef 93       	push	r30
    1850:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[1], UDR1 ) == VCP_TERM )
    1852:	60 91 9c 00 	lds	r22, 0x009C
    1856:	80 91 6a 0e 	lds	r24, 0x0E6A
    185a:	90 91 6b 0e 	lds	r25, 0x0E6B
    185e:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <Receive_VCP_byte>
    1862:	81 30       	cpi	r24, 0x01	; 1
    1864:	29 f4       	brne	.+10     	; 0x1870 <__vector_30+0x44>
  {
    rx_flag[1]++;
    1866:	80 91 6e 0e 	lds	r24, 0x0E6E
    186a:	8f 5f       	subi	r24, 0xFF	; 255
    186c:	80 93 6e 0e 	sts	0x0E6E, r24
  }
}
    1870:	ff 91       	pop	r31
    1872:	ef 91       	pop	r30
    1874:	bf 91       	pop	r27
    1876:	af 91       	pop	r26
    1878:	9f 91       	pop	r25
    187a:	8f 91       	pop	r24
    187c:	7f 91       	pop	r23
    187e:	6f 91       	pop	r22
    1880:	5f 91       	pop	r21
    1882:	4f 91       	pop	r20
    1884:	3f 91       	pop	r19
    1886:	2f 91       	pop	r18
    1888:	0f 90       	pop	r0
    188a:	0b be       	out	0x3b, r0	; 59
    188c:	0f 90       	pop	r0
    188e:	0f be       	out	0x3f, r0	; 63
    1890:	0f 90       	pop	r0
    1892:	1f 90       	pop	r1
    1894:	18 95       	reti

00001896 <__vector_21>:

ISR ( ADC_vect )
{
    1896:	1f 92       	push	r1
    1898:	0f 92       	push	r0
    189a:	0f b6       	in	r0, 0x3f	; 63
    189c:	0f 92       	push	r0
    189e:	11 24       	eor	r1, r1
    18a0:	8f 93       	push	r24
  ADC_low = ADCL;	// Left adjusted; read 2 LSB then 8 MSB
    18a2:	84 b1       	in	r24, 0x04	; 4
    18a4:	80 93 62 0e 	sts	0x0E62, r24
  ADC_high = ADCH;
    18a8:	85 b1       	in	r24, 0x05	; 5
    18aa:	80 93 29 0a 	sts	0x0A29, r24
  adc_flag = 1;
    18ae:	81 e0       	ldi	r24, 0x01	; 1
    18b0:	80 93 0b 0a 	sts	0x0A0B, r24
}
    18b4:	8f 91       	pop	r24
    18b6:	0f 90       	pop	r0
    18b8:	0f be       	out	0x3f, r0	; 63
    18ba:	0f 90       	pop	r0
    18bc:	1f 90       	pop	r1
    18be:	18 95       	reti

000018c0 <__vector_20>:

ISR( USART0_TX_vect )
{
    18c0:	1f 92       	push	r1
    18c2:	0f 92       	push	r0
    18c4:	0f b6       	in	r0, 0x3f	; 63
    18c6:	0f 92       	push	r0
    18c8:	11 24       	eor	r1, r1
    18ca:	0b b6       	in	r0, 0x3b	; 59
    18cc:	0f 92       	push	r0
    18ce:	2f 93       	push	r18
    18d0:	3f 93       	push	r19
    18d2:	4f 93       	push	r20
    18d4:	5f 93       	push	r21
    18d6:	6f 93       	push	r22
    18d8:	7f 93       	push	r23
    18da:	8f 93       	push	r24
    18dc:	9f 93       	push	r25
    18de:	af 93       	push	r26
    18e0:	bf 93       	push	r27
    18e2:	ef 93       	push	r30
    18e4:	ff 93       	push	r31
    18e6:	80 e0       	ldi	r24, 0x00	; 0
    18e8:	0e 94 1c 0b 	call	0x1638	; 0x1638 <tx_put_byte.part.0>
  tx_put_byte( 0 );
}
    18ec:	ff 91       	pop	r31
    18ee:	ef 91       	pop	r30
    18f0:	bf 91       	pop	r27
    18f2:	af 91       	pop	r26
    18f4:	9f 91       	pop	r25
    18f6:	8f 91       	pop	r24
    18f8:	7f 91       	pop	r23
    18fa:	6f 91       	pop	r22
    18fc:	5f 91       	pop	r21
    18fe:	4f 91       	pop	r20
    1900:	3f 91       	pop	r19
    1902:	2f 91       	pop	r18
    1904:	0f 90       	pop	r0
    1906:	0b be       	out	0x3b, r0	; 59
    1908:	0f 90       	pop	r0
    190a:	0f be       	out	0x3f, r0	; 63
    190c:	0f 90       	pop	r0
    190e:	1f 90       	pop	r1
    1910:	18 95       	reti

00001912 <__vector_18>:

ISR( USART0_RX_vect )
{
    1912:	1f 92       	push	r1
    1914:	0f 92       	push	r0
    1916:	0f b6       	in	r0, 0x3f	; 63
    1918:	0f 92       	push	r0
    191a:	11 24       	eor	r1, r1
    191c:	0b b6       	in	r0, 0x3b	; 59
    191e:	0f 92       	push	r0
    1920:	2f 93       	push	r18
    1922:	3f 93       	push	r19
    1924:	4f 93       	push	r20
    1926:	5f 93       	push	r21
    1928:	6f 93       	push	r22
    192a:	7f 93       	push	r23
    192c:	8f 93       	push	r24
    192e:	9f 93       	push	r25
    1930:	af 93       	push	r26
    1932:	bf 93       	push	r27
    1934:	ef 93       	push	r30
    1936:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[0], UDR0 ) == VCP_TERM )
    1938:	6c b1       	in	r22, 0x0c	; 12
    193a:	80 91 68 0e 	lds	r24, 0x0E68
    193e:	90 91 69 0e 	lds	r25, 0x0E69
    1942:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <Receive_VCP_byte>
    1946:	81 30       	cpi	r24, 0x01	; 1
    1948:	29 f4       	brne	.+10     	; 0x1954 <__vector_18+0x42>
  {
    rx_flag[0]++;
    194a:	80 91 6d 0e 	lds	r24, 0x0E6D
    194e:	8f 5f       	subi	r24, 0xFF	; 255
    1950:	80 93 6d 0e 	sts	0x0E6D, r24
  }
}
    1954:	ff 91       	pop	r31
    1956:	ef 91       	pop	r30
    1958:	bf 91       	pop	r27
    195a:	af 91       	pop	r26
    195c:	9f 91       	pop	r25
    195e:	8f 91       	pop	r24
    1960:	7f 91       	pop	r23
    1962:	6f 91       	pop	r22
    1964:	5f 91       	pop	r21
    1966:	4f 91       	pop	r20
    1968:	3f 91       	pop	r19
    196a:	2f 91       	pop	r18
    196c:	0f 90       	pop	r0
    196e:	0b be       	out	0x3b, r0	; 59
    1970:	0f 90       	pop	r0
    1972:	0f be       	out	0x3f, r0	; 63
    1974:	0f 90       	pop	r0
    1976:	1f 90       	pop	r1
    1978:	18 95       	reti

0000197a <tx_put_byte>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    197a:	82 30       	cpi	r24, 0x02	; 2
    197c:	10 f4       	brcc	.+4      	; 0x1982 <tx_put_byte+0x8>
    197e:	0c 94 1c 0b 	jmp	0x1638	; 0x1638 <tx_put_byte.part.0>
    1982:	08 95       	ret

00001984 <construct_telemetry_packet>:
  }
}


void construct_telemetry_packet( uint8_t* packet_payload )
{
    1984:	2f 92       	push	r2
    1986:	3f 92       	push	r3
    1988:	4f 92       	push	r4
    198a:	5f 92       	push	r5
    198c:	6f 92       	push	r6
    198e:	7f 92       	push	r7
    1990:	8f 92       	push	r8
    1992:	9f 92       	push	r9
    1994:	af 92       	push	r10
    1996:	bf 92       	push	r11
    1998:	cf 92       	push	r12
    199a:	df 92       	push	r13
    199c:	ef 92       	push	r14
    199e:	ff 92       	push	r15
    19a0:	0f 93       	push	r16
    19a2:	1f 93       	push	r17
    19a4:	cf 93       	push	r28
    19a6:	df 93       	push	r29
    19a8:	cd b7       	in	r28, 0x3d	; 61
    19aa:	de b7       	in	r29, 0x3e	; 62
    19ac:	28 97       	sbiw	r28, 0x08	; 8
    19ae:	0f b6       	in	r0, 0x3f	; 63
    19b0:	f8 94       	cli
    19b2:	de bf       	out	0x3e, r29	; 62
    19b4:	0f be       	out	0x3f, r0	; 63
    19b6:	cd bf       	out	0x3d, r28	; 61
    19b8:	98 87       	std	Y+8, r25	; 0x08
    19ba:	8f 83       	std	Y+7, r24	; 0x07
  packet_payload[0] = VCP_POWER_TELEMETRY;
    19bc:	dc 01       	movw	r26, r24
    19be:	1c 92       	st	X, r1
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
    19c0:	30 91 4a 05 	lds	r19, 0x054A
    19c4:	33 0f       	add	r19, r19
                  ( svit[RADIO_1].switch_state << 2 )    |
    19c6:	80 91 64 05 	lds	r24, 0x0564
    19ca:	b4 e0       	ldi	r27, 0x04	; 4
    19cc:	8b 9f       	mul	r24, r27
    19ce:	c0 01       	movw	r24, r0
    19d0:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    19d2:	38 2b       	or	r19, r24
    19d4:	80 91 30 05 	lds	r24, 0x0530
    19d8:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
    19da:	80 91 7e 05 	lds	r24, 0x057E
    19de:	e8 e0       	ldi	r30, 0x08	; 8
    19e0:	8e 9f       	mul	r24, r30
    19e2:	c0 01       	movw	r24, r0
    19e4:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    19e6:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
    19e8:	80 91 cc 05 	lds	r24, 0x05CC
    19ec:	f0 e1       	ldi	r31, 0x10	; 16
    19ee:	8f 9f       	mul	r24, r31
    19f0:	c0 01       	movw	r24, r0
    19f2:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    19f4:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;
    19f6:	80 91 e6 05 	lds	r24, 0x05E6
    19fa:	20 e2       	ldi	r18, 0x20	; 32
    19fc:	82 9f       	mul	r24, r18
    19fe:	c0 01       	movw	r24, r0
    1a00:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1a02:	38 2b       	or	r19, r24
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
    1a04:	40 91 1a 06 	lds	r20, 0x061A
    1a08:	44 0f       	add	r20, r20
                  ( svit[TORQUER_3].switch_state << 2 ) |
    1a0a:	80 91 34 06 	lds	r24, 0x0634
    1a0e:	54 e0       	ldi	r21, 0x04	; 4
    1a10:	85 9f       	mul	r24, r21
    1a12:	c0 01       	movw	r24, r0
    1a14:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1a16:	48 2b       	or	r20, r24
    1a18:	80 91 00 06 	lds	r24, 0x0600
    1a1c:	48 2b       	or	r20, r24
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );
    1a1e:	e8 e9       	ldi	r30, 0x98	; 152
    1a20:	f5 e0       	ldi	r31, 0x05	; 5
    1a22:	80 81       	ld	r24, Z
    1a24:	a8 e0       	ldi	r26, 0x08	; 8
    1a26:	8a 9f       	mul	r24, r26
    1a28:	c0 01       	movw	r24, r0
    1a2a:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1a2c:	48 2b       	or	r20, r24
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
    1a2e:	20 91 60 04 	lds	r18, 0x0460
    1a32:	22 0f       	add	r18, r18
                  ( svit[FC_5V].switch_state << 2 )        |
    1a34:	80 91 7a 04 	lds	r24, 0x047A
    1a38:	b4 e0       	ldi	r27, 0x04	; 4
    1a3a:	8b 9f       	mul	r24, r27
    1a3c:	c0 01       	movw	r24, r0
    1a3e:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a40:	28 2b       	or	r18, r24
    1a42:	80 91 46 04 	lds	r24, 0x0446
    1a46:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
    1a48:	80 91 ae 04 	lds	r24, 0x04AE
    1a4c:	58 e0       	ldi	r21, 0x08	; 8
    1a4e:	85 9f       	mul	r24, r21
    1a50:	c0 01       	movw	r24, r0
    1a52:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a54:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
    1a56:	80 91 c8 04 	lds	r24, 0x04C8
    1a5a:	a0 e1       	ldi	r26, 0x10	; 16
    1a5c:	8a 9f       	mul	r24, r26
    1a5e:	c0 01       	movw	r24, r0
    1a60:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a62:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
    1a64:	80 91 e2 04 	lds	r24, 0x04E2
    1a68:	b0 e2       	ldi	r27, 0x20	; 32
    1a6a:	8b 9f       	mul	r24, r27
    1a6c:	c0 01       	movw	r24, r0
    1a6e:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a70:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
    1a72:	80 91 fc 04 	lds	r24, 0x04FC
    1a76:	50 e4       	ldi	r21, 0x40	; 64
    1a78:	85 9f       	mul	r24, r21
    1a7a:	c0 01       	movw	r24, r0
    1a7c:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a7e:	28 2b       	or	r18, r24
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;
    1a80:	80 91 16 05 	lds	r24, 0x0516
    1a84:	a0 e8       	ldi	r26, 0x80	; 128
    1a86:	8a 9f       	mul	r24, r26
    1a88:	c0 01       	movw	r24, r0
    1a8a:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1a8c:	28 2b       	or	r18, r24
  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );

  packet_payload[1] = on_off_state0;
    1a8e:	af 81       	ldd	r26, Y+7	; 0x07
    1a90:	b8 85       	ldd	r27, Y+8	; 0x08
    1a92:	11 96       	adiw	r26, 0x01	; 1
    1a94:	2c 93       	st	X, r18
    1a96:	11 97       	sbiw	r26, 0x01	; 1
  packet_payload[2] = on_off_state1;
    1a98:	12 96       	adiw	r26, 0x02	; 2
    1a9a:	3c 93       	st	X, r19
    1a9c:	12 97       	sbiw	r26, 0x02	; 2
  packet_payload[3] = on_off_state2;
    1a9e:	13 96       	adiw	r26, 0x03	; 3
    1aa0:	4c 93       	st	X, r20
    1aa2:	13 97       	sbiw	r26, 0x03	; 3
  packet_payload[4] = 0x99;
    1aa4:	89 e9       	ldi	r24, 0x99	; 153
    1aa6:	14 96       	adiw	r26, 0x04	; 4
    1aa8:	8c 93       	st	X, r24
    1aaa:	14 97       	sbiw	r26, 0x04	; 4
  packet_payload[5] = svit[MAESTRO].switch_state;
    1aac:	80 81       	ld	r24, Z
    1aae:	15 96       	adiw	r26, 0x05	; 5
    1ab0:	8c 93       	st	X, r24

  // voltage values (raw ADC output)
  packet_payload[6]  = SVIT_check_V_critical( svit[SPECTROMETER].name );
    1ab2:	24 e4       	ldi	r18, 0x44	; 68
    1ab4:	62 2e       	mov	r6, r18
    1ab6:	24 e0       	ldi	r18, 0x04	; 4
    1ab8:	72 2e       	mov	r7, r18
    1aba:	f3 01       	movw	r30, r6
    1abc:	80 81       	ld	r24, Z
    1abe:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1ac2:	af 81       	ldd	r26, Y+7	; 0x07
    1ac4:	b8 85       	ldd	r27, Y+8	; 0x08
    1ac6:	16 96       	adiw	r26, 0x06	; 6
    1ac8:	8c 93       	st	X, r24
  packet_payload[7]  = SVIT_check_V_critical( svit[STAR_TRACKER].name );
    1aca:	3e e5       	ldi	r19, 0x5E	; 94
    1acc:	83 2e       	mov	r8, r19
    1ace:	34 e0       	ldi	r19, 0x04	; 4
    1ad0:	93 2e       	mov	r9, r19
    1ad2:	f4 01       	movw	r30, r8
    1ad4:	80 81       	ld	r24, Z
    1ad6:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1ada:	af 81       	ldd	r26, Y+7	; 0x07
    1adc:	b8 85       	ldd	r27, Y+8	; 0x08
    1ade:	17 96       	adiw	r26, 0x07	; 7
    1ae0:	8c 93       	st	X, r24
  packet_payload[8]  = SVIT_check_V_critical( svit[FC_5V].name );
    1ae2:	48 e7       	ldi	r20, 0x78	; 120
    1ae4:	a4 2e       	mov	r10, r20
    1ae6:	44 e0       	ldi	r20, 0x04	; 4
    1ae8:	b4 2e       	mov	r11, r20
    1aea:	f5 01       	movw	r30, r10
    1aec:	80 81       	ld	r24, Z
    1aee:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1af2:	af 81       	ldd	r26, Y+7	; 0x07
    1af4:	b8 85       	ldd	r27, Y+8	; 0x08
    1af6:	18 96       	adiw	r26, 0x08	; 8
    1af8:	8c 93       	st	X, r24
  packet_payload[9]  = SVIT_check_V_critical( svit[FC_3_3V].name );
    1afa:	52 e9       	ldi	r21, 0x92	; 146
    1afc:	c5 2e       	mov	r12, r21
    1afe:	54 e0       	ldi	r21, 0x04	; 4
    1b00:	d5 2e       	mov	r13, r21
    1b02:	f6 01       	movw	r30, r12
    1b04:	80 81       	ld	r24, Z
    1b06:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1b0a:	af 81       	ldd	r26, Y+7	; 0x07
    1b0c:	b8 85       	ldd	r27, Y+8	; 0x08
    1b0e:	19 96       	adiw	r26, 0x09	; 9
    1b10:	8c 93       	st	X, r24
  packet_payload[10] = SVIT_check_V_critical( svit[GPS_1].name );
    1b12:	6c ea       	ldi	r22, 0xAC	; 172
    1b14:	e6 2e       	mov	r14, r22
    1b16:	64 e0       	ldi	r22, 0x04	; 4
    1b18:	f6 2e       	mov	r15, r22
    1b1a:	f7 01       	movw	r30, r14
    1b1c:	80 81       	ld	r24, Z
    1b1e:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1b22:	af 81       	ldd	r26, Y+7	; 0x07
    1b24:	b8 85       	ldd	r27, Y+8	; 0x08
    1b26:	1a 96       	adiw	r26, 0x0a	; 10
    1b28:	8c 93       	st	X, r24
  packet_payload[11] = SVIT_check_V_critical( svit[CDH_IB].name );
    1b2a:	00 ee       	ldi	r16, 0xE0	; 224
    1b2c:	14 e0       	ldi	r17, 0x04	; 4
    1b2e:	f8 01       	movw	r30, r16
    1b30:	80 81       	ld	r24, Z
    1b32:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1b36:	af 81       	ldd	r26, Y+7	; 0x07
    1b38:	b8 85       	ldd	r27, Y+8	; 0x08
    1b3a:	1b 96       	adiw	r26, 0x0b	; 11
    1b3c:	8c 93       	st	X, r24
  packet_payload[12] = SVIT_check_V_critical( svit[HEATER_1].name );
    1b3e:	ea ef       	ldi	r30, 0xFA	; 250
    1b40:	f4 e0       	ldi	r31, 0x04	; 4
    1b42:	80 81       	ld	r24, Z
    1b44:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1b48:	af 81       	ldd	r26, Y+7	; 0x07
    1b4a:	b8 85       	ldd	r27, Y+8	; 0x08
    1b4c:	1c 96       	adiw	r26, 0x0c	; 12
    1b4e:	8c 93       	st	X, r24
  packet_payload[13] = SVIT_check_V_critical( svit[HEATER_2].name );
    1b50:	74 e1       	ldi	r23, 0x14	; 20
    1b52:	47 2e       	mov	r4, r23
    1b54:	75 e0       	ldi	r23, 0x05	; 5
    1b56:	57 2e       	mov	r5, r23
    1b58:	f2 01       	movw	r30, r4
    1b5a:	80 81       	ld	r24, Z
    1b5c:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1b60:	af 81       	ldd	r26, Y+7	; 0x07
    1b62:	b8 85       	ldd	r27, Y+8	; 0x08
    1b64:	1d 96       	adiw	r26, 0x0d	; 13
    1b66:	8c 93       	st	X, r24
  packet_payload[14] = SVIT_check_V_critical( svit[CMG].name );
    1b68:	ee e2       	ldi	r30, 0x2E	; 46
    1b6a:	2e 2e       	mov	r2, r30
    1b6c:	e5 e0       	ldi	r30, 0x05	; 5
    1b6e:	3e 2e       	mov	r3, r30
    1b70:	f1 01       	movw	r30, r2
    1b72:	80 81       	ld	r24, Z
    1b74:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1b78:	af 81       	ldd	r26, Y+7	; 0x07
    1b7a:	b8 85       	ldd	r27, Y+8	; 0x08
    1b7c:	1e 96       	adiw	r26, 0x0e	; 14
    1b7e:	8c 93       	st	X, r24
  packet_payload[15] = SVIT_check_V_critical( svit[SUN_SENSOR].name );
    1b80:	28 e4       	ldi	r18, 0x48	; 72
    1b82:	35 e0       	ldi	r19, 0x05	; 5
    1b84:	f9 01       	movw	r30, r18
    1b86:	80 81       	ld	r24, Z
    1b88:	29 83       	std	Y+1, r18	; 0x01
    1b8a:	3a 83       	std	Y+2, r19	; 0x02
    1b8c:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1b90:	af 81       	ldd	r26, Y+7	; 0x07
    1b92:	b8 85       	ldd	r27, Y+8	; 0x08
    1b94:	1f 96       	adiw	r26, 0x0f	; 15
    1b96:	8c 93       	st	X, r24
  packet_payload[16] = SVIT_check_V_critical( svit[RADIO_1].name );
    1b98:	42 e6       	ldi	r20, 0x62	; 98
    1b9a:	55 e0       	ldi	r21, 0x05	; 5
    1b9c:	fa 01       	movw	r30, r20
    1b9e:	80 81       	ld	r24, Z
    1ba0:	4b 83       	std	Y+3, r20	; 0x03
    1ba2:	5c 83       	std	Y+4, r21	; 0x04
    1ba4:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1ba8:	af 81       	ldd	r26, Y+7	; 0x07
    1baa:	b8 85       	ldd	r27, Y+8	; 0x08
    1bac:	50 96       	adiw	r26, 0x10	; 16
    1bae:	8c 93       	st	X, r24
  packet_payload[17] = SVIT_check_V_critical( svit[RADIO_2].name );
    1bb0:	6c e7       	ldi	r22, 0x7C	; 124
    1bb2:	75 e0       	ldi	r23, 0x05	; 5
    1bb4:	fb 01       	movw	r30, r22
    1bb6:	80 81       	ld	r24, Z
    1bb8:	6d 83       	std	Y+5, r22	; 0x05
    1bba:	7e 83       	std	Y+6, r23	; 0x06
    1bbc:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1bc0:	af 81       	ldd	r26, Y+7	; 0x07
    1bc2:	b8 85       	ldd	r27, Y+8	; 0x08
    1bc4:	51 96       	adiw	r26, 0x11	; 17
    1bc6:	8c 93       	st	X, r24
  packet_payload[18] = SVIT_check_V_critical( svit[FOG_15V].name );
    1bc8:	ea ec       	ldi	r30, 0xCA	; 202
    1bca:	f5 e0       	ldi	r31, 0x05	; 5
    1bcc:	80 81       	ld	r24, Z
    1bce:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1bd2:	af 81       	ldd	r26, Y+7	; 0x07
    1bd4:	b8 85       	ldd	r27, Y+8	; 0x08
    1bd6:	52 96       	adiw	r26, 0x12	; 18
    1bd8:	8c 93       	st	X, r24
  packet_payload[19] = SVIT_check_V_critical( svit[FOG_5V].name );
    1bda:	e4 ee       	ldi	r30, 0xE4	; 228
    1bdc:	f5 e0       	ldi	r31, 0x05	; 5
    1bde:	80 81       	ld	r24, Z
    1be0:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1be4:	af 81       	ldd	r26, Y+7	; 0x07
    1be6:	b8 85       	ldd	r27, Y+8	; 0x08
    1be8:	53 96       	adiw	r26, 0x13	; 19
    1bea:	8c 93       	st	X, r24
  packet_payload[20] = SVIT_check_V_critical( svit[TORQUER_1].name );
    1bec:	ee ef       	ldi	r30, 0xFE	; 254
    1bee:	f5 e0       	ldi	r31, 0x05	; 5
    1bf0:	80 81       	ld	r24, Z
    1bf2:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1bf6:	af 81       	ldd	r26, Y+7	; 0x07
    1bf8:	b8 85       	ldd	r27, Y+8	; 0x08
    1bfa:	54 96       	adiw	r26, 0x14	; 20
    1bfc:	8c 93       	st	X, r24
  packet_payload[21] = SVIT_check_V_critical( svit[TORQUER_2].name );
    1bfe:	e8 e1       	ldi	r30, 0x18	; 24
    1c00:	f6 e0       	ldi	r31, 0x06	; 6
    1c02:	80 81       	ld	r24, Z
    1c04:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1c08:	af 81       	ldd	r26, Y+7	; 0x07
    1c0a:	b8 85       	ldd	r27, Y+8	; 0x08
    1c0c:	55 96       	adiw	r26, 0x15	; 21
    1c0e:	8c 93       	st	X, r24
  packet_payload[22] = SVIT_check_V_critical( svit[TORQUER_3].name );
    1c10:	e2 e3       	ldi	r30, 0x32	; 50
    1c12:	f6 e0       	ldi	r31, 0x06	; 6
    1c14:	80 81       	ld	r24, Z
    1c16:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1c1a:	af 81       	ldd	r26, Y+7	; 0x07
    1c1c:	b8 85       	ldd	r27, Y+8	; 0x08
    1c1e:	56 96       	adiw	r26, 0x16	; 22
    1c20:	8c 93       	st	X, r24
  packet_payload[23] = SVIT_check_V_critical( svit[BATTERY_1].name );
    1c22:	ec e4       	ldi	r30, 0x4C	; 76
    1c24:	f6 e0       	ldi	r31, 0x06	; 6
    1c26:	80 81       	ld	r24, Z
    1c28:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1c2c:	af 81       	ldd	r26, Y+7	; 0x07
    1c2e:	b8 85       	ldd	r27, Y+8	; 0x08
    1c30:	57 96       	adiw	r26, 0x17	; 23
    1c32:	8c 93       	st	X, r24
  packet_payload[24] = SVIT_check_V_critical( svit[BATTERY_2].name );
    1c34:	e6 e6       	ldi	r30, 0x66	; 102
    1c36:	f6 e0       	ldi	r31, 0x06	; 6
    1c38:	80 81       	ld	r24, Z
    1c3a:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1c3e:	af 81       	ldd	r26, Y+7	; 0x07
    1c40:	b8 85       	ldd	r27, Y+8	; 0x08
    1c42:	58 96       	adiw	r26, 0x18	; 24
    1c44:	8c 93       	st	X, r24
  packet_payload[25] = SVIT_check_V_critical( svit[SOLAR_FULL].name );
    1c46:	e0 e8       	ldi	r30, 0x80	; 128
    1c48:	f6 e0       	ldi	r31, 0x06	; 6
    1c4a:	80 81       	ld	r24, Z
    1c4c:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1c50:	af 81       	ldd	r26, Y+7	; 0x07
    1c52:	b8 85       	ldd	r27, Y+8	; 0x08
    1c54:	59 96       	adiw	r26, 0x19	; 25
    1c56:	8c 93       	st	X, r24
  packet_payload[26] = SVIT_check_V_critical( svit[SOLAR_1].name );
    1c58:	ea e9       	ldi	r30, 0x9A	; 154
    1c5a:	f6 e0       	ldi	r31, 0x06	; 6
    1c5c:	80 81       	ld	r24, Z
    1c5e:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1c62:	af 81       	ldd	r26, Y+7	; 0x07
    1c64:	b8 85       	ldd	r27, Y+8	; 0x08
    1c66:	5a 96       	adiw	r26, 0x1a	; 26
    1c68:	8c 93       	st	X, r24
  packet_payload[27] = SVIT_check_V_critical( svit[SOLAR_2].name );
    1c6a:	e4 eb       	ldi	r30, 0xB4	; 180
    1c6c:	f6 e0       	ldi	r31, 0x06	; 6
    1c6e:	80 81       	ld	r24, Z
    1c70:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1c74:	af 81       	ldd	r26, Y+7	; 0x07
    1c76:	b8 85       	ldd	r27, Y+8	; 0x08
    1c78:	5b 96       	adiw	r26, 0x1b	; 27
    1c7a:	8c 93       	st	X, r24
  packet_payload[28] = SVIT_check_V_critical( svit[SOLAR_3].name );
    1c7c:	ee ec       	ldi	r30, 0xCE	; 206
    1c7e:	f6 e0       	ldi	r31, 0x06	; 6
    1c80:	80 81       	ld	r24, Z
    1c82:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1c86:	af 81       	ldd	r26, Y+7	; 0x07
    1c88:	b8 85       	ldd	r27, Y+8	; 0x08
    1c8a:	5c 96       	adiw	r26, 0x1c	; 28
    1c8c:	8c 93       	st	X, r24
  packet_payload[29] = SVIT_check_V_critical( svit[SOLAR_4].name );
    1c8e:	e8 ee       	ldi	r30, 0xE8	; 232
    1c90:	f6 e0       	ldi	r31, 0x06	; 6
    1c92:	80 81       	ld	r24, Z
    1c94:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1c98:	af 81       	ldd	r26, Y+7	; 0x07
    1c9a:	b8 85       	ldd	r27, Y+8	; 0x08
    1c9c:	5d 96       	adiw	r26, 0x1d	; 29
    1c9e:	8c 93       	st	X, r24
  packet_payload[30] = SVIT_check_V_critical( svit[SOLAR_5].name );
    1ca0:	e2 e0       	ldi	r30, 0x02	; 2
    1ca2:	f7 e0       	ldi	r31, 0x07	; 7
    1ca4:	80 81       	ld	r24, Z
    1ca6:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1caa:	af 81       	ldd	r26, Y+7	; 0x07
    1cac:	b8 85       	ldd	r27, Y+8	; 0x08
    1cae:	5e 96       	adiw	r26, 0x1e	; 30
    1cb0:	8c 93       	st	X, r24
  packet_payload[31] = SVIT_check_V_critical( svit[SOLAR_6].name );
    1cb2:	ec e1       	ldi	r30, 0x1C	; 28
    1cb4:	f7 e0       	ldi	r31, 0x07	; 7
    1cb6:	80 81       	ld	r24, Z
    1cb8:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1cbc:	af 81       	ldd	r26, Y+7	; 0x07
    1cbe:	b8 85       	ldd	r27, Y+8	; 0x08
    1cc0:	5f 96       	adiw	r26, 0x1f	; 31
    1cc2:	8c 93       	st	X, r24
  packet_payload[32] = SVIT_check_V_critical( svit[SOLAR_7].name );
    1cc4:	e6 e3       	ldi	r30, 0x36	; 54
    1cc6:	f7 e0       	ldi	r31, 0x07	; 7
    1cc8:	80 81       	ld	r24, Z
    1cca:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1cce:	af 81       	ldd	r26, Y+7	; 0x07
    1cd0:	b8 85       	ldd	r27, Y+8	; 0x08
    1cd2:	90 96       	adiw	r26, 0x20	; 32
    1cd4:	8c 93       	st	X, r24
  packet_payload[33] = SVIT_check_V_critical( svit[SOLAR_8].name );
    1cd6:	e0 e5       	ldi	r30, 0x50	; 80
    1cd8:	f7 e0       	ldi	r31, 0x07	; 7
    1cda:	80 81       	ld	r24, Z
    1cdc:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1ce0:	af 81       	ldd	r26, Y+7	; 0x07
    1ce2:	b8 85       	ldd	r27, Y+8	; 0x08
    1ce4:	91 96       	adiw	r26, 0x21	; 33
    1ce6:	8c 93       	st	X, r24
  packet_payload[34] = SVIT_check_V_critical( svit[SOLAR_9].name );
    1ce8:	ea e6       	ldi	r30, 0x6A	; 106
    1cea:	f7 e0       	ldi	r31, 0x07	; 7
    1cec:	80 81       	ld	r24, Z
    1cee:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1cf2:	af 81       	ldd	r26, Y+7	; 0x07
    1cf4:	b8 85       	ldd	r27, Y+8	; 0x08
    1cf6:	92 96       	adiw	r26, 0x22	; 34
    1cf8:	8c 93       	st	X, r24
  packet_payload[35] = SVIT_check_V_critical( svit[SOLAR_10].name );
    1cfa:	e4 e8       	ldi	r30, 0x84	; 132
    1cfc:	f7 e0       	ldi	r31, 0x07	; 7
    1cfe:	80 81       	ld	r24, Z
    1d00:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1d04:	af 81       	ldd	r26, Y+7	; 0x07
    1d06:	b8 85       	ldd	r27, Y+8	; 0x08
    1d08:	93 96       	adiw	r26, 0x23	; 35
    1d0a:	8c 93       	st	X, r24
  packet_payload[36] = SVIT_check_V_critical( svit[SOLAR_11].name );
    1d0c:	ee e9       	ldi	r30, 0x9E	; 158
    1d0e:	f7 e0       	ldi	r31, 0x07	; 7
    1d10:	80 81       	ld	r24, Z
    1d12:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1d16:	af 81       	ldd	r26, Y+7	; 0x07
    1d18:	b8 85       	ldd	r27, Y+8	; 0x08
    1d1a:	94 96       	adiw	r26, 0x24	; 36
    1d1c:	8c 93       	st	X, r24
  packet_payload[37] = SVIT_check_V_critical( svit[SOLAR_12].name );
    1d1e:	e8 eb       	ldi	r30, 0xB8	; 184
    1d20:	f7 e0       	ldi	r31, 0x07	; 7
    1d22:	80 81       	ld	r24, Z
    1d24:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1d28:	af 81       	ldd	r26, Y+7	; 0x07
    1d2a:	b8 85       	ldd	r27, Y+8	; 0x08
    1d2c:	95 96       	adiw	r26, 0x25	; 37
    1d2e:	8c 93       	st	X, r24
  packet_payload[38] = SVIT_check_V_critical( svit[POWER_BOARD].name );
    1d30:	80 91 d2 07 	lds	r24, 0x07D2
    1d34:	0e 94 83 08 	call	0x1106	; 0x1106 <SVIT_check_V_critical>
    1d38:	ef 81       	ldd	r30, Y+7	; 0x07
    1d3a:	f8 85       	ldd	r31, Y+8	; 0x08
    1d3c:	86 a3       	std	Z+38, r24	; 0x26
  //uint8_t voltage_error1;
  //uint8_t voltage_error2;
  //uint8_t voltage_error3;
  //uint8_t voltage_error4;
 
  packet_payload[39] = 0;
    1d3e:	17 a2       	std	Z+39, r1	; 0x27
  packet_payload[40] = 0;
    1d40:	10 a6       	std	Z+40, r1	; 0x28
  packet_payload[41] = 0;
    1d42:	11 a6       	std	Z+41, r1	; 0x29
  packet_payload[42] = 0;
    1d44:	12 a6       	std	Z+42, r1	; 0x2a
  packet_payload[43] = 0;
    1d46:	13 a6       	std	Z+43, r1	; 0x2b

  // current values (raw ADC output)
  packet_payload[44] = SVIT_check_I_critical( svit[SPECTROMETER].name );
    1d48:	d3 01       	movw	r26, r6
    1d4a:	8c 91       	ld	r24, X
    1d4c:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1d50:	ef 81       	ldd	r30, Y+7	; 0x07
    1d52:	f8 85       	ldd	r31, Y+8	; 0x08
    1d54:	84 a7       	std	Z+44, r24	; 0x2c
  packet_payload[45] = SVIT_check_I_critical( svit[STAR_TRACKER].name );
    1d56:	d4 01       	movw	r26, r8
    1d58:	8c 91       	ld	r24, X
    1d5a:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1d5e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d60:	f8 85       	ldd	r31, Y+8	; 0x08
    1d62:	85 a7       	std	Z+45, r24	; 0x2d
  packet_payload[46] = SVIT_check_I_critical( svit[FC_5V].name );
    1d64:	d5 01       	movw	r26, r10
    1d66:	8c 91       	ld	r24, X
    1d68:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1d6c:	ef 81       	ldd	r30, Y+7	; 0x07
    1d6e:	f8 85       	ldd	r31, Y+8	; 0x08
    1d70:	86 a7       	std	Z+46, r24	; 0x2e
  packet_payload[47] = SVIT_check_I_critical( svit[FC_3_3V].name );
    1d72:	d6 01       	movw	r26, r12
    1d74:	8c 91       	ld	r24, X
    1d76:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1d7a:	ef 81       	ldd	r30, Y+7	; 0x07
    1d7c:	f8 85       	ldd	r31, Y+8	; 0x08
    1d7e:	87 a7       	std	Z+47, r24	; 0x2f
  packet_payload[48] = SVIT_check_I_critical( svit[GPS_1].name );
    1d80:	d7 01       	movw	r26, r14
    1d82:	8c 91       	ld	r24, X
    1d84:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1d88:	ef 81       	ldd	r30, Y+7	; 0x07
    1d8a:	f8 85       	ldd	r31, Y+8	; 0x08
    1d8c:	80 ab       	std	Z+48, r24	; 0x30
  packet_payload[49] = SVIT_check_I_critical( svit[CDH_IB].name );
    1d8e:	d8 01       	movw	r26, r16
    1d90:	8c 91       	ld	r24, X
    1d92:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1d96:	ef 81       	ldd	r30, Y+7	; 0x07
    1d98:	f8 85       	ldd	r31, Y+8	; 0x08
    1d9a:	81 ab       	std	Z+49, r24	; 0x31
  packet_payload[50] = SVIT_check_I_critical( svit[HEATER_1].name );
    1d9c:	aa ef       	ldi	r26, 0xFA	; 250
    1d9e:	b4 e0       	ldi	r27, 0x04	; 4
    1da0:	8c 91       	ld	r24, X
    1da2:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1da6:	ef 81       	ldd	r30, Y+7	; 0x07
    1da8:	f8 85       	ldd	r31, Y+8	; 0x08
    1daa:	82 ab       	std	Z+50, r24	; 0x32
  packet_payload[51] = SVIT_check_I_critical( svit[HEATER_2].name );
    1dac:	d2 01       	movw	r26, r4
    1dae:	8c 91       	ld	r24, X
    1db0:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1db4:	ef 81       	ldd	r30, Y+7	; 0x07
    1db6:	f8 85       	ldd	r31, Y+8	; 0x08
    1db8:	83 ab       	std	Z+51, r24	; 0x33
  packet_payload[52] = SVIT_check_I_critical( svit[CMG].name );
    1dba:	d1 01       	movw	r26, r2
    1dbc:	8c 91       	ld	r24, X
    1dbe:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1dc2:	ef 81       	ldd	r30, Y+7	; 0x07
    1dc4:	f8 85       	ldd	r31, Y+8	; 0x08
    1dc6:	84 ab       	std	Z+52, r24	; 0x34
  packet_payload[53] = SVIT_check_I_critical( svit[SUN_SENSOR].name );
    1dc8:	29 81       	ldd	r18, Y+1	; 0x01
    1dca:	3a 81       	ldd	r19, Y+2	; 0x02
    1dcc:	d9 01       	movw	r26, r18
    1dce:	8c 91       	ld	r24, X
    1dd0:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1dd4:	ef 81       	ldd	r30, Y+7	; 0x07
    1dd6:	f8 85       	ldd	r31, Y+8	; 0x08
    1dd8:	85 ab       	std	Z+53, r24	; 0x35
  packet_payload[54] = SVIT_check_I_critical( svit[RADIO_1].name );
    1dda:	4b 81       	ldd	r20, Y+3	; 0x03
    1ddc:	5c 81       	ldd	r21, Y+4	; 0x04
    1dde:	da 01       	movw	r26, r20
    1de0:	8c 91       	ld	r24, X
    1de2:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1de6:	ef 81       	ldd	r30, Y+7	; 0x07
    1de8:	f8 85       	ldd	r31, Y+8	; 0x08
    1dea:	86 ab       	std	Z+54, r24	; 0x36
  packet_payload[55] = SVIT_check_I_critical( svit[RADIO_2].name );
    1dec:	6d 81       	ldd	r22, Y+5	; 0x05
    1dee:	7e 81       	ldd	r23, Y+6	; 0x06
    1df0:	db 01       	movw	r26, r22
    1df2:	8c 91       	ld	r24, X
    1df4:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1df8:	ef 81       	ldd	r30, Y+7	; 0x07
    1dfa:	f8 85       	ldd	r31, Y+8	; 0x08
    1dfc:	87 ab       	std	Z+55, r24	; 0x37
  packet_payload[56] = SVIT_check_I_critical( svit[FOG_15V].name );
    1dfe:	aa ec       	ldi	r26, 0xCA	; 202
    1e00:	b5 e0       	ldi	r27, 0x05	; 5
    1e02:	8c 91       	ld	r24, X
    1e04:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1e08:	ef 81       	ldd	r30, Y+7	; 0x07
    1e0a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e0c:	80 af       	std	Z+56, r24	; 0x38
  packet_payload[57] = SVIT_check_I_critical( svit[FOG_5V].name );
    1e0e:	a4 ee       	ldi	r26, 0xE4	; 228
    1e10:	b5 e0       	ldi	r27, 0x05	; 5
    1e12:	8c 91       	ld	r24, X
    1e14:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1e18:	ef 81       	ldd	r30, Y+7	; 0x07
    1e1a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e1c:	81 af       	std	Z+57, r24	; 0x39
  packet_payload[58] = SVIT_check_I_critical( svit[TORQUER_1].name );
    1e1e:	ae ef       	ldi	r26, 0xFE	; 254
    1e20:	b5 e0       	ldi	r27, 0x05	; 5
    1e22:	8c 91       	ld	r24, X
    1e24:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1e28:	ef 81       	ldd	r30, Y+7	; 0x07
    1e2a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e2c:	82 af       	std	Z+58, r24	; 0x3a
  packet_payload[59] = SVIT_check_I_critical( svit[TORQUER_2].name );
    1e2e:	a8 e1       	ldi	r26, 0x18	; 24
    1e30:	b6 e0       	ldi	r27, 0x06	; 6
    1e32:	8c 91       	ld	r24, X
    1e34:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1e38:	ef 81       	ldd	r30, Y+7	; 0x07
    1e3a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e3c:	83 af       	std	Z+59, r24	; 0x3b
  packet_payload[60] = SVIT_check_I_critical( svit[TORQUER_3].name );
    1e3e:	a2 e3       	ldi	r26, 0x32	; 50
    1e40:	b6 e0       	ldi	r27, 0x06	; 6
    1e42:	8c 91       	ld	r24, X
    1e44:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1e48:	ef 81       	ldd	r30, Y+7	; 0x07
    1e4a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e4c:	84 af       	std	Z+60, r24	; 0x3c
  packet_payload[61] = SVIT_check_I_critical( svit[BATTERY_1].name );
    1e4e:	ac e4       	ldi	r26, 0x4C	; 76
    1e50:	b6 e0       	ldi	r27, 0x06	; 6
    1e52:	8c 91       	ld	r24, X
    1e54:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1e58:	ef 81       	ldd	r30, Y+7	; 0x07
    1e5a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e5c:	85 af       	std	Z+61, r24	; 0x3d
  packet_payload[62] = SVIT_check_I_critical( svit[BATTERY_2].name );
    1e5e:	a6 e6       	ldi	r26, 0x66	; 102
    1e60:	b6 e0       	ldi	r27, 0x06	; 6
    1e62:	8c 91       	ld	r24, X
    1e64:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1e68:	ef 81       	ldd	r30, Y+7	; 0x07
    1e6a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e6c:	86 af       	std	Z+62, r24	; 0x3e
  packet_payload[63] = SVIT_check_I_critical( svit[SOLAR_FULL].name );
    1e6e:	a0 e8       	ldi	r26, 0x80	; 128
    1e70:	b6 e0       	ldi	r27, 0x06	; 6
    1e72:	8c 91       	ld	r24, X
    1e74:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1e78:	ef 81       	ldd	r30, Y+7	; 0x07
    1e7a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e7c:	87 af       	std	Z+63, r24	; 0x3f
  packet_payload[64] = SVIT_check_I_critical( svit[SOLAR_1].name );
    1e7e:	aa e9       	ldi	r26, 0x9A	; 154
    1e80:	b6 e0       	ldi	r27, 0x06	; 6
    1e82:	8c 91       	ld	r24, X
    1e84:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1e88:	ef 81       	ldd	r30, Y+7	; 0x07
    1e8a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e8c:	e0 5c       	subi	r30, 0xC0	; 192
    1e8e:	ff 4f       	sbci	r31, 0xFF	; 255
    1e90:	80 83       	st	Z, r24
  packet_payload[65] = SVIT_check_I_critical( svit[SOLAR_2].name );
    1e92:	e4 eb       	ldi	r30, 0xB4	; 180
    1e94:	f6 e0       	ldi	r31, 0x06	; 6
    1e96:	80 81       	ld	r24, Z
    1e98:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1e9c:	ef 81       	ldd	r30, Y+7	; 0x07
    1e9e:	f8 85       	ldd	r31, Y+8	; 0x08
    1ea0:	ef 5b       	subi	r30, 0xBF	; 191
    1ea2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ea4:	80 83       	st	Z, r24
  packet_payload[66] = SVIT_check_I_critical( svit[SOLAR_3].name );
    1ea6:	ae ec       	ldi	r26, 0xCE	; 206
    1ea8:	b6 e0       	ldi	r27, 0x06	; 6
    1eaa:	8c 91       	ld	r24, X
    1eac:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1eb0:	ef 81       	ldd	r30, Y+7	; 0x07
    1eb2:	f8 85       	ldd	r31, Y+8	; 0x08
    1eb4:	ee 5b       	subi	r30, 0xBE	; 190
    1eb6:	ff 4f       	sbci	r31, 0xFF	; 255
    1eb8:	80 83       	st	Z, r24
  packet_payload[67] = SVIT_check_I_critical( svit[SOLAR_4].name );
    1eba:	e8 ee       	ldi	r30, 0xE8	; 232
    1ebc:	f6 e0       	ldi	r31, 0x06	; 6
    1ebe:	80 81       	ld	r24, Z
    1ec0:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1ec4:	ef 81       	ldd	r30, Y+7	; 0x07
    1ec6:	f8 85       	ldd	r31, Y+8	; 0x08
    1ec8:	ed 5b       	subi	r30, 0xBD	; 189
    1eca:	ff 4f       	sbci	r31, 0xFF	; 255
    1ecc:	80 83       	st	Z, r24
  packet_payload[68] = SVIT_check_I_critical( svit[SOLAR_5].name );
    1ece:	a2 e0       	ldi	r26, 0x02	; 2
    1ed0:	b7 e0       	ldi	r27, 0x07	; 7
    1ed2:	8c 91       	ld	r24, X
    1ed4:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1ed8:	ef 81       	ldd	r30, Y+7	; 0x07
    1eda:	f8 85       	ldd	r31, Y+8	; 0x08
    1edc:	ec 5b       	subi	r30, 0xBC	; 188
    1ede:	ff 4f       	sbci	r31, 0xFF	; 255
    1ee0:	80 83       	st	Z, r24
  packet_payload[69] = SVIT_check_I_critical( svit[SOLAR_6].name );
    1ee2:	ec e1       	ldi	r30, 0x1C	; 28
    1ee4:	f7 e0       	ldi	r31, 0x07	; 7
    1ee6:	80 81       	ld	r24, Z
    1ee8:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1eec:	ef 81       	ldd	r30, Y+7	; 0x07
    1eee:	f8 85       	ldd	r31, Y+8	; 0x08
    1ef0:	eb 5b       	subi	r30, 0xBB	; 187
    1ef2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ef4:	80 83       	st	Z, r24
  packet_payload[70] = SVIT_check_I_critical( svit[SOLAR_7].name );
    1ef6:	a6 e3       	ldi	r26, 0x36	; 54
    1ef8:	b7 e0       	ldi	r27, 0x07	; 7
    1efa:	8c 91       	ld	r24, X
    1efc:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1f00:	ef 81       	ldd	r30, Y+7	; 0x07
    1f02:	f8 85       	ldd	r31, Y+8	; 0x08
    1f04:	ea 5b       	subi	r30, 0xBA	; 186
    1f06:	ff 4f       	sbci	r31, 0xFF	; 255
    1f08:	80 83       	st	Z, r24
  packet_payload[71] = SVIT_check_I_critical( svit[SOLAR_8].name );
    1f0a:	e0 e5       	ldi	r30, 0x50	; 80
    1f0c:	f7 e0       	ldi	r31, 0x07	; 7
    1f0e:	80 81       	ld	r24, Z
    1f10:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1f14:	ef 81       	ldd	r30, Y+7	; 0x07
    1f16:	f8 85       	ldd	r31, Y+8	; 0x08
    1f18:	e9 5b       	subi	r30, 0xB9	; 185
    1f1a:	ff 4f       	sbci	r31, 0xFF	; 255
    1f1c:	80 83       	st	Z, r24
  packet_payload[72] = SVIT_check_I_critical( svit[SOLAR_9].name );
    1f1e:	aa e6       	ldi	r26, 0x6A	; 106
    1f20:	b7 e0       	ldi	r27, 0x07	; 7
    1f22:	8c 91       	ld	r24, X
    1f24:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1f28:	ef 81       	ldd	r30, Y+7	; 0x07
    1f2a:	f8 85       	ldd	r31, Y+8	; 0x08
    1f2c:	e8 5b       	subi	r30, 0xB8	; 184
    1f2e:	ff 4f       	sbci	r31, 0xFF	; 255
    1f30:	80 83       	st	Z, r24
  packet_payload[73] = SVIT_check_I_critical( svit[SOLAR_10].name );
    1f32:	e4 e8       	ldi	r30, 0x84	; 132
    1f34:	f7 e0       	ldi	r31, 0x07	; 7
    1f36:	80 81       	ld	r24, Z
    1f38:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1f3c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f3e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f40:	e7 5b       	subi	r30, 0xB7	; 183
    1f42:	ff 4f       	sbci	r31, 0xFF	; 255
    1f44:	80 83       	st	Z, r24
  packet_payload[74] = SVIT_check_I_critical( svit[SOLAR_11].name );
    1f46:	ae e9       	ldi	r26, 0x9E	; 158
    1f48:	b7 e0       	ldi	r27, 0x07	; 7
    1f4a:	8c 91       	ld	r24, X
    1f4c:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1f50:	ef 81       	ldd	r30, Y+7	; 0x07
    1f52:	f8 85       	ldd	r31, Y+8	; 0x08
    1f54:	e6 5b       	subi	r30, 0xB6	; 182
    1f56:	ff 4f       	sbci	r31, 0xFF	; 255
    1f58:	80 83       	st	Z, r24
  packet_payload[75] = SVIT_check_I_critical( svit[SOLAR_12].name );
    1f5a:	e8 eb       	ldi	r30, 0xB8	; 184
    1f5c:	f7 e0       	ldi	r31, 0x07	; 7
    1f5e:	80 81       	ld	r24, Z
    1f60:	0e 94 74 08 	call	0x10e8	; 0x10e8 <SVIT_check_I_critical>
    1f64:	ef 81       	ldd	r30, Y+7	; 0x07
    1f66:	f8 85       	ldd	r31, Y+8	; 0x08
    1f68:	e5 5b       	subi	r30, 0xB5	; 181
    1f6a:	ff 4f       	sbci	r31, 0xFF	; 255
    1f6c:	80 83       	st	Z, r24
  packet_payload[76] = 0xFF;//SVIT_check_I_critical( svit[POWER_BOARD].name );
    1f6e:	ef 81       	ldd	r30, Y+7	; 0x07
    1f70:	f8 85       	ldd	r31, Y+8	; 0x08
    1f72:	e4 5b       	subi	r30, 0xB4	; 180
    1f74:	ff 4f       	sbci	r31, 0xFF	; 255
    1f76:	8f ef       	ldi	r24, 0xFF	; 255
    1f78:	80 83       	st	Z, r24
  //uint8_t current_error1;
  //uint8_t current_error2;
  //uint8_t current_error3;
  //uint8_t current_error4;

  packet_payload[77] = batt1_voltage;//V_ack_change();
    1f7a:	ef 81       	ldd	r30, Y+7	; 0x07
    1f7c:	f8 85       	ldd	r31, Y+8	; 0x08
    1f7e:	e3 5b       	subi	r30, 0xB3	; 179
    1f80:	ff 4f       	sbci	r31, 0xFF	; 255
    1f82:	90 91 33 0a 	lds	r25, 0x0A33
    1f86:	90 83       	st	Z, r25
  packet_payload[78] = soc;//soc;// I_ack_change();
    1f88:	ef 81       	ldd	r30, Y+7	; 0x07
    1f8a:	f8 85       	ldd	r31, Y+8	; 0x08
    1f8c:	e2 5b       	subi	r30, 0xB2	; 178
    1f8e:	ff 4f       	sbci	r31, 0xFF	; 255
    1f90:	90 91 71 10 	lds	r25, 0x1071
    1f94:	90 83       	st	Z, r25
  packet_payload[79] = 0x00;//low >> 6;//safe_mode;
    1f96:	ef 81       	ldd	r30, Y+7	; 0x07
    1f98:	f8 85       	ldd	r31, Y+8	; 0x08
    1f9a:	e1 5b       	subi	r30, 0xB1	; 177
    1f9c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f9e:	10 82       	st	Z, r1
  packet_payload[80] = 0x00;//charging;
    1fa0:	ef 81       	ldd	r30, Y+7	; 0x07
    1fa2:	f8 85       	ldd	r31, Y+8	; 0x08
    1fa4:	e0 5b       	subi	r30, 0xB0	; 176
    1fa6:	ff 4f       	sbci	r31, 0xFF	; 255
    1fa8:	10 82       	st	Z, r1
  packet_payload[81] = 0x00;//chargeforward;
    1faa:	ef 81       	ldd	r30, Y+7	; 0x07
    1fac:	f8 85       	ldd	r31, Y+8	; 0x08
    1fae:	ef 5a       	subi	r30, 0xAF	; 175
    1fb0:	ff 4f       	sbci	r31, 0xFF	; 255
    1fb2:	10 82       	st	Z, r1

  // temperature values (raw ADC output)
  packet_payload[82] = debug;//average_samples( svit[STAR_TRACKER].T_samples );
    1fb4:	ef 81       	ldd	r30, Y+7	; 0x07
    1fb6:	f8 85       	ldd	r31, Y+8	; 0x08
    1fb8:	ee 5a       	subi	r30, 0xAE	; 174
    1fba:	ff 4f       	sbci	r31, 0xFF	; 255
    1fbc:	90 91 fb 07 	lds	r25, 0x07FB
    1fc0:	90 83       	st	Z, r25
  packet_payload[83] = 0xFF;//average_samples( svit[BATTERY_1].T_samples );
    1fc2:	ef 81       	ldd	r30, Y+7	; 0x07
    1fc4:	f8 85       	ldd	r31, Y+8	; 0x08
    1fc6:	ed 5a       	subi	r30, 0xAD	; 173
    1fc8:	ff 4f       	sbci	r31, 0xFF	; 255
    1fca:	80 83       	st	Z, r24
  packet_payload[84] = average_samples( svit[BATTERY_2].T_samples );
    1fcc:	8c e7       	ldi	r24, 0x7C	; 124
    1fce:	96 e0       	ldi	r25, 0x06	; 6
    1fd0:	0e 94 65 08 	call	0x10ca	; 0x10ca <average_samples>
    1fd4:	ef 81       	ldd	r30, Y+7	; 0x07
    1fd6:	f8 85       	ldd	r31, Y+8	; 0x08
    1fd8:	ec 5a       	subi	r30, 0xAC	; 172
    1fda:	ff 4f       	sbci	r31, 0xFF	; 255
    1fdc:	80 83       	st	Z, r24
  packet_payload[85] = average_samples( svit[SOLAR_1].T_samples );
    1fde:	80 eb       	ldi	r24, 0xB0	; 176
    1fe0:	96 e0       	ldi	r25, 0x06	; 6
    1fe2:	0e 94 65 08 	call	0x10ca	; 0x10ca <average_samples>
    1fe6:	ef 81       	ldd	r30, Y+7	; 0x07
    1fe8:	f8 85       	ldd	r31, Y+8	; 0x08
    1fea:	eb 5a       	subi	r30, 0xAB	; 171
    1fec:	ff 4f       	sbci	r31, 0xFF	; 255
    1fee:	80 83       	st	Z, r24
  packet_payload[86] = average_samples( svit[SOLAR_2].T_samples );
    1ff0:	8a ec       	ldi	r24, 0xCA	; 202
    1ff2:	96 e0       	ldi	r25, 0x06	; 6
    1ff4:	0e 94 65 08 	call	0x10ca	; 0x10ca <average_samples>
    1ff8:	ef 81       	ldd	r30, Y+7	; 0x07
    1ffa:	f8 85       	ldd	r31, Y+8	; 0x08
    1ffc:	ea 5a       	subi	r30, 0xAA	; 170
    1ffe:	ff 4f       	sbci	r31, 0xFF	; 255
    2000:	80 83       	st	Z, r24
  packet_payload[87] = average_samples( svit[SOLAR_3].T_samples );
    2002:	84 ee       	ldi	r24, 0xE4	; 228
    2004:	96 e0       	ldi	r25, 0x06	; 6
    2006:	0e 94 65 08 	call	0x10ca	; 0x10ca <average_samples>
    200a:	ef 81       	ldd	r30, Y+7	; 0x07
    200c:	f8 85       	ldd	r31, Y+8	; 0x08
    200e:	e9 5a       	subi	r30, 0xA9	; 169
    2010:	ff 4f       	sbci	r31, 0xFF	; 255
    2012:	80 83       	st	Z, r24
  packet_payload[88] = average_samples( svit[SOLAR_4].T_samples );
    2014:	8e ef       	ldi	r24, 0xFE	; 254
    2016:	96 e0       	ldi	r25, 0x06	; 6
    2018:	0e 94 65 08 	call	0x10ca	; 0x10ca <average_samples>
    201c:	ef 81       	ldd	r30, Y+7	; 0x07
    201e:	f8 85       	ldd	r31, Y+8	; 0x08
    2020:	e8 5a       	subi	r30, 0xA8	; 168
    2022:	ff 4f       	sbci	r31, 0xFF	; 255
    2024:	80 83       	st	Z, r24
  packet_payload[89] = average_samples( svit[SOLAR_5].T_samples );
    2026:	88 e1       	ldi	r24, 0x18	; 24
    2028:	97 e0       	ldi	r25, 0x07	; 7
    202a:	0e 94 65 08 	call	0x10ca	; 0x10ca <average_samples>
    202e:	ef 81       	ldd	r30, Y+7	; 0x07
    2030:	f8 85       	ldd	r31, Y+8	; 0x08
    2032:	e7 5a       	subi	r30, 0xA7	; 167
    2034:	ff 4f       	sbci	r31, 0xFF	; 255
    2036:	80 83       	st	Z, r24
  packet_payload[90] = average_samples( svit[SOLAR_9].T_samples );
    2038:	80 e8       	ldi	r24, 0x80	; 128
    203a:	97 e0       	ldi	r25, 0x07	; 7
    203c:	0e 94 65 08 	call	0x10ca	; 0x10ca <average_samples>
    2040:	ef 81       	ldd	r30, Y+7	; 0x07
    2042:	f8 85       	ldd	r31, Y+8	; 0x08
    2044:	e6 5a       	subi	r30, 0xA6	; 166
    2046:	ff 4f       	sbci	r31, 0xFF	; 255
    2048:	80 83       	st	Z, r24
  packet_payload[91] = average_samples( svit[POWER_BOARD].T_samples );
    204a:	88 ee       	ldi	r24, 0xE8	; 232
    204c:	97 e0       	ldi	r25, 0x07	; 7
    204e:	0e 94 65 08 	call	0x10ca	; 0x10ca <average_samples>
    2052:	ef 81       	ldd	r30, Y+7	; 0x07
    2054:	f8 85       	ldd	r31, Y+8	; 0x08
    2056:	e5 5a       	subi	r30, 0xA5	; 165
    2058:	ff 4f       	sbci	r31, 0xFF	; 255
    205a:	80 83       	st	Z, r24

uint8_t V_ack_change( void )
{
  uint8_t temp;

  temp = V_upper_val_change;
    205c:	80 91 43 0c 	lds	r24, 0x0C43
  V_upper_val_change = 0;
    2060:	10 92 43 0c 	sts	0x0C43, r1
  //uint8_t temperature_error1;
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
    2064:	ef 81       	ldd	r30, Y+7	; 0x07
    2066:	f8 85       	ldd	r31, Y+8	; 0x08
    2068:	e4 5a       	subi	r30, 0xA4	; 164
    206a:	ff 4f       	sbci	r31, 0xFF	; 255
    206c:	80 83       	st	Z, r24

uint8_t I_ack_change( void )
{
  uint8_t temp;

  temp = I_upper_val_change;
    206e:	80 91 3e 0c 	lds	r24, 0x0C3E
  I_upper_val_change = 0;
    2072:	10 92 3e 0c 	sts	0x0C3E, r1
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
  packet_payload[93] = I_ack_change();
    2076:	ef 81       	ldd	r30, Y+7	; 0x07
    2078:	f8 85       	ldd	r31, Y+8	; 0x08
    207a:	e3 5a       	subi	r30, 0xA3	; 163
    207c:	ff 4f       	sbci	r31, 0xFF	; 255
    207e:	80 83       	st	Z, r24
}
    2080:	28 96       	adiw	r28, 0x08	; 8
    2082:	0f b6       	in	r0, 0x3f	; 63
    2084:	f8 94       	cli
    2086:	de bf       	out	0x3e, r29	; 62
    2088:	0f be       	out	0x3f, r0	; 63
    208a:	cd bf       	out	0x3d, r28	; 61
    208c:	df 91       	pop	r29
    208e:	cf 91       	pop	r28
    2090:	1f 91       	pop	r17
    2092:	0f 91       	pop	r16
    2094:	ff 90       	pop	r15
    2096:	ef 90       	pop	r14
    2098:	df 90       	pop	r13
    209a:	cf 90       	pop	r12
    209c:	bf 90       	pop	r11
    209e:	af 90       	pop	r10
    20a0:	9f 90       	pop	r9
    20a2:	8f 90       	pop	r8
    20a4:	7f 90       	pop	r7
    20a6:	6f 90       	pop	r6
    20a8:	5f 90       	pop	r5
    20aa:	4f 90       	pop	r4
    20ac:	3f 90       	pop	r3
    20ae:	2f 90       	pop	r2
    20b0:	08 95       	ret

000020b2 <transmit_packet>:

void transmit_packet( uint8_t uart, uint8_t packet_type, uint8_t ack_command )
{
    20b2:	6f 92       	push	r6
    20b4:	7f 92       	push	r7
    20b6:	8f 92       	push	r8
    20b8:	9f 92       	push	r9
    20ba:	bf 92       	push	r11
    20bc:	cf 92       	push	r12
    20be:	df 92       	push	r13
    20c0:	ef 92       	push	r14
    20c2:	ff 92       	push	r15
    20c4:	0f 93       	push	r16
    20c6:	1f 93       	push	r17
    20c8:	cf 93       	push	r28
    20ca:	df 93       	push	r29
    20cc:	b8 2e       	mov	r11, r24
  uint8_t VCP_tx_status;

  switch( packet_type )
    20ce:	61 30       	cpi	r22, 0x01	; 1
    20d0:	b9 f0       	breq	.+46     	; 0x2100 <transmit_packet+0x4e>
    20d2:	20 f0       	brcs	.+8      	; 0x20dc <transmit_packet+0x2a>
    20d4:	62 30       	cpi	r22, 0x02	; 2
    20d6:	09 f0       	breq	.+2      	; 0x20da <transmit_packet+0x28>
    20d8:	8b c0       	rjmp	.+278    	; 0x21f0 <transmit_packet+0x13e>
    20da:	22 c0       	rjmp	.+68     	; 0x2120 <transmit_packet+0x6e>
  {
    case VCP_POWER_TELEMETRY:
      construct_telemetry_packet( tel_packet_payload[uart] );
    20dc:	c8 2f       	mov	r28, r24
    20de:	d0 e0       	ldi	r29, 0x00	; 0
    20e0:	2f ef       	ldi	r18, 0xFF	; 255
    20e2:	82 9f       	mul	r24, r18
    20e4:	c0 01       	movw	r24, r0
    20e6:	11 24       	eor	r1, r1
    20e8:	8d 58       	subi	r24, 0x8D	; 141
    20ea:	91 4f       	sbci	r25, 0xF1	; 241
    20ec:	0e 94 c2 0c 	call	0x1984	; 0x1984 <construct_telemetry_packet>
      tel_packet_payload_size[uart] = 96;
    20f0:	fe 01       	movw	r30, r28
    20f2:	ee 0f       	add	r30, r30
    20f4:	ff 1f       	adc	r31, r31
    20f6:	e3 50       	subi	r30, 0x03	; 3
    20f8:	f8 4f       	sbci	r31, 0xF8	; 248
    20fa:	80 e6       	ldi	r24, 0x60	; 96
    20fc:	90 e0       	ldi	r25, 0x00	; 0
    20fe:	21 c0       	rjmp	.+66     	; 0x2142 <transmit_packet+0x90>
      break;
    case VCP_INVALID_COMMAND:
      tel_packet_payload[uart][0] = VCP_INVALID_COMMAND;
    2100:	e8 2f       	mov	r30, r24
    2102:	f0 e0       	ldi	r31, 0x00	; 0
    2104:	8f ef       	ldi	r24, 0xFF	; 255
    2106:	b8 9e       	mul	r11, r24
    2108:	d0 01       	movw	r26, r0
    210a:	11 24       	eor	r1, r1
    210c:	ad 58       	subi	r26, 0x8D	; 141
    210e:	b1 4f       	sbci	r27, 0xF1	; 241
    2110:	6c 93       	st	X, r22
      tel_packet_payload_size[uart] = 1;
    2112:	ee 0f       	add	r30, r30
    2114:	ff 1f       	adc	r31, r31
    2116:	e3 50       	subi	r30, 0x03	; 3
    2118:	f8 4f       	sbci	r31, 0xF8	; 248
    211a:	81 e0       	ldi	r24, 0x01	; 1
    211c:	90 e0       	ldi	r25, 0x00	; 0
    211e:	11 c0       	rjmp	.+34     	; 0x2142 <transmit_packet+0x90>
      break;
    case VCP_ACK:
      tel_packet_payload[uart][0] = VCP_ACK;
    2120:	e8 2f       	mov	r30, r24
    2122:	f0 e0       	ldi	r31, 0x00	; 0
    2124:	2f ef       	ldi	r18, 0xFF	; 255
    2126:	82 9f       	mul	r24, r18
    2128:	d0 01       	movw	r26, r0
    212a:	11 24       	eor	r1, r1
    212c:	ad 58       	subi	r26, 0x8D	; 141
    212e:	b1 4f       	sbci	r27, 0xF1	; 241
    2130:	6c 93       	st	X, r22
      tel_packet_payload[uart][1] = ack_command;
    2132:	11 96       	adiw	r26, 0x01	; 1
    2134:	4c 93       	st	X, r20
      tel_packet_payload_size[uart] = 2;
    2136:	ee 0f       	add	r30, r30
    2138:	ff 1f       	adc	r31, r31
    213a:	e3 50       	subi	r30, 0x03	; 3
    213c:	f8 4f       	sbci	r31, 0xF8	; 248
    213e:	82 e0       	ldi	r24, 0x02	; 2
    2140:	90 e0       	ldi	r25, 0x00	; 0
    2142:	91 83       	std	Z+1, r25	; 0x01
    2144:	80 83       	st	Z, r24
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2146:	8b 2c       	mov	r8, r11
    2148:	91 2c       	mov	r9, r1
    214a:	8f ef       	ldi	r24, 0xFF	; 255
    214c:	b8 9e       	mul	r11, r24
    214e:	70 01       	movw	r14, r0
    2150:	11 24       	eor	r1, r1
    2152:	e7 01       	movw	r28, r14
    2154:	c2 5c       	subi	r28, 0xC2	; 194
    2156:	d5 4f       	sbci	r29, 0xF5	; 245
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
    2158:	64 01       	movw	r12, r8
    215a:	cc 0c       	add	r12, r12
    215c:	dd 1c       	adc	r13, r13
    215e:	f6 01       	movw	r30, r12
    2160:	e3 50       	subi	r30, 0x03	; 3
    2162:	f8 4f       	sbci	r31, 0xF8	; 248
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2164:	00 81       	ld	r16, Z
    2166:	11 81       	ldd	r17, Z+1	; 0x01
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
    2168:	97 01       	movw	r18, r14
    216a:	2d 58       	subi	r18, 0x8D	; 141
    216c:	31 4f       	sbci	r19, 0xF1	; 241
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    216e:	a8 e4       	ldi	r26, 0x48	; 72
    2170:	6a 2e       	mov	r6, r26
    2172:	ae e0       	ldi	r26, 0x0E	; 14
    2174:	7a 2e       	mov	r7, r26
    2176:	6c 0c       	add	r6, r12
    2178:	7d 1c       	adc	r7, r13
    217a:	41 e0       	ldi	r20, 0x01	; 1
    217c:	b3 01       	movw	r22, r6
    217e:	ce 01       	movw	r24, r28
    2180:	0e 94 ee 09 	call	0x13dc	; 0x13dc <Create_VCP_frame>
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
                  );

  // VCP frame creation was successful
  if ( VCP_tx_status == VCP_TERM )
    2184:	81 30       	cpi	r24, 0x01	; 1
    2186:	a1 f5       	brne	.+104    	; 0x21f0 <transmit_packet+0x13e>
  {
    tel_packet_size[uart] = dest_size[uart];
    2188:	f3 01       	movw	r30, r6
    218a:	80 81       	ld	r24, Z
    218c:	91 81       	ldd	r25, Z+1	; 0x01
    218e:	f6 01       	movw	r30, r12
    2190:	eb 5c       	subi	r30, 0xCB	; 203
    2192:	fb 4f       	sbci	r31, 0xFB	; 251
    2194:	91 83       	std	Z+1, r25	; 0x01
    2196:	80 83       	st	Z, r24
    memcpy( tel_packet[uart], dest_data[uart], tel_packet_size[uart] );
    2198:	80 81       	ld	r24, Z
    219a:	91 81       	ldd	r25, Z+1	; 0x01
    219c:	97 01       	movw	r18, r14
    219e:	24 5f       	subi	r18, 0xF4	; 244
    21a0:	37 4f       	sbci	r19, 0xF7	; 247
    21a2:	ac 01       	movw	r20, r24
    21a4:	be 01       	movw	r22, r28
    21a6:	c9 01       	movw	r24, r18
    21a8:	0e 94 ef 13 	call	0x27de	; 0x27de <memcpy>
    tel_packet_index[uart] = 0;
    21ac:	f4 01       	movw	r30, r8
    21ae:	eb 5f       	subi	r30, 0xFB	; 251
    21b0:	f7 4f       	sbci	r31, 0xF7	; 247
    21b2:	10 82       	st	Z, r1
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
    21b4:	f1 e0       	ldi	r31, 0x01	; 1
    21b6:	bf 12       	cpse	r11, r31
    21b8:	06 c0       	rjmp	.+12     	; 0x21c6 <transmit_packet+0x114>
    21ba:	80 91 9b 00 	lds	r24, 0x009B
    21be:	88 23       	and	r24, r24
    21c0:	b9 f0       	breq	.+46     	; 0x21f0 <transmit_packet+0x13e>
      tx_put_byte( uart );
    21c2:	81 e0       	ldi	r24, 0x01	; 1
    21c4:	06 c0       	rjmp	.+12     	; 0x21d2 <transmit_packet+0x120>
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
    21c6:	b1 10       	cpse	r11, r1
    21c8:	13 c0       	rjmp	.+38     	; 0x21f0 <transmit_packet+0x13e>
    21ca:	8b b1       	in	r24, 0x0b	; 11
    21cc:	88 23       	and	r24, r24
    21ce:	81 f0       	breq	.+32     	; 0x21f0 <transmit_packet+0x13e>
      tx_put_byte( uart );
    21d0:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    21d2:	df 91       	pop	r29
    21d4:	cf 91       	pop	r28
    21d6:	1f 91       	pop	r17
    21d8:	0f 91       	pop	r16
    21da:	ff 90       	pop	r15
    21dc:	ef 90       	pop	r14
    21de:	df 90       	pop	r13
    21e0:	cf 90       	pop	r12
    21e2:	bf 90       	pop	r11
    21e4:	9f 90       	pop	r9
    21e6:	8f 90       	pop	r8
    21e8:	7f 90       	pop	r7
    21ea:	6f 90       	pop	r6
    tel_packet_index[uart] = 0;
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    21ec:	0c 94 bd 0c 	jmp	0x197a	; 0x197a <tx_put_byte>
  }
}
    21f0:	df 91       	pop	r29
    21f2:	cf 91       	pop	r28
    21f4:	1f 91       	pop	r17
    21f6:	0f 91       	pop	r16
    21f8:	ff 90       	pop	r15
    21fa:	ef 90       	pop	r14
    21fc:	df 90       	pop	r13
    21fe:	cf 90       	pop	r12
    2200:	bf 90       	pop	r11
    2202:	9f 90       	pop	r9
    2204:	8f 90       	pop	r8
    2206:	7f 90       	pop	r7
    2208:	6f 90       	pop	r6
    220a:	08 95       	ret

0000220c <__subsf3>:
    220c:	50 58       	subi	r21, 0x80	; 128

0000220e <__addsf3>:
    220e:	bb 27       	eor	r27, r27
    2210:	aa 27       	eor	r26, r26
    2212:	0e d0       	rcall	.+28     	; 0x2230 <__addsf3x>
    2214:	44 c1       	rjmp	.+648    	; 0x249e <__fp_round>
    2216:	35 d1       	rcall	.+618    	; 0x2482 <__fp_pscA>
    2218:	30 f0       	brcs	.+12     	; 0x2226 <__addsf3+0x18>
    221a:	3a d1       	rcall	.+628    	; 0x2490 <__fp_pscB>
    221c:	20 f0       	brcs	.+8      	; 0x2226 <__addsf3+0x18>
    221e:	31 f4       	brne	.+12     	; 0x222c <__addsf3+0x1e>
    2220:	9f 3f       	cpi	r25, 0xFF	; 255
    2222:	11 f4       	brne	.+4      	; 0x2228 <__addsf3+0x1a>
    2224:	1e f4       	brtc	.+6      	; 0x222c <__addsf3+0x1e>
    2226:	2a c1       	rjmp	.+596    	; 0x247c <__fp_nan>
    2228:	0e f4       	brtc	.+2      	; 0x222c <__addsf3+0x1e>
    222a:	e0 95       	com	r30
    222c:	e7 fb       	bst	r30, 7
    222e:	20 c1       	rjmp	.+576    	; 0x2470 <__fp_inf>

00002230 <__addsf3x>:
    2230:	e9 2f       	mov	r30, r25
    2232:	46 d1       	rcall	.+652    	; 0x24c0 <__fp_split3>
    2234:	80 f3       	brcs	.-32     	; 0x2216 <__addsf3+0x8>
    2236:	ba 17       	cp	r27, r26
    2238:	62 07       	cpc	r22, r18
    223a:	73 07       	cpc	r23, r19
    223c:	84 07       	cpc	r24, r20
    223e:	95 07       	cpc	r25, r21
    2240:	18 f0       	brcs	.+6      	; 0x2248 <__addsf3x+0x18>
    2242:	71 f4       	brne	.+28     	; 0x2260 <__addsf3x+0x30>
    2244:	9e f5       	brtc	.+102    	; 0x22ac <__addsf3x+0x7c>
    2246:	5e c1       	rjmp	.+700    	; 0x2504 <__fp_zero>
    2248:	0e f4       	brtc	.+2      	; 0x224c <__addsf3x+0x1c>
    224a:	e0 95       	com	r30
    224c:	0b 2e       	mov	r0, r27
    224e:	ba 2f       	mov	r27, r26
    2250:	a0 2d       	mov	r26, r0
    2252:	0b 01       	movw	r0, r22
    2254:	b9 01       	movw	r22, r18
    2256:	90 01       	movw	r18, r0
    2258:	0c 01       	movw	r0, r24
    225a:	ca 01       	movw	r24, r20
    225c:	a0 01       	movw	r20, r0
    225e:	11 24       	eor	r1, r1
    2260:	ff 27       	eor	r31, r31
    2262:	59 1b       	sub	r21, r25
    2264:	99 f0       	breq	.+38     	; 0x228c <__addsf3x+0x5c>
    2266:	59 3f       	cpi	r21, 0xF9	; 249
    2268:	50 f4       	brcc	.+20     	; 0x227e <__addsf3x+0x4e>
    226a:	50 3e       	cpi	r21, 0xE0	; 224
    226c:	68 f1       	brcs	.+90     	; 0x22c8 <__addsf3x+0x98>
    226e:	1a 16       	cp	r1, r26
    2270:	f0 40       	sbci	r31, 0x00	; 0
    2272:	a2 2f       	mov	r26, r18
    2274:	23 2f       	mov	r18, r19
    2276:	34 2f       	mov	r19, r20
    2278:	44 27       	eor	r20, r20
    227a:	58 5f       	subi	r21, 0xF8	; 248
    227c:	f3 cf       	rjmp	.-26     	; 0x2264 <__addsf3x+0x34>
    227e:	46 95       	lsr	r20
    2280:	37 95       	ror	r19
    2282:	27 95       	ror	r18
    2284:	a7 95       	ror	r26
    2286:	f0 40       	sbci	r31, 0x00	; 0
    2288:	53 95       	inc	r21
    228a:	c9 f7       	brne	.-14     	; 0x227e <__addsf3x+0x4e>
    228c:	7e f4       	brtc	.+30     	; 0x22ac <__addsf3x+0x7c>
    228e:	1f 16       	cp	r1, r31
    2290:	ba 0b       	sbc	r27, r26
    2292:	62 0b       	sbc	r22, r18
    2294:	73 0b       	sbc	r23, r19
    2296:	84 0b       	sbc	r24, r20
    2298:	ba f0       	brmi	.+46     	; 0x22c8 <__addsf3x+0x98>
    229a:	91 50       	subi	r25, 0x01	; 1
    229c:	a1 f0       	breq	.+40     	; 0x22c6 <__addsf3x+0x96>
    229e:	ff 0f       	add	r31, r31
    22a0:	bb 1f       	adc	r27, r27
    22a2:	66 1f       	adc	r22, r22
    22a4:	77 1f       	adc	r23, r23
    22a6:	88 1f       	adc	r24, r24
    22a8:	c2 f7       	brpl	.-16     	; 0x229a <__addsf3x+0x6a>
    22aa:	0e c0       	rjmp	.+28     	; 0x22c8 <__addsf3x+0x98>
    22ac:	ba 0f       	add	r27, r26
    22ae:	62 1f       	adc	r22, r18
    22b0:	73 1f       	adc	r23, r19
    22b2:	84 1f       	adc	r24, r20
    22b4:	48 f4       	brcc	.+18     	; 0x22c8 <__addsf3x+0x98>
    22b6:	87 95       	ror	r24
    22b8:	77 95       	ror	r23
    22ba:	67 95       	ror	r22
    22bc:	b7 95       	ror	r27
    22be:	f7 95       	ror	r31
    22c0:	9e 3f       	cpi	r25, 0xFE	; 254
    22c2:	08 f0       	brcs	.+2      	; 0x22c6 <__addsf3x+0x96>
    22c4:	b3 cf       	rjmp	.-154    	; 0x222c <__addsf3+0x1e>
    22c6:	93 95       	inc	r25
    22c8:	88 0f       	add	r24, r24
    22ca:	08 f0       	brcs	.+2      	; 0x22ce <__addsf3x+0x9e>
    22cc:	99 27       	eor	r25, r25
    22ce:	ee 0f       	add	r30, r30
    22d0:	97 95       	ror	r25
    22d2:	87 95       	ror	r24
    22d4:	08 95       	ret

000022d6 <__cmpsf2>:
    22d6:	a8 d0       	rcall	.+336    	; 0x2428 <__fp_cmp>
    22d8:	08 f4       	brcc	.+2      	; 0x22dc <__cmpsf2+0x6>
    22da:	81 e0       	ldi	r24, 0x01	; 1
    22dc:	08 95       	ret

000022de <__divsf3>:
    22de:	0c d0       	rcall	.+24     	; 0x22f8 <__divsf3x>
    22e0:	de c0       	rjmp	.+444    	; 0x249e <__fp_round>
    22e2:	d6 d0       	rcall	.+428    	; 0x2490 <__fp_pscB>
    22e4:	40 f0       	brcs	.+16     	; 0x22f6 <__divsf3+0x18>
    22e6:	cd d0       	rcall	.+410    	; 0x2482 <__fp_pscA>
    22e8:	30 f0       	brcs	.+12     	; 0x22f6 <__divsf3+0x18>
    22ea:	21 f4       	brne	.+8      	; 0x22f4 <__divsf3+0x16>
    22ec:	5f 3f       	cpi	r21, 0xFF	; 255
    22ee:	19 f0       	breq	.+6      	; 0x22f6 <__divsf3+0x18>
    22f0:	bf c0       	rjmp	.+382    	; 0x2470 <__fp_inf>
    22f2:	51 11       	cpse	r21, r1
    22f4:	08 c1       	rjmp	.+528    	; 0x2506 <__fp_szero>
    22f6:	c2 c0       	rjmp	.+388    	; 0x247c <__fp_nan>

000022f8 <__divsf3x>:
    22f8:	e3 d0       	rcall	.+454    	; 0x24c0 <__fp_split3>
    22fa:	98 f3       	brcs	.-26     	; 0x22e2 <__divsf3+0x4>

000022fc <__divsf3_pse>:
    22fc:	99 23       	and	r25, r25
    22fe:	c9 f3       	breq	.-14     	; 0x22f2 <__divsf3+0x14>
    2300:	55 23       	and	r21, r21
    2302:	b1 f3       	breq	.-20     	; 0x22f0 <__divsf3+0x12>
    2304:	95 1b       	sub	r25, r21
    2306:	55 0b       	sbc	r21, r21
    2308:	bb 27       	eor	r27, r27
    230a:	aa 27       	eor	r26, r26
    230c:	62 17       	cp	r22, r18
    230e:	73 07       	cpc	r23, r19
    2310:	84 07       	cpc	r24, r20
    2312:	38 f0       	brcs	.+14     	; 0x2322 <__divsf3_pse+0x26>
    2314:	9f 5f       	subi	r25, 0xFF	; 255
    2316:	5f 4f       	sbci	r21, 0xFF	; 255
    2318:	22 0f       	add	r18, r18
    231a:	33 1f       	adc	r19, r19
    231c:	44 1f       	adc	r20, r20
    231e:	aa 1f       	adc	r26, r26
    2320:	a9 f3       	breq	.-22     	; 0x230c <__divsf3_pse+0x10>
    2322:	33 d0       	rcall	.+102    	; 0x238a <__divsf3_pse+0x8e>
    2324:	0e 2e       	mov	r0, r30
    2326:	3a f0       	brmi	.+14     	; 0x2336 <__divsf3_pse+0x3a>
    2328:	e0 e8       	ldi	r30, 0x80	; 128
    232a:	30 d0       	rcall	.+96     	; 0x238c <__divsf3_pse+0x90>
    232c:	91 50       	subi	r25, 0x01	; 1
    232e:	50 40       	sbci	r21, 0x00	; 0
    2330:	e6 95       	lsr	r30
    2332:	00 1c       	adc	r0, r0
    2334:	ca f7       	brpl	.-14     	; 0x2328 <__divsf3_pse+0x2c>
    2336:	29 d0       	rcall	.+82     	; 0x238a <__divsf3_pse+0x8e>
    2338:	fe 2f       	mov	r31, r30
    233a:	27 d0       	rcall	.+78     	; 0x238a <__divsf3_pse+0x8e>
    233c:	66 0f       	add	r22, r22
    233e:	77 1f       	adc	r23, r23
    2340:	88 1f       	adc	r24, r24
    2342:	bb 1f       	adc	r27, r27
    2344:	26 17       	cp	r18, r22
    2346:	37 07       	cpc	r19, r23
    2348:	48 07       	cpc	r20, r24
    234a:	ab 07       	cpc	r26, r27
    234c:	b0 e8       	ldi	r27, 0x80	; 128
    234e:	09 f0       	breq	.+2      	; 0x2352 <__divsf3_pse+0x56>
    2350:	bb 0b       	sbc	r27, r27
    2352:	80 2d       	mov	r24, r0
    2354:	bf 01       	movw	r22, r30
    2356:	ff 27       	eor	r31, r31
    2358:	93 58       	subi	r25, 0x83	; 131
    235a:	5f 4f       	sbci	r21, 0xFF	; 255
    235c:	2a f0       	brmi	.+10     	; 0x2368 <__divsf3_pse+0x6c>
    235e:	9e 3f       	cpi	r25, 0xFE	; 254
    2360:	51 05       	cpc	r21, r1
    2362:	68 f0       	brcs	.+26     	; 0x237e <__divsf3_pse+0x82>
    2364:	85 c0       	rjmp	.+266    	; 0x2470 <__fp_inf>
    2366:	cf c0       	rjmp	.+414    	; 0x2506 <__fp_szero>
    2368:	5f 3f       	cpi	r21, 0xFF	; 255
    236a:	ec f3       	brlt	.-6      	; 0x2366 <__divsf3_pse+0x6a>
    236c:	98 3e       	cpi	r25, 0xE8	; 232
    236e:	dc f3       	brlt	.-10     	; 0x2366 <__divsf3_pse+0x6a>
    2370:	86 95       	lsr	r24
    2372:	77 95       	ror	r23
    2374:	67 95       	ror	r22
    2376:	b7 95       	ror	r27
    2378:	f7 95       	ror	r31
    237a:	9f 5f       	subi	r25, 0xFF	; 255
    237c:	c9 f7       	brne	.-14     	; 0x2370 <__divsf3_pse+0x74>
    237e:	88 0f       	add	r24, r24
    2380:	91 1d       	adc	r25, r1
    2382:	96 95       	lsr	r25
    2384:	87 95       	ror	r24
    2386:	97 f9       	bld	r25, 7
    2388:	08 95       	ret
    238a:	e1 e0       	ldi	r30, 0x01	; 1
    238c:	66 0f       	add	r22, r22
    238e:	77 1f       	adc	r23, r23
    2390:	88 1f       	adc	r24, r24
    2392:	bb 1f       	adc	r27, r27
    2394:	62 17       	cp	r22, r18
    2396:	73 07       	cpc	r23, r19
    2398:	84 07       	cpc	r24, r20
    239a:	ba 07       	cpc	r27, r26
    239c:	20 f0       	brcs	.+8      	; 0x23a6 <__divsf3_pse+0xaa>
    239e:	62 1b       	sub	r22, r18
    23a0:	73 0b       	sbc	r23, r19
    23a2:	84 0b       	sbc	r24, r20
    23a4:	ba 0b       	sbc	r27, r26
    23a6:	ee 1f       	adc	r30, r30
    23a8:	88 f7       	brcc	.-30     	; 0x238c <__divsf3_pse+0x90>
    23aa:	e0 95       	com	r30
    23ac:	08 95       	ret

000023ae <__floatunsisf>:
    23ae:	e8 94       	clt
    23b0:	09 c0       	rjmp	.+18     	; 0x23c4 <__floatsisf+0x12>

000023b2 <__floatsisf>:
    23b2:	97 fb       	bst	r25, 7
    23b4:	3e f4       	brtc	.+14     	; 0x23c4 <__floatsisf+0x12>
    23b6:	90 95       	com	r25
    23b8:	80 95       	com	r24
    23ba:	70 95       	com	r23
    23bc:	61 95       	neg	r22
    23be:	7f 4f       	sbci	r23, 0xFF	; 255
    23c0:	8f 4f       	sbci	r24, 0xFF	; 255
    23c2:	9f 4f       	sbci	r25, 0xFF	; 255
    23c4:	99 23       	and	r25, r25
    23c6:	a9 f0       	breq	.+42     	; 0x23f2 <__floatsisf+0x40>
    23c8:	f9 2f       	mov	r31, r25
    23ca:	96 e9       	ldi	r25, 0x96	; 150
    23cc:	bb 27       	eor	r27, r27
    23ce:	93 95       	inc	r25
    23d0:	f6 95       	lsr	r31
    23d2:	87 95       	ror	r24
    23d4:	77 95       	ror	r23
    23d6:	67 95       	ror	r22
    23d8:	b7 95       	ror	r27
    23da:	f1 11       	cpse	r31, r1
    23dc:	f8 cf       	rjmp	.-16     	; 0x23ce <__floatsisf+0x1c>
    23de:	fa f4       	brpl	.+62     	; 0x241e <__floatsisf+0x6c>
    23e0:	bb 0f       	add	r27, r27
    23e2:	11 f4       	brne	.+4      	; 0x23e8 <__floatsisf+0x36>
    23e4:	60 ff       	sbrs	r22, 0
    23e6:	1b c0       	rjmp	.+54     	; 0x241e <__floatsisf+0x6c>
    23e8:	6f 5f       	subi	r22, 0xFF	; 255
    23ea:	7f 4f       	sbci	r23, 0xFF	; 255
    23ec:	8f 4f       	sbci	r24, 0xFF	; 255
    23ee:	9f 4f       	sbci	r25, 0xFF	; 255
    23f0:	16 c0       	rjmp	.+44     	; 0x241e <__floatsisf+0x6c>
    23f2:	88 23       	and	r24, r24
    23f4:	11 f0       	breq	.+4      	; 0x23fa <__floatsisf+0x48>
    23f6:	96 e9       	ldi	r25, 0x96	; 150
    23f8:	11 c0       	rjmp	.+34     	; 0x241c <__floatsisf+0x6a>
    23fa:	77 23       	and	r23, r23
    23fc:	21 f0       	breq	.+8      	; 0x2406 <__floatsisf+0x54>
    23fe:	9e e8       	ldi	r25, 0x8E	; 142
    2400:	87 2f       	mov	r24, r23
    2402:	76 2f       	mov	r23, r22
    2404:	05 c0       	rjmp	.+10     	; 0x2410 <__floatsisf+0x5e>
    2406:	66 23       	and	r22, r22
    2408:	71 f0       	breq	.+28     	; 0x2426 <__floatsisf+0x74>
    240a:	96 e8       	ldi	r25, 0x86	; 134
    240c:	86 2f       	mov	r24, r22
    240e:	70 e0       	ldi	r23, 0x00	; 0
    2410:	60 e0       	ldi	r22, 0x00	; 0
    2412:	2a f0       	brmi	.+10     	; 0x241e <__floatsisf+0x6c>
    2414:	9a 95       	dec	r25
    2416:	66 0f       	add	r22, r22
    2418:	77 1f       	adc	r23, r23
    241a:	88 1f       	adc	r24, r24
    241c:	da f7       	brpl	.-10     	; 0x2414 <__floatsisf+0x62>
    241e:	88 0f       	add	r24, r24
    2420:	96 95       	lsr	r25
    2422:	87 95       	ror	r24
    2424:	97 f9       	bld	r25, 7
    2426:	08 95       	ret

00002428 <__fp_cmp>:
    2428:	99 0f       	add	r25, r25
    242a:	00 08       	sbc	r0, r0
    242c:	55 0f       	add	r21, r21
    242e:	aa 0b       	sbc	r26, r26
    2430:	e0 e8       	ldi	r30, 0x80	; 128
    2432:	fe ef       	ldi	r31, 0xFE	; 254
    2434:	16 16       	cp	r1, r22
    2436:	17 06       	cpc	r1, r23
    2438:	e8 07       	cpc	r30, r24
    243a:	f9 07       	cpc	r31, r25
    243c:	c0 f0       	brcs	.+48     	; 0x246e <__fp_cmp+0x46>
    243e:	12 16       	cp	r1, r18
    2440:	13 06       	cpc	r1, r19
    2442:	e4 07       	cpc	r30, r20
    2444:	f5 07       	cpc	r31, r21
    2446:	98 f0       	brcs	.+38     	; 0x246e <__fp_cmp+0x46>
    2448:	62 1b       	sub	r22, r18
    244a:	73 0b       	sbc	r23, r19
    244c:	84 0b       	sbc	r24, r20
    244e:	95 0b       	sbc	r25, r21
    2450:	39 f4       	brne	.+14     	; 0x2460 <__fp_cmp+0x38>
    2452:	0a 26       	eor	r0, r26
    2454:	61 f0       	breq	.+24     	; 0x246e <__fp_cmp+0x46>
    2456:	23 2b       	or	r18, r19
    2458:	24 2b       	or	r18, r20
    245a:	25 2b       	or	r18, r21
    245c:	21 f4       	brne	.+8      	; 0x2466 <__fp_cmp+0x3e>
    245e:	08 95       	ret
    2460:	0a 26       	eor	r0, r26
    2462:	09 f4       	brne	.+2      	; 0x2466 <__fp_cmp+0x3e>
    2464:	a1 40       	sbci	r26, 0x01	; 1
    2466:	a6 95       	lsr	r26
    2468:	8f ef       	ldi	r24, 0xFF	; 255
    246a:	81 1d       	adc	r24, r1
    246c:	81 1d       	adc	r24, r1
    246e:	08 95       	ret

00002470 <__fp_inf>:
    2470:	97 f9       	bld	r25, 7
    2472:	9f 67       	ori	r25, 0x7F	; 127
    2474:	80 e8       	ldi	r24, 0x80	; 128
    2476:	70 e0       	ldi	r23, 0x00	; 0
    2478:	60 e0       	ldi	r22, 0x00	; 0
    247a:	08 95       	ret

0000247c <__fp_nan>:
    247c:	9f ef       	ldi	r25, 0xFF	; 255
    247e:	80 ec       	ldi	r24, 0xC0	; 192
    2480:	08 95       	ret

00002482 <__fp_pscA>:
    2482:	00 24       	eor	r0, r0
    2484:	0a 94       	dec	r0
    2486:	16 16       	cp	r1, r22
    2488:	17 06       	cpc	r1, r23
    248a:	18 06       	cpc	r1, r24
    248c:	09 06       	cpc	r0, r25
    248e:	08 95       	ret

00002490 <__fp_pscB>:
    2490:	00 24       	eor	r0, r0
    2492:	0a 94       	dec	r0
    2494:	12 16       	cp	r1, r18
    2496:	13 06       	cpc	r1, r19
    2498:	14 06       	cpc	r1, r20
    249a:	05 06       	cpc	r0, r21
    249c:	08 95       	ret

0000249e <__fp_round>:
    249e:	09 2e       	mov	r0, r25
    24a0:	03 94       	inc	r0
    24a2:	00 0c       	add	r0, r0
    24a4:	11 f4       	brne	.+4      	; 0x24aa <__fp_round+0xc>
    24a6:	88 23       	and	r24, r24
    24a8:	52 f0       	brmi	.+20     	; 0x24be <__fp_round+0x20>
    24aa:	bb 0f       	add	r27, r27
    24ac:	40 f4       	brcc	.+16     	; 0x24be <__fp_round+0x20>
    24ae:	bf 2b       	or	r27, r31
    24b0:	11 f4       	brne	.+4      	; 0x24b6 <__fp_round+0x18>
    24b2:	60 ff       	sbrs	r22, 0
    24b4:	04 c0       	rjmp	.+8      	; 0x24be <__fp_round+0x20>
    24b6:	6f 5f       	subi	r22, 0xFF	; 255
    24b8:	7f 4f       	sbci	r23, 0xFF	; 255
    24ba:	8f 4f       	sbci	r24, 0xFF	; 255
    24bc:	9f 4f       	sbci	r25, 0xFF	; 255
    24be:	08 95       	ret

000024c0 <__fp_split3>:
    24c0:	57 fd       	sbrc	r21, 7
    24c2:	90 58       	subi	r25, 0x80	; 128
    24c4:	44 0f       	add	r20, r20
    24c6:	55 1f       	adc	r21, r21
    24c8:	59 f0       	breq	.+22     	; 0x24e0 <__fp_splitA+0x10>
    24ca:	5f 3f       	cpi	r21, 0xFF	; 255
    24cc:	71 f0       	breq	.+28     	; 0x24ea <__fp_splitA+0x1a>
    24ce:	47 95       	ror	r20

000024d0 <__fp_splitA>:
    24d0:	88 0f       	add	r24, r24
    24d2:	97 fb       	bst	r25, 7
    24d4:	99 1f       	adc	r25, r25
    24d6:	61 f0       	breq	.+24     	; 0x24f0 <__fp_splitA+0x20>
    24d8:	9f 3f       	cpi	r25, 0xFF	; 255
    24da:	79 f0       	breq	.+30     	; 0x24fa <__fp_splitA+0x2a>
    24dc:	87 95       	ror	r24
    24de:	08 95       	ret
    24e0:	12 16       	cp	r1, r18
    24e2:	13 06       	cpc	r1, r19
    24e4:	14 06       	cpc	r1, r20
    24e6:	55 1f       	adc	r21, r21
    24e8:	f2 cf       	rjmp	.-28     	; 0x24ce <__fp_split3+0xe>
    24ea:	46 95       	lsr	r20
    24ec:	f1 df       	rcall	.-30     	; 0x24d0 <__fp_splitA>
    24ee:	08 c0       	rjmp	.+16     	; 0x2500 <__fp_splitA+0x30>
    24f0:	16 16       	cp	r1, r22
    24f2:	17 06       	cpc	r1, r23
    24f4:	18 06       	cpc	r1, r24
    24f6:	99 1f       	adc	r25, r25
    24f8:	f1 cf       	rjmp	.-30     	; 0x24dc <__fp_splitA+0xc>
    24fa:	86 95       	lsr	r24
    24fc:	71 05       	cpc	r23, r1
    24fe:	61 05       	cpc	r22, r1
    2500:	08 94       	sec
    2502:	08 95       	ret

00002504 <__fp_zero>:
    2504:	e8 94       	clt

00002506 <__fp_szero>:
    2506:	bb 27       	eor	r27, r27
    2508:	66 27       	eor	r22, r22
    250a:	77 27       	eor	r23, r23
    250c:	cb 01       	movw	r24, r22
    250e:	97 f9       	bld	r25, 7
    2510:	08 95       	ret

00002512 <__gesf2>:
    2512:	8a df       	rcall	.-236    	; 0x2428 <__fp_cmp>
    2514:	08 f4       	brcc	.+2      	; 0x2518 <__gesf2+0x6>
    2516:	8f ef       	ldi	r24, 0xFF	; 255
    2518:	08 95       	ret

0000251a <__udivmodhi4>:
    251a:	aa 1b       	sub	r26, r26
    251c:	bb 1b       	sub	r27, r27
    251e:	51 e1       	ldi	r21, 0x11	; 17
    2520:	07 c0       	rjmp	.+14     	; 0x2530 <__udivmodhi4_ep>

00002522 <__udivmodhi4_loop>:
    2522:	aa 1f       	adc	r26, r26
    2524:	bb 1f       	adc	r27, r27
    2526:	a6 17       	cp	r26, r22
    2528:	b7 07       	cpc	r27, r23
    252a:	10 f0       	brcs	.+4      	; 0x2530 <__udivmodhi4_ep>
    252c:	a6 1b       	sub	r26, r22
    252e:	b7 0b       	sbc	r27, r23

00002530 <__udivmodhi4_ep>:
    2530:	88 1f       	adc	r24, r24
    2532:	99 1f       	adc	r25, r25
    2534:	5a 95       	dec	r21
    2536:	a9 f7       	brne	.-22     	; 0x2522 <__udivmodhi4_loop>
    2538:	80 95       	com	r24
    253a:	90 95       	com	r25
    253c:	bc 01       	movw	r22, r24
    253e:	cd 01       	movw	r24, r26
    2540:	08 95       	ret

00002542 <__divmodhi4>:
    2542:	97 fb       	bst	r25, 7
    2544:	07 2e       	mov	r0, r23
    2546:	16 f4       	brtc	.+4      	; 0x254c <__divmodhi4+0xa>
    2548:	00 94       	com	r0
    254a:	07 d0       	rcall	.+14     	; 0x255a <__divmodhi4_neg1>
    254c:	77 fd       	sbrc	r23, 7
    254e:	09 d0       	rcall	.+18     	; 0x2562 <__divmodhi4_neg2>
    2550:	0e 94 8d 12 	call	0x251a	; 0x251a <__udivmodhi4>
    2554:	07 fc       	sbrc	r0, 7
    2556:	05 d0       	rcall	.+10     	; 0x2562 <__divmodhi4_neg2>
    2558:	3e f4       	brtc	.+14     	; 0x2568 <__divmodhi4_exit>

0000255a <__divmodhi4_neg1>:
    255a:	90 95       	com	r25
    255c:	81 95       	neg	r24
    255e:	9f 4f       	sbci	r25, 0xFF	; 255
    2560:	08 95       	ret

00002562 <__divmodhi4_neg2>:
    2562:	70 95       	com	r23
    2564:	61 95       	neg	r22
    2566:	7f 4f       	sbci	r23, 0xFF	; 255

00002568 <__divmodhi4_exit>:
    2568:	08 95       	ret

0000256a <malloc>:
    256a:	0f 93       	push	r16
    256c:	1f 93       	push	r17
    256e:	cf 93       	push	r28
    2570:	df 93       	push	r29
    2572:	82 30       	cpi	r24, 0x02	; 2
    2574:	91 05       	cpc	r25, r1
    2576:	10 f4       	brcc	.+4      	; 0x257c <malloc+0x12>
    2578:	82 e0       	ldi	r24, 0x02	; 2
    257a:	90 e0       	ldi	r25, 0x00	; 0
    257c:	e0 91 74 10 	lds	r30, 0x1074
    2580:	f0 91 75 10 	lds	r31, 0x1075
    2584:	20 e0       	ldi	r18, 0x00	; 0
    2586:	30 e0       	ldi	r19, 0x00	; 0
    2588:	c0 e0       	ldi	r28, 0x00	; 0
    258a:	d0 e0       	ldi	r29, 0x00	; 0
    258c:	23 c0       	rjmp	.+70     	; 0x25d4 <malloc+0x6a>
    258e:	40 81       	ld	r20, Z
    2590:	51 81       	ldd	r21, Z+1	; 0x01
    2592:	48 17       	cp	r20, r24
    2594:	59 07       	cpc	r21, r25
    2596:	a8 f0       	brcs	.+42     	; 0x25c2 <malloc+0x58>
    2598:	48 17       	cp	r20, r24
    259a:	59 07       	cpc	r21, r25
    259c:	61 f4       	brne	.+24     	; 0x25b6 <malloc+0x4c>
    259e:	82 81       	ldd	r24, Z+2	; 0x02
    25a0:	93 81       	ldd	r25, Z+3	; 0x03
    25a2:	20 97       	sbiw	r28, 0x00	; 0
    25a4:	19 f0       	breq	.+6      	; 0x25ac <malloc+0x42>
    25a6:	9b 83       	std	Y+3, r25	; 0x03
    25a8:	8a 83       	std	Y+2, r24	; 0x02
    25aa:	2e c0       	rjmp	.+92     	; 0x2608 <malloc+0x9e>
    25ac:	90 93 75 10 	sts	0x1075, r25
    25b0:	80 93 74 10 	sts	0x1074, r24
    25b4:	29 c0       	rjmp	.+82     	; 0x2608 <malloc+0x9e>
    25b6:	21 15       	cp	r18, r1
    25b8:	31 05       	cpc	r19, r1
    25ba:	29 f0       	breq	.+10     	; 0x25c6 <malloc+0x5c>
    25bc:	42 17       	cp	r20, r18
    25be:	53 07       	cpc	r21, r19
    25c0:	10 f0       	brcs	.+4      	; 0x25c6 <malloc+0x5c>
    25c2:	a9 01       	movw	r20, r18
    25c4:	02 c0       	rjmp	.+4      	; 0x25ca <malloc+0x60>
    25c6:	be 01       	movw	r22, r28
    25c8:	df 01       	movw	r26, r30
    25ca:	02 81       	ldd	r16, Z+2	; 0x02
    25cc:	13 81       	ldd	r17, Z+3	; 0x03
    25ce:	ef 01       	movw	r28, r30
    25d0:	9a 01       	movw	r18, r20
    25d2:	f8 01       	movw	r30, r16
    25d4:	30 97       	sbiw	r30, 0x00	; 0
    25d6:	d9 f6       	brne	.-74     	; 0x258e <malloc+0x24>
    25d8:	21 15       	cp	r18, r1
    25da:	31 05       	cpc	r19, r1
    25dc:	09 f1       	breq	.+66     	; 0x2620 <malloc+0xb6>
    25de:	28 1b       	sub	r18, r24
    25e0:	39 0b       	sbc	r19, r25
    25e2:	24 30       	cpi	r18, 0x04	; 4
    25e4:	31 05       	cpc	r19, r1
    25e6:	90 f4       	brcc	.+36     	; 0x260c <malloc+0xa2>
    25e8:	12 96       	adiw	r26, 0x02	; 2
    25ea:	8d 91       	ld	r24, X+
    25ec:	9c 91       	ld	r25, X
    25ee:	13 97       	sbiw	r26, 0x03	; 3
    25f0:	61 15       	cp	r22, r1
    25f2:	71 05       	cpc	r23, r1
    25f4:	21 f0       	breq	.+8      	; 0x25fe <malloc+0x94>
    25f6:	fb 01       	movw	r30, r22
    25f8:	93 83       	std	Z+3, r25	; 0x03
    25fa:	82 83       	std	Z+2, r24	; 0x02
    25fc:	04 c0       	rjmp	.+8      	; 0x2606 <malloc+0x9c>
    25fe:	90 93 75 10 	sts	0x1075, r25
    2602:	80 93 74 10 	sts	0x1074, r24
    2606:	fd 01       	movw	r30, r26
    2608:	32 96       	adiw	r30, 0x02	; 2
    260a:	44 c0       	rjmp	.+136    	; 0x2694 <malloc+0x12a>
    260c:	fd 01       	movw	r30, r26
    260e:	e2 0f       	add	r30, r18
    2610:	f3 1f       	adc	r31, r19
    2612:	81 93       	st	Z+, r24
    2614:	91 93       	st	Z+, r25
    2616:	22 50       	subi	r18, 0x02	; 2
    2618:	31 09       	sbc	r19, r1
    261a:	2d 93       	st	X+, r18
    261c:	3c 93       	st	X, r19
    261e:	3a c0       	rjmp	.+116    	; 0x2694 <malloc+0x12a>
    2620:	20 91 72 10 	lds	r18, 0x1072
    2624:	30 91 73 10 	lds	r19, 0x1073
    2628:	23 2b       	or	r18, r19
    262a:	41 f4       	brne	.+16     	; 0x263c <malloc+0xd2>
    262c:	20 91 02 01 	lds	r18, 0x0102
    2630:	30 91 03 01 	lds	r19, 0x0103
    2634:	30 93 73 10 	sts	0x1073, r19
    2638:	20 93 72 10 	sts	0x1072, r18
    263c:	20 91 00 01 	lds	r18, 0x0100
    2640:	30 91 01 01 	lds	r19, 0x0101
    2644:	21 15       	cp	r18, r1
    2646:	31 05       	cpc	r19, r1
    2648:	41 f4       	brne	.+16     	; 0x265a <malloc+0xf0>
    264a:	2d b7       	in	r18, 0x3d	; 61
    264c:	3e b7       	in	r19, 0x3e	; 62
    264e:	40 91 04 01 	lds	r20, 0x0104
    2652:	50 91 05 01 	lds	r21, 0x0105
    2656:	24 1b       	sub	r18, r20
    2658:	35 0b       	sbc	r19, r21
    265a:	e0 91 72 10 	lds	r30, 0x1072
    265e:	f0 91 73 10 	lds	r31, 0x1073
    2662:	e2 17       	cp	r30, r18
    2664:	f3 07       	cpc	r31, r19
    2666:	a0 f4       	brcc	.+40     	; 0x2690 <malloc+0x126>
    2668:	2e 1b       	sub	r18, r30
    266a:	3f 0b       	sbc	r19, r31
    266c:	28 17       	cp	r18, r24
    266e:	39 07       	cpc	r19, r25
    2670:	78 f0       	brcs	.+30     	; 0x2690 <malloc+0x126>
    2672:	ac 01       	movw	r20, r24
    2674:	4e 5f       	subi	r20, 0xFE	; 254
    2676:	5f 4f       	sbci	r21, 0xFF	; 255
    2678:	24 17       	cp	r18, r20
    267a:	35 07       	cpc	r19, r21
    267c:	48 f0       	brcs	.+18     	; 0x2690 <malloc+0x126>
    267e:	4e 0f       	add	r20, r30
    2680:	5f 1f       	adc	r21, r31
    2682:	50 93 73 10 	sts	0x1073, r21
    2686:	40 93 72 10 	sts	0x1072, r20
    268a:	81 93       	st	Z+, r24
    268c:	91 93       	st	Z+, r25
    268e:	02 c0       	rjmp	.+4      	; 0x2694 <malloc+0x12a>
    2690:	e0 e0       	ldi	r30, 0x00	; 0
    2692:	f0 e0       	ldi	r31, 0x00	; 0
    2694:	cf 01       	movw	r24, r30
    2696:	df 91       	pop	r29
    2698:	cf 91       	pop	r28
    269a:	1f 91       	pop	r17
    269c:	0f 91       	pop	r16
    269e:	08 95       	ret

000026a0 <free>:
    26a0:	ef 92       	push	r14
    26a2:	ff 92       	push	r15
    26a4:	0f 93       	push	r16
    26a6:	1f 93       	push	r17
    26a8:	cf 93       	push	r28
    26aa:	df 93       	push	r29
    26ac:	00 97       	sbiw	r24, 0x00	; 0
    26ae:	09 f4       	brne	.+2      	; 0x26b2 <free+0x12>
    26b0:	8f c0       	rjmp	.+286    	; 0x27d0 <free+0x130>
    26b2:	dc 01       	movw	r26, r24
    26b4:	12 97       	sbiw	r26, 0x02	; 2
    26b6:	13 96       	adiw	r26, 0x03	; 3
    26b8:	1c 92       	st	X, r1
    26ba:	1e 92       	st	-X, r1
    26bc:	12 97       	sbiw	r26, 0x02	; 2
    26be:	e0 90 74 10 	lds	r14, 0x1074
    26c2:	f0 90 75 10 	lds	r15, 0x1075
    26c6:	e1 14       	cp	r14, r1
    26c8:	f1 04       	cpc	r15, r1
    26ca:	89 f4       	brne	.+34     	; 0x26ee <free+0x4e>
    26cc:	2d 91       	ld	r18, X+
    26ce:	3c 91       	ld	r19, X
    26d0:	11 97       	sbiw	r26, 0x01	; 1
    26d2:	28 0f       	add	r18, r24
    26d4:	39 1f       	adc	r19, r25
    26d6:	80 91 72 10 	lds	r24, 0x1072
    26da:	90 91 73 10 	lds	r25, 0x1073
    26de:	82 17       	cp	r24, r18
    26e0:	93 07       	cpc	r25, r19
    26e2:	89 f5       	brne	.+98     	; 0x2746 <free+0xa6>
    26e4:	b0 93 73 10 	sts	0x1073, r27
    26e8:	a0 93 72 10 	sts	0x1072, r26
    26ec:	71 c0       	rjmp	.+226    	; 0x27d0 <free+0x130>
    26ee:	e7 01       	movw	r28, r14
    26f0:	20 e0       	ldi	r18, 0x00	; 0
    26f2:	30 e0       	ldi	r19, 0x00	; 0
    26f4:	01 c0       	rjmp	.+2      	; 0x26f8 <free+0x58>
    26f6:	ea 01       	movw	r28, r20
    26f8:	ca 17       	cp	r28, r26
    26fa:	db 07       	cpc	r29, r27
    26fc:	38 f4       	brcc	.+14     	; 0x270c <free+0x6c>
    26fe:	4a 81       	ldd	r20, Y+2	; 0x02
    2700:	5b 81       	ldd	r21, Y+3	; 0x03
    2702:	9e 01       	movw	r18, r28
    2704:	41 15       	cp	r20, r1
    2706:	51 05       	cpc	r21, r1
    2708:	b1 f7       	brne	.-20     	; 0x26f6 <free+0x56>
    270a:	22 c0       	rjmp	.+68     	; 0x2750 <free+0xb0>
    270c:	bc 01       	movw	r22, r24
    270e:	62 50       	subi	r22, 0x02	; 2
    2710:	71 09       	sbc	r23, r1
    2712:	fb 01       	movw	r30, r22
    2714:	d3 83       	std	Z+3, r29	; 0x03
    2716:	c2 83       	std	Z+2, r28	; 0x02
    2718:	00 81       	ld	r16, Z
    271a:	11 81       	ldd	r17, Z+1	; 0x01
    271c:	ac 01       	movw	r20, r24
    271e:	40 0f       	add	r20, r16
    2720:	51 1f       	adc	r21, r17
    2722:	4c 17       	cp	r20, r28
    2724:	5d 07       	cpc	r21, r29
    2726:	61 f4       	brne	.+24     	; 0x2740 <free+0xa0>
    2728:	48 81       	ld	r20, Y
    272a:	59 81       	ldd	r21, Y+1	; 0x01
    272c:	40 0f       	add	r20, r16
    272e:	51 1f       	adc	r21, r17
    2730:	4e 5f       	subi	r20, 0xFE	; 254
    2732:	5f 4f       	sbci	r21, 0xFF	; 255
    2734:	51 83       	std	Z+1, r21	; 0x01
    2736:	40 83       	st	Z, r20
    2738:	4a 81       	ldd	r20, Y+2	; 0x02
    273a:	5b 81       	ldd	r21, Y+3	; 0x03
    273c:	53 83       	std	Z+3, r21	; 0x03
    273e:	42 83       	std	Z+2, r20	; 0x02
    2740:	21 15       	cp	r18, r1
    2742:	31 05       	cpc	r19, r1
    2744:	29 f4       	brne	.+10     	; 0x2750 <free+0xb0>
    2746:	b0 93 75 10 	sts	0x1075, r27
    274a:	a0 93 74 10 	sts	0x1074, r26
    274e:	40 c0       	rjmp	.+128    	; 0x27d0 <free+0x130>
    2750:	f9 01       	movw	r30, r18
    2752:	b3 83       	std	Z+3, r27	; 0x03
    2754:	a2 83       	std	Z+2, r26	; 0x02
    2756:	e9 01       	movw	r28, r18
    2758:	69 91       	ld	r22, Y+
    275a:	79 91       	ld	r23, Y+
    275c:	c6 0f       	add	r28, r22
    275e:	d7 1f       	adc	r29, r23
    2760:	ac 17       	cp	r26, r28
    2762:	bd 07       	cpc	r27, r29
    2764:	79 f4       	brne	.+30     	; 0x2784 <free+0xe4>
    2766:	dc 01       	movw	r26, r24
    2768:	5e 91       	ld	r21, -X
    276a:	4e 91       	ld	r20, -X
    276c:	46 0f       	add	r20, r22
    276e:	57 1f       	adc	r21, r23
    2770:	4e 5f       	subi	r20, 0xFE	; 254
    2772:	5f 4f       	sbci	r21, 0xFF	; 255
    2774:	51 83       	std	Z+1, r21	; 0x01
    2776:	40 83       	st	Z, r20
    2778:	12 96       	adiw	r26, 0x02	; 2
    277a:	8d 91       	ld	r24, X+
    277c:	9c 91       	ld	r25, X
    277e:	13 97       	sbiw	r26, 0x03	; 3
    2780:	93 83       	std	Z+3, r25	; 0x03
    2782:	82 83       	std	Z+2, r24	; 0x02
    2784:	a0 e0       	ldi	r26, 0x00	; 0
    2786:	b0 e0       	ldi	r27, 0x00	; 0
    2788:	02 c0       	rjmp	.+4      	; 0x278e <free+0xee>
    278a:	d7 01       	movw	r26, r14
    278c:	7c 01       	movw	r14, r24
    278e:	f7 01       	movw	r30, r14
    2790:	82 81       	ldd	r24, Z+2	; 0x02
    2792:	93 81       	ldd	r25, Z+3	; 0x03
    2794:	00 97       	sbiw	r24, 0x00	; 0
    2796:	c9 f7       	brne	.-14     	; 0x278a <free+0xea>
    2798:	c7 01       	movw	r24, r14
    279a:	02 96       	adiw	r24, 0x02	; 2
    279c:	20 81       	ld	r18, Z
    279e:	31 81       	ldd	r19, Z+1	; 0x01
    27a0:	82 0f       	add	r24, r18
    27a2:	93 1f       	adc	r25, r19
    27a4:	20 91 72 10 	lds	r18, 0x1072
    27a8:	30 91 73 10 	lds	r19, 0x1073
    27ac:	28 17       	cp	r18, r24
    27ae:	39 07       	cpc	r19, r25
    27b0:	79 f4       	brne	.+30     	; 0x27d0 <free+0x130>
    27b2:	10 97       	sbiw	r26, 0x00	; 0
    27b4:	29 f4       	brne	.+10     	; 0x27c0 <free+0x120>
    27b6:	10 92 75 10 	sts	0x1075, r1
    27ba:	10 92 74 10 	sts	0x1074, r1
    27be:	04 c0       	rjmp	.+8      	; 0x27c8 <free+0x128>
    27c0:	13 96       	adiw	r26, 0x03	; 3
    27c2:	1c 92       	st	X, r1
    27c4:	1e 92       	st	-X, r1
    27c6:	12 97       	sbiw	r26, 0x02	; 2
    27c8:	f0 92 73 10 	sts	0x1073, r15
    27cc:	e0 92 72 10 	sts	0x1072, r14
    27d0:	df 91       	pop	r29
    27d2:	cf 91       	pop	r28
    27d4:	1f 91       	pop	r17
    27d6:	0f 91       	pop	r16
    27d8:	ff 90       	pop	r15
    27da:	ef 90       	pop	r14
    27dc:	08 95       	ret

000027de <memcpy>:
    27de:	fb 01       	movw	r30, r22
    27e0:	dc 01       	movw	r26, r24
    27e2:	02 c0       	rjmp	.+4      	; 0x27e8 <memcpy+0xa>
    27e4:	01 90       	ld	r0, Z+
    27e6:	0d 92       	st	X+, r0
    27e8:	41 50       	subi	r20, 0x01	; 1
    27ea:	50 40       	sbci	r21, 0x00	; 0
    27ec:	d8 f7       	brcc	.-10     	; 0x27e4 <memcpy+0x6>
    27ee:	08 95       	ret

000027f0 <_exit>:
    27f0:	f8 94       	cli

000027f2 <__stop_program>:
    27f2:	ff cf       	rjmp	.-2      	; 0x27f2 <__stop_program>
