
violet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000023e  00800100  00002630  000026c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002630  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c5d  0080033e  0080033e  00002902  2**0
                  ALLOC
  3 .stab         00003ff0  00000000  00000000  00002904  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000010d7  00000000  00000000  000068f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  000079cb  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000278  00000000  00000000  000079fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00004e7c  00000000  00000000  00007c72  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001104  00000000  00000000  0000caee  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000013e2  00000000  00000000  0000dbf2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000096c  00000000  00000000  0000efd4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000a92  00000000  00000000  0000f940  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002b69  00000000  00000000  000103d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000200  00000000  00000000  00012f3b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
{
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
 * insert_str
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
{
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
		output[i] = input[i - start_index];

	return i;
}
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 f1 0a 	jmp	0x15e2	; 0x15e2 <__vector_12>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 d3 0a 	jmp	0x15a6	; 0x15a6 <__vector_15>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 0c 0c 	jmp	0x1818	; 0x1818 <__vector_18>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 e3 0b 	jmp	0x17c6	; 0x17c6 <__vector_20>
      54:	0c 94 ce 0b 	jmp	0x179c	; 0x179c <__vector_21>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 99 0b 	jmp	0x1732	; 0x1732 <__vector_30>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 70 0b 	jmp	0x16e0	; 0x16e0 <__vector_32>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	13 e0       	ldi	r17, 0x03	; 3
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e0 e3       	ldi	r30, 0x30	; 48
      a0:	f6 e2       	ldi	r31, 0x26	; 38
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ae 33       	cpi	r26, 0x3E	; 62
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	2f e0       	ldi	r18, 0x0F	; 15
      b4:	ae e3       	ldi	r26, 0x3E	; 62
      b6:	b3 e0       	ldi	r27, 0x03	; 3
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	ab 39       	cpi	r26, 0x9B	; 155
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 60 06 	call	0xcc0	; 0xcc0 <main>
      c6:	0c 94 16 13 	jmp	0x262c	; 0x262c <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <set_component>:
  else if (real < 11.2) {
	 real = 11.2;
  }
  
  //charging = 0xcc;
  if (charging == 0xdd) // change back to dd for tomorrow 
      ce:	8f 92       	push	r8
      d0:	af 92       	push	r10
      d2:	cf 92       	push	r12
      d4:	ef 92       	push	r14
      d6:	0f 93       	push	r16
      d8:	cf 93       	push	r28
      da:	df 93       	push	r29
      dc:	cd b7       	in	r28, 0x3d	; 61
      de:	de b7       	in	r29, 0x3e	; 62
      e0:	9a e1       	ldi	r25, 0x1A	; 26
  {
  	if (real > 12.43) 
      e2:	89 9f       	mul	r24, r25
      e4:	f0 01       	movw	r30, r0
      e6:	11 24       	eor	r1, r1
      e8:	e2 59       	subi	r30, 0x92	; 146
      ea:	fc 4f       	sbci	r31, 0xFC	; 252
      ec:	60 83       	st	Z, r22
      ee:	41 83       	std	Z+1, r20	; 0x01
      f0:	22 83       	std	Z+2, r18	; 0x02
      f2:	13 82       	std	Z+3, r1	; 0x03
      f4:	04 83       	std	Z+4, r16	; 0x04
      f6:	e5 82       	std	Z+5, r14	; 0x05
	{
      debug = 0x0A;
      f8:	c6 82       	std	Z+6, r12	; 0x06
      fa:	12 86       	std	Z+10, r1	; 0x0a
      fc:	13 86       	std	Z+11, r1	; 0x0b
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
      fe:	a4 86       	std	Z+12, r10	; 0x0c
     100:	85 86       	std	Z+13, r8	; 0x0d
     102:	8a 85       	ldd	r24, Y+10	; 0x0a
     104:	86 87       	std	Z+14, r24	; 0x0e
     106:	12 8a       	std	Z+18, r1	; 0x12
     108:	13 8a       	std	Z+19, r1	; 0x13
     10a:	8b 85       	ldd	r24, Y+11	; 0x0b
     10c:	84 8b       	std	Z+20, r24	; 0x14
     10e:	8c 85       	ldd	r24, Y+12	; 0x0c
     110:	85 8b       	std	Z+21, r24	; 0x15
     112:	11 8e       	std	Z+25, r1	; 0x19
     114:	df 91       	pop	r29
     116:	cf 91       	pop	r28
     118:	0f 91       	pop	r16
     11a:	ef 90       	pop	r14
     11c:	cf 90       	pop	r12
     11e:	af 90       	pop	r10
     120:	8f 90       	pop	r8
     122:	08 95       	ret

00000124 <initialize_svit>:
     124:	8f 92       	push	r8
     126:	af 92       	push	r10
     128:	cf 92       	push	r12
     12a:	ef 92       	push	r14
     12c:	ff 92       	push	r15
     12e:	0f 93       	push	r16
     130:	1f 93       	push	r17
     132:	cf 93       	push	r28
     134:	df 93       	push	r29
     136:	80 e6       	ldi	r24, 0x60	; 96
     138:	87 b9       	out	0x07, r24	; 7
     13a:	8f e8       	ldi	r24, 0x8F	; 143
     13c:	86 b9       	out	0x06, r24	; 6
     13e:	1f 92       	push	r1
     140:	d3 e0       	ldi	r29, 0x03	; 3
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     142:	df 93       	push	r29
     144:	c1 ee       	ldi	r28, 0xE1	; 225
     146:	cf 93       	push	r28
     148:	86 e0       	ldi	r24, 0x06	; 6
     14a:	88 2e       	mov	r8, r24
     14c:	a1 2c       	mov	r10, r1
     14e:	91 ee       	ldi	r25, 0xE1	; 225
     150:	c9 2e       	mov	r12, r25
     152:	2b e0       	ldi	r18, 0x0B	; 11
     154:	e2 2e       	mov	r14, r18
     156:	00 e0       	ldi	r16, 0x00	; 0
     158:	21 e0       	ldi	r18, 0x01	; 1
     15a:	47 e0       	ldi	r20, 0x07	; 7
     15c:	60 e0       	ldi	r22, 0x00	; 0
     15e:	80 e0       	ldi	r24, 0x00	; 0
     160:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     164:	87 e0       	ldi	r24, 0x07	; 7
     166:	8f 93       	push	r24
     168:	ff 24       	eor	r15, r15
     16a:	f3 94       	inc	r15
     16c:	ff 92       	push	r15
     16e:	cf 93       	push	r28
     170:	37 e0       	ldi	r19, 0x07	; 7
     172:	83 2e       	mov	r8, r19
     174:	47 e1       	ldi	r20, 0x17	; 23
     176:	e4 2e       	mov	r14, r20
     178:	21 e0       	ldi	r18, 0x01	; 1
     17a:	48 e0       	ldi	r20, 0x08	; 8
     17c:	61 e0       	ldi	r22, 0x01	; 1
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     17e:	81 e0       	ldi	r24, 0x01	; 1
     180:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     184:	1f 92       	push	r1
     186:	df 93       	push	r29
     188:	cf 93       	push	r28
     18a:	81 2c       	mov	r8, r1
     18c:	aa 24       	eor	r10, r10
     18e:	a3 94       	inc	r10
     190:	53 e1       	ldi	r21, 0x13	; 19
     192:	e5 2e       	mov	r14, r21
     194:	01 e0       	ldi	r16, 0x01	; 1
     196:	21 e0       	ldi	r18, 0x01	; 1
     198:	41 e0       	ldi	r20, 0x01	; 1
     19a:	62 e0       	ldi	r22, 0x02	; 2
     19c:	82 e0       	ldi	r24, 0x02	; 2
     19e:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1a2:	1f 92       	push	r1
     1a4:	df 93       	push	r29
     1a6:	cf 93       	push	r28
     1a8:	6e e0       	ldi	r22, 0x0E	; 14
     1aa:	86 2e       	mov	r8, r22
     1ac:	72 e0       	ldi	r23, 0x02	; 2
     1ae:	a7 2e       	mov	r10, r23
     1b0:	ed e0       	ldi	r30, 0x0D	; 13
     1b2:	ee 2e       	mov	r14, r30
     1b4:	02 e0       	ldi	r16, 0x02	; 2
     1b6:	21 e0       	ldi	r18, 0x01	; 1
     1b8:	41 e0       	ldi	r20, 0x01	; 1
     1ba:	63 e0       	ldi	r22, 0x03	; 3
     1bc:	83 e0       	ldi	r24, 0x03	; 3
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     1be:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1c2:	1f 92       	push	r1
     1c4:	df 93       	push	r29
     1c6:	cf 93       	push	r28
     1c8:	88 24       	eor	r8, r8
     1ca:	83 94       	inc	r8
     1cc:	aa 24       	eor	r10, r10
     1ce:	a3 94       	inc	r10
     1d0:	f5 e1       	ldi	r31, 0x15	; 21
     1d2:	ef 2e       	mov	r14, r31
     1d4:	01 e0       	ldi	r16, 0x01	; 1
     1d6:	21 e0       	ldi	r18, 0x01	; 1
     1d8:	42 e0       	ldi	r20, 0x02	; 2
     1da:	64 e0       	ldi	r22, 0x04	; 4
     1dc:	84 e0       	ldi	r24, 0x04	; 4
     1de:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     1e2:	1f 92       	push	r1
     1e4:	df 93       	push	r29
     1e6:	cf 93       	push	r28
     1e8:	a2 e0       	ldi	r26, 0x02	; 2
     1ea:	8a 2e       	mov	r8, r26
     1ec:	ba e1       	ldi	r27, 0x1A	; 26
     1ee:	eb 2e       	mov	r14, r27
     1f0:	21 e0       	ldi	r18, 0x01	; 1
     1f2:	43 e0       	ldi	r20, 0x03	; 3
     1f4:	65 e0       	ldi	r22, 0x05	; 5
     1f6:	85 e0       	ldi	r24, 0x05	; 5
     1f8:	0e 94 67 00 	call	0xce	; 0xce <set_component>
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     1fc:	1f 92       	push	r1
     1fe:	df 93       	push	r29
     200:	cf 93       	push	r28
     202:	13 e0       	ldi	r17, 0x03	; 3
     204:	81 2e       	mov	r8, r17
     206:	8d e1       	ldi	r24, 0x1D	; 29
     208:	e8 2e       	mov	r14, r24
     20a:	21 e0       	ldi	r18, 0x01	; 1
     20c:	44 e0       	ldi	r20, 0x04	; 4
     20e:	66 e0       	ldi	r22, 0x06	; 6
     210:	86 e0       	ldi	r24, 0x06	; 6
     212:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     216:	1f 92       	push	r1
     218:	df 93       	push	r29
     21a:	cf 93       	push	r28
     21c:	9f e1       	ldi	r25, 0x1F	; 31
     21e:	89 2e       	mov	r8, r25
     220:	2e e0       	ldi	r18, 0x0E	; 14
     222:	e2 2e       	mov	r14, r18
     224:	21 e0       	ldi	r18, 0x01	; 1
     226:	45 e0       	ldi	r20, 0x05	; 5
     228:	67 e0       	ldi	r22, 0x07	; 7
     22a:	87 e0       	ldi	r24, 0x07	; 7
     22c:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     230:	1f 92       	push	r1
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     232:	df 93       	push	r29
     234:	cf 93       	push	r28
     236:	34 e0       	ldi	r19, 0x04	; 4
     238:	83 2e       	mov	r8, r19
     23a:	4b e1       	ldi	r20, 0x1B	; 27
     23c:	e4 2e       	mov	r14, r20
     23e:	21 e0       	ldi	r18, 0x01	; 1
     240:	46 e0       	ldi	r20, 0x06	; 6
     242:	68 e0       	ldi	r22, 0x08	; 8
     244:	88 e0       	ldi	r24, 0x08	; 8
     246:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     24a:	1f 92       	push	r1
     24c:	df 93       	push	r29
     24e:	cf 93       	push	r28
     250:	58 e0       	ldi	r21, 0x08	; 8
     252:	85 2e       	mov	r8, r21
     254:	6f e0       	ldi	r22, 0x0F	; 15
     256:	e6 2e       	mov	r14, r22
     258:	21 e0       	ldi	r18, 0x01	; 1
     25a:	49 e0       	ldi	r20, 0x09	; 9
     25c:	69 e0       	ldi	r22, 0x09	; 9
     25e:	89 e0       	ldi	r24, 0x09	; 9
     260:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     264:	1f 92       	push	r1
     266:	df 93       	push	r29
     268:	cf 93       	push	r28
     26a:	79 e0       	ldi	r23, 0x09	; 9
     26c:	87 2e       	mov	r8, r23
     26e:	e9 e1       	ldi	r30, 0x19	; 25
     270:	ee 2e       	mov	r14, r30
     272:	21 e0       	ldi	r18, 0x01	; 1
     274:	4a e0       	ldi	r20, 0x0A	; 10
     276:	6a e0       	ldi	r22, 0x0A	; 10
     278:	8a e0       	ldi	r24, 0x0A	; 10
     27a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     27e:	8d b7       	in	r24, 0x3d	; 61
     280:	9e b7       	in	r25, 0x3e	; 62
     282:	81 96       	adiw	r24, 0x21	; 33
     284:	0f b6       	in	r0, 0x3f	; 63
     286:	f8 94       	cli
     288:	9e bf       	out	0x3e, r25	; 62
     28a:	0f be       	out	0x3f, r0	; 63
     28c:	8d bf       	out	0x3d, r24	; 61
     28e:	1f 92       	push	r1
     290:	df 93       	push	r29
     292:	cf 93       	push	r28
     294:	fa e0       	ldi	r31, 0x0A	; 10
     296:	8f 2e       	mov	r8, r31
     298:	a8 e1       	ldi	r26, 0x18	; 24
     29a:	ea 2e       	mov	r14, r26
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	4b e0       	ldi	r20, 0x0B	; 11
     2a0:	6b e0       	ldi	r22, 0x0B	; 11
     2a2:	8b e0       	ldi	r24, 0x0B	; 11
     2a4:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2a8:	1f 92       	push	r1
     2aa:	df 93       	push	r29
     2ac:	cf 93       	push	r28
     2ae:	b0 e1       	ldi	r27, 0x10	; 16
     2b0:	8b 2e       	mov	r8, r27
     2b2:	11 e1       	ldi	r17, 0x11	; 17
     2b4:	e1 2e       	mov	r14, r17
     2b6:	20 e0       	ldi	r18, 0x00	; 0
     2b8:	4c e0       	ldi	r20, 0x0C	; 12
     2ba:	6c e0       	ldi	r22, 0x0C	; 12
     2bc:	8c e0       	ldi	r24, 0x0C	; 12
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2be:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	8f 93       	push	r24
     2c6:	12 e0       	ldi	r17, 0x02	; 2
     2c8:	1f 93       	push	r17
     2ca:	cf 93       	push	r28
     2cc:	8c e0       	ldi	r24, 0x0C	; 12
     2ce:	88 2e       	mov	r8, r24
     2d0:	96 e1       	ldi	r25, 0x16	; 22
     2d2:	e9 2e       	mov	r14, r25
     2d4:	21 e0       	ldi	r18, 0x01	; 1
     2d6:	4d e0       	ldi	r20, 0x0D	; 13
     2d8:	6d e0       	ldi	r22, 0x0D	; 13
     2da:	8d e0       	ldi	r24, 0x0D	; 13
     2dc:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2e0:	1f 92       	push	r1
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     2e2:	df 93       	push	r29
     2e4:	cf 93       	push	r28
     2e6:	26 e0       	ldi	r18, 0x06	; 6
     2e8:	82 2e       	mov	r8, r18
     2ea:	a1 2c       	mov	r10, r1
     2ec:	34 e0       	ldi	r19, 0x04	; 4
     2ee:	e3 2e       	mov	r14, r19
     2f0:	00 e0       	ldi	r16, 0x00	; 0
     2f2:	21 e0       	ldi	r18, 0x01	; 1
     2f4:	4e e0       	ldi	r20, 0x0E	; 14
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2f6:	6e e0       	ldi	r22, 0x0E	; 14
     2f8:	8e e0       	ldi	r24, 0x0E	; 14
     2fa:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     2fe:	1f 92       	push	r1
     300:	df 93       	push	r29
     302:	cf 93       	push	r28
     304:	81 2c       	mov	r8, r1
     306:	43 e0       	ldi	r20, 0x03	; 3
     308:	a4 2e       	mov	r10, r20
     30a:	55 e1       	ldi	r21, 0x15	; 21
     30c:	e5 2e       	mov	r14, r21
     30e:	02 e0       	ldi	r16, 0x02	; 2
     310:	21 e0       	ldi	r18, 0x01	; 1
     312:	40 e1       	ldi	r20, 0x10	; 16
     314:	6f e0       	ldi	r22, 0x0F	; 15
     316:	8f e0       	ldi	r24, 0x0F	; 15
     318:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     31c:	1f 92       	push	r1
     31e:	df 93       	push	r29
     320:	cf 93       	push	r28
     322:	6d e0       	ldi	r22, 0x0D	; 13
     324:	86 2e       	mov	r8, r22
     326:	aa 24       	eor	r10, r10
     328:	a3 94       	inc	r10
     32a:	72 e1       	ldi	r23, 0x12	; 18
     32c:	e7 2e       	mov	r14, r23
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     32e:	01 e0       	ldi	r16, 0x01	; 1
     330:	21 e0       	ldi	r18, 0x01	; 1
     332:	4f e0       	ldi	r20, 0x0F	; 15
     334:	60 e1       	ldi	r22, 0x10	; 16
     336:	80 e1       	ldi	r24, 0x10	; 16
     338:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     33c:	1f 92       	push	r1
     33e:	df 93       	push	r29
     340:	cf 93       	push	r28
     342:	e5 e0       	ldi	r30, 0x05	; 5
     344:	8e 2e       	mov	r8, r30
     346:	fc e1       	ldi	r31, 0x1C	; 28
     348:	ef 2e       	mov	r14, r31
     34a:	20 e0       	ldi	r18, 0x00	; 0
     34c:	4f ef       	ldi	r20, 0xFF	; 255
     34e:	61 e1       	ldi	r22, 0x11	; 17
     350:	81 e1       	ldi	r24, 0x11	; 17
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     352:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     356:	1f 92       	push	r1
     358:	df 93       	push	r29
     35a:	cf 93       	push	r28
     35c:	a0 e1       	ldi	r26, 0x10	; 16
     35e:	8a 2e       	mov	r8, r26
     360:	b2 e0       	ldi	r27, 0x02	; 2
     362:	ab 2e       	mov	r10, r27
     364:	0f e0       	ldi	r16, 0x0F	; 15
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     366:	e0 2e       	mov	r14, r16
     368:	02 e0       	ldi	r16, 0x02	; 2
     36a:	20 e0       	ldi	r18, 0x00	; 0
     36c:	4f ef       	ldi	r20, 0xFF	; 255
     36e:	62 e1       	ldi	r22, 0x12	; 18
     370:	82 e1       	ldi	r24, 0x12	; 18
     372:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     376:	1f 92       	push	r1
     378:	df 93       	push	r29
     37a:	cf 93       	push	r28
     37c:	82 e1       	ldi	r24, 0x12	; 18
     37e:	88 2e       	mov	r8, r24
     380:	91 e1       	ldi	r25, 0x11	; 17
     382:	e9 2e       	mov	r14, r25
     384:	20 e0       	ldi	r18, 0x00	; 0
     386:	4f ef       	ldi	r20, 0xFF	; 255
     388:	63 e1       	ldi	r22, 0x13	; 19
     38a:	83 e1       	ldi	r24, 0x13	; 19
     38c:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     390:	89 e0       	ldi	r24, 0x09	; 9
     392:	8f 93       	push	r24
     394:	1f 93       	push	r17
     396:	cf 93       	push	r28
     398:	22 e0       	ldi	r18, 0x02	; 2
     39a:	82 2e       	mov	r8, r18
     39c:	a1 2c       	mov	r10, r1
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     39e:	ee 24       	eor	r14, r14
     3a0:	e3 94       	inc	r14
     3a2:	00 e0       	ldi	r16, 0x00	; 0
     3a4:	21 e0       	ldi	r18, 0x01	; 1
     3a6:	4f ef       	ldi	r20, 0xFF	; 255
     3a8:	64 e1       	ldi	r22, 0x14	; 20
     3aa:	84 e1       	ldi	r24, 0x14	; 20
     3ac:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     3b0:	8b e0       	ldi	r24, 0x0B	; 11
     3b2:	8f 93       	push	r24
     3b4:	1f 93       	push	r17
     3b6:	cf 93       	push	r28
     3b8:	3e e1       	ldi	r19, 0x1E	; 30
     3ba:	83 2e       	mov	r8, r19
     3bc:	42 e0       	ldi	r20, 0x02	; 2
     3be:	a4 2e       	mov	r10, r20
     3c0:	54 e1       	ldi	r21, 0x14	; 20
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     3c2:	e5 2e       	mov	r14, r21
     3c4:	02 e0       	ldi	r16, 0x02	; 2
     3c6:	21 e0       	ldi	r18, 0x01	; 1
     3c8:	4f ef       	ldi	r20, 0xFF	; 255
     3ca:	65 e1       	ldi	r22, 0x15	; 21
     3cc:	85 e1       	ldi	r24, 0x15	; 21
     3ce:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     3d2:	8d b7       	in	r24, 0x3d	; 61
     3d4:	9e b7       	in	r25, 0x3e	; 62
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     3d6:	81 96       	adiw	r24, 0x21	; 33
     3d8:	0f b6       	in	r0, 0x3f	; 63
     3da:	f8 94       	cli
     3dc:	9e bf       	out	0x3e, r25	; 62
     3de:	0f be       	out	0x3f, r0	; 63
     3e0:	8d bf       	out	0x3d, r24	; 61
     3e2:	1f 92       	push	r1
     3e4:	df 93       	push	r29
     3e6:	cf 93       	push	r28
     3e8:	63 e0       	ldi	r22, 0x03	; 3
     3ea:	86 2e       	mov	r8, r22
     3ec:	a1 2c       	mov	r10, r1
     3ee:	77 e0       	ldi	r23, 0x07	; 7
     3f0:	e7 2e       	mov	r14, r23
     3f2:	00 e0       	ldi	r16, 0x00	; 0
     3f4:	21 e0       	ldi	r18, 0x01	; 1
     3f6:	4f ef       	ldi	r20, 0xFF	; 255
     3f8:	66 e1       	ldi	r22, 0x16	; 22
     3fa:	86 e1       	ldi	r24, 0x16	; 22
     3fc:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     400:	1f 92       	push	r1
     402:	1f 93       	push	r17
     404:	cf 93       	push	r28
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     406:	e4 e1       	ldi	r30, 0x14	; 20
     408:	8e 2e       	mov	r8, r30
     40a:	f2 e1       	ldi	r31, 0x12	; 18
     40c:	ef 2e       	mov	r14, r31
     40e:	21 e0       	ldi	r18, 0x01	; 1
     410:	4f ef       	ldi	r20, 0xFF	; 255
     412:	67 e1       	ldi	r22, 0x17	; 23
     414:	87 e1       	ldi	r24, 0x17	; 23
     416:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     41a:	ff 92       	push	r15
     41c:	1f 93       	push	r17
     41e:	cf 93       	push	r28
     420:	a5 e1       	ldi	r26, 0x15	; 21
     422:	8a 2e       	mov	r8, r26
     424:	b3 e1       	ldi	r27, 0x13	; 19
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     426:	eb 2e       	mov	r14, r27
     428:	21 e0       	ldi	r18, 0x01	; 1
     42a:	4f ef       	ldi	r20, 0xFF	; 255
     42c:	68 e1       	ldi	r22, 0x18	; 24
     42e:	88 e1       	ldi	r24, 0x18	; 24
     430:	0e 94 67 00 	call	0xce	; 0xce <set_component>
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     434:	1f 93       	push	r17
     436:	1f 93       	push	r17
     438:	cf 93       	push	r28
     43a:	86 e1       	ldi	r24, 0x16	; 22
     43c:	88 2e       	mov	r8, r24
     43e:	9a e0       	ldi	r25, 0x0A	; 10
     440:	e9 2e       	mov	r14, r25
     442:	21 e0       	ldi	r18, 0x01	; 1
	}
    else 
	{
	  debug = 0x0B;
     444:	4f ef       	ldi	r20, 0xFF	; 255
     446:	69 e1       	ldi	r22, 0x19	; 25
     448:	89 e1       	ldi	r24, 0x19	; 25
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     44a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     44e:	df 93       	push	r29
     450:	1f 93       	push	r17
     452:	cf 93       	push	r28
     454:	27 e1       	ldi	r18, 0x17	; 23
     456:	82 2e       	mov	r8, r18
     458:	3f e0       	ldi	r19, 0x0F	; 15
     45a:	e3 2e       	mov	r14, r19
     45c:	21 e0       	ldi	r18, 0x01	; 1
     45e:	4f ef       	ldi	r20, 0xFF	; 255
     460:	6a e1       	ldi	r22, 0x1A	; 26
     462:	8a e1       	ldi	r24, 0x1A	; 26
     464:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     468:	84 e0       	ldi	r24, 0x04	; 4
     46a:	8f 93       	push	r24
     46c:	1f 93       	push	r17
     46e:	cf 93       	push	r28
     470:	48 e1       	ldi	r20, 0x18	; 24
     472:	84 2e       	mov	r8, r20
     474:	59 e0       	ldi	r21, 0x09	; 9
     476:	e5 2e       	mov	r14, r21
     478:	21 e0       	ldi	r18, 0x01	; 1
     47a:	4f ef       	ldi	r20, 0xFF	; 255
     47c:	6b e1       	ldi	r22, 0x1B	; 27
     47e:	8b e1       	ldi	r24, 0x1B	; 27
     480:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     484:	1f 92       	push	r1
     486:	df 93       	push	r29
     488:	cf 93       	push	r28
     48a:	69 e1       	ldi	r22, 0x19	; 25
     48c:	86 2e       	mov	r8, r22
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     48e:	7e e0       	ldi	r23, 0x0E	; 14
     490:	e7 2e       	mov	r14, r23
     492:	21 e0       	ldi	r18, 0x01	; 1
     494:	4f ef       	ldi	r20, 0xFF	; 255
     496:	6c e1       	ldi	r22, 0x1C	; 28
     498:	8c e1       	ldi	r24, 0x1C	; 28
     49a:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     49e:	1f 92       	push	r1
     4a0:	df 93       	push	r29
     4a2:	cf 93       	push	r28
     4a4:	ea e1       	ldi	r30, 0x1A	; 26
     4a6:	8e 2e       	mov	r8, r30
     4a8:	f0 e1       	ldi	r31, 0x10	; 16
     4aa:	ef 2e       	mov	r14, r31
     4ac:	21 e0       	ldi	r18, 0x01	; 1
     4ae:	4f ef       	ldi	r20, 0xFF	; 255
     4b0:	6d e1       	ldi	r22, 0x1D	; 29
     4b2:	8d e1       	ldi	r24, 0x1D	; 29
     4b4:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4b8:	1f 92       	push	r1
     4ba:	df 93       	push	r29
     4bc:	cf 93       	push	r28
     4be:	ab e1       	ldi	r26, 0x1B	; 27
     4c0:	8a 2e       	mov	r8, r26
     4c2:	b8 e0       	ldi	r27, 0x08	; 8
     4c4:	eb 2e       	mov	r14, r27
     4c6:	21 e0       	ldi	r18, 0x01	; 1
     4c8:	4f ef       	ldi	r20, 0xFF	; 255
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     4ca:	6e e1       	ldi	r22, 0x1E	; 30
     4cc:	8e e1       	ldi	r24, 0x1E	; 30
     4ce:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4d2:	85 e0       	ldi	r24, 0x05	; 5
     4d4:	8f 93       	push	r24
     4d6:	1f 93       	push	r17
     4d8:	cf 93       	push	r28
     4da:	8c e1       	ldi	r24, 0x1C	; 28
     4dc:	88 2e       	mov	r8, r24
     4de:	9d e0       	ldi	r25, 0x0D	; 13
     4e0:	e9 2e       	mov	r14, r25
     4e2:	21 e0       	ldi	r18, 0x01	; 1
     4e4:	4f ef       	ldi	r20, 0xFF	; 255
     4e6:	6f e1       	ldi	r22, 0x1F	; 31
     4e8:	8f e1       	ldi	r24, 0x1F	; 31
     4ea:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     4ee:	1f 92       	push	r1
     4f0:	df 93       	push	r29
     4f2:	cf 93       	push	r28
     4f4:	2d e1       	ldi	r18, 0x1D	; 29
     4f6:	82 2e       	mov	r8, r18
     4f8:	3c e0       	ldi	r19, 0x0C	; 12
     4fa:	e3 2e       	mov	r14, r19
     4fc:	21 e0       	ldi	r18, 0x01	; 1
     4fe:	4f ef       	ldi	r20, 0xFF	; 255
     500:	60 e2       	ldi	r22, 0x20	; 32
     502:	80 e2       	ldi	r24, 0x20	; 32
     504:	0e 94 67 00 	call	0xce	; 0xce <set_component>
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     508:	8d b7       	in	r24, 0x3d	; 61
     50a:	9e b7       	in	r25, 0x3e	; 62
     50c:	81 96       	adiw	r24, 0x21	; 33
     50e:	0f b6       	in	r0, 0x3f	; 63
     510:	f8 94       	cli
     512:	9e bf       	out	0x3e, r25	; 62
     514:	0f be       	out	0x3f, r0	; 63
     516:	8d bf       	out	0x3d, r24	; 61
     518:	1f 92       	push	r1
     51a:	df 93       	push	r29
     51c:	cf 93       	push	r28
     51e:	4e e1       	ldi	r20, 0x1E	; 30
     520:	84 2e       	mov	r8, r20
     522:	5b e0       	ldi	r21, 0x0B	; 11
     524:	e5 2e       	mov	r14, r21
     526:	21 e0       	ldi	r18, 0x01	; 1
     528:	4f ef       	ldi	r20, 0xFF	; 255
     52a:	61 e2       	ldi	r22, 0x21	; 33
     52c:	81 e2       	ldi	r24, 0x21	; 33
     52e:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     532:	1f 92       	push	r1
     534:	df 93       	push	r29
     536:	cf 93       	push	r28
     538:	6f e1       	ldi	r22, 0x1F	; 31
     53a:	86 2e       	mov	r8, r22
     53c:	71 e1       	ldi	r23, 0x11	; 17
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     53e:	e7 2e       	mov	r14, r23
     540:	21 e0       	ldi	r18, 0x01	; 1
     542:	4f ef       	ldi	r20, 0xFF	; 255
     544:	62 e2       	ldi	r22, 0x22	; 34
     546:	82 e2       	ldi	r24, 0x22	; 34
     548:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     54c:	86 e0       	ldi	r24, 0x06	; 6
     54e:	8f 93       	push	r24
     550:	1f 93       	push	r17
     552:	cf 93       	push	r28
     554:	81 2c       	mov	r8, r1
     556:	e5 e0       	ldi	r30, 0x05	; 5
     558:	ee 2e       	mov	r14, r30
     55a:	21 e0       	ldi	r18, 0x01	; 1
     55c:	4f ef       	ldi	r20, 0xFF	; 255
     55e:	63 e2       	ldi	r22, 0x23	; 35
     560:	83 e2       	ldi	r24, 0x23	; 35
     562:	0e 94 67 00 	call	0xce	; 0xce <set_component>
     566:	8d b7       	in	r24, 0x3d	; 61
     568:	9e b7       	in	r25, 0x3e	; 62
     56a:	09 96       	adiw	r24, 0x09	; 9
     56c:	0f b6       	in	r0, 0x3f	; 63
     56e:	f8 94       	cli
     570:	9e bf       	out	0x3e, r25	; 62
     572:	0f be       	out	0x3f, r0	; 63
     574:	8d bf       	out	0x3d, r24	; 61
     576:	df 91       	pop	r29
     578:	cf 91       	pop	r28
     57a:	1f 91       	pop	r17
     57c:	0f 91       	pop	r16
     57e:	ff 90       	pop	r15
     580:	ef 90       	pop	r14
     582:	cf 90       	pop	r12
     584:	af 90       	pop	r10
     586:	8f 90       	pop	r8
     588:	08 95       	ret

0000058a <receive_message>:
     58a:	ff 92       	push	r15
     58c:	0f 93       	push	r16
     58e:	1f 93       	push	r17
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	f8 2e       	mov	r15, r24
     596:	fb 01       	movw	r30, r22
     598:	c1 81       	ldd	r28, Z+1	; 0x01
     59a:	90 81       	ld	r25, Z
     59c:	93 30       	cpi	r25, 0x03	; 3
     59e:	09 f4       	brne	.+2      	; 0x5a2 <receive_message+0x18>
     5a0:	5a c0       	rjmp	.+180    	; 0x656 <receive_message+0xcc>
     5a2:	30 f4       	brcc	.+12     	; 0x5b0 <receive_message+0x26>
     5a4:	0c 2f       	mov	r16, r28
     5a6:	10 e0       	ldi	r17, 0x00	; 0
     5a8:	91 30       	cpi	r25, 0x01	; 1
     5aa:	11 f1       	breq	.+68     	; 0x5f0 <receive_message+0x66>
     5ac:	90 f5       	brcc	.+100    	; 0x612 <receive_message+0x88>
     5ae:	0c c0       	rjmp	.+24     	; 0x5c8 <receive_message+0x3e>
     5b0:	95 30       	cpi	r25, 0x05	; 5
     5b2:	09 f4       	brne	.+2      	; 0x5b6 <receive_message+0x2c>
     5b4:	55 c0       	rjmp	.+170    	; 0x660 <receive_message+0xd6>
     5b6:	08 f4       	brcc	.+2      	; 0x5ba <receive_message+0x30>
     5b8:	50 c0       	rjmp	.+160    	; 0x65a <receive_message+0xd0>
     5ba:	96 30       	cpi	r25, 0x06	; 6
     5bc:	09 f4       	brne	.+2      	; 0x5c0 <receive_message+0x36>
     5be:	60 c0       	rjmp	.+192    	; 0x680 <receive_message+0xf6>
     5c0:	97 30       	cpi	r25, 0x07	; 7
     5c2:	09 f0       	breq	.+2      	; 0x5c6 <receive_message+0x3c>
     5c4:	7b c0       	rjmp	.+246    	; 0x6bc <receive_message+0x132>
     5c6:	6b c0       	rjmp	.+214    	; 0x69e <receive_message+0x114>
     5c8:	8c e2       	ldi	r24, 0x2C	; 44
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     5ca:	80 93 87 0d 	sts	0x0D87, r24
     5ce:	8a e1       	ldi	r24, 0x1A	; 26
     5d0:	80 9f       	mul	r24, r16
     5d2:	e0 01       	movw	r28, r0
     5d4:	81 9f       	mul	r24, r17
     5d6:	d0 0d       	add	r29, r0
     5d8:	11 24       	eor	r1, r1
     5da:	c2 59       	subi	r28, 0x92	; 146
     5dc:	dc 4f       	sbci	r29, 0xFC	; 252
     5de:	89 81       	ldd	r24, Y+1	; 0x01
     5e0:	8f 3f       	cpi	r24, 0xFF	; 255
     5e2:	21 f0       	breq	.+8      	; 0x5ec <receive_message+0x62>
     5e4:	0e 94 6f 07 	call	0xede	; 0xede <switch_on>
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	8a 83       	std	Y+2, r24	; 0x02
     5ec:	40 e0       	ldi	r20, 0x00	; 0
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     5ee:	0f c0       	rjmp	.+30     	; 0x60e <receive_message+0x84>
     5f0:	8a e1       	ldi	r24, 0x1A	; 26
     5f2:	80 9f       	mul	r24, r16
     5f4:	e0 01       	movw	r28, r0
     5f6:	81 9f       	mul	r24, r17
     5f8:	d0 0d       	add	r29, r0
     5fa:	11 24       	eor	r1, r1
     5fc:	c2 59       	subi	r28, 0x92	; 146
     5fe:	dc 4f       	sbci	r29, 0xFC	; 252
     600:	89 81       	ldd	r24, Y+1	; 0x01
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     602:	8f 3f       	cpi	r24, 0xFF	; 255
     604:	19 f0       	breq	.+6      	; 0x60c <receive_message+0x82>
     606:	0e 94 b2 07 	call	0xf64	; 0xf64 <switch_off>
     60a:	1a 82       	std	Y+2, r1	; 0x02
     60c:	41 e0       	ldi	r20, 0x01	; 1
     60e:	62 e0       	ldi	r22, 0x02	; 2
     610:	57 c0       	rjmp	.+174    	; 0x6c0 <receive_message+0x136>
     612:	8a e1       	ldi	r24, 0x1A	; 26
     614:	80 9f       	mul	r24, r16
     616:	e0 01       	movw	r28, r0
     618:	81 9f       	mul	r24, r17
     61a:	d0 0d       	add	r29, r0
     61c:	11 24       	eor	r1, r1
     61e:	c2 59       	subi	r28, 0x92	; 146
     620:	dc 4f       	sbci	r29, 0xFC	; 252
     622:	89 81       	ldd	r24, Y+1	; 0x01
     624:	8f 3f       	cpi	r24, 0xFF	; 255
     626:	19 f0       	breq	.+6      	; 0x62e <receive_message+0xa4>
     628:	0e 94 b2 07 	call	0xf64	; 0xf64 <switch_off>
     62c:	1a 82       	std	Y+2, r1	; 0x02
     62e:	85 e0       	ldi	r24, 0x05	; 5
     630:	8a 95       	dec	r24
     632:	f1 f7       	brne	.-4      	; 0x630 <receive_message+0xa6>
     634:	8a e1       	ldi	r24, 0x1A	; 26
     636:	80 9f       	mul	r24, r16
     638:	e0 01       	movw	r28, r0
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     63a:	81 9f       	mul	r24, r17
     63c:	d0 0d       	add	r29, r0
     63e:	11 24       	eor	r1, r1
     640:	c2 59       	subi	r28, 0x92	; 146
     642:	dc 4f       	sbci	r29, 0xFC	; 252
     644:	89 81       	ldd	r24, Y+1	; 0x01
     646:	8f 3f       	cpi	r24, 0xFF	; 255
     648:	21 f0       	breq	.+8      	; 0x652 <receive_message+0xc8>
     64a:	0e 94 6f 07 	call	0xede	; 0xede <switch_on>
     64e:	81 e0       	ldi	r24, 0x01	; 1
     650:	8a 83       	std	Y+2, r24	; 0x02
     652:	42 e0       	ldi	r20, 0x02	; 2
     654:	dc cf       	rjmp	.-72     	; 0x60e <receive_message+0x84>
     656:	43 e0       	ldi	r20, 0x03	; 3
     658:	da cf       	rjmp	.-76     	; 0x60e <receive_message+0x84>
     65a:	40 e0       	ldi	r20, 0x00	; 0
     65c:	60 e0       	ldi	r22, 0x00	; 0
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     65e:	30 c0       	rjmp	.+96     	; 0x6c0 <receive_message+0x136>
     660:	8a e1       	ldi	r24, 0x1A	; 26
     662:	c8 9f       	mul	r28, r24
     664:	e0 01       	movw	r28, r0
     666:	11 24       	eor	r1, r1
     668:	c2 59       	subi	r28, 0x92	; 146
     66a:	dc 4f       	sbci	r29, 0xFC	; 252
     66c:	89 81       	ldd	r24, Y+1	; 0x01
     66e:	8f 3f       	cpi	r24, 0xFF	; 255
     670:	29 f0       	breq	.+10     	; 0x67c <receive_message+0xf2>
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     672:	0e 94 6f 07 	call	0xede	; 0xede <switch_on>
     676:	81 e0       	ldi	r24, 0x01	; 1
     678:	8a 83       	std	Y+2, r24	; 0x02
     67a:	8b 83       	std	Y+3, r24	; 0x03
     67c:	45 e0       	ldi	r20, 0x05	; 5
     67e:	c7 cf       	rjmp	.-114    	; 0x60e <receive_message+0x84>
     680:	8a e1       	ldi	r24, 0x1A	; 26
     682:	c8 9f       	mul	r28, r24
     684:	e0 01       	movw	r28, r0
     686:	11 24       	eor	r1, r1
     688:	c2 59       	subi	r28, 0x92	; 146
     68a:	dc 4f       	sbci	r29, 0xFC	; 252
     68c:	89 81       	ldd	r24, Y+1	; 0x01
     68e:	8f 3f       	cpi	r24, 0xFF	; 255
     690:	f9 f0       	breq	.+62     	; 0x6d0 <receive_message+0x146>
     692:	82 81       	ldd	r24, Z+2	; 0x02
     694:	8e 83       	std	Y+6, r24	; 0x06
     696:	82 81       	ldd	r24, Z+2	; 0x02
     698:	80 93 6b 0b 	sts	0x0B6B, r24
     69c:	19 c0       	rjmp	.+50     	; 0x6d0 <receive_message+0x146>
     69e:	8a e1       	ldi	r24, 0x1A	; 26
     6a0:	c8 9f       	mul	r28, r24
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6a2:	e0 01       	movw	r28, r0
     6a4:	11 24       	eor	r1, r1
     6a6:	c2 59       	subi	r28, 0x92	; 146
     6a8:	dc 4f       	sbci	r29, 0xFC	; 252
     6aa:	89 81       	ldd	r24, Y+1	; 0x01
     6ac:	8f 3f       	cpi	r24, 0xFF	; 255
     6ae:	81 f0       	breq	.+32     	; 0x6d0 <receive_message+0x146>
     6b0:	82 81       	ldd	r24, Z+2	; 0x02
     6b2:	8e 87       	std	Y+14, r24	; 0x0e
     6b4:	82 81       	ldd	r24, Z+2	; 0x02
     6b6:	80 93 66 0b 	sts	0x0B66, r24
     6ba:	0a c0       	rjmp	.+20     	; 0x6d0 <receive_message+0x146>
     6bc:	40 e0       	ldi	r20, 0x00	; 0
     6be:	61 e0       	ldi	r22, 0x01	; 1
     6c0:	8f 2d       	mov	r24, r15
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     6c2:	df 91       	pop	r29
     6c4:	cf 91       	pop	r28
     6c6:	1f 91       	pop	r17
     6c8:	0f 91       	pop	r16
     6ca:	ff 90       	pop	r15
     6cc:	0c 94 dc 0f 	jmp	0x1fb8	; 0x1fb8 <transmit_packet>
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	1f 91       	pop	r17
     6d6:	0f 91       	pop	r16
     6d8:	ff 90       	pop	r15
     6da:	08 95       	ret

000006dc <StateofCharge>:
     6dc:	e0 91 5c 09 	lds	r30, 0x095C
     6e0:	ef 3f       	cpi	r30, 0xFF	; 255
     6e2:	c1 f1       	breq	.+112    	; 0x754 <StateofCharge+0x78>
     6e4:	8e 2f       	mov	r24, r30
     6e6:	84 56       	subi	r24, 0x64	; 100
     6e8:	8b 31       	cpi	r24, 0x1B	; 27
     6ea:	08 f5       	brcc	.+66     	; 0x72e <StateofCharge+0x52>
     6ec:	80 91 3e 03 	lds	r24, 0x033E
     6f0:	8f 5f       	subi	r24, 0xFF	; 255
     6f2:	80 93 3e 03 	sts	0x033E, r24
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     6f6:	f0 e0       	ldi	r31, 0x00	; 0
     6f8:	ee 0f       	add	r30, r30
     6fa:	ff 1f       	adc	r31, r31
     6fc:	e4 5c       	subi	r30, 0xC4	; 196
     6fe:	fd 4f       	sbci	r31, 0xFD	; 253
     700:	60 81       	ld	r22, Z
     702:	71 81       	ldd	r23, Z+1	; 0x01
     704:	6b 50       	subi	r22, 0x0B	; 11
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
	}
  	percent = 100*(1 - batt_time/discharge_max_time);
     706:	71 09       	sbc	r23, r1
     708:	80 e0       	ldi	r24, 0x00	; 0
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	0e 94 f5 10 	call	0x21ea	; 0x21ea <__floatunsisf>
     710:	28 eb       	ldi	r18, 0xB8	; 184
     712:	3e e1       	ldi	r19, 0x1E	; 30
     714:	49 e2       	ldi	r20, 0x29	; 41
     716:	51 e4       	ldi	r21, 0x41	; 65
     718:	0e 94 8d 10 	call	0x211a	; 0x211a <__divsf3>
     71c:	60 93 1d 07 	sts	0x071D, r22
     720:	70 93 1e 07 	sts	0x071E, r23
     724:	80 93 1f 07 	sts	0x071F, r24
     728:	90 93 20 07 	sts	0x0720, r25
     72c:	08 95       	ret
     72e:	e4 36       	cpi	r30, 0x64	; 100
     730:	28 f4       	brcc	.+10     	; 0x73c <StateofCharge+0x60>
     732:	80 e0       	ldi	r24, 0x00	; 0
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	a0 e8       	ldi	r26, 0x80	; 128
     738:	bf eb       	ldi	r27, 0xBF	; 191
     73a:	04 c0       	rjmp	.+8      	; 0x744 <StateofCharge+0x68>
  }
  else 
  {
    float temp_real = 0;
    if (real < 13.35)
     73c:	80 e0       	ldi	r24, 0x00	; 0
     73e:	90 e0       	ldi	r25, 0x00	; 0
     740:	a8 ed       	ldi	r26, 0xD8	; 216
     742:	b2 e4       	ldi	r27, 0x42	; 66
     744:	80 93 1d 07 	sts	0x071D, r24
     748:	90 93 1e 07 	sts	0x071E, r25
     74c:	a0 93 1f 07 	sts	0x071F, r26
	{
	  debug = 0x0C;
     750:	b0 93 20 07 	sts	0x0720, r27
     754:	08 95       	ret

00000756 <assign_charge_fit>:
	  // voltage is normalized by mean 13.13 and std 0.1754 (real - 13.13)/0.1754
	  temp_real = (real - 13.13)*5.701254;
     756:	80 e0       	ldi	r24, 0x00	; 0
     758:	90 e3       	ldi	r25, 0x30	; 48
     75a:	af e1       	ldi	r26, 0x1F	; 31
     75c:	b6 e4       	ldi	r27, 0x46	; 70
     75e:	80 93 62 09 	sts	0x0962, r24
     762:	90 93 63 09 	sts	0x0963, r25
     766:	a0 93 64 09 	sts	0x0964, r26
     76a:	b0 93 65 09 	sts	0x0965, r27
     76e:	8c e5       	ldi	r24, 0x5C	; 92
     770:	9f e8       	ldi	r25, 0x8F	; 143
     772:	a4 e9       	ldi	r26, 0x94	; 148
     774:	b1 e4       	ldi	r27, 0x41	; 65
	  batt_time = p1*pow(temp_real,3) + p2*pow(temp_real,2) + p3*temp_real + p4;
     776:	80 93 36 09 	sts	0x0936, r24
     77a:	90 93 37 09 	sts	0x0937, r25
     77e:	a0 93 38 09 	sts	0x0938, r26
     782:	b0 93 39 09 	sts	0x0939, r27
     786:	8d ec       	ldi	r24, 0xCD	; 205
     788:	9c ec       	ldi	r25, 0xCC	; 204
     78a:	a8 e3       	ldi	r26, 0x38	; 56
     78c:	b3 e4       	ldi	r27, 0x43	; 67
     78e:	80 93 5b 03 	sts	0x035B, r24
     792:	90 93 5c 03 	sts	0x035C, r25
     796:	a0 93 5d 03 	sts	0x035D, r26
     79a:	b0 93 5e 03 	sts	0x035E, r27
     79e:	86 e6       	ldi	r24, 0x66	; 102
     7a0:	96 ee       	ldi	r25, 0xE6	; 230
     7a2:	a5 e2       	ldi	r26, 0x25	; 37
     7a4:	b4 e4       	ldi	r27, 0x44	; 68
     7a6:	80 93 7a 0d 	sts	0x0D7A, r24
     7aa:	90 93 7b 0d 	sts	0x0D7B, r25
     7ae:	a0 93 7c 0d 	sts	0x0D7C, r26
     7b2:	b0 93 7d 0d 	sts	0x0D7D, r27
     7b6:	86 e6       	ldi	r24, 0x66	; 102
     7b8:	96 ea       	ldi	r25, 0xA6	; 166
     7ba:	a1 e5       	ldi	r26, 0x51	; 81
     7bc:	b4 e4       	ldi	r27, 0x44	; 68
     7be:	80 93 94 0d 	sts	0x0D94, r24
     7c2:	90 93 95 0d 	sts	0x0D95, r25
     7c6:	a0 93 96 0d 	sts	0x0D96, r26
     7ca:	b0 93 97 0d 	sts	0x0D97, r27
     7ce:	81 ee       	ldi	r24, 0xE1	; 225
     7d0:	9a ef       	ldi	r25, 0xFA	; 250
     7d2:	ac e9       	ldi	r26, 0x9C	; 156
     7d4:	b2 e4       	ldi	r27, 0x42	; 66
     7d6:	80 93 57 09 	sts	0x0957, r24
     7da:	90 93 58 09 	sts	0x0958, r25
     7de:	a0 93 59 09 	sts	0x0959, r26
     7e2:	b0 93 5a 09 	sts	0x095A, r27
     7e6:	86 e6       	ldi	r24, 0x66	; 102
     7e8:	96 ec       	ldi	r25, 0xC6	; 198
     7ea:	a7 e0       	ldi	r26, 0x07	; 7
     7ec:	b4 e4       	ldi	r27, 0x44	; 68
     7ee:	80 93 16 07 	sts	0x0716, r24
     7f2:	90 93 17 07 	sts	0x0717, r25
     7f6:	a0 93 18 07 	sts	0x0718, r26
     7fa:	b0 93 19 07 	sts	0x0719, r27
     7fe:	80 e0       	ldi	r24, 0x00	; 0
     800:	90 eb       	ldi	r25, 0xB0	; 176
     802:	a7 e1       	ldi	r26, 0x17	; 23
     804:	b5 e4       	ldi	r27, 0x45	; 69
     806:	80 93 53 09 	sts	0x0953, r24
     80a:	90 93 54 09 	sts	0x0954, r25
     80e:	a0 93 55 09 	sts	0x0955, r26
	}
	else 
	{
	  debug = 0x0D;
     812:	b0 93 56 09 	sts	0x0956, r27
	  // voltage is normalized by mean 13.7 and std 0.1558 (real - 13.7)/0.1558;
	  temp_real = (real - 13.7)*6.418485;
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	98 e9       	ldi	r25, 0x98	; 152
     81a:	ae ea       	ldi	r26, 0xAE	; 174
     81c:	b5 e4       	ldi	r27, 0x45	; 69
     81e:	80 93 8a 0d 	sts	0x0D8A, r24
     822:	90 93 8b 0d 	sts	0x0D8B, r25
     826:	a0 93 8c 0d 	sts	0x0D8C, r26
     82a:	b0 93 8d 0d 	sts	0x0D8D, r27
     82e:	08 95       	ret

00000830 <assign_discharge_fit>:
     830:	80 e0       	ldi	r24, 0x00	; 0
     832:	96 e1       	ldi	r25, 0x16	; 22
     834:	a9 e8       	ldi	r26, 0x89	; 137
      batt_time = q1*pow(temp_real,3) + q2*pow(temp_real,2) + q3*temp_real + q4;
     836:	b6 e4       	ldi	r27, 0x46	; 70
     838:	80 93 2b 07 	sts	0x072B, r24
     83c:	90 93 2c 07 	sts	0x072C, r25
     840:	a0 93 2d 07 	sts	0x072D, r26
     844:	b0 93 2e 07 	sts	0x072E, r27
     848:	88 eb       	ldi	r24, 0xB8	; 184
     84a:	93 ec       	ldi	r25, 0xC3	; 195
     84c:	90 93 77 0d 	sts	0x0D77, r25
     850:	80 93 76 0d 	sts	0x0D76, r24
     854:	8a ee       	ldi	r24, 0xEA	; 234
     856:	98 eb       	ldi	r25, 0xB8	; 184
     858:	90 93 81 0d 	sts	0x0D81, r25
     85c:	80 93 80 0d 	sts	0x0D80, r24
     860:	8f e6       	ldi	r24, 0x6F	; 111
     862:	9c e9       	ldi	r25, 0x9C	; 156
     864:	90 93 1b 07 	sts	0x071B, r25
     868:	80 93 1a 07 	sts	0x071A, r24
     86c:	85 e9       	ldi	r24, 0x95	; 149
     86e:	9c e2       	ldi	r25, 0x2C	; 44
     870:	90 93 4c 09 	sts	0x094C, r25
     874:	80 93 4b 09 	sts	0x094B, r24
     878:	81 e7       	ldi	r24, 0x71	; 113
     87a:	9a ea       	ldi	r25, 0xAA	; 170
     87c:	90 93 59 03 	sts	0x0359, r25
     880:	80 93 58 03 	sts	0x0358, r24
     884:	8a ec       	ldi	r24, 0xCA	; 202
     886:	98 e3       	ldi	r25, 0x38	; 56
     888:	90 93 41 09 	sts	0x0941, r25
     88c:	80 93 40 09 	sts	0x0940, r24
     890:	82 e0       	ldi	r24, 0x02	; 2
     892:	93 e0       	ldi	r25, 0x03	; 3
     894:	90 93 79 0d 	sts	0x0D79, r25
     898:	80 93 78 0d 	sts	0x0D78, r24
     89c:	8d ea       	ldi	r24, 0xAD	; 173
     89e:	97 e0       	ldi	r25, 0x07	; 7
     8a0:	90 93 7f 0d 	sts	0x0D7F, r25
     8a4:	80 93 7e 0d 	sts	0x0D7E, r24
     8a8:	80 e8       	ldi	r24, 0x80	; 128
     8aa:	95 e1       	ldi	r25, 0x15	; 21
     8ac:	90 93 35 07 	sts	0x0735, r25
     8b0:	80 93 34 07 	sts	0x0734, r24
     8b4:	8e e4       	ldi	r24, 0x4E	; 78
     8b6:	9c ef       	ldi	r25, 0xFC	; 252
     8b8:	90 93 33 07 	sts	0x0733, r25
     8bc:	80 93 32 07 	sts	0x0732, r24
     8c0:	8b e3       	ldi	r24, 0x3B	; 59
     8c2:	93 e0       	ldi	r25, 0x03	; 3
     8c4:	90 93 75 0d 	sts	0x0D75, r25
     8c8:	80 93 74 0d 	sts	0x0D74, r24
     8cc:	8c ed       	ldi	r24, 0xDC	; 220
     8ce:	9b e6       	ldi	r25, 0x6B	; 107
     8d0:	ae e2       	ldi	r26, 0x2E	; 46
     8d2:	b0 e4       	ldi	r27, 0x40	; 64
     8d4:	80 93 21 07 	sts	0x0721, r24
     8d8:	90 93 22 07 	sts	0x0722, r25
     8dc:	a0 93 23 07 	sts	0x0723, r26
     8e0:	b0 93 24 07 	sts	0x0724, r27
	}
  	percent = 100*(batt_time/charge_max_time);
     8e4:	80 e8       	ldi	r24, 0x80	; 128
     8e6:	95 e5       	ldi	r25, 0x55	; 85
     8e8:	a2 ec       	ldi	r26, 0xC2	; 194
     8ea:	b1 e1       	ldi	r27, 0x11	; 17
     8ec:	80 93 47 09 	sts	0x0947, r24
     8f0:	90 93 48 09 	sts	0x0948, r25
     8f4:	a0 93 49 09 	sts	0x0949, r26
     8f8:	b0 93 4a 09 	sts	0x094A, r27
     8fc:	80 ea       	ldi	r24, 0xA0	; 160
     8fe:	9c e3       	ldi	r25, 0x3C	; 60
     900:	a3 e7       	ldi	r26, 0x73	; 115
     902:	bc e0       	ldi	r27, 0x0C	; 12
     904:	80 93 63 03 	sts	0x0363, r24
     908:	90 93 64 03 	sts	0x0364, r25
     90c:	a0 93 65 03 	sts	0x0365, r26
     910:	b0 93 66 03 	sts	0x0366, r27
     914:	80 ea       	ldi	r24, 0xA0	; 160
     916:	96 e6       	ldi	r25, 0x66	; 102
     918:	ac ef       	ldi	r26, 0xFC	; 252
     91a:	b9 e1       	ldi	r27, 0x19	; 25
     91c:	80 93 68 03 	sts	0x0368, r24
     920:	90 93 69 03 	sts	0x0369, r25
  }
  
  // Percent limiting for periodic function
  if (percent < 1) 
     924:	a0 93 6a 03 	sts	0x036A, r26
     928:	b0 93 6b 03 	sts	0x036B, r27
     92c:	80 e2       	ldi	r24, 0x20	; 32
     92e:	95 eb       	ldi	r25, 0xB5	; 181
     930:	a4 ea       	ldi	r26, 0xA4	; 164
     932:	b6 ef       	ldi	r27, 0xF6	; 246
     934:	80 93 43 09 	sts	0x0943, r24
     938:	90 93 44 09 	sts	0x0944, r25
     93c:	a0 93 45 09 	sts	0x0945, r26
     940:	b0 93 46 09 	sts	0x0946, r27
     944:	80 e9       	ldi	r24, 0x90	; 144
  { 
  	debug2 = 0xA0;
     946:	92 ec       	ldi	r25, 0xC2	; 194
     948:	ad eb       	ldi	r26, 0xBD	; 189
     94a:	bb e0       	ldi	r27, 0x0B	; 11
  	soc = 0; 
     94c:	80 93 3b 09 	sts	0x093B, r24
     950:	90 93 3c 09 	sts	0x093C, r25
  }
  else if (percent > 99) 
     954:	a0 93 3d 09 	sts	0x093D, r26
     958:	b0 93 3e 09 	sts	0x093E, r27
     95c:	88 e8       	ldi	r24, 0x88	; 136
     95e:	9b e7       	ldi	r25, 0x7B	; 123
     960:	a5 e8       	ldi	r26, 0x85	; 133
     962:	bb ef       	ldi	r27, 0xFB	; 251
     964:	80 93 82 0d 	sts	0x0D82, r24
  { 
  	debug2 = 0xB0;
     968:	90 93 83 0d 	sts	0x0D83, r25
  	soc = 255;
     96c:	a0 93 84 0d 	sts	0x0D84, r26
     970:	b0 93 85 0d 	sts	0x0D85, r27
  }
  else { 
  	debug2 = 0xC0;
     974:	8c ed       	ldi	r24, 0xDC	; 220
     976:	93 ec       	ldi	r25, 0xC3	; 195
     978:	a6 e0       	ldi	r26, 0x06	; 6
  	soc = (char)floor((int)(percent)); 
     97a:	bf ef       	ldi	r27, 0xFF	; 255
     97c:	80 93 54 03 	sts	0x0354, r24
     980:	90 93 55 03 	sts	0x0355, r25
     984:	a0 93 56 03 	sts	0x0356, r26
     988:	b0 93 57 03 	sts	0x0357, r27
     98c:	8a e6       	ldi	r24, 0x6A	; 106
     98e:	9d ea       	ldi	r25, 0xAD	; 173
     990:	a7 ed       	ldi	r26, 0xD7	; 215
     992:	bf ef       	ldi	r27, 0xFF	; 255
     994:	80 93 6b 0d 	sts	0x0D6B, r24
     998:	90 93 6c 0d 	sts	0x0D6C, r25
  }
}
     99c:	a0 93 6d 0d 	sts	0x0D6D, r26
     9a0:	b0 93 6e 0d 	sts	0x0D6E, r27
     9a4:	8c eb       	ldi	r24, 0xBC	; 188
     9a6:	90 ee       	ldi	r25, 0xE0	; 224
     9a8:	a4 e6       	ldi	r26, 0x64	; 100
     9aa:	bf ef       	ldi	r27, 0xFF	; 255
     9ac:	80 93 3f 03 	sts	0x033F, r24
     9b0:	90 93 40 03 	sts	0x0340, r25
     9b4:	a0 93 41 03 	sts	0x0341, r26
     9b8:	b0 93 42 03 	sts	0x0342, r27
     9bc:	82 ec       	ldi	r24, 0xC2	; 194
     9be:	96 ec       	ldi	r25, 0xC6	; 198
     9c0:	aa eb       	ldi	r26, 0xBA	; 186
     9c2:	be e3       	ldi	r27, 0x3E	; 62
  g2 =  1.969854815603661E8;
  h3 =  -7.513816845838763E7;
  g3 =  -1.633385950799686E7;
  h4 =   -2.642581886559125E6;
  g4 =   -1.016608352073227E7;
  w2 =  0.364797662747743;
     9c4:	80 93 67 0b 	sts	0x0B67, r24
     9c8:	90 93 68 0b 	sts	0x0B68, r25
     9cc:	a0 93 69 0b 	sts	0x0B69, r26
     9d0:	b0 93 6a 0b 	sts	0x0B6A, r27
     9d4:	08 95       	ret

000009d6 <initialize>:
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE,    MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE,    MUX2    ,       6     );  // Fake Data
}

void initialize( void )
{
     9d6:	ef 92       	push	r14
     9d8:	ff 92       	push	r15
     9da:	0f 93       	push	r16
     9dc:	1f 93       	push	r17
     9de:	cf 93       	push	r28
     9e0:	df 93       	push	r29
   // pin initialization
  DDRA  = 0b11111111;
     9e2:	1f ef       	ldi	r17, 0xFF	; 255
     9e4:	1a bb       	out	0x1a, r17	; 26
  PORTA = 0b00000111;
     9e6:	87 e0       	ldi	r24, 0x07	; 7
     9e8:	8b bb       	out	0x1b, r24	; 27

  DDRB  = 0b11111111;
     9ea:	17 bb       	out	0x17, r17	; 23
  PORTB = 0b11100000;
     9ec:	80 ee       	ldi	r24, 0xE0	; 224
     9ee:	88 bb       	out	0x18, r24	; 24

  DDRC  = 0b11111111;
     9f0:	14 bb       	out	0x14, r17	; 20
  PORTC = 0b11111111;
     9f2:	15 bb       	out	0x15, r17	; 21

  DDRD  = 0b11111011;
     9f4:	8b ef       	ldi	r24, 0xFB	; 251
     9f6:	81 bb       	out	0x11, r24	; 17
  PORTD = 0b11110000;
     9f8:	80 ef       	ldi	r24, 0xF0	; 240
     9fa:	82 bb       	out	0x12, r24	; 18

  DDRE  = 0b11111110;
     9fc:	9e ef       	ldi	r25, 0xFE	; 254
     9fe:	92 b9       	out	0x02, r25	; 2
  PORTE = 0b00000000;
     a00:	13 b8       	out	0x03, r1	; 3

  DDRF  = 0b11110000;
     a02:	80 93 61 00 	sts	0x0061, r24
  //0b11111111;	//testing
  PORTF = 0b00000000;
     a06:	10 92 62 00 	sts	0x0062, r1

  DDRG  = 0b00011111;
     a0a:	8f e1       	ldi	r24, 0x1F	; 31
     a0c:	80 93 64 00 	sts	0x0064, r24
  PORTG = 0b00000100;
     a10:	04 e0       	ldi	r16, 0x04	; 4
     a12:	00 93 65 00 	sts	0x0065, r16
  // compare value = 124
  // compare match interrupt freq = (14.7456 MHz / 1024 / 100) = 144 Hz
  // use timer0_counter to get 144 / 144 = 1 Hz

  // enable clear on match interrupt
  TIMSK = ( 1 << OCIE0 );
     a16:	82 e0       	ldi	r24, 0x02	; 2
     a18:	87 bf       	out	0x37, r24	; 55
  OCR0 = 71;
     a1a:	87 e4       	ldi	r24, 0x47	; 71
     a1c:	81 bf       	out	0x31, r24	; 49

  // enable clear on match mode, set prescalar to 1024
  TCCR0 = ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );
     a1e:	8f e0       	ldi	r24, 0x0F	; 15
     a20:	83 bf       	out	0x33, r24	; 51

  timer0_counter[0] = 99;
     a22:	83 e6       	ldi	r24, 0x63	; 99
     a24:	80 93 64 0b 	sts	0x0B64, r24
  timer0_counter[1] = 199;
     a28:	87 ec       	ldi	r24, 0xC7	; 199
     a2a:	80 93 65 0b 	sts	0x0B65, r24
  period of interrupts = 28800 / 14400 Hz = 2 s/interrupt
  use timer1_counter to get a total period of 2*65535 =  s (24 hours is 86400 seconds)
  */
  
  // Enable clear on match interrupt for the 16 bit timer/counter 1, register A
  OCR1A = 28800;		//28800 corresponds to 2 seconds
     a2e:	80 e8       	ldi	r24, 0x80	; 128
     a30:	90 e7       	ldi	r25, 0x70	; 112
     a32:	9b bd       	out	0x2b, r25	; 43
     a34:	8a bd       	out	0x2a, r24	; 42

  // Enable clear on match mode, set prescalar to 1024.
  // CS[2:0] = 101 (1024 prescalar)
  // WGM[3:0] = 0100 (Clear Timer on Compare (CTC) when timer matches OCR1A)
  
  TCCR1B = ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS10 );
     a36:	8d e0       	ldi	r24, 0x0D	; 13
     a38:	8e bd       	out	0x2e, r24	; 46
  // Explicit Default Defs
  // TCCR1A |= 0;
  // TCNT1 = 0;
  timer1_counter[0] = CYCLE_COUNTER;	//CYCLE_COUNTER   = 900 for 2 seconds interrupt handler = 1800 secs (30 minutes)
     a3a:	84 e8       	ldi	r24, 0x84	; 132
     a3c:	80 93 86 0d 	sts	0x0D86, r24
  timer1_counter[1] = CYCLE_COUNTER_2;	//CYCLE_COUNTER_2 = 300 for 2 seconds interrupt handler = 600 secs  (10 minutes)
     a40:	8c e2       	ldi	r24, 0x2C	; 44
     a42:	80 93 87 0d 	sts	0x0D87, r24
  //---------------------------------------------------------------------  
  // End of timer 1 Setup
  //--------------------------------------------------------------------- 
  
  // communication
  uart_init();
     a46:	0e 94 3f 09 	call	0x127e	; 0x127e <uart_init>

  // for use in debugging
  // stdout = stdin = stderr = &uart_str;

  tel_packet_size[0] = 0;
     a4a:	10 92 60 03 	sts	0x0360, r1
     a4e:	10 92 5f 03 	sts	0x035F, r1
  tel_packet_size[1] = 0;
     a52:	10 92 62 03 	sts	0x0362, r1
     a56:	10 92 61 03 	sts	0x0361, r1
  tel_packet_index[0] = 0;
     a5a:	10 92 2f 07 	sts	0x072F, r1
  tel_packet_index[1] = 0;
     a5e:	10 92 30 07 	sts	0x0730, r1
  uart_vcp_buff[0] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     a62:	8a e0       	ldi	r24, 0x0A	; 10
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <malloc>
     a6a:	7c 01       	movw	r14, r24
     a6c:	ee e8       	ldi	r30, 0x8E	; 142
     a6e:	fd e0       	ldi	r31, 0x0D	; 13
     a70:	80 83       	st	Z, r24
     a72:	f1 82       	std	Z+1, r15	; 0x01
  uart_vcp_buff[1] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     a74:	8a e0       	ldi	r24, 0x0A	; 10
     a76:	90 e0       	ldi	r25, 0x00	; 0
     a78:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <malloc>
     a7c:	c0 e9       	ldi	r28, 0x90	; 144
     a7e:	dd e0       	ldi	r29, 0x0D	; 13
     a80:	88 83       	st	Y, r24
     a82:	99 83       	std	Y+1, r25	; 0x01
  vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     a84:	4f ef       	ldi	r20, 0xFF	; 255
     a86:	50 e0       	ldi	r21, 0x00	; 0
     a88:	6d e6       	ldi	r22, 0x6D	; 109
     a8a:	7b e0       	ldi	r23, 0x0B	; 11
     a8c:	c7 01       	movw	r24, r14
     a8e:	0e 94 65 09 	call	0x12ca	; 0x12ca <vcpptr_init>
  vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     a92:	4f ef       	ldi	r20, 0xFF	; 255
     a94:	50 e0       	ldi	r21, 0x00	; 0
     a96:	6c e6       	ldi	r22, 0x6C	; 108
     a98:	7c e0       	ldi	r23, 0x0C	; 12
     a9a:	88 81       	ld	r24, Y
     a9c:	99 81       	ldd	r25, Y+1	; 0x01
     a9e:	0e 94 65 09 	call	0x12ca	; 0x12ca <vcpptr_init>

  rx_flag[0] = 0;
     aa2:	10 92 92 0d 	sts	0x0D92, r1
  rx_flag[1] = 0;
     aa6:	10 92 93 0d 	sts	0x0D93, r1

  // svit
  initialize_svit();
     aaa:	0e 94 92 00 	call	0x124	; 0x124 <initialize_svit>

  // rev up those interrupts
  sei();
     aae:	78 94       	sei

  //ADC conversions
  adc_flag = 1;
     ab0:	c1 e0       	ldi	r28, 0x01	; 1
     ab2:	c0 93 35 09 	sts	0x0935, r28
	adc_component = 0;
     ab6:	10 92 6d 03 	sts	0x036D, r1
	adc_sensor_type = ADC_INIT;//get default case on first interation as to not enter switch
     aba:	00 93 42 09 	sts	0x0942, r16
  ADC_high = 0;
     abe:	10 92 52 09 	sts	0x0952, r1

  V_upper_val_change = 0;
     ac2:	10 92 6b 0b 	sts	0x0B6B, r1
  I_upper_val_change = 0;
     ac6:	10 92 66 0b 	sts	0x0B66, r1

  //---------------------------------------------------------------------  
  // SOC Initializations
  //--------------------------------------------------------------------- 
  // and shunt and safe transmit flags
  safe_mode = 0;
     aca:	10 92 3f 09 	sts	0x093F, r1
  transmit_safe = 0;
     ace:	10 92 3a 09 	sts	0x093A, r1
  transmit_shunt = 0;
     ad2:	10 92 73 0d 	sts	0x0D73, r1
  been_to_safe = 0;
     ad6:	10 92 67 03 	sts	0x0367, r1
  been_to_shunt = 0;
     ada:	10 92 5d 09 	sts	0x095D, r1
  assign_charge_fit();
     ade:	0e 94 ab 03 	call	0x756	; 0x756 <assign_charge_fit>
  assign_discharge_fit();
     ae2:	0e 94 18 04 	call	0x830	; 0x830 <assign_discharge_fit>
  
  // First get battery voltage so that the SoC can
  // accurately determine whether batteries are charging or discharging
  batt1_voltage = 0xff;
     ae6:	10 93 5c 09 	sts	0x095C, r17
  batt2_voltage = 0xff;
     aea:	10 93 6c 0b 	sts	0x0B6C, r17
  charging = 0xff;
     aee:	10 93 26 07 	sts	0x0726, r17
  chargeforward = 0;
     af2:	10 92 89 0d 	sts	0x0D89, r1
  chargebackward = 0;
     af6:	10 92 6c 03 	sts	0x036C, r1
  debug = 0;
     afa:	10 92 25 07 	sts	0x0725, r1
  debug2 = 0;
     afe:	10 92 31 07 	sts	0x0731, r1
  percent = 0;
     b02:	10 92 1d 07 	sts	0x071D, r1
     b06:	10 92 1e 07 	sts	0x071E, r1
     b0a:	10 92 1f 07 	sts	0x071F, r1
     b0e:	10 92 20 07 	sts	0x0720, r1
  soc = 0;
     b12:	10 92 96 0f 	sts	0x0F96, r1
  high = 0;
     b16:	10 92 4d 09 	sts	0x094D, r1
  low = 0;
     b1a:	10 92 5b 09 	sts	0x095B, r1
  limit_check_overriden = 0; // Initially limit checking is NOT OVERRIDEN
     b1e:	10 92 1c 07 	sts	0x071C, r1
  //--------------------------------------------------------------------- 

  //---------------------------------------------------------------------  
  // Timer Initializations
  //---------------------------------------------------------------------
  cdh_heartbeat_flag = 0;	//Default: do not have flag to restart components on
     b22:	10 92 5a 03 	sts	0x035A, r1
  rad_torq_flag = 1;		//Indicates need to delay radio/torquer on signals later
     b26:	c0 93 43 03 	sts	0x0343, r28
  SVIT_t *component; 	// Initialize Radios to be OFF
  component = &svit[components[RADIO_1]];
     b2a:	a0 91 4f 03 	lds	r26, 0x034F
     b2e:	ca e1       	ldi	r28, 0x1A	; 26
     b30:	ca 9f       	mul	r28, r26
     b32:	d0 01       	movw	r26, r0
     b34:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     b36:	a2 59       	subi	r26, 0x92	; 146
     b38:	bc 4f       	sbci	r27, 0xFC	; 252
     b3a:	11 96       	adiw	r26, 0x01	; 1
     b3c:	8c 91       	ld	r24, X
     b3e:	0e 94 b2 07 	call	0xf64	; 0xf64 <switch_off>
  component = &svit[components[RADIO_2]];
     b42:	e0 91 50 03 	lds	r30, 0x0350
     b46:	ce 9f       	mul	r28, r30
     b48:	f0 01       	movw	r30, r0
     b4a:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     b4c:	e2 59       	subi	r30, 0x92	; 146
     b4e:	fc 4f       	sbci	r31, 0xFC	; 252
     b50:	81 81       	ldd	r24, Z+1	; 0x01
     b52:	0e 94 b2 07 	call	0xf64	; 0xf64 <switch_off>
  component = &svit[TORQUER_1];	// Initialize Torque Coils to be OFF
  component->switch_state = SW_OFF;
     b56:	10 92 2a 05 	sts	0x052A, r1
  component = &svit[TORQUER_2];
  component->switch_state = SW_OFF;
     b5a:	10 92 44 05 	sts	0x0544, r1
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
     b5e:	10 92 5e 05 	sts	0x055E, r1
  torquer_off(TORQUER_1);
     b62:	81 e1       	ldi	r24, 0x11	; 17
     b64:	0e 94 38 07 	call	0xe70	; 0xe70 <torquer_off>
  torquer_off(TORQUER_2);
     b68:	82 e1       	ldi	r24, 0x12	; 18
     b6a:	0e 94 38 07 	call	0xe70	; 0xe70 <torquer_off>
  torquer_off(TORQUER_3);
     b6e:	83 e1       	ldi	r24, 0x13	; 19
  //---------------------------------------------------------------------  
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}
     b70:	df 91       	pop	r29
     b72:	cf 91       	pop	r28
     b74:	1f 91       	pop	r17
     b76:	0f 91       	pop	r16
     b78:	ff 90       	pop	r15
     b7a:	ef 90       	pop	r14
  component->switch_state = SW_OFF;
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
  torquer_off(TORQUER_1);
  torquer_off(TORQUER_2);
  torquer_off(TORQUER_3);
     b7c:	0c 94 38 07 	jmp	0xe70	; 0xe70 <torquer_off>

00000b80 <compareVoltage>:
void compareVoltage( void ) {
  SVIT_t *component;
  //component = &svit[BATTERY_1_b];
  //chargebackward = average_samples( component->I_samples );
  component = &svit[BATTERY_1];
  chargeforward= average_samples( component->I_samples );
     b80:	85 e8       	ldi	r24, 0x85	; 133
     b82:	95 e0       	ldi	r25, 0x05	; 5
     b84:	0e 94 f5 07 	call	0xfea	; 0xfea <average_samples>
     b88:	80 93 89 0d 	sts	0x0D89, r24
  if (chargeforward > 2){
     b8c:	83 30       	cpi	r24, 0x03	; 3
     b8e:	10 f0       	brcs	.+4      	; 0xb94 <compareVoltage+0x14>
    charging = 0xdd;//discharging
     b90:	8d ed       	ldi	r24, 0xDD	; 221
     b92:	01 c0       	rjmp	.+2      	; 0xb96 <compareVoltage+0x16>
    }
  else{
    charging = 0xcc;
     b94:	8c ec       	ldi	r24, 0xCC	; 204
     b96:	80 93 26 07 	sts	0x0726, r24
     b9a:	08 95       	ret

00000b9c <limit_check>:
we should at least get the framework set up for limit checking on arbitrary values.
The power board should have upper and lower limits for vsense and csense data, 
and turn off components if their voltage/current is too high. ONLY CHECKS
BATTERY 1 VOLTAGE LINE RIGHT NOW.
*/
void limit_check( void ) {
     b9c:	cf 92       	push	r12
     b9e:	df 92       	push	r13
     ba0:	ef 92       	push	r14
     ba2:	ff 92       	push	r15
     ba4:	0f 93       	push	r16
     ba6:	1f 93       	push	r17
     ba8:	cf 93       	push	r28
     baa:	df 93       	push	r29
	unsigned char sw;
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
     bac:	c0 90 1d 07 	lds	r12, 0x071D
     bb0:	d0 90 1e 07 	lds	r13, 0x071E
     bb4:	e0 90 1f 07 	lds	r14, 0x071F
     bb8:	f0 90 20 07 	lds	r15, 0x0720
     bbc:	20 e0       	ldi	r18, 0x00	; 0
     bbe:	30 e0       	ldi	r19, 0x00	; 0
     bc0:	a9 01       	movw	r20, r18
     bc2:	c7 01       	movw	r24, r14
     bc4:	b6 01       	movw	r22, r12
     bc6:	0e 94 89 10 	call	0x2112	; 0x2112 <__cmpsf2>
     bca:	87 ff       	sbrs	r24, 7
     bcc:	4c c0       	rjmp	.+152    	; 0xc66 <limit_check+0xca>
     bce:	29 e2       	ldi	r18, 0x29	; 41
     bd0:	3c e5       	ldi	r19, 0x5C	; 92
     bd2:	4f e0       	ldi	r20, 0x0F	; 15
     bd4:	5f eb       	ldi	r21, 0xBF	; 191
     bd6:	c7 01       	movw	r24, r14
     bd8:	b6 01       	movw	r22, r12
     bda:	0e 94 89 10 	call	0x2112	; 0x2112 <__cmpsf2>
     bde:	87 ff       	sbrs	r24, 7
     be0:	0a c0       	rjmp	.+20     	; 0xbf6 <limit_check+0x5a>
     be2:	25 e8       	ldi	r18, 0x85	; 133
     be4:	3b ee       	ldi	r19, 0xEB	; 235
     be6:	41 e1       	ldi	r20, 0x11	; 17
     be8:	5f eb       	ldi	r21, 0xBF	; 191
     bea:	c7 01       	movw	r24, r14
     bec:	b6 01       	movw	r22, r12
     bee:	0e 94 a7 11 	call	0x234e	; 0x234e <__gesf2>
     bf2:	18 16       	cp	r1, r24
     bf4:	c4 f1       	brlt	.+112    	; 0xc66 <limit_check+0xca>
		safe_mode = 1;
     bf6:	81 e0       	ldi	r24, 0x01	; 1
     bf8:	80 93 3f 09 	sts	0x093F, r24
     bfc:	04 e4       	ldi	r16, 0x44	; 68
     bfe:	13 e0       	ldi	r17, 0x03	; 3
		for (sw = 0; sw < sizeof(components); sw++) {
			component = &svit[components[sw]];
     c00:	ba e1       	ldi	r27, 0x1A	; 26
     c02:	fb 2e       	mov	r15, r27
     c04:	f8 01       	movw	r30, r16
     c06:	c1 91       	ld	r28, Z+
     c08:	8f 01       	movw	r16, r30
     c0a:	fc 9e       	mul	r15, r28
     c0c:	e0 01       	movw	r28, r0
     c0e:	11 24       	eor	r1, r1
     c10:	c2 59       	subi	r28, 0x92	; 146
     c12:	dc 4f       	sbci	r29, 0xFC	; 252
			switch_off( component->switch_num );
     c14:	89 81       	ldd	r24, Y+1	; 0x01
     c16:	0e 94 b2 07 	call	0xf64	; 0xf64 <switch_off>
			component->switch_state = SW_OFF;
     c1a:	1a 82       	std	Y+2, r1	; 0x02
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
		safe_mode = 1;
		for (sw = 0; sw < sizeof(components); sw++) {
     c1c:	f3 e0       	ldi	r31, 0x03	; 3
     c1e:	04 35       	cpi	r16, 0x54	; 84
     c20:	1f 07       	cpc	r17, r31
     c22:	81 f7       	brne	.-32     	; 0xc04 <limit_check+0x68>
			component = &svit[components[sw]];
			switch_off( component->switch_num );
			component->switch_state = SW_OFF;
		}
		component = &svit[TORQUER_1];
		component->switch_state = SW_OFF;
     c24:	10 92 2a 05 	sts	0x052A, r1
		component = &svit[TORQUER_2];
		component->switch_state = SW_OFF;
     c28:	10 92 44 05 	sts	0x0544, r1
		component = &svit[TORQUER_3];
		component->switch_state = SW_OFF;
     c2c:	10 92 5e 05 	sts	0x055E, r1
		torquer_off(TORQUER_1);
     c30:	81 e1       	ldi	r24, 0x11	; 17
     c32:	0e 94 38 07 	call	0xe70	; 0xe70 <torquer_off>
		torquer_off(TORQUER_2);
     c36:	82 e1       	ldi	r24, 0x12	; 18
     c38:	0e 94 38 07 	call	0xe70	; 0xe70 <torquer_off>
		torquer_off(TORQUER_3);
     c3c:	83 e1       	ldi	r24, 0x13	; 19
     c3e:	0e 94 38 07 	call	0xe70	; 0xe70 <torquer_off>
		// Only transmit once
		if (!transmit_safe && !been_to_safe) { 
     c42:	80 91 3a 09 	lds	r24, 0x093A
     c46:	81 11       	cpse	r24, r1
     c48:	08 c0       	rjmp	.+16     	; 0xc5a <limit_check+0xbe>
     c4a:	80 91 67 03 	lds	r24, 0x0367
     c4e:	81 11       	cpse	r24, r1
     c50:	04 c0       	rjmp	.+8      	; 0xc5a <limit_check+0xbe>
			transmit_packet( 0, VCP_ACK, SAFE_MODE);
     c52:	40 e0       	ldi	r20, 0x00	; 0
     c54:	62 e0       	ldi	r22, 0x02	; 2
     c56:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <transmit_packet>
			transmit_safe = 1;
		}
		else {}
		been_to_safe = 1;
     c5a:	81 e0       	ldi	r24, 0x01	; 1
     c5c:	80 93 67 03 	sts	0x0367, r24
		transmit_safe = 1;
     c60:	80 93 3a 09 	sts	0x093A, r24
     c64:	24 c0       	rjmp	.+72     	; 0xcae <limit_check+0x112>
	}
	else if (percent > SHUNT_MODE) {
     c66:	20 e0       	ldi	r18, 0x00	; 0
     c68:	30 e0       	ldi	r19, 0x00	; 0
     c6a:	48 ec       	ldi	r20, 0xC8	; 200
     c6c:	52 e4       	ldi	r21, 0x42	; 66
     c6e:	c7 01       	movw	r24, r14
     c70:	b6 01       	movw	r22, r12
     c72:	0e 94 a7 11 	call	0x234e	; 0x234e <__gesf2>
     c76:	18 16       	cp	r1, r24
     c78:	d4 f4       	brge	.+52     	; 0xcae <limit_check+0x112>
	    safe_mode = 0;
     c7a:	10 92 3f 09 	sts	0x093F, r1
		// turn on the maestro and send ack_command w/ value of SHUNT_MODE
		component = &svit[MAESTRO];
		switch_on( component->switch_num );
     c7e:	80 91 c1 04 	lds	r24, 0x04C1
     c82:	0e 94 6f 07 	call	0xede	; 0xede <switch_on>
		component->switch_state = SW_ON;
     c86:	81 e0       	ldi	r24, 0x01	; 1
     c88:	80 93 c2 04 	sts	0x04C2, r24
		// Only transmit once
		if (!transmit_shunt && !been_to_shunt) {
     c8c:	80 91 73 0d 	lds	r24, 0x0D73
     c90:	81 11       	cpse	r24, r1
     c92:	08 c0       	rjmp	.+16     	; 0xca4 <limit_check+0x108>
     c94:	80 91 5d 09 	lds	r24, 0x095D
     c98:	81 11       	cpse	r24, r1
     c9a:	04 c0       	rjmp	.+8      	; 0xca4 <limit_check+0x108>
			transmit_packet( 0, VCP_ACK, SHUNT_MODE);
     c9c:	44 e6       	ldi	r20, 0x64	; 100
     c9e:	62 e0       	ldi	r22, 0x02	; 2
     ca0:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <transmit_packet>
		}
		else {}	
		been_to_shunt = 1;
     ca4:	81 e0       	ldi	r24, 0x01	; 1
     ca6:	80 93 5d 09 	sts	0x095D, r24
		transmit_shunt = 1;	
     caa:	80 93 73 0d 	sts	0x0D73, r24
	}
	else {} // To avoid annoying compile warning 
}
     cae:	df 91       	pop	r29
     cb0:	cf 91       	pop	r28
     cb2:	1f 91       	pop	r17
     cb4:	0f 91       	pop	r16
     cb6:	ff 90       	pop	r15
     cb8:	ef 90       	pop	r14
     cba:	df 90       	pop	r13
     cbc:	cf 90       	pop	r12
     cbe:	08 95       	ret

00000cc0 <main>:


// MAIN
int main( void ) 
{  
  initialize();
     cc0:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <initialize>
  //fprintf( stdout, "uart initialized\n" );
	
  //Testing
  cntr = 0;
     cc4:	10 92 34 09 	sts	0x0934, r1

  while(1)
  {
	cntr = 1 - cntr; //Testing
     cc8:	11 e0       	ldi	r17, 0x01	; 1
	
    if ( timer0_counter[1] == 0 )
    {
        timer0_counter[1] = 199;
     cca:	c7 ec       	ldi	r28, 0xC7	; 199
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     ccc:	dc e2       	ldi	r29, 0x2C	; 44
  //Testing
  cntr = 0;

  while(1)
  {
	cntr = 1 - cntr; //Testing
     cce:	80 91 34 09 	lds	r24, 0x0934
     cd2:	91 2f       	mov	r25, r17
     cd4:	98 1b       	sub	r25, r24
     cd6:	90 93 34 09 	sts	0x0934, r25
	
    if ( timer0_counter[1] == 0 )
     cda:	80 91 65 0b 	lds	r24, 0x0B65
     cde:	81 11       	cpse	r24, r1
     ce0:	07 c0       	rjmp	.+14     	; 0xcf0 <main+0x30>
    {
        timer0_counter[1] = 199;
     ce2:	c0 93 65 0b 	sts	0x0B65, r28
        transmit_packet( 1, VCP_POWER_TELEMETRY, 0);
     ce6:	40 e0       	ldi	r20, 0x00	; 0
     ce8:	60 e0       	ldi	r22, 0x00	; 0
     cea:	81 e0       	ldi	r24, 0x01	; 1
     cec:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <transmit_packet>
    }
	  if ( timer0_counter[0] == 0 )
     cf0:	80 91 64 0b 	lds	r24, 0x0B64
     cf4:	81 11       	cpse	r24, r1
     cf6:	06 c0       	rjmp	.+12     	; 0xd04 <main+0x44>
    {
        timer0_counter[0] = 199;
     cf8:	c0 93 64 0b 	sts	0x0B64, r28
        transmit_packet( 0, VCP_POWER_TELEMETRY, 0);
     cfc:	40 e0       	ldi	r20, 0x00	; 0
     cfe:	60 e0       	ldi	r22, 0x00	; 0
     d00:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <transmit_packet>
    }
	  if ( rx_flag[0] > 0 )
     d04:	80 91 92 0d 	lds	r24, 0x0D92
     d08:	88 23       	and	r24, r24
     d0a:	c9 f0       	breq	.+50     	; 0xd3e <main+0x7e>
    {
        rx_flag[0]--;
     d0c:	80 91 92 0d 	lds	r24, 0x0D92
     d10:	81 50       	subi	r24, 0x01	; 1
     d12:	80 93 92 0d 	sts	0x0D92, r24
        receive_message( 0, uart_vcp_buff[0]->message, uart_vcp_buff[0]->index );
     d16:	e0 91 8e 0d 	lds	r30, 0x0D8E
     d1a:	f0 91 8f 0d 	lds	r31, 0x0D8F
     d1e:	61 81       	ldd	r22, Z+1	; 0x01
     d20:	72 81       	ldd	r23, Z+2	; 0x02
     d22:	47 81       	ldd	r20, Z+7	; 0x07
     d24:	80 e0       	ldi	r24, 0x00	; 0
     d26:	0e 94 c5 02 	call	0x58a	; 0x58a <receive_message>
        vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     d2a:	4f ef       	ldi	r20, 0xFF	; 255
     d2c:	50 e0       	ldi	r21, 0x00	; 0
     d2e:	6d e6       	ldi	r22, 0x6D	; 109
     d30:	7b e0       	ldi	r23, 0x0B	; 11
     d32:	80 91 8e 0d 	lds	r24, 0x0D8E
     d36:	90 91 8f 0d 	lds	r25, 0x0D8F
     d3a:	0e 94 65 09 	call	0x12ca	; 0x12ca <vcpptr_init>
    }
	  if ( rx_flag[1] > 0 )
     d3e:	80 91 93 0d 	lds	r24, 0x0D93
     d42:	88 23       	and	r24, r24
     d44:	c9 f0       	breq	.+50     	; 0xd78 <main+0xb8>
    {
        rx_flag[1]--;
     d46:	80 91 93 0d 	lds	r24, 0x0D93
     d4a:	81 50       	subi	r24, 0x01	; 1
     d4c:	80 93 93 0d 	sts	0x0D93, r24
        receive_message( 1, uart_vcp_buff[1]->message, uart_vcp_buff[1]->index );
     d50:	e0 91 90 0d 	lds	r30, 0x0D90
     d54:	f0 91 91 0d 	lds	r31, 0x0D91
     d58:	61 81       	ldd	r22, Z+1	; 0x01
     d5a:	72 81       	ldd	r23, Z+2	; 0x02
     d5c:	47 81       	ldd	r20, Z+7	; 0x07
     d5e:	81 e0       	ldi	r24, 0x01	; 1
     d60:	0e 94 c5 02 	call	0x58a	; 0x58a <receive_message>
        vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     d64:	4f ef       	ldi	r20, 0xFF	; 255
     d66:	50 e0       	ldi	r21, 0x00	; 0
     d68:	6c e6       	ldi	r22, 0x6C	; 108
     d6a:	7c e0       	ldi	r23, 0x0C	; 12
     d6c:	80 91 90 0d 	lds	r24, 0x0D90
     d70:	90 91 91 0d 	lds	r25, 0x0D91
     d74:	0e 94 65 09 	call	0x12ca	; 0x12ca <vcpptr_init>
    }
    if (adc_flag == 1)
     d78:	80 91 35 09 	lds	r24, 0x0935
     d7c:	81 30       	cpi	r24, 0x01	; 1
     d7e:	91 f4       	brne	.+36     	; 0xda4 <main+0xe4>
    {
        adc_flag = 0;
     d80:	10 92 35 09 	sts	0x0935, r1
        read_VIT();
     d84:	0e 94 2c 08 	call	0x1058	; 0x1058 <read_VIT>
		//calcSOC();
		StateofCharge();
     d88:	0e 94 6e 03 	call	0x6dc	; 0x6dc <StateofCharge>

		/*
		Manual Override on Limit Checking: The power board must be able to receive a 
		command to disable and/or change the limits in the limit checking code
		*/
		if (!limit_check_overriden) {
     d8c:	80 91 1c 07 	lds	r24, 0x071C
     d90:	81 11       	cpse	r24, r1
     d92:	02 c0       	rjmp	.+4      	; 0xd98 <main+0xd8>
			limit_check(); // First determine if voltage is within valid range, then switch
     d94:	0e 94 ce 05 	call	0xb9c	; 0xb9c <limit_check>
		}

		if ( adc_component == 23 ) 
     d98:	80 91 6d 03 	lds	r24, 0x036D
     d9c:	87 31       	cpi	r24, 0x17	; 23
     d9e:	11 f4       	brne	.+4      	; 0xda4 <main+0xe4>
      	{ //23ish anything after battery values are calculated
  			  compareVoltage();
     da0:	0e 94 c0 05 	call	0xb80	; 0xb80 <compareVoltage>
	   	}
    }	
	
	//Restart all board components if CDH-IB heartbeat timeout
	if (cdh_heartbeat_flag == 1){
     da4:	80 91 5a 03 	lds	r24, 0x035A
     da8:	81 30       	cpi	r24, 0x01	; 1
     daa:	09 f0       	breq	.+2      	; 0xdae <main+0xee>
     dac:	90 cf       	rjmp	.-224    	; 0xcce <main+0xe>
		//Restart all components
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
     dae:	10 92 5a 03 	sts	0x035A, r1
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
     db2:	d0 93 87 0d 	sts	0x0D87, r29
     db6:	8b cf       	rjmp	.-234    	; 0xcce <main+0xe>

00000db8 <torquer_off.part.0>:
void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
  {
    case TORQUER_1:
      CLR( PORTC, 0 );
     db8:	a8 98       	cbi	0x15, 0	; 21
	  CLR( PORTG, 1 );
     dba:	e5 e6       	ldi	r30, 0x65	; 101
     dbc:	f0 e0       	ldi	r31, 0x00	; 0
     dbe:	80 81       	ld	r24, Z
     dc0:	8d 7f       	andi	r24, 0xFD	; 253
     dc2:	80 83       	st	Z, r24
     dc4:	08 95       	ret

00000dc6 <set_mux_sel>:
#include "mcupwr-Defs.h"


void set_mux_sel( uint8_t mux_num, uint8_t mux_sel )
{
  switch( mux_num )
     dc6:	81 30       	cpi	r24, 0x01	; 1
     dc8:	f9 f0       	breq	.+62     	; 0xe08 <set_mux_sel+0x42>
     dca:	20 f0       	brcs	.+8      	; 0xdd4 <set_mux_sel+0xe>
     dcc:	82 30       	cpi	r24, 0x02	; 2
     dce:	09 f0       	breq	.+2      	; 0xdd2 <set_mux_sel+0xc>
     dd0:	4e c0       	rjmp	.+156    	; 0xe6e <set_mux_sel+0xa8>
     dd2:	34 c0       	rjmp	.+104    	; 0xe3c <set_mux_sel+0x76>
  {
    case MUX0:
      READ( mux_sel, 4 ) ? SET( PORTA, 7 ) : CLR( PORTA, 7 );
     dd4:	64 ff       	sbrs	r22, 4
     dd6:	02 c0       	rjmp	.+4      	; 0xddc <set_mux_sel+0x16>
     dd8:	df 9a       	sbi	0x1b, 7	; 27
     dda:	01 c0       	rjmp	.+2      	; 0xdde <set_mux_sel+0x18>
     ddc:	df 98       	cbi	0x1b, 7	; 27
      READ( mux_sel, 3 ) ? SET( PORTA, 6 ) : CLR( PORTA, 6 );
     dde:	63 ff       	sbrs	r22, 3
     de0:	02 c0       	rjmp	.+4      	; 0xde6 <set_mux_sel+0x20>
     de2:	de 9a       	sbi	0x1b, 6	; 27
     de4:	01 c0       	rjmp	.+2      	; 0xde8 <set_mux_sel+0x22>
     de6:	de 98       	cbi	0x1b, 6	; 27
      READ( mux_sel, 2 ) ? SET( PORTA, 5 ) : CLR( PORTA, 5 );
     de8:	62 ff       	sbrs	r22, 2
     dea:	02 c0       	rjmp	.+4      	; 0xdf0 <set_mux_sel+0x2a>
     dec:	dd 9a       	sbi	0x1b, 5	; 27
     dee:	01 c0       	rjmp	.+2      	; 0xdf2 <set_mux_sel+0x2c>
     df0:	dd 98       	cbi	0x1b, 5	; 27
      READ( mux_sel, 1 ) ? SET( PORTA, 4 ) : CLR( PORTA, 4 );
     df2:	61 ff       	sbrs	r22, 1
     df4:	02 c0       	rjmp	.+4      	; 0xdfa <set_mux_sel+0x34>
     df6:	dc 9a       	sbi	0x1b, 4	; 27
     df8:	01 c0       	rjmp	.+2      	; 0xdfc <set_mux_sel+0x36>
     dfa:	dc 98       	cbi	0x1b, 4	; 27
      READ( mux_sel, 0 ) ? SET( PORTA, 3 ) : CLR( PORTA, 3 );
     dfc:	60 ff       	sbrs	r22, 0
     dfe:	02 c0       	rjmp	.+4      	; 0xe04 <set_mux_sel+0x3e>
     e00:	db 9a       	sbi	0x1b, 3	; 27
     e02:	08 95       	ret
     e04:	db 98       	cbi	0x1b, 3	; 27
     e06:	08 95       	ret

      break;

    case MUX1:
      READ( mux_sel, 4 ) ? SET( PORTB, 0 ) : CLR( PORTB, 0 );
     e08:	64 ff       	sbrs	r22, 4
     e0a:	02 c0       	rjmp	.+4      	; 0xe10 <set_mux_sel+0x4a>
     e0c:	c0 9a       	sbi	0x18, 0	; 24
     e0e:	01 c0       	rjmp	.+2      	; 0xe12 <set_mux_sel+0x4c>
     e10:	c0 98       	cbi	0x18, 0	; 24
      READ( mux_sel, 3 ) ? SET( PORTB, 1 ) : CLR( PORTB, 1 );
     e12:	63 ff       	sbrs	r22, 3
     e14:	02 c0       	rjmp	.+4      	; 0xe1a <set_mux_sel+0x54>
     e16:	c1 9a       	sbi	0x18, 1	; 24
     e18:	01 c0       	rjmp	.+2      	; 0xe1c <set_mux_sel+0x56>
     e1a:	c1 98       	cbi	0x18, 1	; 24
      READ( mux_sel, 2 ) ? SET( PORTB, 2 ) : CLR( PORTB, 2 );
     e1c:	62 ff       	sbrs	r22, 2
     e1e:	02 c0       	rjmp	.+4      	; 0xe24 <set_mux_sel+0x5e>
     e20:	c2 9a       	sbi	0x18, 2	; 24
     e22:	01 c0       	rjmp	.+2      	; 0xe26 <set_mux_sel+0x60>
     e24:	c2 98       	cbi	0x18, 2	; 24
      READ( mux_sel, 1 ) ? SET( PORTB, 3 ) : CLR( PORTB, 3 );
     e26:	61 ff       	sbrs	r22, 1
     e28:	02 c0       	rjmp	.+4      	; 0xe2e <set_mux_sel+0x68>
     e2a:	c3 9a       	sbi	0x18, 3	; 24
     e2c:	01 c0       	rjmp	.+2      	; 0xe30 <set_mux_sel+0x6a>
     e2e:	c3 98       	cbi	0x18, 3	; 24
      READ( mux_sel, 0 ) ? SET( PORTB, 4 ) : CLR( PORTB, 4 );
     e30:	60 ff       	sbrs	r22, 0
     e32:	02 c0       	rjmp	.+4      	; 0xe38 <set_mux_sel+0x72>
     e34:	c4 9a       	sbi	0x18, 4	; 24
     e36:	08 95       	ret
     e38:	c4 98       	cbi	0x18, 4	; 24
     e3a:	08 95       	ret

      break;

    case MUX2:
      READ( mux_sel, 4 ) ? SET( PORTE, 3 ) : CLR( PORTE, 3 );
     e3c:	64 ff       	sbrs	r22, 4
     e3e:	02 c0       	rjmp	.+4      	; 0xe44 <set_mux_sel+0x7e>
     e40:	1b 9a       	sbi	0x03, 3	; 3
     e42:	01 c0       	rjmp	.+2      	; 0xe46 <set_mux_sel+0x80>
     e44:	1b 98       	cbi	0x03, 3	; 3
      READ( mux_sel, 3 ) ? SET( PORTE, 4 ) : CLR( PORTE, 4 );
     e46:	63 ff       	sbrs	r22, 3
     e48:	02 c0       	rjmp	.+4      	; 0xe4e <set_mux_sel+0x88>
     e4a:	1c 9a       	sbi	0x03, 4	; 3
     e4c:	01 c0       	rjmp	.+2      	; 0xe50 <set_mux_sel+0x8a>
     e4e:	1c 98       	cbi	0x03, 4	; 3
      READ( mux_sel, 2 ) ? SET( PORTE, 5 ) : CLR( PORTE, 5 );
     e50:	62 ff       	sbrs	r22, 2
     e52:	02 c0       	rjmp	.+4      	; 0xe58 <set_mux_sel+0x92>
     e54:	1d 9a       	sbi	0x03, 5	; 3
     e56:	01 c0       	rjmp	.+2      	; 0xe5a <set_mux_sel+0x94>
     e58:	1d 98       	cbi	0x03, 5	; 3
      READ( mux_sel, 1 ) ? SET( PORTE, 6 ) : CLR( PORTE, 6 );
     e5a:	61 ff       	sbrs	r22, 1
     e5c:	02 c0       	rjmp	.+4      	; 0xe62 <set_mux_sel+0x9c>
     e5e:	1e 9a       	sbi	0x03, 6	; 3
     e60:	01 c0       	rjmp	.+2      	; 0xe64 <set_mux_sel+0x9e>
     e62:	1e 98       	cbi	0x03, 6	; 3
      READ( mux_sel, 0 ) ? SET( PORTE, 7 ) : CLR( PORTE, 7 );
     e64:	60 ff       	sbrs	r22, 0
     e66:	02 c0       	rjmp	.+4      	; 0xe6c <set_mux_sel+0xa6>
     e68:	1f 9a       	sbi	0x03, 7	; 3
     e6a:	08 95       	ret
     e6c:	1f 98       	cbi	0x03, 7	; 3
     e6e:	08 95       	ret

00000e70 <torquer_off>:
  }
}

void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
     e70:	82 31       	cpi	r24, 0x12	; 18
     e72:	31 f0       	breq	.+12     	; 0xe80 <torquer_off+0x10>
     e74:	83 31       	cpi	r24, 0x13	; 19
     e76:	59 f0       	breq	.+22     	; 0xe8e <torquer_off+0x1e>
     e78:	81 31       	cpi	r24, 0x11	; 17
     e7a:	99 f4       	brne	.+38     	; 0xea2 <torquer_off+0x32>
     e7c:	0c 94 dc 06 	jmp	0xdb8	; 0xdb8 <torquer_off.part.0>
      CLR( PORTC, 0 );
	  CLR( PORTG, 1 );
      break;

    case TORQUER_2:
      CLR( PORTG, 0 );
     e80:	80 91 65 00 	lds	r24, 0x0065
     e84:	8e 7f       	andi	r24, 0xFE	; 254
     e86:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTD, 0 );
     e8a:	90 98       	cbi	0x12, 0	; 18
      break;
     e8c:	08 95       	ret

    case TORQUER_3:
      CLR( PORTG, 3 );
     e8e:	80 91 65 00 	lds	r24, 0x0065
     e92:	87 7f       	andi	r24, 0xF7	; 247
     e94:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTG, 4 );
     e98:	80 91 65 00 	lds	r24, 0x0065
     e9c:	8f 7e       	andi	r24, 0xEF	; 239
     e9e:	80 93 65 00 	sts	0x0065, r24
     ea2:	08 95       	ret

00000ea4 <torquer_on>:
  }  
}

void torquer_on( uint8_t torquer_num )
{
  switch( torquer_num )
     ea4:	82 31       	cpi	r24, 0x12	; 18
     ea6:	49 f0       	breq	.+18     	; 0xeba <torquer_on+0x16>
     ea8:	83 31       	cpi	r24, 0x13	; 19
     eaa:	71 f0       	breq	.+28     	; 0xec8 <torquer_on+0x24>
     eac:	81 31       	cpi	r24, 0x11	; 17
     eae:	b1 f4       	brne	.+44     	; 0xedc <torquer_on+0x38>
  {
    case TORQUER_1:
      SET( PORTC, 0 );
     eb0:	a8 9a       	sbi	0x15, 0	; 21
	  SET( PORTG, 1 );
     eb2:	80 91 65 00 	lds	r24, 0x0065
     eb6:	82 60       	ori	r24, 0x02	; 2
     eb8:	0f c0       	rjmp	.+30     	; 0xed8 <torquer_on+0x34>
      break;

    case TORQUER_2:
      SET( PORTG, 0 );
     eba:	80 91 65 00 	lds	r24, 0x0065
     ebe:	81 60       	ori	r24, 0x01	; 1
     ec0:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTD, 0 );
     ec4:	90 9a       	sbi	0x12, 0	; 18
      break;
     ec6:	08 95       	ret

    case TORQUER_3:
      SET( PORTG, 3 );
     ec8:	80 91 65 00 	lds	r24, 0x0065
     ecc:	88 60       	ori	r24, 0x08	; 8
     ece:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTG, 4 );
     ed2:	80 91 65 00 	lds	r24, 0x0065
     ed6:	80 61       	ori	r24, 0x10	; 16
     ed8:	80 93 65 00 	sts	0x0065, r24
     edc:	08 95       	ret

00000ede <switch_on>:
  }
}

void switch_on( uint8_t switch_num )
{
  switch ( switch_num )
     ede:	88 30       	cpi	r24, 0x08	; 8
     ee0:	59 f1       	breq	.+86     	; 0xf38 <switch_on+0x5a>
     ee2:	68 f4       	brcc	.+26     	; 0xefe <switch_on+0x20>
     ee4:	84 30       	cpi	r24, 0x04	; 4
     ee6:	01 f1       	breq	.+64     	; 0xf28 <switch_on+0x4a>
     ee8:	30 f4       	brcc	.+12     	; 0xef6 <switch_on+0x18>
     eea:	82 30       	cpi	r24, 0x02	; 2
     eec:	c9 f0       	breq	.+50     	; 0xf20 <switch_on+0x42>
     eee:	d0 f4       	brcc	.+52     	; 0xf24 <switch_on+0x46>
     ef0:	81 30       	cpi	r24, 0x01	; 1
     ef2:	b9 f5       	brne	.+110    	; 0xf62 <switch_on+0x84>
     ef4:	13 c0       	rjmp	.+38     	; 0xf1c <switch_on+0x3e>
     ef6:	86 30       	cpi	r24, 0x06	; 6
     ef8:	d9 f0       	breq	.+54     	; 0xf30 <switch_on+0x52>
     efa:	e0 f4       	brcc	.+56     	; 0xf34 <switch_on+0x56>
     efc:	17 c0       	rjmp	.+46     	; 0xf2c <switch_on+0x4e>
     efe:	8c 30       	cpi	r24, 0x0C	; 12
     f00:	39 f1       	breq	.+78     	; 0xf50 <switch_on+0x72>
     f02:	20 f4       	brcc	.+8      	; 0xf0c <switch_on+0x2e>
     f04:	8a 30       	cpi	r24, 0x0A	; 10
     f06:	01 f1       	breq	.+64     	; 0xf48 <switch_on+0x6a>
     f08:	08 f5       	brcc	.+66     	; 0xf4c <switch_on+0x6e>
     f0a:	18 c0       	rjmp	.+48     	; 0xf3c <switch_on+0x5e>
     f0c:	8e 30       	cpi	r24, 0x0E	; 14
     f0e:	21 f1       	breq	.+72     	; 0xf58 <switch_on+0x7a>
     f10:	08 f1       	brcs	.+66     	; 0xf54 <switch_on+0x76>
     f12:	8f 30       	cpi	r24, 0x0F	; 15
     f14:	19 f1       	breq	.+70     	; 0xf5c <switch_on+0x7e>
     f16:	80 31       	cpi	r24, 0x10	; 16
     f18:	21 f5       	brne	.+72     	; 0xf62 <switch_on+0x84>
     f1a:	22 c0       	rjmp	.+68     	; 0xf60 <switch_on+0x82>
  {
    case 1:
      SET( PORTA, 0 );
     f1c:	d8 9a       	sbi	0x1b, 0	; 27
      break;
     f1e:	08 95       	ret

    case 2:
      SET( PORTA, 1 );
     f20:	d9 9a       	sbi	0x1b, 1	; 27
      break;
     f22:	08 95       	ret

    case 3:
      SET( PORTA, 2 );
     f24:	da 9a       	sbi	0x1b, 2	; 27
      break;
     f26:	08 95       	ret

    case 4:
      SET( PORTB, 5 );
     f28:	c5 9a       	sbi	0x18, 5	; 24
      break;
     f2a:	08 95       	ret

    case 5:
      SET( PORTB, 6 );
     f2c:	c6 9a       	sbi	0x18, 6	; 24
      break;
     f2e:	08 95       	ret

    case 6:
      SET( PORTB, 7 );
     f30:	c7 9a       	sbi	0x18, 7	; 24
      break;
     f32:	08 95       	ret

    case 7:
      SET( PORTD, 4 );
     f34:	94 9a       	sbi	0x12, 4	; 18
      break;
     f36:	08 95       	ret

    case 8:
      SET( PORTD, 5 );
     f38:	95 9a       	sbi	0x12, 5	; 18
      break;
     f3a:	08 95       	ret

    case 9:
      SET( PORTG, 2 );
     f3c:	80 91 65 00 	lds	r24, 0x0065
     f40:	84 60       	ori	r24, 0x04	; 4
     f42:	80 93 65 00 	sts	0x0065, r24
      break;
     f46:	08 95       	ret

    case 10: 
      SET( PORTC, 7 );
     f48:	af 9a       	sbi	0x15, 7	; 21
      break;
     f4a:	08 95       	ret

    case 11:
      SET( PORTC, 6 );
     f4c:	ae 9a       	sbi	0x15, 6	; 21
      break;
     f4e:	08 95       	ret

    case 12:
      SET( PORTC, 5 );
     f50:	ad 9a       	sbi	0x15, 5	; 21
      break;
     f52:	08 95       	ret

    case 13:
      SET( PORTC, 4 );
     f54:	ac 9a       	sbi	0x15, 4	; 21
      break;
     f56:	08 95       	ret

    case 14:
      SET( PORTC, 3 );
     f58:	ab 9a       	sbi	0x15, 3	; 21
      break;
     f5a:	08 95       	ret

    case 15:
      SET( PORTC, 2 );
     f5c:	aa 9a       	sbi	0x15, 2	; 21
      break;
     f5e:	08 95       	ret

    case 16:
      SET( PORTC, 1 );
     f60:	a9 9a       	sbi	0x15, 1	; 21
     f62:	08 95       	ret

00000f64 <switch_off>:
  }
}

void switch_off( uint8_t switch_num )
{
  switch ( switch_num )
     f64:	88 30       	cpi	r24, 0x08	; 8
     f66:	59 f1       	breq	.+86     	; 0xfbe <switch_off+0x5a>
     f68:	68 f4       	brcc	.+26     	; 0xf84 <switch_off+0x20>
     f6a:	84 30       	cpi	r24, 0x04	; 4
     f6c:	01 f1       	breq	.+64     	; 0xfae <switch_off+0x4a>
     f6e:	30 f4       	brcc	.+12     	; 0xf7c <switch_off+0x18>
     f70:	82 30       	cpi	r24, 0x02	; 2
     f72:	c9 f0       	breq	.+50     	; 0xfa6 <switch_off+0x42>
     f74:	d0 f4       	brcc	.+52     	; 0xfaa <switch_off+0x46>
     f76:	81 30       	cpi	r24, 0x01	; 1
     f78:	b9 f5       	brne	.+110    	; 0xfe8 <switch_off+0x84>
     f7a:	13 c0       	rjmp	.+38     	; 0xfa2 <switch_off+0x3e>
     f7c:	86 30       	cpi	r24, 0x06	; 6
     f7e:	d9 f0       	breq	.+54     	; 0xfb6 <switch_off+0x52>
     f80:	e0 f4       	brcc	.+56     	; 0xfba <switch_off+0x56>
     f82:	17 c0       	rjmp	.+46     	; 0xfb2 <switch_off+0x4e>
     f84:	8c 30       	cpi	r24, 0x0C	; 12
     f86:	39 f1       	breq	.+78     	; 0xfd6 <switch_off+0x72>
     f88:	20 f4       	brcc	.+8      	; 0xf92 <switch_off+0x2e>
     f8a:	8a 30       	cpi	r24, 0x0A	; 10
     f8c:	01 f1       	breq	.+64     	; 0xfce <switch_off+0x6a>
     f8e:	08 f5       	brcc	.+66     	; 0xfd2 <switch_off+0x6e>
     f90:	18 c0       	rjmp	.+48     	; 0xfc2 <switch_off+0x5e>
     f92:	8e 30       	cpi	r24, 0x0E	; 14
     f94:	21 f1       	breq	.+72     	; 0xfde <switch_off+0x7a>
     f96:	08 f1       	brcs	.+66     	; 0xfda <switch_off+0x76>
     f98:	8f 30       	cpi	r24, 0x0F	; 15
     f9a:	19 f1       	breq	.+70     	; 0xfe2 <switch_off+0x7e>
     f9c:	80 31       	cpi	r24, 0x10	; 16
     f9e:	21 f5       	brne	.+72     	; 0xfe8 <switch_off+0x84>
     fa0:	22 c0       	rjmp	.+68     	; 0xfe6 <switch_off+0x82>
  {
    case 1:
      CLR( PORTA, 0 );
     fa2:	d8 98       	cbi	0x1b, 0	; 27
      break;
     fa4:	08 95       	ret

    case 2:
      CLR( PORTA, 1 );
     fa6:	d9 98       	cbi	0x1b, 1	; 27
      break;
     fa8:	08 95       	ret

    case 3:
      CLR( PORTA, 2 );
     faa:	da 98       	cbi	0x1b, 2	; 27
      break;
     fac:	08 95       	ret

    case 4:
      CLR( PORTB, 5 );
     fae:	c5 98       	cbi	0x18, 5	; 24
      break;
     fb0:	08 95       	ret

    case 5:
      CLR( PORTB, 6 );
     fb2:	c6 98       	cbi	0x18, 6	; 24
      break;
     fb4:	08 95       	ret

    case 6:
      CLR( PORTB, 7 );
     fb6:	c7 98       	cbi	0x18, 7	; 24
      break;
     fb8:	08 95       	ret

    case 7:
      CLR( PORTD, 4 );
     fba:	94 98       	cbi	0x12, 4	; 18
      break;
     fbc:	08 95       	ret

    case 8:
      CLR( PORTD, 5 );
     fbe:	95 98       	cbi	0x12, 5	; 18
      break;
     fc0:	08 95       	ret

    case 9:
      CLR( PORTG, 2 );
     fc2:	80 91 65 00 	lds	r24, 0x0065
     fc6:	8b 7f       	andi	r24, 0xFB	; 251
     fc8:	80 93 65 00 	sts	0x0065, r24
      break;
     fcc:	08 95       	ret

    case 10: 
      CLR( PORTC, 7 );
     fce:	af 98       	cbi	0x15, 7	; 21
      break;
     fd0:	08 95       	ret

    case 11:
      CLR( PORTC, 6 );
     fd2:	ae 98       	cbi	0x15, 6	; 21
      break;
     fd4:	08 95       	ret

    case 12:
      CLR( PORTC, 5 );
     fd6:	ad 98       	cbi	0x15, 5	; 21
      break;
     fd8:	08 95       	ret

    case 13:
      CLR( PORTC, 4 );
     fda:	ac 98       	cbi	0x15, 4	; 21
      break;
     fdc:	08 95       	ret

    case 14:
      CLR( PORTC, 3 );
     fde:	ab 98       	cbi	0x15, 3	; 21
      break;
     fe0:	08 95       	ret

    case 15:
      CLR( PORTC, 2 );
     fe2:	aa 98       	cbi	0x15, 2	; 21
      break;
     fe4:	08 95       	ret

    case 16:
      CLR( PORTC, 1 );
     fe6:	a9 98       	cbi	0x15, 1	; 21
     fe8:	08 95       	ret

00000fea <average_samples>:
    return  average_samples( component->I_samples );
  }
}

uint8_t average_samples( uint8_t samples[NUM_SAMPLES] )
{
     fea:	fc 01       	movw	r30, r24
  uint8_t average = 0;
  uint16_t sum = 0;

  for(uint8_t avg_index = 0; avg_index < NUM_SAMPLES; avg_index++)
    sum += samples[avg_index];
     fec:	21 81       	ldd	r18, Z+1	; 0x01
     fee:	80 81       	ld	r24, Z
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	82 0f       	add	r24, r18
     ff4:	91 1d       	adc	r25, r1
     ff6:	22 81       	ldd	r18, Z+2	; 0x02
     ff8:	82 0f       	add	r24, r18
     ffa:	91 1d       	adc	r25, r1

  average = sum / NUM_SAMPLES;
     ffc:	63 e0       	ldi	r22, 0x03	; 3
     ffe:	70 e0       	ldi	r23, 0x00	; 0
    1000:	0e 94 ab 11 	call	0x2356	; 0x2356 <__udivmodhi4>
    1004:	86 2f       	mov	r24, r22

  return average;
}
    1006:	08 95       	ret

00001008 <SVIT_check_I_critical>:
}

uint8_t SVIT_check_I_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1008:	9a e1       	ldi	r25, 0x1A	; 26
    100a:	89 9f       	mul	r24, r25
    100c:	f0 01       	movw	r30, r0
    100e:	11 24       	eor	r1, r1
    1010:	e2 59       	subi	r30, 0x92	; 146
    1012:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->I_critical_value != 0 )
    1014:	83 89       	ldd	r24, Z+19	; 0x13
    1016:	88 23       	and	r24, r24
    1018:	11 f0       	breq	.+4      	; 0x101e <SVIT_check_I_critical+0x16>
  {
    temp= component->I_critical_value;
    component->I_critical_value = 0;
    101a:	13 8a       	std	Z+19, r1	; 0x13
    101c:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->I_samples );
    101e:	cf 01       	movw	r24, r30
    1020:	0f 96       	adiw	r24, 0x0f	; 15
    1022:	0c 94 f5 07 	jmp	0xfea	; 0xfea <average_samples>

00001026 <SVIT_check_V_critical>:
}

uint8_t SVIT_check_V_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    1026:	9a e1       	ldi	r25, 0x1A	; 26
    1028:	89 9f       	mul	r24, r25
    102a:	f0 01       	movw	r30, r0
    102c:	11 24       	eor	r1, r1
    102e:	e2 59       	subi	r30, 0x92	; 146
    1030:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->V_critical_value != 0 )
    1032:	83 85       	ldd	r24, Z+11	; 0x0b
    1034:	88 23       	and	r24, r24
    1036:	11 f0       	breq	.+4      	; 0x103c <SVIT_check_V_critical+0x16>
  {
    temp= component->V_critical_value;
    component->V_critical_value = 0;
    1038:	13 86       	std	Z+11, r1	; 0x0b
    103a:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->V_samples );
    103c:	cf 01       	movw	r24, r30
    103e:	07 96       	adiw	r24, 0x07	; 7
    1040:	0c 94 f5 07 	jmp	0xfea	; 0xfea <average_samples>

00001044 <perform_ADC>:
}

void perform_ADC( uint8_t mux_num )
{
  // set Vref to AVCC and set the ADC channel to the correct pin ( mux_num )
  ADMUX = (1 << ADLAR) | ( 1 << REFS0 );
    1044:	90 e6       	ldi	r25, 0x60	; 96
    1046:	97 b9       	out	0x07, r25	; 7
  ADMUX &= ~0x3;
    1048:	97 b1       	in	r25, 0x07	; 7
    104a:	9c 7f       	andi	r25, 0xFC	; 252
    104c:	97 b9       	out	0x07, r25	; 7
  ADMUX |= mux_num;
    104e:	97 b1       	in	r25, 0x07	; 7
    1050:	98 2b       	or	r25, r24
    1052:	97 b9       	out	0x07, r25	; 7

  // signal ADC to start a new conversion
  ADCSRA |= ( 1 << ADSC );
    1054:	36 9a       	sbi	0x06, 6	; 6
    1056:	08 95       	ret

00001058 <read_VIT>:

  // when the conversion finishes, the result is stored in ADCL and ADCH
}

void read_VIT( void )
{
    1058:	1f 93       	push	r17
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type )
    105e:	80 91 42 09 	lds	r24, 0x0942
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1062:	c0 91 6d 03 	lds	r28, 0x036D
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type )
    1066:	82 30       	cpi	r24, 0x02	; 2
    1068:	09 f4       	brne	.+2      	; 0x106c <read_VIT+0x14>
    106a:	5d c0       	rjmp	.+186    	; 0x1126 <__stack+0x27>
    106c:	20 f4       	brcc	.+8      	; 0x1076 <read_VIT+0x1e>
    106e:	81 30       	cpi	r24, 0x01	; 1
    1070:	09 f0       	breq	.+2      	; 0x1074 <read_VIT+0x1c>
    1072:	eb c0       	rjmp	.+470    	; 0x124a <__stack+0x14b>
    1074:	07 c0       	rjmp	.+14     	; 0x1084 <read_VIT+0x2c>
    1076:	83 30       	cpi	r24, 0x03	; 3
    1078:	09 f4       	brne	.+2      	; 0x107c <read_VIT+0x24>
    107a:	ab c0       	rjmp	.+342    	; 0x11d2 <__stack+0xd3>
    107c:	84 30       	cpi	r24, 0x04	; 4
    107e:	09 f0       	breq	.+2      	; 0x1082 <read_VIT+0x2a>
    1080:	e4 c0       	rjmp	.+456    	; 0x124a <__stack+0x14b>
    1082:	cf c0       	rjmp	.+414    	; 0x1222 <__stack+0x123>
  {
		case ADC_VOLTAGE:
			component = &svit[adc_component];
    1084:	8a e1       	ldi	r24, 0x1A	; 26
    1086:	c8 9f       	mul	r28, r24
    1088:	e0 01       	movw	r28, r0
    108a:	11 24       	eor	r1, r1
    108c:	c2 59       	subi	r28, 0x92	; 146
    108e:	dc 4f       	sbci	r29, 0xFC	; 252
			sample_index = component->V_sample_index;
			component->V_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    1090:	2a 85       	ldd	r18, Y+10	; 0x0a
    1092:	30 e0       	ldi	r19, 0x00	; 0
    1094:	c9 01       	movw	r24, r18
    1096:	01 96       	adiw	r24, 0x01	; 1
    1098:	63 e0       	ldi	r22, 0x03	; 3
    109a:	70 e0       	ldi	r23, 0x00	; 0
    109c:	0e 94 bf 11 	call	0x237e	; 0x237e <__divmodhi4>
    10a0:	8a 87       	std	Y+10, r24	; 0x0a

			// SoC: If component is a battery, store in different global variable
			if (component->name == BATTERY_1) {
    10a2:	98 81       	ld	r25, Y
    10a4:	94 31       	cpi	r25, 0x14	; 20
    10a6:	69 f4       	brne	.+26     	; 0x10c2 <read_VIT+0x6a>
				batt1_voltage = ADC_high;
    10a8:	80 91 52 09 	lds	r24, 0x0952
    10ac:	80 93 5c 09 	sts	0x095C, r24
				high = ADC_high;
    10b0:	80 91 52 09 	lds	r24, 0x0952
    10b4:	80 93 4d 09 	sts	0x094D, r24
				low = ADC_low;
    10b8:	80 91 88 0d 	lds	r24, 0x0D88
    10bc:	80 93 5b 09 	sts	0x095B, r24
    10c0:	06 c0       	rjmp	.+12     	; 0x10ce <read_VIT+0x76>
				//debug = adc_component;
			}
			else if (component->name == BATTERY_2) {
    10c2:	95 31       	cpi	r25, 0x15	; 21
    10c4:	21 f4       	brne	.+8      	; 0x10ce <read_VIT+0x76>
				batt2_voltage = ADC_high;
    10c6:	80 91 52 09 	lds	r24, 0x0952
    10ca:	80 93 6c 0b 	sts	0x0B6C, r24
			}
			component->V_samples[sample_index] = ADC_high;
    10ce:	80 91 52 09 	lds	r24, 0x0952
    10d2:	fe 01       	movw	r30, r28
    10d4:	e2 0f       	add	r30, r18
    10d6:	f3 1f       	adc	r31, r19
    10d8:	87 83       	std	Z+7, r24	; 0x07
      
	  	if ( ( ADC_high > component->V_upper_limit ) && ( component->force_on != 1 ) )
    10da:	20 91 52 09 	lds	r18, 0x0952
    10de:	8e 81       	ldd	r24, Y+6	; 0x06
    10e0:	82 17       	cp	r24, r18
    10e2:	d8 f4       	brcc	.+54     	; 0x111a <__stack+0x1b>
    10e4:	8b 81       	ldd	r24, Y+3	; 0x03
    10e6:	81 30       	cpi	r24, 0x01	; 1
    10e8:	c1 f0       	breq	.+48     	; 0x111a <__stack+0x1b>
			{
				if ( component->switch_num != SW_NULL )
    10ea:	89 81       	ldd	r24, Y+1	; 0x01
    10ec:	8f 3f       	cpi	r24, 0xFF	; 255
    10ee:	19 f0       	breq	.+6      	; 0x10f6 <read_VIT+0x9e>
				{
			  	switch_off( component->switch_num );
    10f0:	0e 94 b2 07 	call	0xf64	; 0xf64 <switch_off>
    10f4:	0e c0       	rjmp	.+28     	; 0x1112 <__stack+0x13>
				}
		  	else
				{
			  	switch ( component->name )
    10f6:	92 31       	cpi	r25, 0x12	; 18
    10f8:	39 f0       	breq	.+14     	; 0x1108 <__stack+0x9>
    10fa:	93 31       	cpi	r25, 0x13	; 19
    10fc:	39 f0       	breq	.+14     	; 0x110c <__stack+0xd>
    10fe:	91 31       	cpi	r25, 0x11	; 17
    1100:	41 f4       	brne	.+16     	; 0x1112 <__stack+0x13>
    1102:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <torquer_off.part.0>
    1106:	05 c0       	rjmp	.+10     	; 0x1112 <__stack+0x13>
			  	{
						case TORQUER_1:
				  		torquer_off( TORQUER_1 );
				  		break;
					  case TORQUER_2:
	  			  	torquer_off( TORQUER_2 );
    1108:	82 e1       	ldi	r24, 0x12	; 18
    110a:	01 c0       	rjmp	.+2      	; 0x110e <__stack+0xf>
		  		  	break;
			  		case TORQUER_3:
				    	torquer_off( TORQUER_3 );
    110c:	83 e1       	ldi	r24, 0x13	; 19
    110e:	0e 94 38 07 	call	0xe70	; 0xe70 <torquer_off>
				    	break;
					  default:
				  	  break;
			    }
  			}
        component->switch_state = SW_OFF;
    1112:	1a 82       	std	Y+2, r1	; 0x02
        component->V_critical_value = ADC_high;
    1114:	80 91 52 09 	lds	r24, 0x0952
    1118:	8b 87       	std	Y+11, r24	; 0x0b
		  }
		  adc_sensor_type = ADC_CURRENT;
    111a:	82 e0       	ldi	r24, 0x02	; 2
    111c:	80 93 42 09 	sts	0x0942, r24

      //perform next ADC conversion
      mux_num = component->I_mux_num;
    1120:	1c 85       	ldd	r17, Y+12	; 0x0c
      mux_sel = component->I_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    1122:	6d 85       	ldd	r22, Y+13	; 0x0d
    1124:	89 c0       	rjmp	.+274    	; 0x1238 <__stack+0x139>
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1126:	9a e1       	ldi	r25, 0x1A	; 26
    1128:	c9 9f       	mul	r28, r25
    112a:	e0 01       	movw	r28, r0
    112c:	11 24       	eor	r1, r1
    112e:	c2 59       	subi	r28, 0x92	; 146
    1130:	dc 4f       	sbci	r29, 0xFC	; 252
	  	sample_index = component->I_sample_index;
	  	component->I_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    1132:	2a 89       	ldd	r18, Y+18	; 0x12
    1134:	30 e0       	ldi	r19, 0x00	; 0
    1136:	c9 01       	movw	r24, r18
    1138:	01 96       	adiw	r24, 0x01	; 1
    113a:	63 e0       	ldi	r22, 0x03	; 3
    113c:	70 e0       	ldi	r23, 0x00	; 0
    113e:	0e 94 bf 11 	call	0x237e	; 0x237e <__divmodhi4>
    1142:	8a 8b       	std	Y+18, r24	; 0x12
		// SoC hardcode backward current
//		if (adc_component == BATTERY_1_b) {
			//debug = 5;
		//}

	  	component->I_samples[sample_index] = ADC_high;
    1144:	80 91 52 09 	lds	r24, 0x0952
    1148:	fe 01       	movw	r30, r28
    114a:	e2 0f       	add	r30, r18
    114c:	f3 1f       	adc	r31, r19
    114e:	87 87       	std	Z+15, r24	; 0x0f
    
	    if ( ( ADC_high > component->I_upper_limit ) && ( component->force_on != 1 ) )
    1150:	90 91 52 09 	lds	r25, 0x0952
    1154:	8e 85       	ldd	r24, Y+14	; 0x0e
    1156:	89 17       	cp	r24, r25
    1158:	e0 f4       	brcc	.+56     	; 0x1192 <__stack+0x93>
    115a:	8b 81       	ldd	r24, Y+3	; 0x03
    115c:	81 30       	cpi	r24, 0x01	; 1
    115e:	c9 f0       	breq	.+50     	; 0x1192 <__stack+0x93>
	  	{
	  		if ( component->switch_num != SW_NULL )
    1160:	89 81       	ldd	r24, Y+1	; 0x01
    1162:	8f 3f       	cpi	r24, 0xFF	; 255
    1164:	19 f0       	breq	.+6      	; 0x116c <__stack+0x6d>
	  		{
	  		  switch_off( component->switch_num );
    1166:	0e 94 b2 07 	call	0xf64	; 0xf64 <switch_off>
    116a:	0f c0       	rjmp	.+30     	; 0x118a <__stack+0x8b>
	  		}
	  		else
	  		{
	  		  switch ( component->name )
    116c:	88 81       	ld	r24, Y
    116e:	82 31       	cpi	r24, 0x12	; 18
    1170:	39 f0       	breq	.+14     	; 0x1180 <__stack+0x81>
    1172:	83 31       	cpi	r24, 0x13	; 19
    1174:	39 f0       	breq	.+14     	; 0x1184 <__stack+0x85>
    1176:	81 31       	cpi	r24, 0x11	; 17
    1178:	41 f4       	brne	.+16     	; 0x118a <__stack+0x8b>
    117a:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <torquer_off.part.0>
    117e:	05 c0       	rjmp	.+10     	; 0x118a <__stack+0x8b>
		  	  {
  		  		case TORQUER_1:
	  	  		  torquer_off( TORQUER_1 );
		    		  break;
			    	case TORQUER_2:
			  	    torquer_off( TORQUER_2 );
    1180:	82 e1       	ldi	r24, 0x12	; 18
    1182:	01 c0       	rjmp	.+2      	; 0x1186 <__stack+0x87>
			  	    break;
  		  		case TORQUER_3:
	  	  		  torquer_off( TORQUER_3 );
    1184:	83 e1       	ldi	r24, 0x13	; 19
    1186:	0e 94 38 07 	call	0xe70	; 0xe70 <torquer_off>
		    		  break;
			     	default:
				      break;
			    }
			  }
			  component->switch_state = 0;
    118a:	1a 82       	std	Y+2, r1	; 0x02
        component->I_critical_value = ADC_high;
    118c:	80 91 52 09 	lds	r24, 0x0952
    1190:	8b 8b       	std	Y+19, r24	; 0x13
		  }
      //perform next ADC conversion
      mux_num = component->T_mux_num;
    1192:	1c 89       	ldd	r17, Y+20	; 0x14
      if( mux_num != MUX_NULL )
    1194:	13 30       	cpi	r17, 0x03	; 3
    1196:	29 f0       	breq	.+10     	; 0x11a2 <__stack+0xa3>
      {
		    adc_sensor_type = ADC_TEMPERATURE;
    1198:	83 e0       	ldi	r24, 0x03	; 3
    119a:	80 93 42 09 	sts	0x0942, r24
        mux_sel = component->T_mux_sel;        
    119e:	6d 89       	ldd	r22, Y+21	; 0x15
    11a0:	4b c0       	rjmp	.+150    	; 0x1238 <__stack+0x139>
		  }
      else
      {
        adc_sensor_type = ADC_VOLTAGE;
    11a2:	81 e0       	ldi	r24, 0x01	; 1
    11a4:	80 93 42 09 	sts	0x0942, r24
		    adc_component = ( adc_component + 1 ) % SVIT_SZ;
    11a8:	80 91 6d 03 	lds	r24, 0x036D
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	01 96       	adiw	r24, 0x01	; 1
    11b0:	64 e2       	ldi	r22, 0x24	; 36
    11b2:	70 e0       	ldi	r23, 0x00	; 0
    11b4:	0e 94 bf 11 	call	0x237e	; 0x237e <__divmodhi4>
    11b8:	80 93 6d 03 	sts	0x036D, r24
        component = &svit[adc_component];
    11bc:	2a e1       	ldi	r18, 0x1A	; 26
    11be:	28 9f       	mul	r18, r24
    11c0:	f0 01       	movw	r30, r0
    11c2:	29 9f       	mul	r18, r25
    11c4:	f0 0d       	add	r31, r0
    11c6:	11 24       	eor	r1, r1
    11c8:	e2 59       	subi	r30, 0x92	; 146
    11ca:	fc 4f       	sbci	r31, 0xFC	; 252
        mux_num = component->V_mux_num;
    11cc:	14 81       	ldd	r17, Z+4	; 0x04
        mux_sel = component->V_mux_sel;
    11ce:	65 81       	ldd	r22, Z+5	; 0x05
    11d0:	33 c0       	rjmp	.+102    	; 0x1238 <__stack+0x139>
      break;
    //-------------------------------------------------------------------
    // Measure temperature
    //-------------------------------------------------------------------
	  case ADC_TEMPERATURE:
		  component = &svit[adc_component];
    11d2:	d0 e0       	ldi	r29, 0x00	; 0
    11d4:	4a e1       	ldi	r20, 0x1A	; 26
    11d6:	4c 9f       	mul	r20, r28
    11d8:	f0 01       	movw	r30, r0
    11da:	4d 9f       	mul	r20, r29
    11dc:	f0 0d       	add	r31, r0
    11de:	11 24       	eor	r1, r1
    11e0:	e2 59       	subi	r30, 0x92	; 146
    11e2:	fc 4f       	sbci	r31, 0xFC	; 252
		  sample_index = component->T_sample_index;
		  component->T_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    11e4:	21 8d       	ldd	r18, Z+25	; 0x19
    11e6:	30 e0       	ldi	r19, 0x00	; 0
    11e8:	c9 01       	movw	r24, r18
    11ea:	01 96       	adiw	r24, 0x01	; 1
    11ec:	63 e0       	ldi	r22, 0x03	; 3
    11ee:	70 e0       	ldi	r23, 0x00	; 0
    11f0:	0e 94 bf 11 	call	0x237e	; 0x237e <__divmodhi4>
    11f4:	81 8f       	std	Z+25, r24	; 0x19
		  component->T_samples[sample_index] = ADC_high;
    11f6:	80 91 52 09 	lds	r24, 0x0952
    11fa:	e2 0f       	add	r30, r18
    11fc:	f3 1f       	adc	r31, r19
    11fe:	86 8b       	std	Z+22, r24	; 0x16
      //perform next ADC conversion
  	  adc_sensor_type = ADC_VOLTAGE;
    1200:	81 e0       	ldi	r24, 0x01	; 1
    1202:	80 93 42 09 	sts	0x0942, r24
		  adc_component = ( adc_component + 1 ) % SVIT_SZ;
    1206:	ce 01       	movw	r24, r28
    1208:	01 96       	adiw	r24, 0x01	; 1
    120a:	64 e2       	ldi	r22, 0x24	; 36
    120c:	70 e0       	ldi	r23, 0x00	; 0
    120e:	0e 94 bf 11 	call	0x237e	; 0x237e <__divmodhi4>
    1212:	80 93 6d 03 	sts	0x036D, r24
      component = &svit[adc_component];
    1216:	48 9f       	mul	r20, r24
    1218:	f0 01       	movw	r30, r0
    121a:	49 9f       	mul	r20, r25
    121c:	f0 0d       	add	r31, r0
    121e:	11 24       	eor	r1, r1
    1220:	1d c0       	rjmp	.+58     	; 0x125c <__stack+0x15d>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
		  break;
    case ADC_INIT:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    1222:	81 e0       	ldi	r24, 0x01	; 1
    1224:	80 93 42 09 	sts	0x0942, r24
      component = &svit[adc_component];
    1228:	9a e1       	ldi	r25, 0x1A	; 26
    122a:	c9 9f       	mul	r28, r25
    122c:	e0 01       	movw	r28, r0
    122e:	11 24       	eor	r1, r1
    1230:	c2 59       	subi	r28, 0x92	; 146
    1232:	dc 4f       	sbci	r29, 0xFC	; 252
      mux_num = component->V_mux_num;
    1234:	1c 81       	ldd	r17, Y+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    1236:	6d 81       	ldd	r22, Y+5	; 0x05
    1238:	81 2f       	mov	r24, r17
    123a:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <set_mux_sel>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    123e:	83 e3       	ldi	r24, 0x33	; 51
    1240:	93 e7       	ldi	r25, 0x73	; 115
    1242:	01 97       	sbiw	r24, 0x01	; 1
    1244:	f1 f7       	brne	.-4      	; 0x1242 <__stack+0x143>
      //_delay_us(1);
	  //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
    1246:	81 2f       	mov	r24, r17
    1248:	15 c0       	rjmp	.+42     	; 0x1274 <__stack+0x175>
      break;
	  default:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    124a:	81 e0       	ldi	r24, 0x01	; 1
    124c:	80 93 42 09 	sts	0x0942, r24
      component = &svit[adc_component];
    1250:	e0 91 6d 03 	lds	r30, 0x036D
    1254:	9a e1       	ldi	r25, 0x1A	; 26
    1256:	e9 9f       	mul	r30, r25
    1258:	f0 01       	movw	r30, r0
    125a:	11 24       	eor	r1, r1
    125c:	e2 59       	subi	r30, 0x92	; 146
    125e:	fc 4f       	sbci	r31, 0xFC	; 252
      mux_num = component->V_mux_num;
    1260:	c4 81       	ldd	r28, Z+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    1262:	65 81       	ldd	r22, Z+5	; 0x05
    1264:	8c 2f       	mov	r24, r28
    1266:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <set_mux_sel>
    126a:	83 e3       	ldi	r24, 0x33	; 51
    126c:	93 e7       	ldi	r25, 0x73	; 115
    126e:	01 97       	sbiw	r24, 0x01	; 1
    1270:	f1 f7       	brne	.-4      	; 0x126e <__stack+0x16f>
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    1272:	8c 2f       	mov	r24, r28
      break;
  } 
}
    1274:	df 91       	pop	r29
    1276:	cf 91       	pop	r28
    1278:	1f 91       	pop	r17
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    127a:	0c 94 22 08 	jmp	0x1044	; 0x1044 <perform_ADC>

0000127e <uart_init>:
{
  #if F_CPU < 2000000UL && defined(U2X)
  UCSR0A = UCSR1A = _BV(U2X); /* improve baud rate error by using 2x clk */
  UBRR0L = UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  #else
  UBRR0L = UBRR1L = 7;//(F_CPU / (16UL * UART_BAUD)) - 1;//7;
    127e:	87 e0       	ldi	r24, 0x07	; 7
    1280:	80 93 99 00 	sts	0x0099, r24
    1284:	89 b9       	out	0x09, r24	; 9
  #endif
  UCSR0B = _BV(TXEN0) | _BV(RXEN0); /* tx/rx enable */
    1286:	88 e1       	ldi	r24, 0x18	; 24
    1288:	8a b9       	out	0x0a, r24	; 10
  UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
    128a:	ea e9       	ldi	r30, 0x9A	; 154
    128c:	f0 e0       	ldi	r31, 0x00	; 0
    128e:	80 83       	st	Z, r24


  UCSR1B = UCSR1B | _BV(TXCIE1);
    1290:	80 81       	ld	r24, Z
    1292:	80 64       	ori	r24, 0x40	; 64
    1294:	80 83       	st	Z, r24
  UCSR1B = UCSR1B | _BV(RXCIE1);
    1296:	80 81       	ld	r24, Z
    1298:	80 68       	ori	r24, 0x80	; 128
    129a:	80 83       	st	Z, r24
  UCSR0B = UCSR0B | _BV(TXCIE0);
    129c:	56 9a       	sbi	0x0a, 6	; 10
  UCSR0B = UCSR0B | _BV(RXCIE0);
    129e:	57 9a       	sbi	0x0a, 7	; 10
    12a0:	08 95       	ret

000012a2 <append_crc16>:
 * Adds a byte of data into the crc calculation using
 * the table above.
 */
void append_crc16(uint8 byte, uint16ptr crc)
{
	*crc = ((*crc) >> 8) ^ ccitt_crc16[((*crc) ^ (byte)) & 0xff];
    12a2:	fb 01       	movw	r30, r22
    12a4:	20 81       	ld	r18, Z
    12a6:	31 81       	ldd	r19, Z+1	; 0x01
    12a8:	f9 01       	movw	r30, r18
    12aa:	e8 27       	eor	r30, r24
    12ac:	ff 27       	eor	r31, r31
    12ae:	ee 0f       	add	r30, r30
    12b0:	ff 1f       	adc	r31, r31
    12b2:	ea 5f       	subi	r30, 0xFA	; 250
    12b4:	fe 4f       	sbci	r31, 0xFE	; 254
    12b6:	23 2f       	mov	r18, r19
    12b8:	33 27       	eor	r19, r19
    12ba:	80 81       	ld	r24, Z
    12bc:	91 81       	ldd	r25, Z+1	; 0x01
    12be:	82 27       	eor	r24, r18
    12c0:	93 27       	eor	r25, r19
    12c2:	fb 01       	movw	r30, r22
    12c4:	91 83       	std	Z+1, r25	; 0x01
    12c6:	80 83       	st	Z, r24
    12c8:	08 95       	ret

000012ca <vcpptr_init>:
// Parameters: 
// vcp_ptrbuffer	*buff -					Pointer to the vcp buffer structure
// uint8			*message_buffer -		Pointer to the allocated data buffer
// uint16			message_buffer_size -	Size of the allocated data buffer
void vcpptr_init(vcp_ptrbuffer *buff, uint8 *message_buffer, uint16 message_buffer_size)
{
    12ca:	fc 01       	movw	r30, r24
	buff->address =	0;
    12cc:	10 82       	st	Z, r1
	buff->message =	message_buffer;
    12ce:	72 83       	std	Z+2, r23	; 0x02
    12d0:	61 83       	std	Z+1, r22	; 0x01
	buff->size =	message_buffer_size;
    12d2:	56 83       	std	Z+6, r21	; 0x06
    12d4:	45 83       	std	Z+5, r20	; 0x05
	buff->index	=	0;
    12d6:	10 86       	std	Z+8, r1	; 0x08
    12d8:	17 82       	std	Z+7, r1	; 0x07
	buff->crc =		CRC16_INIT_VALUE;
    12da:	14 82       	std	Z+4, r1	; 0x04
    12dc:	13 82       	std	Z+3, r1	; 0x03
	buff->status =	VCP_IDLE;
    12de:	11 86       	std	Z+9, r1	; 0x09
    12e0:	08 95       	ret

000012e2 <Create_VCP_frame>:
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
    12e2:	4f 92       	push	r4
    12e4:	5f 92       	push	r5
    12e6:	6f 92       	push	r6
    12e8:	7f 92       	push	r7
    12ea:	8f 92       	push	r8
    12ec:	9f 92       	push	r9
    12ee:	af 92       	push	r10
    12f0:	bf 92       	push	r11
    12f2:	cf 92       	push	r12
    12f4:	df 92       	push	r13
    12f6:	ef 92       	push	r14
    12f8:	ff 92       	push	r15
    12fa:	0f 93       	push	r16
    12fc:	1f 93       	push	r17
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	00 d0       	rcall	.+0      	; 0x1304 <Create_VCP_frame+0x22>
    1304:	1f 92       	push	r1
    1306:	cd b7       	in	r28, 0x3d	; 61
    1308:	de b7       	in	r29, 0x3e	; 62
    130a:	6c 01       	movw	r12, r24
    130c:	5b 01       	movw	r10, r22
    130e:	79 01       	movw	r14, r18
	uint16_t crc = CRC16_INIT_VALUE;
    1310:	1a 82       	std	Y+2, r1	; 0x02
    1312:	19 82       	std	Y+1, r1	; 0x01
	uint16_t src_index = 0;
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
    1314:	00 97       	sbiw	r24, 0x00	; 0
    1316:	09 f4       	brne	.+2      	; 0x131a <Create_VCP_frame+0x38>
    1318:	58 c0       	rjmp	.+176    	; 0x13ca <Create_VCP_frame+0xe8>
    131a:	21 15       	cp	r18, r1
    131c:	31 05       	cpc	r19, r1
    131e:	09 f4       	brne	.+2      	; 0x1322 <Create_VCP_frame+0x40>
    1320:	54 c0       	rjmp	.+168    	; 0x13ca <Create_VCP_frame+0xe8>
		return VCP_NULL_ERR;

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
    1322:	4c 30       	cpi	r20, 0x0C	; 12
    1324:	18 f0       	brcs	.+6      	; 0x132c <Create_VCP_frame+0x4a>
    1326:	48 33       	cpi	r20, 0x38	; 56
    1328:	09 f0       	breq	.+2      	; 0x132c <Create_VCP_frame+0x4a>
    132a:	51 c0       	rjmp	.+162    	; 0x13ce <Create_VCP_frame+0xec>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    132c:	44 24       	eor	r4, r4
    132e:	43 94       	inc	r4
    1330:	51 2c       	mov	r5, r1
    1332:	4c 0e       	add	r4, r28
    1334:	5d 1e       	adc	r5, r29
    1336:	b2 01       	movw	r22, r4
    1338:	84 2f       	mov	r24, r20
    133a:	4b 83       	std	Y+3, r20	; 0x03
    133c:	0e 94 51 09 	call	0x12a2	; 0x12a2 <append_crc16>
// uint8ptr		dst -		Pointer to the destination buffer
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
    1340:	37 01       	movw	r6, r14
    1342:	60 0e       	add	r6, r16
    1344:	71 1e       	adc	r7, r17
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    1346:	47 01       	movw	r8, r14
    1348:	07 c0       	rjmp	.+14     	; 0x1358 <Create_VCP_frame+0x76>
	  append_crc16(src[src_index], &crc);
    134a:	b2 01       	movw	r22, r4
    134c:	f4 01       	movw	r30, r8
    134e:	81 91       	ld	r24, Z+
    1350:	4f 01       	movw	r8, r30
    1352:	4b 83       	std	Y+3, r20	; 0x03
    1354:	0e 94 51 09 	call	0x12a2	; 0x12a2 <append_crc16>
    1358:	4b 81       	ldd	r20, Y+3	; 0x03
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    135a:	86 14       	cp	r8, r6
    135c:	97 04       	cpc	r9, r7
    135e:	a9 f7       	brne	.-22     	; 0x134a <Create_VCP_frame+0x68>
	  append_crc16(src[src_index], &crc);
	
	// Add CRC to the end of the source buffer
	src[src_index++] = ((crc >> 8) & 0xFF);
    1360:	89 81       	ldd	r24, Y+1	; 0x01
    1362:	9a 81       	ldd	r25, Y+2	; 0x02
    1364:	f7 01       	movw	r30, r14
    1366:	e0 0f       	add	r30, r16
    1368:	f1 1f       	adc	r31, r17
    136a:	90 83       	st	Z, r25
	src[src_index++] = (crc & 0xFF);
    136c:	81 83       	std	Z+1, r24	; 0x01
    136e:	0e 5f       	subi	r16, 0xFE	; 254
    1370:	1f 4f       	sbci	r17, 0xFF	; 255
	payload_size = src_index;
	
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
    1372:	80 ec       	ldi	r24, 0xC0	; 192
    1374:	f6 01       	movw	r30, r12
    1376:	80 83       	st	Z, r24
	// then insert VCP address
	dst[dst_index++] =					addr;
    1378:	41 83       	std	Z+1, r20	; 0x01
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    137a:	d7 01       	movw	r26, r14
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
    137c:	42 e0       	ldi	r20, 0x02	; 2
    137e:	50 e0       	ldi	r21, 0x00	; 0
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    1380:	2d ed       	ldi	r18, 0xDD	; 221
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
    1382:	3b ed       	ldi	r19, 0xDB	; 219
			dst[dst_index++] =			TFEND;
    1384:	6c ed       	ldi	r22, 0xDC	; 220
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1386:	0f c0       	rjmp	.+30     	; 0x13a6 <Create_VCP_frame+0xc4>
	{
		if (src[src_index] == FEND)
    1388:	8d 91       	ld	r24, X+
    138a:	80 3c       	cpi	r24, 0xC0	; 192
    138c:	19 f4       	brne	.+6      	; 0x1394 <Create_VCP_frame+0xb2>
		{
			dst[dst_index++] =			FESC;
    138e:	30 83       	st	Z, r19
			dst[dst_index++] =			TFEND;
    1390:	61 83       	std	Z+1, r22	; 0x01
    1392:	04 c0       	rjmp	.+8      	; 0x139c <Create_VCP_frame+0xba>
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
    1394:	80 83       	st	Z, r24
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
    1396:	8b 3d       	cpi	r24, 0xDB	; 219
    1398:	21 f4       	brne	.+8      	; 0x13a2 <Create_VCP_frame+0xc0>
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    139a:	21 83       	std	Z+1, r18	; 0x01
    139c:	4e 5f       	subi	r20, 0xFE	; 254
    139e:	5f 4f       	sbci	r21, 0xFF	; 255
    13a0:	02 c0       	rjmp	.+4      	; 0x13a6 <Create_VCP_frame+0xc4>
		}
		else
		{
			dst[dst_index++] =			src[src_index];
    13a2:	4f 5f       	subi	r20, 0xFF	; 255
    13a4:	5f 4f       	sbci	r21, 0xFF	; 255
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    13a6:	cd 01       	movw	r24, r26
    13a8:	8e 19       	sub	r24, r14
    13aa:	9f 09       	sbc	r25, r15
    13ac:	f6 01       	movw	r30, r12
    13ae:	e4 0f       	add	r30, r20
    13b0:	f5 1f       	adc	r31, r21
    13b2:	80 17       	cp	r24, r16
    13b4:	91 07       	cpc	r25, r17
    13b6:	40 f3       	brcs	.-48     	; 0x1388 <Create_VCP_frame+0xa6>
		//if (dst_index >= *dst_size - 1)
			//return VCP_OVR_ERR;
	}
	
	// End the frame with FEND
	dst[dst_index++] =					FEND;
    13b8:	80 ec       	ldi	r24, 0xC0	; 192
    13ba:	80 83       	st	Z, r24
    13bc:	4f 5f       	subi	r20, 0xFF	; 255
    13be:	5f 4f       	sbci	r21, 0xFF	; 255
	
	// Save the frame size
	*dst_size = dst_index;
    13c0:	f5 01       	movw	r30, r10
    13c2:	51 83       	std	Z+1, r21	; 0x01
    13c4:	40 83       	st	Z, r20
	
	// All good
	return VCP_TERM;
    13c6:	81 e0       	ldi	r24, 0x01	; 1
    13c8:	03 c0       	rjmp	.+6      	; 0x13d0 <Create_VCP_frame+0xee>
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
		return VCP_NULL_ERR;
    13ca:	85 e0       	ldi	r24, 0x05	; 5
    13cc:	01 c0       	rjmp	.+2      	; 0x13d0 <Create_VCP_frame+0xee>

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
		return VCP_ADDR_ERR;
    13ce:	86 e0       	ldi	r24, 0x06	; 6
	// Save the frame size
	*dst_size = dst_index;
	
	// All good
	return VCP_TERM;
}
    13d0:	0f 90       	pop	r0
    13d2:	0f 90       	pop	r0
    13d4:	0f 90       	pop	r0
    13d6:	df 91       	pop	r29
    13d8:	cf 91       	pop	r28
    13da:	1f 91       	pop	r17
    13dc:	0f 91       	pop	r16
    13de:	ff 90       	pop	r15
    13e0:	ef 90       	pop	r14
    13e2:	df 90       	pop	r13
    13e4:	cf 90       	pop	r12
    13e6:	bf 90       	pop	r11
    13e8:	af 90       	pop	r10
    13ea:	9f 90       	pop	r9
    13ec:	8f 90       	pop	r8
    13ee:	7f 90       	pop	r7
    13f0:	6f 90       	pop	r6
    13f2:	5f 90       	pop	r5
    13f4:	4f 90       	pop	r4
    13f6:	08 95       	ret

000013f8 <Receive_VCP_byte>:
// and return VCP status.
// Parameters:
// vcp_ptrbuffer	*buff -	Pointer to the vcp buffer structure
// uint8			byte -	received byte
uint8_t Receive_VCP_byte(vcp_ptrbuffer *buff, uint8 byte)
{
    13f8:	cf 92       	push	r12
    13fa:	df 92       	push	r13
    13fc:	ef 92       	push	r14
    13fe:	ff 92       	push	r15
    1400:	0f 93       	push	r16
    1402:	1f 93       	push	r17
    1404:	cf 93       	push	r28
    1406:	df 93       	push	r29
    1408:	ec 01       	movw	r28, r24
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
    140a:	29 81       	ldd	r18, Y+1	; 0x01
    140c:	3a 81       	ldd	r19, Y+2	; 0x02
    140e:	21 15       	cp	r18, r1
    1410:	31 05       	cpc	r19, r1
    1412:	09 f4       	brne	.+2      	; 0x1416 <Receive_VCP_byte+0x1e>
    1414:	84 c0       	rjmp	.+264    	; 0x151e <Receive_VCP_byte+0x126>
		return VCP_NULL_ERR;
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
    1416:	8f 81       	ldd	r24, Y+7	; 0x07
    1418:	98 85       	ldd	r25, Y+8	; 0x08
    141a:	4d 81       	ldd	r20, Y+5	; 0x05
    141c:	5e 81       	ldd	r21, Y+6	; 0x06
    141e:	41 50       	subi	r20, 0x01	; 1
    1420:	51 09       	sbc	r21, r1
    1422:	84 17       	cp	r24, r20
    1424:	95 07       	cpc	r25, r21
    1426:	08 f0       	brcs	.+2      	; 0x142a <Receive_VCP_byte+0x32>
    1428:	7c c0       	rjmp	.+248    	; 0x1522 <Receive_VCP_byte+0x12a>
		return VCP_OVR_ERR;
	
	// State Machine
	switch (buff->status)
    142a:	49 85       	ldd	r20, Y+9	; 0x09
    142c:	42 30       	cpi	r20, 0x02	; 2
    142e:	39 f1       	breq	.+78     	; 0x147e <Receive_VCP_byte+0x86>
    1430:	18 f4       	brcc	.+6      	; 0x1438 <Receive_VCP_byte+0x40>
    1432:	44 23       	and	r20, r20
    1434:	31 f0       	breq	.+12     	; 0x1442 <Receive_VCP_byte+0x4a>
    1436:	38 c0       	rjmp	.+112    	; 0x14a8 <Receive_VCP_byte+0xb0>
    1438:	40 31       	cpi	r20, 0x10	; 16
    143a:	31 f0       	breq	.+12     	; 0x1448 <Receive_VCP_byte+0x50>
    143c:	40 32       	cpi	r20, 0x20	; 32
    143e:	a1 f5       	brne	.+104    	; 0x14a8 <Receive_VCP_byte+0xb0>
    1440:	0a c0       	rjmp	.+20     	; 0x1456 <Receive_VCP_byte+0x5e>
	{
		case VCP_IDLE:										
			if (byte == FEND)
    1442:	60 3c       	cpi	r22, 0xC0	; 192
    1444:	91 f5       	brne	.+100    	; 0x14aa <Receive_VCP_byte+0xb2>
    1446:	0d c0       	rjmp	.+26     	; 0x1462 <Receive_VCP_byte+0x6a>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
    1448:	6c 30       	cpi	r22, 0x0C	; 12
    144a:	18 f0       	brcs	.+6      	; 0x1452 <Receive_VCP_byte+0x5a>
    144c:	68 33       	cpi	r22, 0x38	; 56
    144e:	09 f0       	breq	.+2      	; 0x1452 <Receive_VCP_byte+0x5a>
    1450:	6a c0       	rjmp	.+212    	; 0x1526 <Receive_VCP_byte+0x12e>
				return VCP_ADDR_ERR;
			else
			{
				buff->address = byte;
    1452:	68 83       	st	Y, r22
    1454:	26 c0       	rjmp	.+76     	; 0x14a2 <Receive_VCP_byte+0xaa>
				buff->status = VCP_RECEIVING;
			}	
			break;
		case VCP_RECEIVING:
			if (byte == FEND)
    1456:	60 3c       	cpi	r22, 0xC0	; 192
    1458:	31 f4       	brne	.+12     	; 0x1466 <Receive_VCP_byte+0x6e>
			{
				if (buff->index > 0)
    145a:	89 2b       	or	r24, r25
    145c:	11 f0       	breq	.+4      	; 0x1462 <Receive_VCP_byte+0x6a>
					// Done
					buff->status = VCP_TERM;
    145e:	81 e0       	ldi	r24, 0x01	; 1
    1460:	21 c0       	rjmp	.+66     	; 0x14a4 <Receive_VCP_byte+0xac>
				else
					// No data between FENDs - assume lost sync and start over
					buff->status = VCP_ADDRESS;
    1462:	80 e1       	ldi	r24, 0x10	; 16
    1464:	1f c0       	rjmp	.+62     	; 0x14a4 <Receive_VCP_byte+0xac>
			}
			else if (byte == FESC)
    1466:	6b 3d       	cpi	r22, 0xDB	; 219
    1468:	11 f4       	brne	.+4      	; 0x146e <Receive_VCP_byte+0x76>
				buff->status = VCP_ESC;
    146a:	82 e0       	ldi	r24, 0x02	; 2
    146c:	1b c0       	rjmp	.+54     	; 0x14a4 <Receive_VCP_byte+0xac>
			else
			{
				buff->message[(buff->index)++] = byte;	
    146e:	f9 01       	movw	r30, r18
    1470:	e8 0f       	add	r30, r24
    1472:	f9 1f       	adc	r31, r25
    1474:	60 83       	st	Z, r22
    1476:	01 96       	adiw	r24, 0x01	; 1
    1478:	98 87       	std	Y+8, r25	; 0x08
    147a:	8f 83       	std	Y+7, r24	; 0x07
    147c:	16 c0       	rjmp	.+44     	; 0x14aa <Receive_VCP_byte+0xb2>
			}						
			break;
		case VCP_ESC:
			if (byte == TFEND)
    147e:	6c 3d       	cpi	r22, 0xDC	; 220
    1480:	29 f4       	brne	.+10     	; 0x148c <Receive_VCP_byte+0x94>
			{
				buff->message[(buff->index)++] = FEND;
    1482:	f9 01       	movw	r30, r18
    1484:	e8 0f       	add	r30, r24
    1486:	f9 1f       	adc	r31, r25
    1488:	40 ec       	ldi	r20, 0xC0	; 192
    148a:	07 c0       	rjmp	.+14     	; 0x149a <Receive_VCP_byte+0xa2>
				buff->status = VCP_RECEIVING;
			}
			else if (byte == TFESC)
    148c:	6d 3d       	cpi	r22, 0xDD	; 221
    148e:	09 f0       	breq	.+2      	; 0x1492 <Receive_VCP_byte+0x9a>
    1490:	4c c0       	rjmp	.+152    	; 0x152a <Receive_VCP_byte+0x132>
			{
				buff->message[(buff->index)++] = FESC;
    1492:	f9 01       	movw	r30, r18
    1494:	e8 0f       	add	r30, r24
    1496:	f9 1f       	adc	r31, r25
    1498:	4b ed       	ldi	r20, 0xDB	; 219
    149a:	40 83       	st	Z, r20
    149c:	01 96       	adiw	r24, 0x01	; 1
    149e:	98 87       	std	Y+8, r25	; 0x08
    14a0:	8f 83       	std	Y+7, r24	; 0x07
				buff->status = VCP_RECEIVING;
    14a2:	80 e2       	ldi	r24, 0x20	; 32
    14a4:	89 87       	std	Y+9, r24	; 0x09
    14a6:	01 c0       	rjmp	.+2      	; 0x14aa <Receive_VCP_byte+0xb2>
			}
			else
				return VCP_ESC_ERR;	
			break;
		default:
			buff->status = VCP_IDLE;
    14a8:	19 86       	std	Y+9, r1	; 0x09
			break; 
	}
	
	// End of frame
	if (buff->status == VCP_TERM)
    14aa:	89 85       	ldd	r24, Y+9	; 0x09
    14ac:	81 30       	cpi	r24, 0x01	; 1
    14ae:	11 f0       	breq	.+4      	; 0x14b4 <Receive_VCP_byte+0xbc>
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
    14b0:	89 85       	ldd	r24, Y+9	; 0x09
    14b2:	3c c0       	rjmp	.+120    	; 0x152c <Receive_VCP_byte+0x134>
	
	// End of frame
	if (buff->status == VCP_TERM)
	{
		// Message CRC is last 2 bytes 
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
    14b4:	89 81       	ldd	r24, Y+1	; 0x01
    14b6:	9a 81       	ldd	r25, Y+2	; 0x02
    14b8:	4f 81       	ldd	r20, Y+7	; 0x07
    14ba:	58 85       	ldd	r21, Y+8	; 0x08
    14bc:	84 0f       	add	r24, r20
    14be:	95 1f       	adc	r25, r21
    14c0:	fc 01       	movw	r30, r24
    14c2:	32 97       	sbiw	r30, 0x02	; 2
    14c4:	30 81       	ld	r19, Z
    14c6:	20 e0       	ldi	r18, 0x00	; 0
    14c8:	fc 01       	movw	r30, r24
    14ca:	31 97       	sbiw	r30, 0x01	; 1
    14cc:	80 81       	ld	r24, Z
    14ce:	69 01       	movw	r12, r18
    14d0:	c8 0e       	add	r12, r24
    14d2:	d1 1c       	adc	r13, r1
		// Remove CRC bytes from the message
		buff->index -= 2;
    14d4:	42 50       	subi	r20, 0x02	; 2
    14d6:	51 09       	sbc	r21, r1
    14d8:	58 87       	std	Y+8, r21	; 0x08
    14da:	4f 83       	std	Y+7, r20	; 0x07
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
    14dc:	7e 01       	movw	r14, r28
    14de:	83 e0       	ldi	r24, 0x03	; 3
    14e0:	e8 0e       	add	r14, r24
    14e2:	f1 1c       	adc	r15, r1
    14e4:	b7 01       	movw	r22, r14
    14e6:	88 81       	ld	r24, Y
    14e8:	0e 94 51 09 	call	0x12a2	; 0x12a2 <append_crc16>
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    14ec:	00 e0       	ldi	r16, 0x00	; 0
    14ee:	10 e0       	ldi	r17, 0x00	; 0
    14f0:	0a c0       	rjmp	.+20     	; 0x1506 <Receive_VCP_byte+0x10e>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
    14f2:	e9 81       	ldd	r30, Y+1	; 0x01
    14f4:	fa 81       	ldd	r31, Y+2	; 0x02
    14f6:	e0 0f       	add	r30, r16
    14f8:	f1 1f       	adc	r31, r17
    14fa:	b7 01       	movw	r22, r14
    14fc:	80 81       	ld	r24, Z
    14fe:	0e 94 51 09 	call	0x12a2	; 0x12a2 <append_crc16>
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
		// Remove CRC bytes from the message
		buff->index -= 2;
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    1502:	0f 5f       	subi	r16, 0xFF	; 255
    1504:	1f 4f       	sbci	r17, 0xFF	; 255
    1506:	8f 81       	ldd	r24, Y+7	; 0x07
    1508:	98 85       	ldd	r25, Y+8	; 0x08
    150a:	08 17       	cp	r16, r24
    150c:	19 07       	cpc	r17, r25
    150e:	88 f3       	brcs	.-30     	; 0x14f2 <Receive_VCP_byte+0xfa>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
		}
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
    1510:	8b 81       	ldd	r24, Y+3	; 0x03
    1512:	9c 81       	ldd	r25, Y+4	; 0x04
    1514:	8c 15       	cp	r24, r12
    1516:	9d 05       	cpc	r25, r13
    1518:	59 f2       	breq	.-106    	; 0x14b0 <Receive_VCP_byte+0xb8>
			return VCP_CRC_ERR;
    151a:	84 e0       	ldi	r24, 0x04	; 4
    151c:	07 c0       	rjmp	.+14     	; 0x152c <Receive_VCP_byte+0x134>
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
		return VCP_NULL_ERR;
    151e:	85 e0       	ldi	r24, 0x05	; 5
    1520:	05 c0       	rjmp	.+10     	; 0x152c <Receive_VCP_byte+0x134>
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
		return VCP_OVR_ERR;
    1522:	83 e0       	ldi	r24, 0x03	; 3
    1524:	03 c0       	rjmp	.+6      	; 0x152c <Receive_VCP_byte+0x134>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
				return VCP_ADDR_ERR;
    1526:	86 e0       	ldi	r24, 0x06	; 6
    1528:	01 c0       	rjmp	.+2      	; 0x152c <Receive_VCP_byte+0x134>
			{
				buff->message[(buff->index)++] = FESC;
				buff->status = VCP_RECEIVING;
			}
			else
				return VCP_ESC_ERR;	
    152a:	87 e0       	ldi	r24, 0x07	; 7
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
}
    152c:	df 91       	pop	r29
    152e:	cf 91       	pop	r28
    1530:	1f 91       	pop	r17
    1532:	0f 91       	pop	r16
    1534:	ff 90       	pop	r15
    1536:	ef 90       	pop	r14
    1538:	df 90       	pop	r13
    153a:	cf 90       	pop	r12
    153c:	08 95       	ret

0000153e <tx_put_byte.part.0>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    return;
  if( tel_packet_index[uart] < tel_packet_size[uart] )
    153e:	28 2f       	mov	r18, r24
    1540:	30 e0       	ldi	r19, 0x00	; 0
    1542:	f9 01       	movw	r30, r18
    1544:	e1 5d       	subi	r30, 0xD1	; 209
    1546:	f8 4f       	sbci	r31, 0xF8	; 248
    1548:	60 81       	ld	r22, Z
    154a:	d9 01       	movw	r26, r18
    154c:	aa 0f       	add	r26, r26
    154e:	bb 1f       	adc	r27, r27
    1550:	a1 5a       	subi	r26, 0xA1	; 161
    1552:	bc 4f       	sbci	r27, 0xFC	; 252
    1554:	4d 91       	ld	r20, X+
    1556:	5c 91       	ld	r21, X
    1558:	70 e0       	ldi	r23, 0x00	; 0
    155a:	64 17       	cp	r22, r20
    155c:	75 07       	cpc	r23, r21
    155e:	10 f5       	brcc	.+68     	; 0x15a4 <tx_put_byte.part.0+0x66>
  {
      if ( uart == 0 )
    1560:	81 11       	cpse	r24, r1
    1562:	0e c0       	rjmp	.+28     	; 0x1580 <tx_put_byte.part.0+0x42>
      UDR0 = tel_packet[uart][tel_packet_index[uart]++];
    1564:	80 81       	ld	r24, Z
    1566:	9f ef       	ldi	r25, 0xFF	; 255
    1568:	92 9f       	mul	r25, r18
    156a:	d0 01       	movw	r26, r0
    156c:	93 9f       	mul	r25, r19
    156e:	b0 0d       	add	r27, r0
    1570:	11 24       	eor	r1, r1
    1572:	a8 0f       	add	r26, r24
    1574:	b1 1d       	adc	r27, r1
    1576:	aa 5c       	subi	r26, 0xCA	; 202
    1578:	b8 4f       	sbci	r27, 0xF8	; 248
    157a:	9c 91       	ld	r25, X
    157c:	9c b9       	out	0x0c, r25	; 12
    157e:	10 c0       	rjmp	.+32     	; 0x15a0 <tx_put_byte.part.0+0x62>
    else if ( uart == 1 )
    1580:	81 30       	cpi	r24, 0x01	; 1
    1582:	81 f4       	brne	.+32     	; 0x15a4 <tx_put_byte.part.0+0x66>
      UDR1 = tel_packet[uart][tel_packet_index[uart]++];
    1584:	80 81       	ld	r24, Z
    1586:	9f ef       	ldi	r25, 0xFF	; 255
    1588:	92 9f       	mul	r25, r18
    158a:	d0 01       	movw	r26, r0
    158c:	93 9f       	mul	r25, r19
    158e:	b0 0d       	add	r27, r0
    1590:	11 24       	eor	r1, r1
    1592:	a8 0f       	add	r26, r24
    1594:	b1 1d       	adc	r27, r1
    1596:	aa 5c       	subi	r26, 0xCA	; 202
    1598:	b8 4f       	sbci	r27, 0xF8	; 248
    159a:	9c 91       	ld	r25, X
    159c:	90 93 9c 00 	sts	0x009C, r25
    15a0:	8f 5f       	subi	r24, 0xFF	; 255
    15a2:	80 83       	st	Z, r24
    15a4:	08 95       	ret

000015a6 <__vector_15>:
#include "vcp_library.h"
#include "crclib.h"
#include "uart.h"

ISR(TIMER0_COMP_vect)
{
    15a6:	1f 92       	push	r1
    15a8:	0f 92       	push	r0
    15aa:	0f b6       	in	r0, 0x3f	; 63
    15ac:	0f 92       	push	r0
    15ae:	11 24       	eor	r1, r1
    15b0:	8f 93       	push	r24
  if ( timer0_counter[0] > 0 )
    15b2:	80 91 64 0b 	lds	r24, 0x0B64
    15b6:	88 23       	and	r24, r24
    15b8:	29 f0       	breq	.+10     	; 0x15c4 <__vector_15+0x1e>
    --timer0_counter[0];
    15ba:	80 91 64 0b 	lds	r24, 0x0B64
    15be:	81 50       	subi	r24, 0x01	; 1
    15c0:	80 93 64 0b 	sts	0x0B64, r24
  if ( timer0_counter[1] > 0 )
    15c4:	80 91 65 0b 	lds	r24, 0x0B65
    15c8:	88 23       	and	r24, r24
    15ca:	29 f0       	breq	.+10     	; 0x15d6 <__vector_15+0x30>
    --timer0_counter[1];
    15cc:	80 91 65 0b 	lds	r24, 0x0B65
    15d0:	81 50       	subi	r24, 0x01	; 1
    15d2:	80 93 65 0b 	sts	0x0B65, r24
	//if (cntr == 0)
	//	PORTC |= 0x01;
	//else
	//	PORTC &= 0xFE;
	//_delay_ms(500);
}
    15d6:	8f 91       	pop	r24
    15d8:	0f 90       	pop	r0
    15da:	0f be       	out	0x3f, r0	; 63
    15dc:	0f 90       	pop	r0
    15de:	1f 90       	pop	r1
    15e0:	18 95       	reti

000015e2 <__vector_12>:

/* Timer 1(A) routine */
ISR(TIMER1_COMPA_vect)		//Handle Radio & Torquer 30 min delays here; handle 10 min CDH-IB no heartbeat restart
{
    15e2:	1f 92       	push	r1
    15e4:	0f 92       	push	r0
    15e6:	0f b6       	in	r0, 0x3f	; 63
    15e8:	0f 92       	push	r0
    15ea:	11 24       	eor	r1, r1
    15ec:	0b b6       	in	r0, 0x3b	; 59
    15ee:	0f 92       	push	r0
    15f0:	2f 93       	push	r18
    15f2:	3f 93       	push	r19
    15f4:	4f 93       	push	r20
    15f6:	5f 93       	push	r21
    15f8:	6f 93       	push	r22
    15fa:	7f 93       	push	r23
    15fc:	8f 93       	push	r24
    15fe:	9f 93       	push	r25
    1600:	af 93       	push	r26
    1602:	bf 93       	push	r27
    1604:	cf 93       	push	r28
    1606:	ef 93       	push	r30
    1608:	ff 93       	push	r31
	SVIT_t *component;
	
	//Testing
	//PORTC ^= 0xFF;
		
	if (timer1_counter[0] <= 0	  &&     rad_torq_flag){	//provides 30 minute delay			
    160a:	80 91 86 0d 	lds	r24, 0x0D86
    160e:	81 11       	cpse	r24, r1
    1610:	31 c0       	rjmp	.+98     	; 0x1674 <__vector_12+0x92>
    1612:	80 91 43 03 	lds	r24, 0x0343
    1616:	88 23       	and	r24, r24
    1618:	69 f1       	breq	.+90     	; 0x1674 <__vector_12+0x92>
	//if ( receive_flag == 1){		//If message is received, reset timer1_counter[0] to CYCLE_COUNTER
	    timer1_counter[0] = CYCLE_COUNTER;
    161a:	84 e8       	ldi	r24, 0x84	; 132
    161c:	80 93 86 0d 	sts	0x0D86, r24
		
		//CHECK: Should the ISR do this code or not?
		
		//Turn on radios
		component = &svit[RADIO_1];
		switch_on( component->switch_num );
    1620:	80 91 8d 04 	lds	r24, 0x048D
    1624:	0e 94 6f 07 	call	0xede	; 0xede <switch_on>
		component->switch_state = SW_ON;
    1628:	c1 e0       	ldi	r28, 0x01	; 1
    162a:	c0 93 8e 04 	sts	0x048E, r28
		component = &svit[RADIO_2];
		switch_on( component->switch_num );
    162e:	80 91 a7 04 	lds	r24, 0x04A7
    1632:	0e 94 6f 07 	call	0xede	; 0xede <switch_on>
		component->switch_state = SW_ON;
    1636:	c0 93 a8 04 	sts	0x04A8, r28
		
		//Turn on torque coils			
		component = &svit[TORQUER_1];
		switch_on( component->switch_num );
    163a:	80 91 29 05 	lds	r24, 0x0529
    163e:	0e 94 6f 07 	call	0xede	; 0xede <switch_on>
		component->switch_state = SW_ON;
    1642:	c0 93 2a 05 	sts	0x052A, r28
		component = &svit[TORQUER_2];
		switch_on( component->switch_num );
    1646:	80 91 43 05 	lds	r24, 0x0543
    164a:	0e 94 6f 07 	call	0xede	; 0xede <switch_on>
		component->switch_state = SW_ON;
    164e:	c0 93 44 05 	sts	0x0544, r28
		component = &svit[TORQUER_3];
		switch_on( component->switch_num );
    1652:	80 91 5d 05 	lds	r24, 0x055D
    1656:	0e 94 6f 07 	call	0xede	; 0xede <switch_on>
		component->switch_state = SW_ON;
    165a:	c0 93 5e 05 	sts	0x055E, r28
		torquer_on(TORQUER_1);
    165e:	81 e1       	ldi	r24, 0x11	; 17
    1660:	0e 94 52 07 	call	0xea4	; 0xea4 <torquer_on>
		torquer_on(TORQUER_2);
    1664:	82 e1       	ldi	r24, 0x12	; 18
    1666:	0e 94 52 07 	call	0xea4	; 0xea4 <torquer_on>
		torquer_on(TORQUER_3);
    166a:	83 e1       	ldi	r24, 0x13	; 19
    166c:	0e 94 52 07 	call	0xea4	; 0xea4 <torquer_on>
		
		//PORTC ^= 0x02;	//LED for STK testing
		//PORTC ^= 0x01;
		
		//Don't reexecute this code
		rad_torq_flag = 0;
    1670:	10 92 43 03 	sts	0x0343, r1
	}
	
	if (timer1_counter[1] <= 0   &&   !cdh_heartbeat_flag){		//If heartbeat timer 1 has expired AND we haven't already ordered a restart
    1674:	80 91 87 0d 	lds	r24, 0x0D87
    1678:	81 11       	cpse	r24, r1
    167a:	07 c0       	rjmp	.+14     	; 0x168a <__vector_12+0xa8>
    167c:	80 91 5a 03 	lds	r24, 0x035A
    1680:	81 11       	cpse	r24, r1
    1682:	03 c0       	rjmp	.+6      	; 0x168a <__vector_12+0xa8>
		//Order full component restart
		cdh_heartbeat_flag = 1;
    1684:	81 e0       	ldi	r24, 0x01	; 1
    1686:	80 93 5a 03 	sts	0x035A, r24
		
	}
	
	//else{
		PORTC ^= 0x01;		//LED for STK testing at PORTC0
    168a:	85 b3       	in	r24, 0x15	; 21
    168c:	91 e0       	ldi	r25, 0x01	; 1
    168e:	89 27       	eor	r24, r25
    1690:	85 bb       	out	0x15, r24	; 21
    1692:	2f ef       	ldi	r18, 0xFF	; 255
    1694:	8f e7       	ldi	r24, 0x7F	; 127
    1696:	96 e1       	ldi	r25, 0x16	; 22
    1698:	21 50       	subi	r18, 0x01	; 1
    169a:	80 40       	sbci	r24, 0x00	; 0
    169c:	90 40       	sbci	r25, 0x00	; 0
    169e:	e1 f7       	brne	.-8      	; 0x1698 <__vector_12+0xb6>
    16a0:	00 c0       	rjmp	.+0      	; 0x16a2 <__vector_12+0xc0>
    16a2:	00 00       	nop
		_delay_ms(500);
		--timer1_counter[0];
    16a4:	80 91 86 0d 	lds	r24, 0x0D86
    16a8:	81 50       	subi	r24, 0x01	; 1
    16aa:	80 93 86 0d 	sts	0x0D86, r24
		--timer1_counter[1];
    16ae:	80 91 87 0d 	lds	r24, 0x0D87
    16b2:	81 50       	subi	r24, 0x01	; 1
    16b4:	80 93 87 0d 	sts	0x0D87, r24
	//}
}
    16b8:	ff 91       	pop	r31
    16ba:	ef 91       	pop	r30
    16bc:	cf 91       	pop	r28
    16be:	bf 91       	pop	r27
    16c0:	af 91       	pop	r26
    16c2:	9f 91       	pop	r25
    16c4:	8f 91       	pop	r24
    16c6:	7f 91       	pop	r23
    16c8:	6f 91       	pop	r22
    16ca:	5f 91       	pop	r21
    16cc:	4f 91       	pop	r20
    16ce:	3f 91       	pop	r19
    16d0:	2f 91       	pop	r18
    16d2:	0f 90       	pop	r0
    16d4:	0b be       	out	0x3b, r0	; 59
    16d6:	0f 90       	pop	r0
    16d8:	0f be       	out	0x3f, r0	; 63
    16da:	0f 90       	pop	r0
    16dc:	1f 90       	pop	r1
    16de:	18 95       	reti

000016e0 <__vector_32>:

ISR(USART1_TX_vect)
{
    16e0:	1f 92       	push	r1
    16e2:	0f 92       	push	r0
    16e4:	0f b6       	in	r0, 0x3f	; 63
    16e6:	0f 92       	push	r0
    16e8:	11 24       	eor	r1, r1
    16ea:	0b b6       	in	r0, 0x3b	; 59
    16ec:	0f 92       	push	r0
    16ee:	2f 93       	push	r18
    16f0:	3f 93       	push	r19
    16f2:	4f 93       	push	r20
    16f4:	5f 93       	push	r21
    16f6:	6f 93       	push	r22
    16f8:	7f 93       	push	r23
    16fa:	8f 93       	push	r24
    16fc:	9f 93       	push	r25
    16fe:	af 93       	push	r26
    1700:	bf 93       	push	r27
    1702:	ef 93       	push	r30
    1704:	ff 93       	push	r31
    1706:	81 e0       	ldi	r24, 0x01	; 1
    1708:	0e 94 9f 0a 	call	0x153e	; 0x153e <tx_put_byte.part.0>
  tx_put_byte( 1 );
}
    170c:	ff 91       	pop	r31
    170e:	ef 91       	pop	r30
    1710:	bf 91       	pop	r27
    1712:	af 91       	pop	r26
    1714:	9f 91       	pop	r25
    1716:	8f 91       	pop	r24
    1718:	7f 91       	pop	r23
    171a:	6f 91       	pop	r22
    171c:	5f 91       	pop	r21
    171e:	4f 91       	pop	r20
    1720:	3f 91       	pop	r19
    1722:	2f 91       	pop	r18
    1724:	0f 90       	pop	r0
    1726:	0b be       	out	0x3b, r0	; 59
    1728:	0f 90       	pop	r0
    172a:	0f be       	out	0x3f, r0	; 63
    172c:	0f 90       	pop	r0
    172e:	1f 90       	pop	r1
    1730:	18 95       	reti

00001732 <__vector_30>:

ISR(USART1_RX_vect)
{
    1732:	1f 92       	push	r1
    1734:	0f 92       	push	r0
    1736:	0f b6       	in	r0, 0x3f	; 63
    1738:	0f 92       	push	r0
    173a:	11 24       	eor	r1, r1
    173c:	0b b6       	in	r0, 0x3b	; 59
    173e:	0f 92       	push	r0
    1740:	2f 93       	push	r18
    1742:	3f 93       	push	r19
    1744:	4f 93       	push	r20
    1746:	5f 93       	push	r21
    1748:	6f 93       	push	r22
    174a:	7f 93       	push	r23
    174c:	8f 93       	push	r24
    174e:	9f 93       	push	r25
    1750:	af 93       	push	r26
    1752:	bf 93       	push	r27
    1754:	ef 93       	push	r30
    1756:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[1], UDR1 ) == VCP_TERM )
    1758:	60 91 9c 00 	lds	r22, 0x009C
    175c:	80 91 90 0d 	lds	r24, 0x0D90
    1760:	90 91 91 0d 	lds	r25, 0x0D91
    1764:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <Receive_VCP_byte>
    1768:	81 30       	cpi	r24, 0x01	; 1
    176a:	29 f4       	brne	.+10     	; 0x1776 <__vector_30+0x44>
  {
    rx_flag[1]++;
    176c:	80 91 93 0d 	lds	r24, 0x0D93
    1770:	8f 5f       	subi	r24, 0xFF	; 255
    1772:	80 93 93 0d 	sts	0x0D93, r24
  }
}
    1776:	ff 91       	pop	r31
    1778:	ef 91       	pop	r30
    177a:	bf 91       	pop	r27
    177c:	af 91       	pop	r26
    177e:	9f 91       	pop	r25
    1780:	8f 91       	pop	r24
    1782:	7f 91       	pop	r23
    1784:	6f 91       	pop	r22
    1786:	5f 91       	pop	r21
    1788:	4f 91       	pop	r20
    178a:	3f 91       	pop	r19
    178c:	2f 91       	pop	r18
    178e:	0f 90       	pop	r0
    1790:	0b be       	out	0x3b, r0	; 59
    1792:	0f 90       	pop	r0
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	0f 90       	pop	r0
    1798:	1f 90       	pop	r1
    179a:	18 95       	reti

0000179c <__vector_21>:

ISR ( ADC_vect )
{
    179c:	1f 92       	push	r1
    179e:	0f 92       	push	r0
    17a0:	0f b6       	in	r0, 0x3f	; 63
    17a2:	0f 92       	push	r0
    17a4:	11 24       	eor	r1, r1
    17a6:	8f 93       	push	r24
  ADC_low = ADCL;	// Left adjusted; read 2 LSB then 8 MSB
    17a8:	84 b1       	in	r24, 0x04	; 4
    17aa:	80 93 88 0d 	sts	0x0D88, r24
  ADC_high = ADCH;
    17ae:	85 b1       	in	r24, 0x05	; 5
    17b0:	80 93 52 09 	sts	0x0952, r24
  adc_flag = 1;
    17b4:	81 e0       	ldi	r24, 0x01	; 1
    17b6:	80 93 35 09 	sts	0x0935, r24
}
    17ba:	8f 91       	pop	r24
    17bc:	0f 90       	pop	r0
    17be:	0f be       	out	0x3f, r0	; 63
    17c0:	0f 90       	pop	r0
    17c2:	1f 90       	pop	r1
    17c4:	18 95       	reti

000017c6 <__vector_20>:

ISR( USART0_TX_vect )
{
    17c6:	1f 92       	push	r1
    17c8:	0f 92       	push	r0
    17ca:	0f b6       	in	r0, 0x3f	; 63
    17cc:	0f 92       	push	r0
    17ce:	11 24       	eor	r1, r1
    17d0:	0b b6       	in	r0, 0x3b	; 59
    17d2:	0f 92       	push	r0
    17d4:	2f 93       	push	r18
    17d6:	3f 93       	push	r19
    17d8:	4f 93       	push	r20
    17da:	5f 93       	push	r21
    17dc:	6f 93       	push	r22
    17de:	7f 93       	push	r23
    17e0:	8f 93       	push	r24
    17e2:	9f 93       	push	r25
    17e4:	af 93       	push	r26
    17e6:	bf 93       	push	r27
    17e8:	ef 93       	push	r30
    17ea:	ff 93       	push	r31
    17ec:	80 e0       	ldi	r24, 0x00	; 0
    17ee:	0e 94 9f 0a 	call	0x153e	; 0x153e <tx_put_byte.part.0>
  tx_put_byte( 0 );
}
    17f2:	ff 91       	pop	r31
    17f4:	ef 91       	pop	r30
    17f6:	bf 91       	pop	r27
    17f8:	af 91       	pop	r26
    17fa:	9f 91       	pop	r25
    17fc:	8f 91       	pop	r24
    17fe:	7f 91       	pop	r23
    1800:	6f 91       	pop	r22
    1802:	5f 91       	pop	r21
    1804:	4f 91       	pop	r20
    1806:	3f 91       	pop	r19
    1808:	2f 91       	pop	r18
    180a:	0f 90       	pop	r0
    180c:	0b be       	out	0x3b, r0	; 59
    180e:	0f 90       	pop	r0
    1810:	0f be       	out	0x3f, r0	; 63
    1812:	0f 90       	pop	r0
    1814:	1f 90       	pop	r1
    1816:	18 95       	reti

00001818 <__vector_18>:

ISR( USART0_RX_vect )
{
    1818:	1f 92       	push	r1
    181a:	0f 92       	push	r0
    181c:	0f b6       	in	r0, 0x3f	; 63
    181e:	0f 92       	push	r0
    1820:	11 24       	eor	r1, r1
    1822:	0b b6       	in	r0, 0x3b	; 59
    1824:	0f 92       	push	r0
    1826:	2f 93       	push	r18
    1828:	3f 93       	push	r19
    182a:	4f 93       	push	r20
    182c:	5f 93       	push	r21
    182e:	6f 93       	push	r22
    1830:	7f 93       	push	r23
    1832:	8f 93       	push	r24
    1834:	9f 93       	push	r25
    1836:	af 93       	push	r26
    1838:	bf 93       	push	r27
    183a:	ef 93       	push	r30
    183c:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[0], UDR0 ) == VCP_TERM )
    183e:	6c b1       	in	r22, 0x0c	; 12
    1840:	80 91 8e 0d 	lds	r24, 0x0D8E
    1844:	90 91 8f 0d 	lds	r25, 0x0D8F
    1848:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <Receive_VCP_byte>
    184c:	81 30       	cpi	r24, 0x01	; 1
    184e:	29 f4       	brne	.+10     	; 0x185a <__vector_18+0x42>
  {
    rx_flag[0]++;
    1850:	80 91 92 0d 	lds	r24, 0x0D92
    1854:	8f 5f       	subi	r24, 0xFF	; 255
    1856:	80 93 92 0d 	sts	0x0D92, r24
  }
}
    185a:	ff 91       	pop	r31
    185c:	ef 91       	pop	r30
    185e:	bf 91       	pop	r27
    1860:	af 91       	pop	r26
    1862:	9f 91       	pop	r25
    1864:	8f 91       	pop	r24
    1866:	7f 91       	pop	r23
    1868:	6f 91       	pop	r22
    186a:	5f 91       	pop	r21
    186c:	4f 91       	pop	r20
    186e:	3f 91       	pop	r19
    1870:	2f 91       	pop	r18
    1872:	0f 90       	pop	r0
    1874:	0b be       	out	0x3b, r0	; 59
    1876:	0f 90       	pop	r0
    1878:	0f be       	out	0x3f, r0	; 63
    187a:	0f 90       	pop	r0
    187c:	1f 90       	pop	r1
    187e:	18 95       	reti

00001880 <tx_put_byte>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    1880:	82 30       	cpi	r24, 0x02	; 2
    1882:	10 f4       	brcc	.+4      	; 0x1888 <tx_put_byte+0x8>
    1884:	0c 94 9f 0a 	jmp	0x153e	; 0x153e <tx_put_byte.part.0>
    1888:	08 95       	ret

0000188a <construct_telemetry_packet>:
  }
}


void construct_telemetry_packet( uint8_t* packet_payload )
{
    188a:	2f 92       	push	r2
    188c:	3f 92       	push	r3
    188e:	4f 92       	push	r4
    1890:	5f 92       	push	r5
    1892:	6f 92       	push	r6
    1894:	7f 92       	push	r7
    1896:	8f 92       	push	r8
    1898:	9f 92       	push	r9
    189a:	af 92       	push	r10
    189c:	bf 92       	push	r11
    189e:	cf 92       	push	r12
    18a0:	df 92       	push	r13
    18a2:	ef 92       	push	r14
    18a4:	ff 92       	push	r15
    18a6:	0f 93       	push	r16
    18a8:	1f 93       	push	r17
    18aa:	cf 93       	push	r28
    18ac:	df 93       	push	r29
    18ae:	cd b7       	in	r28, 0x3d	; 61
    18b0:	de b7       	in	r29, 0x3e	; 62
    18b2:	28 97       	sbiw	r28, 0x08	; 8
    18b4:	0f b6       	in	r0, 0x3f	; 63
    18b6:	f8 94       	cli
    18b8:	de bf       	out	0x3e, r29	; 62
    18ba:	0f be       	out	0x3f, r0	; 63
    18bc:	cd bf       	out	0x3d, r28	; 61
    18be:	98 87       	std	Y+8, r25	; 0x08
    18c0:	8f 83       	std	Y+7, r24	; 0x07
  packet_payload[0] = VCP_POWER_TELEMETRY;
    18c2:	dc 01       	movw	r26, r24
    18c4:	1c 92       	st	X, r1
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
    18c6:	30 91 74 04 	lds	r19, 0x0474
    18ca:	33 0f       	add	r19, r19
                  ( svit[RADIO_1].switch_state << 2 )    |
    18cc:	80 91 8e 04 	lds	r24, 0x048E
    18d0:	b4 e0       	ldi	r27, 0x04	; 4
    18d2:	8b 9f       	mul	r24, r27
    18d4:	c0 01       	movw	r24, r0
    18d6:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    18d8:	38 2b       	or	r19, r24
    18da:	80 91 5a 04 	lds	r24, 0x045A
    18de:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
    18e0:	80 91 a8 04 	lds	r24, 0x04A8
    18e4:	e8 e0       	ldi	r30, 0x08	; 8
    18e6:	8e 9f       	mul	r24, r30
    18e8:	c0 01       	movw	r24, r0
    18ea:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    18ec:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
    18ee:	80 91 f6 04 	lds	r24, 0x04F6
    18f2:	f0 e1       	ldi	r31, 0x10	; 16
    18f4:	8f 9f       	mul	r24, r31
    18f6:	c0 01       	movw	r24, r0
    18f8:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    18fa:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;
    18fc:	80 91 10 05 	lds	r24, 0x0510
    1900:	20 e2       	ldi	r18, 0x20	; 32
    1902:	82 9f       	mul	r24, r18
    1904:	c0 01       	movw	r24, r0
    1906:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1908:	38 2b       	or	r19, r24
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
    190a:	40 91 44 05 	lds	r20, 0x0544
    190e:	44 0f       	add	r20, r20
                  ( svit[TORQUER_3].switch_state << 2 ) |
    1910:	80 91 5e 05 	lds	r24, 0x055E
    1914:	54 e0       	ldi	r21, 0x04	; 4
    1916:	85 9f       	mul	r24, r21
    1918:	c0 01       	movw	r24, r0
    191a:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    191c:	48 2b       	or	r20, r24
    191e:	80 91 2a 05 	lds	r24, 0x052A
    1922:	48 2b       	or	r20, r24
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );
    1924:	e2 ec       	ldi	r30, 0xC2	; 194
    1926:	f4 e0       	ldi	r31, 0x04	; 4
    1928:	80 81       	ld	r24, Z
    192a:	a8 e0       	ldi	r26, 0x08	; 8
    192c:	8a 9f       	mul	r24, r26
    192e:	c0 01       	movw	r24, r0
    1930:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1932:	48 2b       	or	r20, r24
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
    1934:	20 91 8a 03 	lds	r18, 0x038A
    1938:	22 0f       	add	r18, r18
                  ( svit[FC_5V].switch_state << 2 )        |
    193a:	80 91 a4 03 	lds	r24, 0x03A4
    193e:	b4 e0       	ldi	r27, 0x04	; 4
    1940:	8b 9f       	mul	r24, r27
    1942:	c0 01       	movw	r24, r0
    1944:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1946:	28 2b       	or	r18, r24
    1948:	80 91 70 03 	lds	r24, 0x0370
    194c:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
    194e:	80 91 d8 03 	lds	r24, 0x03D8
    1952:	58 e0       	ldi	r21, 0x08	; 8
    1954:	85 9f       	mul	r24, r21
    1956:	c0 01       	movw	r24, r0
    1958:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    195a:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
    195c:	80 91 f2 03 	lds	r24, 0x03F2
    1960:	a0 e1       	ldi	r26, 0x10	; 16
    1962:	8a 9f       	mul	r24, r26
    1964:	c0 01       	movw	r24, r0
    1966:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1968:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
    196a:	80 91 0c 04 	lds	r24, 0x040C
    196e:	b0 e2       	ldi	r27, 0x20	; 32
    1970:	8b 9f       	mul	r24, r27
    1972:	c0 01       	movw	r24, r0
    1974:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1976:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
    1978:	80 91 26 04 	lds	r24, 0x0426
    197c:	50 e4       	ldi	r21, 0x40	; 64
    197e:	85 9f       	mul	r24, r21
    1980:	c0 01       	movw	r24, r0
    1982:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1984:	28 2b       	or	r18, r24
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;
    1986:	80 91 40 04 	lds	r24, 0x0440
    198a:	a0 e8       	ldi	r26, 0x80	; 128
    198c:	8a 9f       	mul	r24, r26
    198e:	c0 01       	movw	r24, r0
    1990:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1992:	28 2b       	or	r18, r24
  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );

  packet_payload[1] = on_off_state0;
    1994:	af 81       	ldd	r26, Y+7	; 0x07
    1996:	b8 85       	ldd	r27, Y+8	; 0x08
    1998:	11 96       	adiw	r26, 0x01	; 1
    199a:	2c 93       	st	X, r18
    199c:	11 97       	sbiw	r26, 0x01	; 1
  packet_payload[2] = on_off_state1;
    199e:	12 96       	adiw	r26, 0x02	; 2
    19a0:	3c 93       	st	X, r19
    19a2:	12 97       	sbiw	r26, 0x02	; 2
  packet_payload[3] = on_off_state2;
    19a4:	13 96       	adiw	r26, 0x03	; 3
    19a6:	4c 93       	st	X, r20
    19a8:	13 97       	sbiw	r26, 0x03	; 3
  packet_payload[4] = 0x99;
    19aa:	89 e9       	ldi	r24, 0x99	; 153
    19ac:	14 96       	adiw	r26, 0x04	; 4
    19ae:	8c 93       	st	X, r24
    19b0:	14 97       	sbiw	r26, 0x04	; 4
  packet_payload[5] = svit[MAESTRO].switch_state;
    19b2:	80 81       	ld	r24, Z
    19b4:	15 96       	adiw	r26, 0x05	; 5
    19b6:	8c 93       	st	X, r24

  // voltage values (raw ADC output)
  packet_payload[6]  = SVIT_check_V_critical( svit[SPECTROMETER].name );
    19b8:	2e e6       	ldi	r18, 0x6E	; 110
    19ba:	62 2e       	mov	r6, r18
    19bc:	23 e0       	ldi	r18, 0x03	; 3
    19be:	72 2e       	mov	r7, r18
    19c0:	f3 01       	movw	r30, r6
    19c2:	80 81       	ld	r24, Z
    19c4:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    19c8:	af 81       	ldd	r26, Y+7	; 0x07
    19ca:	b8 85       	ldd	r27, Y+8	; 0x08
    19cc:	16 96       	adiw	r26, 0x06	; 6
    19ce:	8c 93       	st	X, r24
  packet_payload[7]  = SVIT_check_V_critical( svit[STAR_TRACKER].name );
    19d0:	38 e8       	ldi	r19, 0x88	; 136
    19d2:	83 2e       	mov	r8, r19
    19d4:	33 e0       	ldi	r19, 0x03	; 3
    19d6:	93 2e       	mov	r9, r19
    19d8:	f4 01       	movw	r30, r8
    19da:	80 81       	ld	r24, Z
    19dc:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    19e0:	af 81       	ldd	r26, Y+7	; 0x07
    19e2:	b8 85       	ldd	r27, Y+8	; 0x08
    19e4:	17 96       	adiw	r26, 0x07	; 7
    19e6:	8c 93       	st	X, r24
  packet_payload[8]  = SVIT_check_V_critical( svit[FC_5V].name );
    19e8:	42 ea       	ldi	r20, 0xA2	; 162
    19ea:	a4 2e       	mov	r10, r20
    19ec:	43 e0       	ldi	r20, 0x03	; 3
    19ee:	b4 2e       	mov	r11, r20
    19f0:	f5 01       	movw	r30, r10
    19f2:	80 81       	ld	r24, Z
    19f4:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    19f8:	af 81       	ldd	r26, Y+7	; 0x07
    19fa:	b8 85       	ldd	r27, Y+8	; 0x08
    19fc:	18 96       	adiw	r26, 0x08	; 8
    19fe:	8c 93       	st	X, r24
  packet_payload[9]  = SVIT_check_V_critical( svit[FC_3_3V].name );
    1a00:	5c eb       	ldi	r21, 0xBC	; 188
    1a02:	c5 2e       	mov	r12, r21
    1a04:	53 e0       	ldi	r21, 0x03	; 3
    1a06:	d5 2e       	mov	r13, r21
    1a08:	f6 01       	movw	r30, r12
    1a0a:	80 81       	ld	r24, Z
    1a0c:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1a10:	af 81       	ldd	r26, Y+7	; 0x07
    1a12:	b8 85       	ldd	r27, Y+8	; 0x08
    1a14:	19 96       	adiw	r26, 0x09	; 9
    1a16:	8c 93       	st	X, r24
  packet_payload[10] = SVIT_check_V_critical( svit[GPS_1].name );
    1a18:	66 ed       	ldi	r22, 0xD6	; 214
    1a1a:	e6 2e       	mov	r14, r22
    1a1c:	63 e0       	ldi	r22, 0x03	; 3
    1a1e:	f6 2e       	mov	r15, r22
    1a20:	f7 01       	movw	r30, r14
    1a22:	80 81       	ld	r24, Z
    1a24:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1a28:	af 81       	ldd	r26, Y+7	; 0x07
    1a2a:	b8 85       	ldd	r27, Y+8	; 0x08
    1a2c:	1a 96       	adiw	r26, 0x0a	; 10
    1a2e:	8c 93       	st	X, r24
  packet_payload[11] = SVIT_check_V_critical( svit[CDH_IB].name );
    1a30:	0a e0       	ldi	r16, 0x0A	; 10
    1a32:	14 e0       	ldi	r17, 0x04	; 4
    1a34:	f8 01       	movw	r30, r16
    1a36:	80 81       	ld	r24, Z
    1a38:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1a3c:	af 81       	ldd	r26, Y+7	; 0x07
    1a3e:	b8 85       	ldd	r27, Y+8	; 0x08
    1a40:	1b 96       	adiw	r26, 0x0b	; 11
    1a42:	8c 93       	st	X, r24
  packet_payload[12] = SVIT_check_V_critical( svit[HEATER_1].name );
    1a44:	e4 e2       	ldi	r30, 0x24	; 36
    1a46:	f4 e0       	ldi	r31, 0x04	; 4
    1a48:	80 81       	ld	r24, Z
    1a4a:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1a4e:	af 81       	ldd	r26, Y+7	; 0x07
    1a50:	b8 85       	ldd	r27, Y+8	; 0x08
    1a52:	1c 96       	adiw	r26, 0x0c	; 12
    1a54:	8c 93       	st	X, r24
  packet_payload[13] = SVIT_check_V_critical( svit[HEATER_2].name );
    1a56:	7e e3       	ldi	r23, 0x3E	; 62
    1a58:	47 2e       	mov	r4, r23
    1a5a:	74 e0       	ldi	r23, 0x04	; 4
    1a5c:	57 2e       	mov	r5, r23
    1a5e:	f2 01       	movw	r30, r4
    1a60:	80 81       	ld	r24, Z
    1a62:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1a66:	af 81       	ldd	r26, Y+7	; 0x07
    1a68:	b8 85       	ldd	r27, Y+8	; 0x08
    1a6a:	1d 96       	adiw	r26, 0x0d	; 13
    1a6c:	8c 93       	st	X, r24
  packet_payload[14] = SVIT_check_V_critical( svit[CMG].name );
    1a6e:	e8 e5       	ldi	r30, 0x58	; 88
    1a70:	2e 2e       	mov	r2, r30
    1a72:	e4 e0       	ldi	r30, 0x04	; 4
    1a74:	3e 2e       	mov	r3, r30
    1a76:	f1 01       	movw	r30, r2
    1a78:	80 81       	ld	r24, Z
    1a7a:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1a7e:	af 81       	ldd	r26, Y+7	; 0x07
    1a80:	b8 85       	ldd	r27, Y+8	; 0x08
    1a82:	1e 96       	adiw	r26, 0x0e	; 14
    1a84:	8c 93       	st	X, r24
  packet_payload[15] = SVIT_check_V_critical( svit[SUN_SENSOR].name );
    1a86:	22 e7       	ldi	r18, 0x72	; 114
    1a88:	34 e0       	ldi	r19, 0x04	; 4
    1a8a:	f9 01       	movw	r30, r18
    1a8c:	80 81       	ld	r24, Z
    1a8e:	29 83       	std	Y+1, r18	; 0x01
    1a90:	3a 83       	std	Y+2, r19	; 0x02
    1a92:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1a96:	af 81       	ldd	r26, Y+7	; 0x07
    1a98:	b8 85       	ldd	r27, Y+8	; 0x08
    1a9a:	1f 96       	adiw	r26, 0x0f	; 15
    1a9c:	8c 93       	st	X, r24
  packet_payload[16] = SVIT_check_V_critical( svit[RADIO_1].name );
    1a9e:	4c e8       	ldi	r20, 0x8C	; 140
    1aa0:	54 e0       	ldi	r21, 0x04	; 4
    1aa2:	fa 01       	movw	r30, r20
    1aa4:	80 81       	ld	r24, Z
    1aa6:	4b 83       	std	Y+3, r20	; 0x03
    1aa8:	5c 83       	std	Y+4, r21	; 0x04
    1aaa:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1aae:	af 81       	ldd	r26, Y+7	; 0x07
    1ab0:	b8 85       	ldd	r27, Y+8	; 0x08
    1ab2:	50 96       	adiw	r26, 0x10	; 16
    1ab4:	8c 93       	st	X, r24
  packet_payload[17] = SVIT_check_V_critical( svit[RADIO_2].name );
    1ab6:	66 ea       	ldi	r22, 0xA6	; 166
    1ab8:	74 e0       	ldi	r23, 0x04	; 4
    1aba:	fb 01       	movw	r30, r22
    1abc:	80 81       	ld	r24, Z
    1abe:	6d 83       	std	Y+5, r22	; 0x05
    1ac0:	7e 83       	std	Y+6, r23	; 0x06
    1ac2:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1ac6:	af 81       	ldd	r26, Y+7	; 0x07
    1ac8:	b8 85       	ldd	r27, Y+8	; 0x08
    1aca:	51 96       	adiw	r26, 0x11	; 17
    1acc:	8c 93       	st	X, r24
  packet_payload[18] = SVIT_check_V_critical( svit[FOG_15V].name );
    1ace:	e4 ef       	ldi	r30, 0xF4	; 244
    1ad0:	f4 e0       	ldi	r31, 0x04	; 4
    1ad2:	80 81       	ld	r24, Z
    1ad4:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1ad8:	af 81       	ldd	r26, Y+7	; 0x07
    1ada:	b8 85       	ldd	r27, Y+8	; 0x08
    1adc:	52 96       	adiw	r26, 0x12	; 18
    1ade:	8c 93       	st	X, r24
  packet_payload[19] = SVIT_check_V_critical( svit[FOG_5V].name );
    1ae0:	ee e0       	ldi	r30, 0x0E	; 14
    1ae2:	f5 e0       	ldi	r31, 0x05	; 5
    1ae4:	80 81       	ld	r24, Z
    1ae6:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1aea:	af 81       	ldd	r26, Y+7	; 0x07
    1aec:	b8 85       	ldd	r27, Y+8	; 0x08
    1aee:	53 96       	adiw	r26, 0x13	; 19
    1af0:	8c 93       	st	X, r24
  packet_payload[20] = SVIT_check_V_critical( svit[TORQUER_1].name );
    1af2:	e8 e2       	ldi	r30, 0x28	; 40
    1af4:	f5 e0       	ldi	r31, 0x05	; 5
    1af6:	80 81       	ld	r24, Z
    1af8:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1afc:	af 81       	ldd	r26, Y+7	; 0x07
    1afe:	b8 85       	ldd	r27, Y+8	; 0x08
    1b00:	54 96       	adiw	r26, 0x14	; 20
    1b02:	8c 93       	st	X, r24
  packet_payload[21] = SVIT_check_V_critical( svit[TORQUER_2].name );
    1b04:	e2 e4       	ldi	r30, 0x42	; 66
    1b06:	f5 e0       	ldi	r31, 0x05	; 5
    1b08:	80 81       	ld	r24, Z
    1b0a:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1b0e:	af 81       	ldd	r26, Y+7	; 0x07
    1b10:	b8 85       	ldd	r27, Y+8	; 0x08
    1b12:	55 96       	adiw	r26, 0x15	; 21
    1b14:	8c 93       	st	X, r24
  packet_payload[22] = SVIT_check_V_critical( svit[TORQUER_3].name );
    1b16:	ec e5       	ldi	r30, 0x5C	; 92
    1b18:	f5 e0       	ldi	r31, 0x05	; 5
    1b1a:	80 81       	ld	r24, Z
    1b1c:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1b20:	af 81       	ldd	r26, Y+7	; 0x07
    1b22:	b8 85       	ldd	r27, Y+8	; 0x08
    1b24:	56 96       	adiw	r26, 0x16	; 22
    1b26:	8c 93       	st	X, r24
  packet_payload[23] = SVIT_check_V_critical( svit[BATTERY_1].name );
    1b28:	e6 e7       	ldi	r30, 0x76	; 118
    1b2a:	f5 e0       	ldi	r31, 0x05	; 5
    1b2c:	80 81       	ld	r24, Z
    1b2e:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1b32:	af 81       	ldd	r26, Y+7	; 0x07
    1b34:	b8 85       	ldd	r27, Y+8	; 0x08
    1b36:	57 96       	adiw	r26, 0x17	; 23
    1b38:	8c 93       	st	X, r24
  packet_payload[24] = SVIT_check_V_critical( svit[BATTERY_2].name );
    1b3a:	e0 e9       	ldi	r30, 0x90	; 144
    1b3c:	f5 e0       	ldi	r31, 0x05	; 5
    1b3e:	80 81       	ld	r24, Z
    1b40:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1b44:	af 81       	ldd	r26, Y+7	; 0x07
    1b46:	b8 85       	ldd	r27, Y+8	; 0x08
    1b48:	58 96       	adiw	r26, 0x18	; 24
    1b4a:	8c 93       	st	X, r24
  packet_payload[25] = SVIT_check_V_critical( svit[SOLAR_FULL].name );
    1b4c:	ea ea       	ldi	r30, 0xAA	; 170
    1b4e:	f5 e0       	ldi	r31, 0x05	; 5
    1b50:	80 81       	ld	r24, Z
    1b52:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1b56:	af 81       	ldd	r26, Y+7	; 0x07
    1b58:	b8 85       	ldd	r27, Y+8	; 0x08
    1b5a:	59 96       	adiw	r26, 0x19	; 25
    1b5c:	8c 93       	st	X, r24
  packet_payload[26] = SVIT_check_V_critical( svit[SOLAR_1].name );
    1b5e:	e4 ec       	ldi	r30, 0xC4	; 196
    1b60:	f5 e0       	ldi	r31, 0x05	; 5
    1b62:	80 81       	ld	r24, Z
    1b64:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1b68:	af 81       	ldd	r26, Y+7	; 0x07
    1b6a:	b8 85       	ldd	r27, Y+8	; 0x08
    1b6c:	5a 96       	adiw	r26, 0x1a	; 26
    1b6e:	8c 93       	st	X, r24
  packet_payload[27] = SVIT_check_V_critical( svit[SOLAR_2].name );
    1b70:	ee ed       	ldi	r30, 0xDE	; 222
    1b72:	f5 e0       	ldi	r31, 0x05	; 5
    1b74:	80 81       	ld	r24, Z
    1b76:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1b7a:	af 81       	ldd	r26, Y+7	; 0x07
    1b7c:	b8 85       	ldd	r27, Y+8	; 0x08
    1b7e:	5b 96       	adiw	r26, 0x1b	; 27
    1b80:	8c 93       	st	X, r24
  packet_payload[28] = SVIT_check_V_critical( svit[SOLAR_3].name );
    1b82:	e8 ef       	ldi	r30, 0xF8	; 248
    1b84:	f5 e0       	ldi	r31, 0x05	; 5
    1b86:	80 81       	ld	r24, Z
    1b88:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1b8c:	af 81       	ldd	r26, Y+7	; 0x07
    1b8e:	b8 85       	ldd	r27, Y+8	; 0x08
    1b90:	5c 96       	adiw	r26, 0x1c	; 28
    1b92:	8c 93       	st	X, r24
  packet_payload[29] = SVIT_check_V_critical( svit[SOLAR_4].name );
    1b94:	e2 e1       	ldi	r30, 0x12	; 18
    1b96:	f6 e0       	ldi	r31, 0x06	; 6
    1b98:	80 81       	ld	r24, Z
    1b9a:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1b9e:	af 81       	ldd	r26, Y+7	; 0x07
    1ba0:	b8 85       	ldd	r27, Y+8	; 0x08
    1ba2:	5d 96       	adiw	r26, 0x1d	; 29
    1ba4:	8c 93       	st	X, r24
  packet_payload[30] = SVIT_check_V_critical( svit[SOLAR_5].name );
    1ba6:	ec e2       	ldi	r30, 0x2C	; 44
    1ba8:	f6 e0       	ldi	r31, 0x06	; 6
    1baa:	80 81       	ld	r24, Z
    1bac:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1bb0:	af 81       	ldd	r26, Y+7	; 0x07
    1bb2:	b8 85       	ldd	r27, Y+8	; 0x08
    1bb4:	5e 96       	adiw	r26, 0x1e	; 30
    1bb6:	8c 93       	st	X, r24
  packet_payload[31] = SVIT_check_V_critical( svit[SOLAR_6].name );
    1bb8:	e6 e4       	ldi	r30, 0x46	; 70
    1bba:	f6 e0       	ldi	r31, 0x06	; 6
    1bbc:	80 81       	ld	r24, Z
    1bbe:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1bc2:	af 81       	ldd	r26, Y+7	; 0x07
    1bc4:	b8 85       	ldd	r27, Y+8	; 0x08
    1bc6:	5f 96       	adiw	r26, 0x1f	; 31
    1bc8:	8c 93       	st	X, r24
  packet_payload[32] = SVIT_check_V_critical( svit[SOLAR_7].name );
    1bca:	e0 e6       	ldi	r30, 0x60	; 96
    1bcc:	f6 e0       	ldi	r31, 0x06	; 6
    1bce:	80 81       	ld	r24, Z
    1bd0:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1bd4:	af 81       	ldd	r26, Y+7	; 0x07
    1bd6:	b8 85       	ldd	r27, Y+8	; 0x08
    1bd8:	90 96       	adiw	r26, 0x20	; 32
    1bda:	8c 93       	st	X, r24
  packet_payload[33] = SVIT_check_V_critical( svit[SOLAR_8].name );
    1bdc:	ea e7       	ldi	r30, 0x7A	; 122
    1bde:	f6 e0       	ldi	r31, 0x06	; 6
    1be0:	80 81       	ld	r24, Z
    1be2:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1be6:	af 81       	ldd	r26, Y+7	; 0x07
    1be8:	b8 85       	ldd	r27, Y+8	; 0x08
    1bea:	91 96       	adiw	r26, 0x21	; 33
    1bec:	8c 93       	st	X, r24
  packet_payload[34] = SVIT_check_V_critical( svit[SOLAR_9].name );
    1bee:	e4 e9       	ldi	r30, 0x94	; 148
    1bf0:	f6 e0       	ldi	r31, 0x06	; 6
    1bf2:	80 81       	ld	r24, Z
    1bf4:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1bf8:	af 81       	ldd	r26, Y+7	; 0x07
    1bfa:	b8 85       	ldd	r27, Y+8	; 0x08
    1bfc:	92 96       	adiw	r26, 0x22	; 34
    1bfe:	8c 93       	st	X, r24
  packet_payload[35] = SVIT_check_V_critical( svit[SOLAR_10].name );
    1c00:	ee ea       	ldi	r30, 0xAE	; 174
    1c02:	f6 e0       	ldi	r31, 0x06	; 6
    1c04:	80 81       	ld	r24, Z
    1c06:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1c0a:	af 81       	ldd	r26, Y+7	; 0x07
    1c0c:	b8 85       	ldd	r27, Y+8	; 0x08
    1c0e:	93 96       	adiw	r26, 0x23	; 35
    1c10:	8c 93       	st	X, r24
  packet_payload[36] = SVIT_check_V_critical( svit[SOLAR_11].name );
    1c12:	e8 ec       	ldi	r30, 0xC8	; 200
    1c14:	f6 e0       	ldi	r31, 0x06	; 6
    1c16:	80 81       	ld	r24, Z
    1c18:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1c1c:	af 81       	ldd	r26, Y+7	; 0x07
    1c1e:	b8 85       	ldd	r27, Y+8	; 0x08
    1c20:	94 96       	adiw	r26, 0x24	; 36
    1c22:	8c 93       	st	X, r24
  packet_payload[37] = SVIT_check_V_critical( svit[SOLAR_12].name );
    1c24:	e2 ee       	ldi	r30, 0xE2	; 226
    1c26:	f6 e0       	ldi	r31, 0x06	; 6
    1c28:	80 81       	ld	r24, Z
    1c2a:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1c2e:	af 81       	ldd	r26, Y+7	; 0x07
    1c30:	b8 85       	ldd	r27, Y+8	; 0x08
    1c32:	95 96       	adiw	r26, 0x25	; 37
    1c34:	8c 93       	st	X, r24
  packet_payload[38] = SVIT_check_V_critical( svit[POWER_BOARD].name );
    1c36:	80 91 fc 06 	lds	r24, 0x06FC
    1c3a:	0e 94 13 08 	call	0x1026	; 0x1026 <SVIT_check_V_critical>
    1c3e:	ef 81       	ldd	r30, Y+7	; 0x07
    1c40:	f8 85       	ldd	r31, Y+8	; 0x08
    1c42:	86 a3       	std	Z+38, r24	; 0x26
  //uint8_t voltage_error1;
  //uint8_t voltage_error2;
  //uint8_t voltage_error3;
  //uint8_t voltage_error4;
 
  packet_payload[39] = 0;
    1c44:	17 a2       	std	Z+39, r1	; 0x27
  packet_payload[40] = 0;
    1c46:	10 a6       	std	Z+40, r1	; 0x28
  packet_payload[41] = 0;
    1c48:	11 a6       	std	Z+41, r1	; 0x29
  packet_payload[42] = 0;
    1c4a:	12 a6       	std	Z+42, r1	; 0x2a
  packet_payload[43] = 0;
    1c4c:	13 a6       	std	Z+43, r1	; 0x2b

  // current values (raw ADC output)
  packet_payload[44] = SVIT_check_I_critical( svit[SPECTROMETER].name );
    1c4e:	d3 01       	movw	r26, r6
    1c50:	8c 91       	ld	r24, X
    1c52:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1c56:	ef 81       	ldd	r30, Y+7	; 0x07
    1c58:	f8 85       	ldd	r31, Y+8	; 0x08
    1c5a:	84 a7       	std	Z+44, r24	; 0x2c
  packet_payload[45] = SVIT_check_I_critical( svit[STAR_TRACKER].name );
    1c5c:	d4 01       	movw	r26, r8
    1c5e:	8c 91       	ld	r24, X
    1c60:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1c64:	ef 81       	ldd	r30, Y+7	; 0x07
    1c66:	f8 85       	ldd	r31, Y+8	; 0x08
    1c68:	85 a7       	std	Z+45, r24	; 0x2d
  packet_payload[46] = SVIT_check_I_critical( svit[FC_5V].name );
    1c6a:	d5 01       	movw	r26, r10
    1c6c:	8c 91       	ld	r24, X
    1c6e:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1c72:	ef 81       	ldd	r30, Y+7	; 0x07
    1c74:	f8 85       	ldd	r31, Y+8	; 0x08
    1c76:	86 a7       	std	Z+46, r24	; 0x2e
  packet_payload[47] = SVIT_check_I_critical( svit[FC_3_3V].name );
    1c78:	d6 01       	movw	r26, r12
    1c7a:	8c 91       	ld	r24, X
    1c7c:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1c80:	ef 81       	ldd	r30, Y+7	; 0x07
    1c82:	f8 85       	ldd	r31, Y+8	; 0x08
    1c84:	87 a7       	std	Z+47, r24	; 0x2f
  packet_payload[48] = SVIT_check_I_critical( svit[GPS_1].name );
    1c86:	d7 01       	movw	r26, r14
    1c88:	8c 91       	ld	r24, X
    1c8a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1c8e:	ef 81       	ldd	r30, Y+7	; 0x07
    1c90:	f8 85       	ldd	r31, Y+8	; 0x08
    1c92:	80 ab       	std	Z+48, r24	; 0x30
  packet_payload[49] = SVIT_check_I_critical( svit[CDH_IB].name );
    1c94:	d8 01       	movw	r26, r16
    1c96:	8c 91       	ld	r24, X
    1c98:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1c9c:	ef 81       	ldd	r30, Y+7	; 0x07
    1c9e:	f8 85       	ldd	r31, Y+8	; 0x08
    1ca0:	81 ab       	std	Z+49, r24	; 0x31
  packet_payload[50] = SVIT_check_I_critical( svit[HEATER_1].name );
    1ca2:	a4 e2       	ldi	r26, 0x24	; 36
    1ca4:	b4 e0       	ldi	r27, 0x04	; 4
    1ca6:	8c 91       	ld	r24, X
    1ca8:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1cac:	ef 81       	ldd	r30, Y+7	; 0x07
    1cae:	f8 85       	ldd	r31, Y+8	; 0x08
    1cb0:	82 ab       	std	Z+50, r24	; 0x32
  packet_payload[51] = SVIT_check_I_critical( svit[HEATER_2].name );
    1cb2:	d2 01       	movw	r26, r4
    1cb4:	8c 91       	ld	r24, X
    1cb6:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1cba:	ef 81       	ldd	r30, Y+7	; 0x07
    1cbc:	f8 85       	ldd	r31, Y+8	; 0x08
    1cbe:	83 ab       	std	Z+51, r24	; 0x33
  packet_payload[52] = SVIT_check_I_critical( svit[CMG].name );
    1cc0:	d1 01       	movw	r26, r2
    1cc2:	8c 91       	ld	r24, X
    1cc4:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1cc8:	ef 81       	ldd	r30, Y+7	; 0x07
    1cca:	f8 85       	ldd	r31, Y+8	; 0x08
    1ccc:	84 ab       	std	Z+52, r24	; 0x34
  packet_payload[53] = SVIT_check_I_critical( svit[SUN_SENSOR].name );
    1cce:	29 81       	ldd	r18, Y+1	; 0x01
    1cd0:	3a 81       	ldd	r19, Y+2	; 0x02
    1cd2:	d9 01       	movw	r26, r18
    1cd4:	8c 91       	ld	r24, X
    1cd6:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1cda:	ef 81       	ldd	r30, Y+7	; 0x07
    1cdc:	f8 85       	ldd	r31, Y+8	; 0x08
    1cde:	85 ab       	std	Z+53, r24	; 0x35
  packet_payload[54] = SVIT_check_I_critical( svit[RADIO_1].name );
    1ce0:	4b 81       	ldd	r20, Y+3	; 0x03
    1ce2:	5c 81       	ldd	r21, Y+4	; 0x04
    1ce4:	da 01       	movw	r26, r20
    1ce6:	8c 91       	ld	r24, X
    1ce8:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1cec:	ef 81       	ldd	r30, Y+7	; 0x07
    1cee:	f8 85       	ldd	r31, Y+8	; 0x08
    1cf0:	86 ab       	std	Z+54, r24	; 0x36
  packet_payload[55] = SVIT_check_I_critical( svit[RADIO_2].name );
    1cf2:	6d 81       	ldd	r22, Y+5	; 0x05
    1cf4:	7e 81       	ldd	r23, Y+6	; 0x06
    1cf6:	db 01       	movw	r26, r22
    1cf8:	8c 91       	ld	r24, X
    1cfa:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1cfe:	ef 81       	ldd	r30, Y+7	; 0x07
    1d00:	f8 85       	ldd	r31, Y+8	; 0x08
    1d02:	87 ab       	std	Z+55, r24	; 0x37
  packet_payload[56] = SVIT_check_I_critical( svit[FOG_15V].name );
    1d04:	a4 ef       	ldi	r26, 0xF4	; 244
    1d06:	b4 e0       	ldi	r27, 0x04	; 4
    1d08:	8c 91       	ld	r24, X
    1d0a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1d0e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d10:	f8 85       	ldd	r31, Y+8	; 0x08
    1d12:	80 af       	std	Z+56, r24	; 0x38
  packet_payload[57] = SVIT_check_I_critical( svit[FOG_5V].name );
    1d14:	ae e0       	ldi	r26, 0x0E	; 14
    1d16:	b5 e0       	ldi	r27, 0x05	; 5
    1d18:	8c 91       	ld	r24, X
    1d1a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1d1e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d20:	f8 85       	ldd	r31, Y+8	; 0x08
    1d22:	81 af       	std	Z+57, r24	; 0x39
  packet_payload[58] = SVIT_check_I_critical( svit[TORQUER_1].name );
    1d24:	a8 e2       	ldi	r26, 0x28	; 40
    1d26:	b5 e0       	ldi	r27, 0x05	; 5
    1d28:	8c 91       	ld	r24, X
    1d2a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1d2e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d30:	f8 85       	ldd	r31, Y+8	; 0x08
    1d32:	82 af       	std	Z+58, r24	; 0x3a
  packet_payload[59] = SVIT_check_I_critical( svit[TORQUER_2].name );
    1d34:	a2 e4       	ldi	r26, 0x42	; 66
    1d36:	b5 e0       	ldi	r27, 0x05	; 5
    1d38:	8c 91       	ld	r24, X
    1d3a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1d3e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d40:	f8 85       	ldd	r31, Y+8	; 0x08
    1d42:	83 af       	std	Z+59, r24	; 0x3b
  packet_payload[60] = SVIT_check_I_critical( svit[TORQUER_3].name );
    1d44:	ac e5       	ldi	r26, 0x5C	; 92
    1d46:	b5 e0       	ldi	r27, 0x05	; 5
    1d48:	8c 91       	ld	r24, X
    1d4a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1d4e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d50:	f8 85       	ldd	r31, Y+8	; 0x08
    1d52:	84 af       	std	Z+60, r24	; 0x3c
  packet_payload[61] = SVIT_check_I_critical( svit[BATTERY_1].name );
    1d54:	a6 e7       	ldi	r26, 0x76	; 118
    1d56:	b5 e0       	ldi	r27, 0x05	; 5
    1d58:	8c 91       	ld	r24, X
    1d5a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1d5e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d60:	f8 85       	ldd	r31, Y+8	; 0x08
    1d62:	85 af       	std	Z+61, r24	; 0x3d
  packet_payload[62] = SVIT_check_I_critical( svit[BATTERY_2].name );
    1d64:	a0 e9       	ldi	r26, 0x90	; 144
    1d66:	b5 e0       	ldi	r27, 0x05	; 5
    1d68:	8c 91       	ld	r24, X
    1d6a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1d6e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d70:	f8 85       	ldd	r31, Y+8	; 0x08
    1d72:	86 af       	std	Z+62, r24	; 0x3e
  packet_payload[63] = SVIT_check_I_critical( svit[SOLAR_FULL].name );
    1d74:	aa ea       	ldi	r26, 0xAA	; 170
    1d76:	b5 e0       	ldi	r27, 0x05	; 5
    1d78:	8c 91       	ld	r24, X
    1d7a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1d7e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d80:	f8 85       	ldd	r31, Y+8	; 0x08
    1d82:	87 af       	std	Z+63, r24	; 0x3f
  packet_payload[64] = SVIT_check_I_critical( svit[SOLAR_1].name );
    1d84:	a4 ec       	ldi	r26, 0xC4	; 196
    1d86:	b5 e0       	ldi	r27, 0x05	; 5
    1d88:	8c 91       	ld	r24, X
    1d8a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1d8e:	ef 81       	ldd	r30, Y+7	; 0x07
    1d90:	f8 85       	ldd	r31, Y+8	; 0x08
    1d92:	e0 5c       	subi	r30, 0xC0	; 192
    1d94:	ff 4f       	sbci	r31, 0xFF	; 255
    1d96:	80 83       	st	Z, r24
  packet_payload[65] = SVIT_check_I_critical( svit[SOLAR_2].name );
    1d98:	ee ed       	ldi	r30, 0xDE	; 222
    1d9a:	f5 e0       	ldi	r31, 0x05	; 5
    1d9c:	80 81       	ld	r24, Z
    1d9e:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1da2:	ef 81       	ldd	r30, Y+7	; 0x07
    1da4:	f8 85       	ldd	r31, Y+8	; 0x08
    1da6:	ef 5b       	subi	r30, 0xBF	; 191
    1da8:	ff 4f       	sbci	r31, 0xFF	; 255
    1daa:	80 83       	st	Z, r24
  packet_payload[66] = SVIT_check_I_critical( svit[SOLAR_3].name );
    1dac:	a8 ef       	ldi	r26, 0xF8	; 248
    1dae:	b5 e0       	ldi	r27, 0x05	; 5
    1db0:	8c 91       	ld	r24, X
    1db2:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1db6:	ef 81       	ldd	r30, Y+7	; 0x07
    1db8:	f8 85       	ldd	r31, Y+8	; 0x08
    1dba:	ee 5b       	subi	r30, 0xBE	; 190
    1dbc:	ff 4f       	sbci	r31, 0xFF	; 255
    1dbe:	80 83       	st	Z, r24
  packet_payload[67] = SVIT_check_I_critical( svit[SOLAR_4].name );
    1dc0:	e2 e1       	ldi	r30, 0x12	; 18
    1dc2:	f6 e0       	ldi	r31, 0x06	; 6
    1dc4:	80 81       	ld	r24, Z
    1dc6:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1dca:	ef 81       	ldd	r30, Y+7	; 0x07
    1dcc:	f8 85       	ldd	r31, Y+8	; 0x08
    1dce:	ed 5b       	subi	r30, 0xBD	; 189
    1dd0:	ff 4f       	sbci	r31, 0xFF	; 255
    1dd2:	80 83       	st	Z, r24
  packet_payload[68] = SVIT_check_I_critical( svit[SOLAR_5].name );
    1dd4:	ac e2       	ldi	r26, 0x2C	; 44
    1dd6:	b6 e0       	ldi	r27, 0x06	; 6
    1dd8:	8c 91       	ld	r24, X
    1dda:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1dde:	ef 81       	ldd	r30, Y+7	; 0x07
    1de0:	f8 85       	ldd	r31, Y+8	; 0x08
    1de2:	ec 5b       	subi	r30, 0xBC	; 188
    1de4:	ff 4f       	sbci	r31, 0xFF	; 255
    1de6:	80 83       	st	Z, r24
  packet_payload[69] = SVIT_check_I_critical( svit[SOLAR_6].name );
    1de8:	e6 e4       	ldi	r30, 0x46	; 70
    1dea:	f6 e0       	ldi	r31, 0x06	; 6
    1dec:	80 81       	ld	r24, Z
    1dee:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1df2:	ef 81       	ldd	r30, Y+7	; 0x07
    1df4:	f8 85       	ldd	r31, Y+8	; 0x08
    1df6:	eb 5b       	subi	r30, 0xBB	; 187
    1df8:	ff 4f       	sbci	r31, 0xFF	; 255
    1dfa:	80 83       	st	Z, r24
  packet_payload[70] = SVIT_check_I_critical( svit[SOLAR_7].name );
    1dfc:	a0 e6       	ldi	r26, 0x60	; 96
    1dfe:	b6 e0       	ldi	r27, 0x06	; 6
    1e00:	8c 91       	ld	r24, X
    1e02:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1e06:	ef 81       	ldd	r30, Y+7	; 0x07
    1e08:	f8 85       	ldd	r31, Y+8	; 0x08
    1e0a:	ea 5b       	subi	r30, 0xBA	; 186
    1e0c:	ff 4f       	sbci	r31, 0xFF	; 255
    1e0e:	80 83       	st	Z, r24
  packet_payload[71] = SVIT_check_I_critical( svit[SOLAR_8].name );
    1e10:	ea e7       	ldi	r30, 0x7A	; 122
    1e12:	f6 e0       	ldi	r31, 0x06	; 6
    1e14:	80 81       	ld	r24, Z
    1e16:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1e1a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e1c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e1e:	e9 5b       	subi	r30, 0xB9	; 185
    1e20:	ff 4f       	sbci	r31, 0xFF	; 255
    1e22:	80 83       	st	Z, r24
  packet_payload[72] = SVIT_check_I_critical( svit[SOLAR_9].name );
    1e24:	a4 e9       	ldi	r26, 0x94	; 148
    1e26:	b6 e0       	ldi	r27, 0x06	; 6
    1e28:	8c 91       	ld	r24, X
    1e2a:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1e2e:	ef 81       	ldd	r30, Y+7	; 0x07
    1e30:	f8 85       	ldd	r31, Y+8	; 0x08
    1e32:	e8 5b       	subi	r30, 0xB8	; 184
    1e34:	ff 4f       	sbci	r31, 0xFF	; 255
    1e36:	80 83       	st	Z, r24
  packet_payload[73] = SVIT_check_I_critical( svit[SOLAR_10].name );
    1e38:	ee ea       	ldi	r30, 0xAE	; 174
    1e3a:	f6 e0       	ldi	r31, 0x06	; 6
    1e3c:	80 81       	ld	r24, Z
    1e3e:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1e42:	ef 81       	ldd	r30, Y+7	; 0x07
    1e44:	f8 85       	ldd	r31, Y+8	; 0x08
    1e46:	e7 5b       	subi	r30, 0xB7	; 183
    1e48:	ff 4f       	sbci	r31, 0xFF	; 255
    1e4a:	80 83       	st	Z, r24
  packet_payload[74] = SVIT_check_I_critical( svit[SOLAR_11].name );
    1e4c:	a8 ec       	ldi	r26, 0xC8	; 200
    1e4e:	b6 e0       	ldi	r27, 0x06	; 6
    1e50:	8c 91       	ld	r24, X
    1e52:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1e56:	ef 81       	ldd	r30, Y+7	; 0x07
    1e58:	f8 85       	ldd	r31, Y+8	; 0x08
    1e5a:	e6 5b       	subi	r30, 0xB6	; 182
    1e5c:	ff 4f       	sbci	r31, 0xFF	; 255
    1e5e:	80 83       	st	Z, r24
  packet_payload[75] = SVIT_check_I_critical( svit[SOLAR_12].name );
    1e60:	e2 ee       	ldi	r30, 0xE2	; 226
    1e62:	f6 e0       	ldi	r31, 0x06	; 6
    1e64:	80 81       	ld	r24, Z
    1e66:	0e 94 04 08 	call	0x1008	; 0x1008 <SVIT_check_I_critical>
    1e6a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e6c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e6e:	e5 5b       	subi	r30, 0xB5	; 181
    1e70:	ff 4f       	sbci	r31, 0xFF	; 255
    1e72:	80 83       	st	Z, r24
  packet_payload[76] = 0xFF;//SVIT_check_I_critical( svit[POWER_BOARD].name );
    1e74:	ef 81       	ldd	r30, Y+7	; 0x07
    1e76:	f8 85       	ldd	r31, Y+8	; 0x08
    1e78:	e4 5b       	subi	r30, 0xB4	; 180
    1e7a:	ff 4f       	sbci	r31, 0xFF	; 255
    1e7c:	8f ef       	ldi	r24, 0xFF	; 255
    1e7e:	80 83       	st	Z, r24
  //uint8_t current_error1;
  //uint8_t current_error2;
  //uint8_t current_error3;
  //uint8_t current_error4;

  packet_payload[77] = batt1_voltage;//V_ack_change();
    1e80:	ef 81       	ldd	r30, Y+7	; 0x07
    1e82:	f8 85       	ldd	r31, Y+8	; 0x08
    1e84:	e3 5b       	subi	r30, 0xB3	; 179
    1e86:	ff 4f       	sbci	r31, 0xFF	; 255
    1e88:	90 91 5c 09 	lds	r25, 0x095C
    1e8c:	90 83       	st	Z, r25
  packet_payload[78] = soc;//soc;// I_ack_change();
    1e8e:	ef 81       	ldd	r30, Y+7	; 0x07
    1e90:	f8 85       	ldd	r31, Y+8	; 0x08
    1e92:	e2 5b       	subi	r30, 0xB2	; 178
    1e94:	ff 4f       	sbci	r31, 0xFF	; 255
    1e96:	90 91 96 0f 	lds	r25, 0x0F96
    1e9a:	90 83       	st	Z, r25
  packet_payload[79] = 0x00;//low >> 6;//safe_mode;
    1e9c:	ef 81       	ldd	r30, Y+7	; 0x07
    1e9e:	f8 85       	ldd	r31, Y+8	; 0x08
    1ea0:	e1 5b       	subi	r30, 0xB1	; 177
    1ea2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ea4:	10 82       	st	Z, r1
  packet_payload[80] = 0x00;//charging;
    1ea6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ea8:	f8 85       	ldd	r31, Y+8	; 0x08
    1eaa:	e0 5b       	subi	r30, 0xB0	; 176
    1eac:	ff 4f       	sbci	r31, 0xFF	; 255
    1eae:	10 82       	st	Z, r1
  packet_payload[81] = 0x00;//chargeforward;
    1eb0:	ef 81       	ldd	r30, Y+7	; 0x07
    1eb2:	f8 85       	ldd	r31, Y+8	; 0x08
    1eb4:	ef 5a       	subi	r30, 0xAF	; 175
    1eb6:	ff 4f       	sbci	r31, 0xFF	; 255
    1eb8:	10 82       	st	Z, r1

  // temperature values (raw ADC output)
  packet_payload[82] = debug;//average_samples( svit[STAR_TRACKER].T_samples );
    1eba:	ef 81       	ldd	r30, Y+7	; 0x07
    1ebc:	f8 85       	ldd	r31, Y+8	; 0x08
    1ebe:	ee 5a       	subi	r30, 0xAE	; 174
    1ec0:	ff 4f       	sbci	r31, 0xFF	; 255
    1ec2:	90 91 25 07 	lds	r25, 0x0725
    1ec6:	90 83       	st	Z, r25
  packet_payload[83] = 0xFF;//average_samples( svit[BATTERY_1].T_samples );
    1ec8:	ef 81       	ldd	r30, Y+7	; 0x07
    1eca:	f8 85       	ldd	r31, Y+8	; 0x08
    1ecc:	ed 5a       	subi	r30, 0xAD	; 173
    1ece:	ff 4f       	sbci	r31, 0xFF	; 255
    1ed0:	80 83       	st	Z, r24
  packet_payload[84] = average_samples( svit[BATTERY_2].T_samples );
    1ed2:	86 ea       	ldi	r24, 0xA6	; 166
    1ed4:	95 e0       	ldi	r25, 0x05	; 5
    1ed6:	0e 94 f5 07 	call	0xfea	; 0xfea <average_samples>
    1eda:	ef 81       	ldd	r30, Y+7	; 0x07
    1edc:	f8 85       	ldd	r31, Y+8	; 0x08
    1ede:	ec 5a       	subi	r30, 0xAC	; 172
    1ee0:	ff 4f       	sbci	r31, 0xFF	; 255
    1ee2:	80 83       	st	Z, r24
  packet_payload[85] = average_samples( svit[SOLAR_1].T_samples );
    1ee4:	8a ed       	ldi	r24, 0xDA	; 218
    1ee6:	95 e0       	ldi	r25, 0x05	; 5
    1ee8:	0e 94 f5 07 	call	0xfea	; 0xfea <average_samples>
    1eec:	ef 81       	ldd	r30, Y+7	; 0x07
    1eee:	f8 85       	ldd	r31, Y+8	; 0x08
    1ef0:	eb 5a       	subi	r30, 0xAB	; 171
    1ef2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ef4:	80 83       	st	Z, r24
  packet_payload[86] = average_samples( svit[SOLAR_2].T_samples );
    1ef6:	84 ef       	ldi	r24, 0xF4	; 244
    1ef8:	95 e0       	ldi	r25, 0x05	; 5
    1efa:	0e 94 f5 07 	call	0xfea	; 0xfea <average_samples>
    1efe:	ef 81       	ldd	r30, Y+7	; 0x07
    1f00:	f8 85       	ldd	r31, Y+8	; 0x08
    1f02:	ea 5a       	subi	r30, 0xAA	; 170
    1f04:	ff 4f       	sbci	r31, 0xFF	; 255
    1f06:	80 83       	st	Z, r24
  packet_payload[87] = average_samples( svit[SOLAR_3].T_samples );
    1f08:	8e e0       	ldi	r24, 0x0E	; 14
    1f0a:	96 e0       	ldi	r25, 0x06	; 6
    1f0c:	0e 94 f5 07 	call	0xfea	; 0xfea <average_samples>
    1f10:	ef 81       	ldd	r30, Y+7	; 0x07
    1f12:	f8 85       	ldd	r31, Y+8	; 0x08
    1f14:	e9 5a       	subi	r30, 0xA9	; 169
    1f16:	ff 4f       	sbci	r31, 0xFF	; 255
    1f18:	80 83       	st	Z, r24
  packet_payload[88] = average_samples( svit[SOLAR_4].T_samples );
    1f1a:	88 e2       	ldi	r24, 0x28	; 40
    1f1c:	96 e0       	ldi	r25, 0x06	; 6
    1f1e:	0e 94 f5 07 	call	0xfea	; 0xfea <average_samples>
    1f22:	ef 81       	ldd	r30, Y+7	; 0x07
    1f24:	f8 85       	ldd	r31, Y+8	; 0x08
    1f26:	e8 5a       	subi	r30, 0xA8	; 168
    1f28:	ff 4f       	sbci	r31, 0xFF	; 255
    1f2a:	80 83       	st	Z, r24
  packet_payload[89] = average_samples( svit[SOLAR_5].T_samples );
    1f2c:	82 e4       	ldi	r24, 0x42	; 66
    1f2e:	96 e0       	ldi	r25, 0x06	; 6
    1f30:	0e 94 f5 07 	call	0xfea	; 0xfea <average_samples>
    1f34:	ef 81       	ldd	r30, Y+7	; 0x07
    1f36:	f8 85       	ldd	r31, Y+8	; 0x08
    1f38:	e7 5a       	subi	r30, 0xA7	; 167
    1f3a:	ff 4f       	sbci	r31, 0xFF	; 255
    1f3c:	80 83       	st	Z, r24
  packet_payload[90] = average_samples( svit[SOLAR_9].T_samples );
    1f3e:	8a ea       	ldi	r24, 0xAA	; 170
    1f40:	96 e0       	ldi	r25, 0x06	; 6
    1f42:	0e 94 f5 07 	call	0xfea	; 0xfea <average_samples>
    1f46:	ef 81       	ldd	r30, Y+7	; 0x07
    1f48:	f8 85       	ldd	r31, Y+8	; 0x08
    1f4a:	e6 5a       	subi	r30, 0xA6	; 166
    1f4c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f4e:	80 83       	st	Z, r24
  packet_payload[91] = average_samples( svit[POWER_BOARD].T_samples );
    1f50:	82 e1       	ldi	r24, 0x12	; 18
    1f52:	97 e0       	ldi	r25, 0x07	; 7
    1f54:	0e 94 f5 07 	call	0xfea	; 0xfea <average_samples>
    1f58:	ef 81       	ldd	r30, Y+7	; 0x07
    1f5a:	f8 85       	ldd	r31, Y+8	; 0x08
    1f5c:	e5 5a       	subi	r30, 0xA5	; 165
    1f5e:	ff 4f       	sbci	r31, 0xFF	; 255
    1f60:	80 83       	st	Z, r24

uint8_t V_ack_change( void )
{
  uint8_t temp;

  temp = V_upper_val_change;
    1f62:	80 91 6b 0b 	lds	r24, 0x0B6B
  V_upper_val_change = 0;
    1f66:	10 92 6b 0b 	sts	0x0B6B, r1
  //uint8_t temperature_error1;
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
    1f6a:	ef 81       	ldd	r30, Y+7	; 0x07
    1f6c:	f8 85       	ldd	r31, Y+8	; 0x08
    1f6e:	e4 5a       	subi	r30, 0xA4	; 164
    1f70:	ff 4f       	sbci	r31, 0xFF	; 255
    1f72:	80 83       	st	Z, r24

uint8_t I_ack_change( void )
{
  uint8_t temp;

  temp = I_upper_val_change;
    1f74:	80 91 66 0b 	lds	r24, 0x0B66
  I_upper_val_change = 0;
    1f78:	10 92 66 0b 	sts	0x0B66, r1
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
  packet_payload[93] = I_ack_change();
    1f7c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f7e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f80:	e3 5a       	subi	r30, 0xA3	; 163
    1f82:	ff 4f       	sbci	r31, 0xFF	; 255
    1f84:	80 83       	st	Z, r24
}
    1f86:	28 96       	adiw	r28, 0x08	; 8
    1f88:	0f b6       	in	r0, 0x3f	; 63
    1f8a:	f8 94       	cli
    1f8c:	de bf       	out	0x3e, r29	; 62
    1f8e:	0f be       	out	0x3f, r0	; 63
    1f90:	cd bf       	out	0x3d, r28	; 61
    1f92:	df 91       	pop	r29
    1f94:	cf 91       	pop	r28
    1f96:	1f 91       	pop	r17
    1f98:	0f 91       	pop	r16
    1f9a:	ff 90       	pop	r15
    1f9c:	ef 90       	pop	r14
    1f9e:	df 90       	pop	r13
    1fa0:	cf 90       	pop	r12
    1fa2:	bf 90       	pop	r11
    1fa4:	af 90       	pop	r10
    1fa6:	9f 90       	pop	r9
    1fa8:	8f 90       	pop	r8
    1faa:	7f 90       	pop	r7
    1fac:	6f 90       	pop	r6
    1fae:	5f 90       	pop	r5
    1fb0:	4f 90       	pop	r4
    1fb2:	3f 90       	pop	r3
    1fb4:	2f 90       	pop	r2
    1fb6:	08 95       	ret

00001fb8 <transmit_packet>:

void transmit_packet( uint8_t uart, uint8_t packet_type, uint8_t ack_command )
{
    1fb8:	6f 92       	push	r6
    1fba:	7f 92       	push	r7
    1fbc:	8f 92       	push	r8
    1fbe:	9f 92       	push	r9
    1fc0:	bf 92       	push	r11
    1fc2:	cf 92       	push	r12
    1fc4:	df 92       	push	r13
    1fc6:	ef 92       	push	r14
    1fc8:	ff 92       	push	r15
    1fca:	0f 93       	push	r16
    1fcc:	1f 93       	push	r17
    1fce:	cf 93       	push	r28
    1fd0:	df 93       	push	r29
    1fd2:	b8 2e       	mov	r11, r24
  uint8_t VCP_tx_status;

  switch( packet_type )
    1fd4:	61 30       	cpi	r22, 0x01	; 1
    1fd6:	b9 f0       	breq	.+46     	; 0x2006 <transmit_packet+0x4e>
    1fd8:	20 f0       	brcs	.+8      	; 0x1fe2 <transmit_packet+0x2a>
    1fda:	62 30       	cpi	r22, 0x02	; 2
    1fdc:	09 f0       	breq	.+2      	; 0x1fe0 <transmit_packet+0x28>
    1fde:	8b c0       	rjmp	.+278    	; 0x20f6 <transmit_packet+0x13e>
    1fe0:	22 c0       	rjmp	.+68     	; 0x2026 <transmit_packet+0x6e>
  {
    case VCP_POWER_TELEMETRY:
      construct_telemetry_packet( tel_packet_payload[uart] );
    1fe2:	c8 2f       	mov	r28, r24
    1fe4:	d0 e0       	ldi	r29, 0x00	; 0
    1fe6:	2f ef       	ldi	r18, 0xFF	; 255
    1fe8:	82 9f       	mul	r24, r18
    1fea:	c0 01       	movw	r24, r0
    1fec:	11 24       	eor	r1, r1
    1fee:	88 56       	subi	r24, 0x68	; 104
    1ff0:	92 4f       	sbci	r25, 0xF2	; 242
    1ff2:	0e 94 45 0c 	call	0x188a	; 0x188a <construct_telemetry_packet>
      tel_packet_payload_size[uart] = 96;
    1ff6:	fe 01       	movw	r30, r28
    1ff8:	ee 0f       	add	r30, r30
    1ffa:	ff 1f       	adc	r31, r31
    1ffc:	e9 5d       	subi	r30, 0xD9	; 217
    1ffe:	f8 4f       	sbci	r31, 0xF8	; 248
    2000:	80 e6       	ldi	r24, 0x60	; 96
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	21 c0       	rjmp	.+66     	; 0x2048 <transmit_packet+0x90>
      break;
    case VCP_INVALID_COMMAND:
      tel_packet_payload[uart][0] = VCP_INVALID_COMMAND;
    2006:	e8 2f       	mov	r30, r24
    2008:	f0 e0       	ldi	r31, 0x00	; 0
    200a:	8f ef       	ldi	r24, 0xFF	; 255
    200c:	b8 9e       	mul	r11, r24
    200e:	d0 01       	movw	r26, r0
    2010:	11 24       	eor	r1, r1
    2012:	a8 56       	subi	r26, 0x68	; 104
    2014:	b2 4f       	sbci	r27, 0xF2	; 242
    2016:	6c 93       	st	X, r22
      tel_packet_payload_size[uart] = 1;
    2018:	ee 0f       	add	r30, r30
    201a:	ff 1f       	adc	r31, r31
    201c:	e9 5d       	subi	r30, 0xD9	; 217
    201e:	f8 4f       	sbci	r31, 0xF8	; 248
    2020:	81 e0       	ldi	r24, 0x01	; 1
    2022:	90 e0       	ldi	r25, 0x00	; 0
    2024:	11 c0       	rjmp	.+34     	; 0x2048 <transmit_packet+0x90>
      break;
    case VCP_ACK:
      tel_packet_payload[uart][0] = VCP_ACK;
    2026:	e8 2f       	mov	r30, r24
    2028:	f0 e0       	ldi	r31, 0x00	; 0
    202a:	2f ef       	ldi	r18, 0xFF	; 255
    202c:	82 9f       	mul	r24, r18
    202e:	d0 01       	movw	r26, r0
    2030:	11 24       	eor	r1, r1
    2032:	a8 56       	subi	r26, 0x68	; 104
    2034:	b2 4f       	sbci	r27, 0xF2	; 242
    2036:	6c 93       	st	X, r22
      tel_packet_payload[uart][1] = ack_command;
    2038:	11 96       	adiw	r26, 0x01	; 1
    203a:	4c 93       	st	X, r20
      tel_packet_payload_size[uart] = 2;
    203c:	ee 0f       	add	r30, r30
    203e:	ff 1f       	adc	r31, r31
    2040:	e9 5d       	subi	r30, 0xD9	; 217
    2042:	f8 4f       	sbci	r31, 0xF8	; 248
    2044:	82 e0       	ldi	r24, 0x02	; 2
    2046:	90 e0       	ldi	r25, 0x00	; 0
    2048:	91 83       	std	Z+1, r25	; 0x01
    204a:	80 83       	st	Z, r24
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    204c:	8b 2c       	mov	r8, r11
    204e:	91 2c       	mov	r9, r1
    2050:	8f ef       	ldi	r24, 0xFF	; 255
    2052:	b8 9e       	mul	r11, r24
    2054:	70 01       	movw	r14, r0
    2056:	11 24       	eor	r1, r1
    2058:	e7 01       	movw	r28, r14
    205a:	ca 59       	subi	r28, 0x9A	; 154
    205c:	d6 4f       	sbci	r29, 0xF6	; 246
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
    205e:	64 01       	movw	r12, r8
    2060:	cc 0c       	add	r12, r12
    2062:	dd 1c       	adc	r13, r13
    2064:	f6 01       	movw	r30, r12
    2066:	e9 5d       	subi	r30, 0xD9	; 217
    2068:	f8 4f       	sbci	r31, 0xF8	; 248
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    206a:	00 81       	ld	r16, Z
    206c:	11 81       	ldd	r17, Z+1	; 0x01
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
    206e:	97 01       	movw	r18, r14
    2070:	28 56       	subi	r18, 0x68	; 104
    2072:	32 4f       	sbci	r19, 0xF2	; 242
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2074:	af e6       	ldi	r26, 0x6F	; 111
    2076:	6a 2e       	mov	r6, r26
    2078:	ad e0       	ldi	r26, 0x0D	; 13
    207a:	7a 2e       	mov	r7, r26
    207c:	6c 0c       	add	r6, r12
    207e:	7d 1c       	adc	r7, r13
    2080:	41 e0       	ldi	r20, 0x01	; 1
    2082:	b3 01       	movw	r22, r6
    2084:	ce 01       	movw	r24, r28
    2086:	0e 94 71 09 	call	0x12e2	; 0x12e2 <Create_VCP_frame>
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
                  );

  // VCP frame creation was successful
  if ( VCP_tx_status == VCP_TERM )
    208a:	81 30       	cpi	r24, 0x01	; 1
    208c:	a1 f5       	brne	.+104    	; 0x20f6 <transmit_packet+0x13e>
  {
    tel_packet_size[uart] = dest_size[uart];
    208e:	f3 01       	movw	r30, r6
    2090:	80 81       	ld	r24, Z
    2092:	91 81       	ldd	r25, Z+1	; 0x01
    2094:	f6 01       	movw	r30, r12
    2096:	e1 5a       	subi	r30, 0xA1	; 161
    2098:	fc 4f       	sbci	r31, 0xFC	; 252
    209a:	91 83       	std	Z+1, r25	; 0x01
    209c:	80 83       	st	Z, r24
    memcpy( tel_packet[uart], dest_data[uart], tel_packet_size[uart] );
    209e:	80 81       	ld	r24, Z
    20a0:	91 81       	ldd	r25, Z+1	; 0x01
    20a2:	97 01       	movw	r18, r14
    20a4:	2a 5c       	subi	r18, 0xCA	; 202
    20a6:	38 4f       	sbci	r19, 0xF8	; 248
    20a8:	ac 01       	movw	r20, r24
    20aa:	be 01       	movw	r22, r28
    20ac:	c9 01       	movw	r24, r18
    20ae:	0e 94 0d 13 	call	0x261a	; 0x261a <memcpy>
    tel_packet_index[uart] = 0;
    20b2:	f4 01       	movw	r30, r8
    20b4:	e1 5d       	subi	r30, 0xD1	; 209
    20b6:	f8 4f       	sbci	r31, 0xF8	; 248
    20b8:	10 82       	st	Z, r1
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
    20ba:	f1 e0       	ldi	r31, 0x01	; 1
    20bc:	bf 12       	cpse	r11, r31
    20be:	06 c0       	rjmp	.+12     	; 0x20cc <transmit_packet+0x114>
    20c0:	80 91 9b 00 	lds	r24, 0x009B
    20c4:	88 23       	and	r24, r24
    20c6:	b9 f0       	breq	.+46     	; 0x20f6 <transmit_packet+0x13e>
      tx_put_byte( uart );
    20c8:	81 e0       	ldi	r24, 0x01	; 1
    20ca:	06 c0       	rjmp	.+12     	; 0x20d8 <transmit_packet+0x120>
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
    20cc:	b1 10       	cpse	r11, r1
    20ce:	13 c0       	rjmp	.+38     	; 0x20f6 <transmit_packet+0x13e>
    20d0:	8b b1       	in	r24, 0x0b	; 11
    20d2:	88 23       	and	r24, r24
    20d4:	81 f0       	breq	.+32     	; 0x20f6 <transmit_packet+0x13e>
      tx_put_byte( uart );
    20d6:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    20d8:	df 91       	pop	r29
    20da:	cf 91       	pop	r28
    20dc:	1f 91       	pop	r17
    20de:	0f 91       	pop	r16
    20e0:	ff 90       	pop	r15
    20e2:	ef 90       	pop	r14
    20e4:	df 90       	pop	r13
    20e6:	cf 90       	pop	r12
    20e8:	bf 90       	pop	r11
    20ea:	9f 90       	pop	r9
    20ec:	8f 90       	pop	r8
    20ee:	7f 90       	pop	r7
    20f0:	6f 90       	pop	r6
    tel_packet_index[uart] = 0;
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    20f2:	0c 94 40 0c 	jmp	0x1880	; 0x1880 <tx_put_byte>
  }
}
    20f6:	df 91       	pop	r29
    20f8:	cf 91       	pop	r28
    20fa:	1f 91       	pop	r17
    20fc:	0f 91       	pop	r16
    20fe:	ff 90       	pop	r15
    2100:	ef 90       	pop	r14
    2102:	df 90       	pop	r13
    2104:	cf 90       	pop	r12
    2106:	bf 90       	pop	r11
    2108:	9f 90       	pop	r9
    210a:	8f 90       	pop	r8
    210c:	7f 90       	pop	r7
    210e:	6f 90       	pop	r6
    2110:	08 95       	ret

00002112 <__cmpsf2>:
    2112:	a8 d0       	rcall	.+336    	; 0x2264 <__fp_cmp>
    2114:	08 f4       	brcc	.+2      	; 0x2118 <__cmpsf2+0x6>
    2116:	81 e0       	ldi	r24, 0x01	; 1
    2118:	08 95       	ret

0000211a <__divsf3>:
    211a:	0c d0       	rcall	.+24     	; 0x2134 <__divsf3x>
    211c:	de c0       	rjmp	.+444    	; 0x22da <__fp_round>
    211e:	d6 d0       	rcall	.+428    	; 0x22cc <__fp_pscB>
    2120:	40 f0       	brcs	.+16     	; 0x2132 <__divsf3+0x18>
    2122:	cd d0       	rcall	.+410    	; 0x22be <__fp_pscA>
    2124:	30 f0       	brcs	.+12     	; 0x2132 <__divsf3+0x18>
    2126:	21 f4       	brne	.+8      	; 0x2130 <__divsf3+0x16>
    2128:	5f 3f       	cpi	r21, 0xFF	; 255
    212a:	19 f0       	breq	.+6      	; 0x2132 <__divsf3+0x18>
    212c:	bf c0       	rjmp	.+382    	; 0x22ac <__fp_inf>
    212e:	51 11       	cpse	r21, r1
    2130:	08 c1       	rjmp	.+528    	; 0x2342 <__fp_szero>
    2132:	c2 c0       	rjmp	.+388    	; 0x22b8 <__fp_nan>

00002134 <__divsf3x>:
    2134:	e3 d0       	rcall	.+454    	; 0x22fc <__fp_split3>
    2136:	98 f3       	brcs	.-26     	; 0x211e <__divsf3+0x4>

00002138 <__divsf3_pse>:
    2138:	99 23       	and	r25, r25
    213a:	c9 f3       	breq	.-14     	; 0x212e <__divsf3+0x14>
    213c:	55 23       	and	r21, r21
    213e:	b1 f3       	breq	.-20     	; 0x212c <__divsf3+0x12>
    2140:	95 1b       	sub	r25, r21
    2142:	55 0b       	sbc	r21, r21
    2144:	bb 27       	eor	r27, r27
    2146:	aa 27       	eor	r26, r26
    2148:	62 17       	cp	r22, r18
    214a:	73 07       	cpc	r23, r19
    214c:	84 07       	cpc	r24, r20
    214e:	38 f0       	brcs	.+14     	; 0x215e <__divsf3_pse+0x26>
    2150:	9f 5f       	subi	r25, 0xFF	; 255
    2152:	5f 4f       	sbci	r21, 0xFF	; 255
    2154:	22 0f       	add	r18, r18
    2156:	33 1f       	adc	r19, r19
    2158:	44 1f       	adc	r20, r20
    215a:	aa 1f       	adc	r26, r26
    215c:	a9 f3       	breq	.-22     	; 0x2148 <__divsf3_pse+0x10>
    215e:	33 d0       	rcall	.+102    	; 0x21c6 <__divsf3_pse+0x8e>
    2160:	0e 2e       	mov	r0, r30
    2162:	3a f0       	brmi	.+14     	; 0x2172 <__divsf3_pse+0x3a>
    2164:	e0 e8       	ldi	r30, 0x80	; 128
    2166:	30 d0       	rcall	.+96     	; 0x21c8 <__divsf3_pse+0x90>
    2168:	91 50       	subi	r25, 0x01	; 1
    216a:	50 40       	sbci	r21, 0x00	; 0
    216c:	e6 95       	lsr	r30
    216e:	00 1c       	adc	r0, r0
    2170:	ca f7       	brpl	.-14     	; 0x2164 <__divsf3_pse+0x2c>
    2172:	29 d0       	rcall	.+82     	; 0x21c6 <__divsf3_pse+0x8e>
    2174:	fe 2f       	mov	r31, r30
    2176:	27 d0       	rcall	.+78     	; 0x21c6 <__divsf3_pse+0x8e>
    2178:	66 0f       	add	r22, r22
    217a:	77 1f       	adc	r23, r23
    217c:	88 1f       	adc	r24, r24
    217e:	bb 1f       	adc	r27, r27
    2180:	26 17       	cp	r18, r22
    2182:	37 07       	cpc	r19, r23
    2184:	48 07       	cpc	r20, r24
    2186:	ab 07       	cpc	r26, r27
    2188:	b0 e8       	ldi	r27, 0x80	; 128
    218a:	09 f0       	breq	.+2      	; 0x218e <__divsf3_pse+0x56>
    218c:	bb 0b       	sbc	r27, r27
    218e:	80 2d       	mov	r24, r0
    2190:	bf 01       	movw	r22, r30
    2192:	ff 27       	eor	r31, r31
    2194:	93 58       	subi	r25, 0x83	; 131
    2196:	5f 4f       	sbci	r21, 0xFF	; 255
    2198:	2a f0       	brmi	.+10     	; 0x21a4 <__divsf3_pse+0x6c>
    219a:	9e 3f       	cpi	r25, 0xFE	; 254
    219c:	51 05       	cpc	r21, r1
    219e:	68 f0       	brcs	.+26     	; 0x21ba <__divsf3_pse+0x82>
    21a0:	85 c0       	rjmp	.+266    	; 0x22ac <__fp_inf>
    21a2:	cf c0       	rjmp	.+414    	; 0x2342 <__fp_szero>
    21a4:	5f 3f       	cpi	r21, 0xFF	; 255
    21a6:	ec f3       	brlt	.-6      	; 0x21a2 <__divsf3_pse+0x6a>
    21a8:	98 3e       	cpi	r25, 0xE8	; 232
    21aa:	dc f3       	brlt	.-10     	; 0x21a2 <__divsf3_pse+0x6a>
    21ac:	86 95       	lsr	r24
    21ae:	77 95       	ror	r23
    21b0:	67 95       	ror	r22
    21b2:	b7 95       	ror	r27
    21b4:	f7 95       	ror	r31
    21b6:	9f 5f       	subi	r25, 0xFF	; 255
    21b8:	c9 f7       	brne	.-14     	; 0x21ac <__divsf3_pse+0x74>
    21ba:	88 0f       	add	r24, r24
    21bc:	91 1d       	adc	r25, r1
    21be:	96 95       	lsr	r25
    21c0:	87 95       	ror	r24
    21c2:	97 f9       	bld	r25, 7
    21c4:	08 95       	ret
    21c6:	e1 e0       	ldi	r30, 0x01	; 1
    21c8:	66 0f       	add	r22, r22
    21ca:	77 1f       	adc	r23, r23
    21cc:	88 1f       	adc	r24, r24
    21ce:	bb 1f       	adc	r27, r27
    21d0:	62 17       	cp	r22, r18
    21d2:	73 07       	cpc	r23, r19
    21d4:	84 07       	cpc	r24, r20
    21d6:	ba 07       	cpc	r27, r26
    21d8:	20 f0       	brcs	.+8      	; 0x21e2 <__divsf3_pse+0xaa>
    21da:	62 1b       	sub	r22, r18
    21dc:	73 0b       	sbc	r23, r19
    21de:	84 0b       	sbc	r24, r20
    21e0:	ba 0b       	sbc	r27, r26
    21e2:	ee 1f       	adc	r30, r30
    21e4:	88 f7       	brcc	.-30     	; 0x21c8 <__divsf3_pse+0x90>
    21e6:	e0 95       	com	r30
    21e8:	08 95       	ret

000021ea <__floatunsisf>:
    21ea:	e8 94       	clt
    21ec:	09 c0       	rjmp	.+18     	; 0x2200 <__floatsisf+0x12>

000021ee <__floatsisf>:
    21ee:	97 fb       	bst	r25, 7
    21f0:	3e f4       	brtc	.+14     	; 0x2200 <__floatsisf+0x12>
    21f2:	90 95       	com	r25
    21f4:	80 95       	com	r24
    21f6:	70 95       	com	r23
    21f8:	61 95       	neg	r22
    21fa:	7f 4f       	sbci	r23, 0xFF	; 255
    21fc:	8f 4f       	sbci	r24, 0xFF	; 255
    21fe:	9f 4f       	sbci	r25, 0xFF	; 255
    2200:	99 23       	and	r25, r25
    2202:	a9 f0       	breq	.+42     	; 0x222e <__floatsisf+0x40>
    2204:	f9 2f       	mov	r31, r25
    2206:	96 e9       	ldi	r25, 0x96	; 150
    2208:	bb 27       	eor	r27, r27
    220a:	93 95       	inc	r25
    220c:	f6 95       	lsr	r31
    220e:	87 95       	ror	r24
    2210:	77 95       	ror	r23
    2212:	67 95       	ror	r22
    2214:	b7 95       	ror	r27
    2216:	f1 11       	cpse	r31, r1
    2218:	f8 cf       	rjmp	.-16     	; 0x220a <__floatsisf+0x1c>
    221a:	fa f4       	brpl	.+62     	; 0x225a <__floatsisf+0x6c>
    221c:	bb 0f       	add	r27, r27
    221e:	11 f4       	brne	.+4      	; 0x2224 <__floatsisf+0x36>
    2220:	60 ff       	sbrs	r22, 0
    2222:	1b c0       	rjmp	.+54     	; 0x225a <__floatsisf+0x6c>
    2224:	6f 5f       	subi	r22, 0xFF	; 255
    2226:	7f 4f       	sbci	r23, 0xFF	; 255
    2228:	8f 4f       	sbci	r24, 0xFF	; 255
    222a:	9f 4f       	sbci	r25, 0xFF	; 255
    222c:	16 c0       	rjmp	.+44     	; 0x225a <__floatsisf+0x6c>
    222e:	88 23       	and	r24, r24
    2230:	11 f0       	breq	.+4      	; 0x2236 <__floatsisf+0x48>
    2232:	96 e9       	ldi	r25, 0x96	; 150
    2234:	11 c0       	rjmp	.+34     	; 0x2258 <__floatsisf+0x6a>
    2236:	77 23       	and	r23, r23
    2238:	21 f0       	breq	.+8      	; 0x2242 <__floatsisf+0x54>
    223a:	9e e8       	ldi	r25, 0x8E	; 142
    223c:	87 2f       	mov	r24, r23
    223e:	76 2f       	mov	r23, r22
    2240:	05 c0       	rjmp	.+10     	; 0x224c <__floatsisf+0x5e>
    2242:	66 23       	and	r22, r22
    2244:	71 f0       	breq	.+28     	; 0x2262 <__floatsisf+0x74>
    2246:	96 e8       	ldi	r25, 0x86	; 134
    2248:	86 2f       	mov	r24, r22
    224a:	70 e0       	ldi	r23, 0x00	; 0
    224c:	60 e0       	ldi	r22, 0x00	; 0
    224e:	2a f0       	brmi	.+10     	; 0x225a <__floatsisf+0x6c>
    2250:	9a 95       	dec	r25
    2252:	66 0f       	add	r22, r22
    2254:	77 1f       	adc	r23, r23
    2256:	88 1f       	adc	r24, r24
    2258:	da f7       	brpl	.-10     	; 0x2250 <__floatsisf+0x62>
    225a:	88 0f       	add	r24, r24
    225c:	96 95       	lsr	r25
    225e:	87 95       	ror	r24
    2260:	97 f9       	bld	r25, 7
    2262:	08 95       	ret

00002264 <__fp_cmp>:
    2264:	99 0f       	add	r25, r25
    2266:	00 08       	sbc	r0, r0
    2268:	55 0f       	add	r21, r21
    226a:	aa 0b       	sbc	r26, r26
    226c:	e0 e8       	ldi	r30, 0x80	; 128
    226e:	fe ef       	ldi	r31, 0xFE	; 254
    2270:	16 16       	cp	r1, r22
    2272:	17 06       	cpc	r1, r23
    2274:	e8 07       	cpc	r30, r24
    2276:	f9 07       	cpc	r31, r25
    2278:	c0 f0       	brcs	.+48     	; 0x22aa <__fp_cmp+0x46>
    227a:	12 16       	cp	r1, r18
    227c:	13 06       	cpc	r1, r19
    227e:	e4 07       	cpc	r30, r20
    2280:	f5 07       	cpc	r31, r21
    2282:	98 f0       	brcs	.+38     	; 0x22aa <__fp_cmp+0x46>
    2284:	62 1b       	sub	r22, r18
    2286:	73 0b       	sbc	r23, r19
    2288:	84 0b       	sbc	r24, r20
    228a:	95 0b       	sbc	r25, r21
    228c:	39 f4       	brne	.+14     	; 0x229c <__fp_cmp+0x38>
    228e:	0a 26       	eor	r0, r26
    2290:	61 f0       	breq	.+24     	; 0x22aa <__fp_cmp+0x46>
    2292:	23 2b       	or	r18, r19
    2294:	24 2b       	or	r18, r20
    2296:	25 2b       	or	r18, r21
    2298:	21 f4       	brne	.+8      	; 0x22a2 <__fp_cmp+0x3e>
    229a:	08 95       	ret
    229c:	0a 26       	eor	r0, r26
    229e:	09 f4       	brne	.+2      	; 0x22a2 <__fp_cmp+0x3e>
    22a0:	a1 40       	sbci	r26, 0x01	; 1
    22a2:	a6 95       	lsr	r26
    22a4:	8f ef       	ldi	r24, 0xFF	; 255
    22a6:	81 1d       	adc	r24, r1
    22a8:	81 1d       	adc	r24, r1
    22aa:	08 95       	ret

000022ac <__fp_inf>:
    22ac:	97 f9       	bld	r25, 7
    22ae:	9f 67       	ori	r25, 0x7F	; 127
    22b0:	80 e8       	ldi	r24, 0x80	; 128
    22b2:	70 e0       	ldi	r23, 0x00	; 0
    22b4:	60 e0       	ldi	r22, 0x00	; 0
    22b6:	08 95       	ret

000022b8 <__fp_nan>:
    22b8:	9f ef       	ldi	r25, 0xFF	; 255
    22ba:	80 ec       	ldi	r24, 0xC0	; 192
    22bc:	08 95       	ret

000022be <__fp_pscA>:
    22be:	00 24       	eor	r0, r0
    22c0:	0a 94       	dec	r0
    22c2:	16 16       	cp	r1, r22
    22c4:	17 06       	cpc	r1, r23
    22c6:	18 06       	cpc	r1, r24
    22c8:	09 06       	cpc	r0, r25
    22ca:	08 95       	ret

000022cc <__fp_pscB>:
    22cc:	00 24       	eor	r0, r0
    22ce:	0a 94       	dec	r0
    22d0:	12 16       	cp	r1, r18
    22d2:	13 06       	cpc	r1, r19
    22d4:	14 06       	cpc	r1, r20
    22d6:	05 06       	cpc	r0, r21
    22d8:	08 95       	ret

000022da <__fp_round>:
    22da:	09 2e       	mov	r0, r25
    22dc:	03 94       	inc	r0
    22de:	00 0c       	add	r0, r0
    22e0:	11 f4       	brne	.+4      	; 0x22e6 <__fp_round+0xc>
    22e2:	88 23       	and	r24, r24
    22e4:	52 f0       	brmi	.+20     	; 0x22fa <__fp_round+0x20>
    22e6:	bb 0f       	add	r27, r27
    22e8:	40 f4       	brcc	.+16     	; 0x22fa <__fp_round+0x20>
    22ea:	bf 2b       	or	r27, r31
    22ec:	11 f4       	brne	.+4      	; 0x22f2 <__fp_round+0x18>
    22ee:	60 ff       	sbrs	r22, 0
    22f0:	04 c0       	rjmp	.+8      	; 0x22fa <__fp_round+0x20>
    22f2:	6f 5f       	subi	r22, 0xFF	; 255
    22f4:	7f 4f       	sbci	r23, 0xFF	; 255
    22f6:	8f 4f       	sbci	r24, 0xFF	; 255
    22f8:	9f 4f       	sbci	r25, 0xFF	; 255
    22fa:	08 95       	ret

000022fc <__fp_split3>:
    22fc:	57 fd       	sbrc	r21, 7
    22fe:	90 58       	subi	r25, 0x80	; 128
    2300:	44 0f       	add	r20, r20
    2302:	55 1f       	adc	r21, r21
    2304:	59 f0       	breq	.+22     	; 0x231c <__fp_splitA+0x10>
    2306:	5f 3f       	cpi	r21, 0xFF	; 255
    2308:	71 f0       	breq	.+28     	; 0x2326 <__fp_splitA+0x1a>
    230a:	47 95       	ror	r20

0000230c <__fp_splitA>:
    230c:	88 0f       	add	r24, r24
    230e:	97 fb       	bst	r25, 7
    2310:	99 1f       	adc	r25, r25
    2312:	61 f0       	breq	.+24     	; 0x232c <__fp_splitA+0x20>
    2314:	9f 3f       	cpi	r25, 0xFF	; 255
    2316:	79 f0       	breq	.+30     	; 0x2336 <__fp_splitA+0x2a>
    2318:	87 95       	ror	r24
    231a:	08 95       	ret
    231c:	12 16       	cp	r1, r18
    231e:	13 06       	cpc	r1, r19
    2320:	14 06       	cpc	r1, r20
    2322:	55 1f       	adc	r21, r21
    2324:	f2 cf       	rjmp	.-28     	; 0x230a <__fp_split3+0xe>
    2326:	46 95       	lsr	r20
    2328:	f1 df       	rcall	.-30     	; 0x230c <__fp_splitA>
    232a:	08 c0       	rjmp	.+16     	; 0x233c <__fp_splitA+0x30>
    232c:	16 16       	cp	r1, r22
    232e:	17 06       	cpc	r1, r23
    2330:	18 06       	cpc	r1, r24
    2332:	99 1f       	adc	r25, r25
    2334:	f1 cf       	rjmp	.-30     	; 0x2318 <__fp_splitA+0xc>
    2336:	86 95       	lsr	r24
    2338:	71 05       	cpc	r23, r1
    233a:	61 05       	cpc	r22, r1
    233c:	08 94       	sec
    233e:	08 95       	ret

00002340 <__fp_zero>:
    2340:	e8 94       	clt

00002342 <__fp_szero>:
    2342:	bb 27       	eor	r27, r27
    2344:	66 27       	eor	r22, r22
    2346:	77 27       	eor	r23, r23
    2348:	cb 01       	movw	r24, r22
    234a:	97 f9       	bld	r25, 7
    234c:	08 95       	ret

0000234e <__gesf2>:
    234e:	8a df       	rcall	.-236    	; 0x2264 <__fp_cmp>
    2350:	08 f4       	brcc	.+2      	; 0x2354 <__gesf2+0x6>
    2352:	8f ef       	ldi	r24, 0xFF	; 255
    2354:	08 95       	ret

00002356 <__udivmodhi4>:
    2356:	aa 1b       	sub	r26, r26
    2358:	bb 1b       	sub	r27, r27
    235a:	51 e1       	ldi	r21, 0x11	; 17
    235c:	07 c0       	rjmp	.+14     	; 0x236c <__udivmodhi4_ep>

0000235e <__udivmodhi4_loop>:
    235e:	aa 1f       	adc	r26, r26
    2360:	bb 1f       	adc	r27, r27
    2362:	a6 17       	cp	r26, r22
    2364:	b7 07       	cpc	r27, r23
    2366:	10 f0       	brcs	.+4      	; 0x236c <__udivmodhi4_ep>
    2368:	a6 1b       	sub	r26, r22
    236a:	b7 0b       	sbc	r27, r23

0000236c <__udivmodhi4_ep>:
    236c:	88 1f       	adc	r24, r24
    236e:	99 1f       	adc	r25, r25
    2370:	5a 95       	dec	r21
    2372:	a9 f7       	brne	.-22     	; 0x235e <__udivmodhi4_loop>
    2374:	80 95       	com	r24
    2376:	90 95       	com	r25
    2378:	bc 01       	movw	r22, r24
    237a:	cd 01       	movw	r24, r26
    237c:	08 95       	ret

0000237e <__divmodhi4>:
    237e:	97 fb       	bst	r25, 7
    2380:	07 2e       	mov	r0, r23
    2382:	16 f4       	brtc	.+4      	; 0x2388 <__divmodhi4+0xa>
    2384:	00 94       	com	r0
    2386:	07 d0       	rcall	.+14     	; 0x2396 <__divmodhi4_neg1>
    2388:	77 fd       	sbrc	r23, 7
    238a:	09 d0       	rcall	.+18     	; 0x239e <__divmodhi4_neg2>
    238c:	0e 94 ab 11 	call	0x2356	; 0x2356 <__udivmodhi4>
    2390:	07 fc       	sbrc	r0, 7
    2392:	05 d0       	rcall	.+10     	; 0x239e <__divmodhi4_neg2>
    2394:	3e f4       	brtc	.+14     	; 0x23a4 <__divmodhi4_exit>

00002396 <__divmodhi4_neg1>:
    2396:	90 95       	com	r25
    2398:	81 95       	neg	r24
    239a:	9f 4f       	sbci	r25, 0xFF	; 255
    239c:	08 95       	ret

0000239e <__divmodhi4_neg2>:
    239e:	70 95       	com	r23
    23a0:	61 95       	neg	r22
    23a2:	7f 4f       	sbci	r23, 0xFF	; 255

000023a4 <__divmodhi4_exit>:
    23a4:	08 95       	ret

000023a6 <malloc>:
    23a6:	0f 93       	push	r16
    23a8:	1f 93       	push	r17
    23aa:	cf 93       	push	r28
    23ac:	df 93       	push	r29
    23ae:	82 30       	cpi	r24, 0x02	; 2
    23b0:	91 05       	cpc	r25, r1
    23b2:	10 f4       	brcc	.+4      	; 0x23b8 <malloc+0x12>
    23b4:	82 e0       	ldi	r24, 0x02	; 2
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	e0 91 99 0f 	lds	r30, 0x0F99
    23bc:	f0 91 9a 0f 	lds	r31, 0x0F9A
    23c0:	20 e0       	ldi	r18, 0x00	; 0
    23c2:	30 e0       	ldi	r19, 0x00	; 0
    23c4:	c0 e0       	ldi	r28, 0x00	; 0
    23c6:	d0 e0       	ldi	r29, 0x00	; 0
    23c8:	23 c0       	rjmp	.+70     	; 0x2410 <malloc+0x6a>
    23ca:	40 81       	ld	r20, Z
    23cc:	51 81       	ldd	r21, Z+1	; 0x01
    23ce:	48 17       	cp	r20, r24
    23d0:	59 07       	cpc	r21, r25
    23d2:	a8 f0       	brcs	.+42     	; 0x23fe <malloc+0x58>
    23d4:	48 17       	cp	r20, r24
    23d6:	59 07       	cpc	r21, r25
    23d8:	61 f4       	brne	.+24     	; 0x23f2 <malloc+0x4c>
    23da:	82 81       	ldd	r24, Z+2	; 0x02
    23dc:	93 81       	ldd	r25, Z+3	; 0x03
    23de:	20 97       	sbiw	r28, 0x00	; 0
    23e0:	19 f0       	breq	.+6      	; 0x23e8 <malloc+0x42>
    23e2:	9b 83       	std	Y+3, r25	; 0x03
    23e4:	8a 83       	std	Y+2, r24	; 0x02
    23e6:	2e c0       	rjmp	.+92     	; 0x2444 <malloc+0x9e>
    23e8:	90 93 9a 0f 	sts	0x0F9A, r25
    23ec:	80 93 99 0f 	sts	0x0F99, r24
    23f0:	29 c0       	rjmp	.+82     	; 0x2444 <malloc+0x9e>
    23f2:	21 15       	cp	r18, r1
    23f4:	31 05       	cpc	r19, r1
    23f6:	29 f0       	breq	.+10     	; 0x2402 <malloc+0x5c>
    23f8:	42 17       	cp	r20, r18
    23fa:	53 07       	cpc	r21, r19
    23fc:	10 f0       	brcs	.+4      	; 0x2402 <malloc+0x5c>
    23fe:	a9 01       	movw	r20, r18
    2400:	02 c0       	rjmp	.+4      	; 0x2406 <malloc+0x60>
    2402:	be 01       	movw	r22, r28
    2404:	df 01       	movw	r26, r30
    2406:	02 81       	ldd	r16, Z+2	; 0x02
    2408:	13 81       	ldd	r17, Z+3	; 0x03
    240a:	ef 01       	movw	r28, r30
    240c:	9a 01       	movw	r18, r20
    240e:	f8 01       	movw	r30, r16
    2410:	30 97       	sbiw	r30, 0x00	; 0
    2412:	d9 f6       	brne	.-74     	; 0x23ca <malloc+0x24>
    2414:	21 15       	cp	r18, r1
    2416:	31 05       	cpc	r19, r1
    2418:	09 f1       	breq	.+66     	; 0x245c <malloc+0xb6>
    241a:	28 1b       	sub	r18, r24
    241c:	39 0b       	sbc	r19, r25
    241e:	24 30       	cpi	r18, 0x04	; 4
    2420:	31 05       	cpc	r19, r1
    2422:	90 f4       	brcc	.+36     	; 0x2448 <malloc+0xa2>
    2424:	12 96       	adiw	r26, 0x02	; 2
    2426:	8d 91       	ld	r24, X+
    2428:	9c 91       	ld	r25, X
    242a:	13 97       	sbiw	r26, 0x03	; 3
    242c:	61 15       	cp	r22, r1
    242e:	71 05       	cpc	r23, r1
    2430:	21 f0       	breq	.+8      	; 0x243a <malloc+0x94>
    2432:	fb 01       	movw	r30, r22
    2434:	93 83       	std	Z+3, r25	; 0x03
    2436:	82 83       	std	Z+2, r24	; 0x02
    2438:	04 c0       	rjmp	.+8      	; 0x2442 <malloc+0x9c>
    243a:	90 93 9a 0f 	sts	0x0F9A, r25
    243e:	80 93 99 0f 	sts	0x0F99, r24
    2442:	fd 01       	movw	r30, r26
    2444:	32 96       	adiw	r30, 0x02	; 2
    2446:	44 c0       	rjmp	.+136    	; 0x24d0 <malloc+0x12a>
    2448:	fd 01       	movw	r30, r26
    244a:	e2 0f       	add	r30, r18
    244c:	f3 1f       	adc	r31, r19
    244e:	81 93       	st	Z+, r24
    2450:	91 93       	st	Z+, r25
    2452:	22 50       	subi	r18, 0x02	; 2
    2454:	31 09       	sbc	r19, r1
    2456:	2d 93       	st	X+, r18
    2458:	3c 93       	st	X, r19
    245a:	3a c0       	rjmp	.+116    	; 0x24d0 <malloc+0x12a>
    245c:	20 91 97 0f 	lds	r18, 0x0F97
    2460:	30 91 98 0f 	lds	r19, 0x0F98
    2464:	23 2b       	or	r18, r19
    2466:	41 f4       	brne	.+16     	; 0x2478 <malloc+0xd2>
    2468:	20 91 02 01 	lds	r18, 0x0102
    246c:	30 91 03 01 	lds	r19, 0x0103
    2470:	30 93 98 0f 	sts	0x0F98, r19
    2474:	20 93 97 0f 	sts	0x0F97, r18
    2478:	20 91 00 01 	lds	r18, 0x0100
    247c:	30 91 01 01 	lds	r19, 0x0101
    2480:	21 15       	cp	r18, r1
    2482:	31 05       	cpc	r19, r1
    2484:	41 f4       	brne	.+16     	; 0x2496 <malloc+0xf0>
    2486:	2d b7       	in	r18, 0x3d	; 61
    2488:	3e b7       	in	r19, 0x3e	; 62
    248a:	40 91 04 01 	lds	r20, 0x0104
    248e:	50 91 05 01 	lds	r21, 0x0105
    2492:	24 1b       	sub	r18, r20
    2494:	35 0b       	sbc	r19, r21
    2496:	e0 91 97 0f 	lds	r30, 0x0F97
    249a:	f0 91 98 0f 	lds	r31, 0x0F98
    249e:	e2 17       	cp	r30, r18
    24a0:	f3 07       	cpc	r31, r19
    24a2:	a0 f4       	brcc	.+40     	; 0x24cc <malloc+0x126>
    24a4:	2e 1b       	sub	r18, r30
    24a6:	3f 0b       	sbc	r19, r31
    24a8:	28 17       	cp	r18, r24
    24aa:	39 07       	cpc	r19, r25
    24ac:	78 f0       	brcs	.+30     	; 0x24cc <malloc+0x126>
    24ae:	ac 01       	movw	r20, r24
    24b0:	4e 5f       	subi	r20, 0xFE	; 254
    24b2:	5f 4f       	sbci	r21, 0xFF	; 255
    24b4:	24 17       	cp	r18, r20
    24b6:	35 07       	cpc	r19, r21
    24b8:	48 f0       	brcs	.+18     	; 0x24cc <malloc+0x126>
    24ba:	4e 0f       	add	r20, r30
    24bc:	5f 1f       	adc	r21, r31
    24be:	50 93 98 0f 	sts	0x0F98, r21
    24c2:	40 93 97 0f 	sts	0x0F97, r20
    24c6:	81 93       	st	Z+, r24
    24c8:	91 93       	st	Z+, r25
    24ca:	02 c0       	rjmp	.+4      	; 0x24d0 <malloc+0x12a>
    24cc:	e0 e0       	ldi	r30, 0x00	; 0
    24ce:	f0 e0       	ldi	r31, 0x00	; 0
    24d0:	cf 01       	movw	r24, r30
    24d2:	df 91       	pop	r29
    24d4:	cf 91       	pop	r28
    24d6:	1f 91       	pop	r17
    24d8:	0f 91       	pop	r16
    24da:	08 95       	ret

000024dc <free>:
    24dc:	ef 92       	push	r14
    24de:	ff 92       	push	r15
    24e0:	0f 93       	push	r16
    24e2:	1f 93       	push	r17
    24e4:	cf 93       	push	r28
    24e6:	df 93       	push	r29
    24e8:	00 97       	sbiw	r24, 0x00	; 0
    24ea:	09 f4       	brne	.+2      	; 0x24ee <free+0x12>
    24ec:	8f c0       	rjmp	.+286    	; 0x260c <free+0x130>
    24ee:	dc 01       	movw	r26, r24
    24f0:	12 97       	sbiw	r26, 0x02	; 2
    24f2:	13 96       	adiw	r26, 0x03	; 3
    24f4:	1c 92       	st	X, r1
    24f6:	1e 92       	st	-X, r1
    24f8:	12 97       	sbiw	r26, 0x02	; 2
    24fa:	e0 90 99 0f 	lds	r14, 0x0F99
    24fe:	f0 90 9a 0f 	lds	r15, 0x0F9A
    2502:	e1 14       	cp	r14, r1
    2504:	f1 04       	cpc	r15, r1
    2506:	89 f4       	brne	.+34     	; 0x252a <free+0x4e>
    2508:	2d 91       	ld	r18, X+
    250a:	3c 91       	ld	r19, X
    250c:	11 97       	sbiw	r26, 0x01	; 1
    250e:	28 0f       	add	r18, r24
    2510:	39 1f       	adc	r19, r25
    2512:	80 91 97 0f 	lds	r24, 0x0F97
    2516:	90 91 98 0f 	lds	r25, 0x0F98
    251a:	82 17       	cp	r24, r18
    251c:	93 07       	cpc	r25, r19
    251e:	89 f5       	brne	.+98     	; 0x2582 <free+0xa6>
    2520:	b0 93 98 0f 	sts	0x0F98, r27
    2524:	a0 93 97 0f 	sts	0x0F97, r26
    2528:	71 c0       	rjmp	.+226    	; 0x260c <free+0x130>
    252a:	e7 01       	movw	r28, r14
    252c:	20 e0       	ldi	r18, 0x00	; 0
    252e:	30 e0       	ldi	r19, 0x00	; 0
    2530:	01 c0       	rjmp	.+2      	; 0x2534 <free+0x58>
    2532:	ea 01       	movw	r28, r20
    2534:	ca 17       	cp	r28, r26
    2536:	db 07       	cpc	r29, r27
    2538:	38 f4       	brcc	.+14     	; 0x2548 <free+0x6c>
    253a:	4a 81       	ldd	r20, Y+2	; 0x02
    253c:	5b 81       	ldd	r21, Y+3	; 0x03
    253e:	9e 01       	movw	r18, r28
    2540:	41 15       	cp	r20, r1
    2542:	51 05       	cpc	r21, r1
    2544:	b1 f7       	brne	.-20     	; 0x2532 <free+0x56>
    2546:	22 c0       	rjmp	.+68     	; 0x258c <free+0xb0>
    2548:	bc 01       	movw	r22, r24
    254a:	62 50       	subi	r22, 0x02	; 2
    254c:	71 09       	sbc	r23, r1
    254e:	fb 01       	movw	r30, r22
    2550:	d3 83       	std	Z+3, r29	; 0x03
    2552:	c2 83       	std	Z+2, r28	; 0x02
    2554:	00 81       	ld	r16, Z
    2556:	11 81       	ldd	r17, Z+1	; 0x01
    2558:	ac 01       	movw	r20, r24
    255a:	40 0f       	add	r20, r16
    255c:	51 1f       	adc	r21, r17
    255e:	4c 17       	cp	r20, r28
    2560:	5d 07       	cpc	r21, r29
    2562:	61 f4       	brne	.+24     	; 0x257c <free+0xa0>
    2564:	48 81       	ld	r20, Y
    2566:	59 81       	ldd	r21, Y+1	; 0x01
    2568:	40 0f       	add	r20, r16
    256a:	51 1f       	adc	r21, r17
    256c:	4e 5f       	subi	r20, 0xFE	; 254
    256e:	5f 4f       	sbci	r21, 0xFF	; 255
    2570:	51 83       	std	Z+1, r21	; 0x01
    2572:	40 83       	st	Z, r20
    2574:	4a 81       	ldd	r20, Y+2	; 0x02
    2576:	5b 81       	ldd	r21, Y+3	; 0x03
    2578:	53 83       	std	Z+3, r21	; 0x03
    257a:	42 83       	std	Z+2, r20	; 0x02
    257c:	21 15       	cp	r18, r1
    257e:	31 05       	cpc	r19, r1
    2580:	29 f4       	brne	.+10     	; 0x258c <free+0xb0>
    2582:	b0 93 9a 0f 	sts	0x0F9A, r27
    2586:	a0 93 99 0f 	sts	0x0F99, r26
    258a:	40 c0       	rjmp	.+128    	; 0x260c <free+0x130>
    258c:	f9 01       	movw	r30, r18
    258e:	b3 83       	std	Z+3, r27	; 0x03
    2590:	a2 83       	std	Z+2, r26	; 0x02
    2592:	e9 01       	movw	r28, r18
    2594:	69 91       	ld	r22, Y+
    2596:	79 91       	ld	r23, Y+
    2598:	c6 0f       	add	r28, r22
    259a:	d7 1f       	adc	r29, r23
    259c:	ac 17       	cp	r26, r28
    259e:	bd 07       	cpc	r27, r29
    25a0:	79 f4       	brne	.+30     	; 0x25c0 <free+0xe4>
    25a2:	dc 01       	movw	r26, r24
    25a4:	5e 91       	ld	r21, -X
    25a6:	4e 91       	ld	r20, -X
    25a8:	46 0f       	add	r20, r22
    25aa:	57 1f       	adc	r21, r23
    25ac:	4e 5f       	subi	r20, 0xFE	; 254
    25ae:	5f 4f       	sbci	r21, 0xFF	; 255
    25b0:	51 83       	std	Z+1, r21	; 0x01
    25b2:	40 83       	st	Z, r20
    25b4:	12 96       	adiw	r26, 0x02	; 2
    25b6:	8d 91       	ld	r24, X+
    25b8:	9c 91       	ld	r25, X
    25ba:	13 97       	sbiw	r26, 0x03	; 3
    25bc:	93 83       	std	Z+3, r25	; 0x03
    25be:	82 83       	std	Z+2, r24	; 0x02
    25c0:	a0 e0       	ldi	r26, 0x00	; 0
    25c2:	b0 e0       	ldi	r27, 0x00	; 0
    25c4:	02 c0       	rjmp	.+4      	; 0x25ca <free+0xee>
    25c6:	d7 01       	movw	r26, r14
    25c8:	7c 01       	movw	r14, r24
    25ca:	f7 01       	movw	r30, r14
    25cc:	82 81       	ldd	r24, Z+2	; 0x02
    25ce:	93 81       	ldd	r25, Z+3	; 0x03
    25d0:	00 97       	sbiw	r24, 0x00	; 0
    25d2:	c9 f7       	brne	.-14     	; 0x25c6 <free+0xea>
    25d4:	c7 01       	movw	r24, r14
    25d6:	02 96       	adiw	r24, 0x02	; 2
    25d8:	20 81       	ld	r18, Z
    25da:	31 81       	ldd	r19, Z+1	; 0x01
    25dc:	82 0f       	add	r24, r18
    25de:	93 1f       	adc	r25, r19
    25e0:	20 91 97 0f 	lds	r18, 0x0F97
    25e4:	30 91 98 0f 	lds	r19, 0x0F98
    25e8:	28 17       	cp	r18, r24
    25ea:	39 07       	cpc	r19, r25
    25ec:	79 f4       	brne	.+30     	; 0x260c <free+0x130>
    25ee:	10 97       	sbiw	r26, 0x00	; 0
    25f0:	29 f4       	brne	.+10     	; 0x25fc <free+0x120>
    25f2:	10 92 9a 0f 	sts	0x0F9A, r1
    25f6:	10 92 99 0f 	sts	0x0F99, r1
    25fa:	04 c0       	rjmp	.+8      	; 0x2604 <free+0x128>
    25fc:	13 96       	adiw	r26, 0x03	; 3
    25fe:	1c 92       	st	X, r1
    2600:	1e 92       	st	-X, r1
    2602:	12 97       	sbiw	r26, 0x02	; 2
    2604:	f0 92 98 0f 	sts	0x0F98, r15
    2608:	e0 92 97 0f 	sts	0x0F97, r14
    260c:	df 91       	pop	r29
    260e:	cf 91       	pop	r28
    2610:	1f 91       	pop	r17
    2612:	0f 91       	pop	r16
    2614:	ff 90       	pop	r15
    2616:	ef 90       	pop	r14
    2618:	08 95       	ret

0000261a <memcpy>:
    261a:	fb 01       	movw	r30, r22
    261c:	dc 01       	movw	r26, r24
    261e:	02 c0       	rjmp	.+4      	; 0x2624 <memcpy+0xa>
    2620:	01 90       	ld	r0, Z+
    2622:	0d 92       	st	X+, r0
    2624:	41 50       	subi	r20, 0x01	; 1
    2626:	50 40       	sbci	r21, 0x00	; 0
    2628:	d8 f7       	brcc	.-10     	; 0x2620 <memcpy+0x6>
    262a:	08 95       	ret

0000262c <_exit>:
    262c:	f8 94       	cli

0000262e <__stop_program>:
    262e:	ff cf       	rjmp	.-2      	; 0x262e <__stop_program>
